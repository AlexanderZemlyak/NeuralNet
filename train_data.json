[
  {
    "instruction": "Implement the classic 15 puzzle game in PascalABC.NET using GraphABC and ABCObjects with tile movement, shuffling, and win condition detection",
    "output": "uses GraphABC,ABCObjects,ABCButtons;\n\nconst\n  n = 4;\n  sz = 100;\n  zz = 10;\n  x0 = 20;\n  y0 = 20;\n\nvar\n  p: array [1..n,1..n] of SquareABC;\n  digits: array [1..n*n-1] of integer;\n  MeshButton: ButtonABC;\n  StatusRect: RectangleABC;\n  EmptyCellX,EmptyCellY: integer;\n  MovesCount: integer;\n  EndOfGame: boolean;\n\nprocedure Swap(var p,p1: SquareABC);\nbegin\n  PABCSystem.Swap(p,p1);\n  var i := p.Left;\n  p.Left := p1.Left;\n  p1.Left := i;\n  i := p.Top;\n  p.Top := p1.Top;\n  p1.Top := i;\nend;\n\nfunction Neighbours(x1,y1,x2,y2: integer): boolean;\nbegin\n  Result := (Abs(x1-x2)=1) and (y1=y2) or (Abs(y1-y2)=1) and (x1=x2)\nend;\n\nprocedure FillDigitsArr;\nbegin\n  for var i:=1 to n*n-1 do\n    digits[i] := i;\nend;\n\nprocedure MixDigitsArr;\nvar x: integer;\nbegin\n  for var i:=1 to n*n-1 do\n  begin\n    repeat\n      x := Random(15)+1;\n    until x<>i;\n    Swap(digits[i],digits[x]);\n  end;\n  if n mod 2=0 then\n    Swap(digits[1],digits[2]);\nend;\n\nprocedure Fill15ByDigitsArr;\nbegin\n  Swap(p[EmptyCellY,EmptyCellX],p[n,n]);\n  EmptyCellX := n;\n  EmptyCellY := n;\n  var i := 1;\n  for var y:=1 to n do\n  for var x:=1 to n do\n  begin\n    if x*y=n*n then exit;\n    p[y,x].Number := digits[i];\n    i += 1;\n  end;\nend;\n\nprocedure Mix15;\nbegin\n  MixDigitsArr;\n  Fill15ByDigitsArr;\n  MovesCount := 0;\n  EndOfGame := False;\n  StatusRect.Text := 'Move count: '+IntToStr(MovesCount);\n  StatusRect.Color := RGB(200,200,255);\nend;\n\nprocedure Create15;\nbegin\n  EmptyCellX := n;\n  EmptyCellY := n;\n  for var x:=1 to n do\n  for var y:=1 to n do\n  begin\n    p[y,x] := new SquareABC(x0+(x-1)*(sz+zz),y0+(y-1)*(sz+zz),sz,clMoneyGreen);\n    p[y,x].BorderColor := clGreen;\n    p[y,x].BorderWidth := 2;\n    p[y,x].TextScale := 0.7;\n  end;\n  p[EmptyCellY,EmptyCellX].Color := clWhite;\n  p[EmptyCellY,EmptyCellX].BorderColor := clWhite;\n  FillDigitsArr;\n  MixDigitsArr;\n  Fill15ByDigitsArr;\nend;\n\nfunction IsSolution: boolean;\nbegin\n  Result:=True;\n  var i:=1;\n  for var y:=1 to n do\n  for var x:=1 to n do\n  begin\n    if p[y,x].Number<>i then\n    begin\n      Result:=False;\n      break;\n    end;\n    i += 1;\n    if i=n*n then i:=0;\n  end;\nend;\n\nprocedure MouseDown(x,y,mb: integer);\nbegin\n  if EndOfGame then\n    exit;\n  if ObjectUnderPoint(x,y)=nil then\n    exit;\n  var fx := (x-x0) div (sz+zz) + 1;\n  var fy := (y-y0) div (sz+zz) + 1;\n  if (fx>n) or (fy>n) then\n    exit;\n  if Neighbours(fx,fy,EmptyCellX,EmptyCellY) then\n  begin\n    Swap(p[EmptyCellY,EmptyCellX],p[fy,fx]);\n    EmptyCellX := fx;\n    EmptyCellY := fy;\n    Inc(MovesCount);\n    StatusRect.Text := 'Move count: ' + MovesCount;\n    if IsSolution then\n    begin\n      StatusRect.Text := 'Victory! Moves made: ' + MovesCount;\n      StatusRect.Color := RGB(255,200,200);\n      EndOfGame := True;\n    end\n  end;\nend;\n\nbegin\n  SetSmoothingOff;\n  Window.Title := '15 Puzzle Game';\n  Window.IsFixedSize := True;\n  SetWindowSize(2*x0+(sz+zz)*n-zz,2*y0+(sz+zz)*n-zz+90);\n  \n  EndOfGame := False;\n  Create15;\n\n  MeshButton := ButtonABC.Create((WindowWidth-200) div 2,2*y0+(sz+zz)*n-zz,200,'Shuffle',clLightGray);\n  MeshButton.OnClick := Mix15;\n  StatusRect := new RectangleABC(0,WindowHeight-40,WindowWidth,40,RGB(200,200,255));\n  StatusRect.TextVisible := True;\n  StatusRect.Text := 'Move count: '+IntToStr(MovesCount);\n  StatusRect.BorderWidth := 2;\n  StatusRect.BorderColor := RGB(80,80,255);\n\n  MovesCount := 0;\n\n  OnMouseDown := MouseDown;\nend."
  },
  {
    "instruction": "Create a parametric 3D spiral curve using Graph3D module in PascalABC.NET",
    "output": "uses Graph3D;\n\nfunction ParametricTrajectory(a,b: real; N: integer; fun: real->Point3D) := PartitionPoints(a,b,N).Select(fun);\n\nfunction ParametricCirve3D(a,b: real; fun: real->Point3D; N: integer := 200): SegmentsT;\nbegin\n  var tr := ParametricTrajectory(a,b,N,fun);\n  Result := Polyline3D(tr);\nend;\n\nbegin\n  ParametricCirve3D(0,20*Pi,t->P3D(0.04*t*cos(t),0.04*t*sin(t),0.1*t),1000);\nend."
  },
  {
    "instruction": "Compare performance between built-in Abs function and System.Math.Abs for integers in PascalABC.NET",
    "output": "begin\n  var s := 0;\n  var n := MaxInt;\n  loop n do\n    s := Abs(-2);\n  Print(MillisecondsDelta);\n  loop n do\n    s := System.Math.Abs(-2);\n  Print(MillisecondsDelta);\nend."
  },
  {
    "instruction": "Demonstrate ABCObjects module for creating and manipulating graphical objects with properties in PascalABC.NET",
    "output": "// ABCObjects module. Changing object properties\nuses ABCObjects,GraphABC;\n\nconst delay = 300;\n\nprocedure Pause := Sleep(delay);\n\nbegin\n  Window.Title := 'ABCObjects: properties of graphical objects';\n  var z := new StarABC(Window.Center.X,Window.Center.Y,70,30,6,Color.Green);\n  var r := new RectangleABC(100,100,200,100,Color.Gold);\n  Pause;\n  r.Center := Window.Center;\n  Pause;\n  r.Height := 70;\n  Pause;\n  r.Width := 220;\n  Pause;\n  z.Radius := 150;\n  Pause;\n  z.Color := Color.LightCoral;\n  Pause;\n  z.Count := 5;\n  Pause;\n \n  r.Text := 'PascalABC.NET';\n  r.Color := Color.Gainsboro;\n  Pause;\n  r.BorderWidth := 3;\n  r.BorderColor := Color.Blue;\n  Pause;\n  r.Center := Window.Center;\nend."
  },
  {
    "instruction": "Implement helper functions for parametric 3D curve generation in PascalABC.NET",
    "output": "uses Graph3D;\n\nfunction ParametricTrajectory(a,b: real; N: integer; fun: real->Point3D) := PartitionPoints(a,b,N).Select(fun);\n\nfunction ParametricCirve3D(a,b: real; fun: real->Point3D; N: integer := 200): SegmentsT;\nbegin\n  var tr := ParametricTrajectory(a,b,N,fun);\n  Result := Polyline3D(tr);\nend;"
  },
  {
    "instruction": "Create tile swapping logic for 15 puzzle game with neighbor detection",
    "output": "procedure Swap(var p,p1: SquareABC);\nbegin\n  PABCSystem.Swap(p,p1);\n  var i := p.Left;\n  p.Left := p1.Left;\n  p1.Left := i;\n  i := p.Top;\n  p.Top := p1.Top;\n  p1.Top := i;\nend;\n\nfunction Neighbours(x1,y1,x2,y2: integer): boolean;\nbegin\n  Result := (Abs(x1-x2)=1) and (y1=y2) or (Abs(y1-y2)=1) and (x1=x2)\nend;\n\nfunction IsSolution: boolean;\nbegin\n  Result:=True;\n  var i:=1;\n  for var y:=1 to n do\n  for var x:=1 to n do\n  begin\n    if p[y,x].Number<>i then\n    begin\n      Result:=False;\n      break;\n    end;\n    i += 1;\n    if i=n*n then i:=0;\n  end;\nend;"
  },
  {
    "instruction": "Implement array shuffling algorithm for 15 puzzle game with even permutation count",
    "output": "procedure FillDigitsArr;\nbegin\n  for var i:=1 to n*n-1 do\n    digits[i] := i;\nend;\n\nprocedure MixDigitsArr;\nvar x: integer;\nbegin\n  for var i:=1 to n*n-1 do\n  begin\n    repeat\n      x := Random(15)+1;\n    until x<>i;\n    Swap(digits[i],digits[x]);\n  end;\n  if n mod 2=0 then\n    Swap(digits[1],digits[2]);\nend;\n\nprocedure Fill15ByDigitsArr;\nbegin\n  Swap(p[EmptyCellY,EmptyCellX],p[n,n]);\n  EmptyCellX := n;\n  EmptyCellY := n;\n  var i := 1;\n  for var y:=1 to n do\n  for var x:=1 to n do\n  begin\n    if x*y=n*n then exit;\n    p[y,x].Number := digits[i];\n    i += 1;\n  end;\nend;"
  },
  {
    "instruction": "Create a simple ball animation with reflection from window boundaries using GraphWPF in PascalABC.NET",
    "output": "uses GraphWPF;\n\nbegin\n  Window.Title := 'Ball Reflection. Real direction of movement';\n  Brush.Color := Colors.Beige;\n  var x := 400.0;\n  var y := 300.0;\n  var dx := 2.1;\n  var dy := -1.2;\n  Circle(x,y,20);\n  while True do\n  begin\n    Sleep(10);\n    Window.Clear;\n    x += dx;\n    y += dy;\n    if not x.Between(0,Window.Width) then \n      dx := -dx;\n    if not y.Between(0,Window.Height) then \n      dy := -dy;\n    Circle(x,y,20);\n    if Milliseconds>2000 then\n      Window.Title := 'Seconds: ' + (Milliseconds div 100)/10;\n  end;\nend."
  },
  {
    "instruction": "Implement a BallInfo class for multiple ball animation with frame-based rendering in PascalABC.NET",
    "output": "uses GraphWPF;\n\ntype \n  BallInfo = auto class\n    x,y,r,dx,dy: real;\n    c: Color;\n    procedure Move := (x,y) := (x+dx,y+dy);\n    procedure Draw := FillCircle(x,y,r,c);\n    procedure CheckDirection;\n    begin\n      if not x.Between(r,Window.Width-r) then \n        dx := -dx;\n      if not y.Between(r,Window.Height-r) then \n        dy := -dy;\n    end;\n    procedure Step;\n    begin\n      Move; \n      CheckDirection;\n      Draw;\n    end;\n    class function CreateRandomBallArray(n: integer): array of BallInfo;\n    begin\n      var rr := 20;\n      Result := ArrGen(n,i->new BallInfo(RandomReal(rr,Window.Width-rr),\n        RandomReal(rr,Window.Height-rr),RandomReal(5,15),\n        RandomReal(-3,3),RandomReal(-3,3),RandomColor));\n    end;    \n  end;\n\nbegin\n  Window.Title := 'Ball Reflection. Frame-based animation';\n  \n  var n := 1000;\n  var a := BallInfo.CreateRandomBallArray(n);\n  \n  BeginFrameBasedAnimation(()->\n    foreach var ball in a do\n      ball.Step\n  );\nend."
  },
  {
    "instruction": "Create time-based ball animation with velocity control using OnDrawFrame event in PascalABC.NET",
    "output": "uses GraphWPF;\n\nconst vmax = 50;\n\ntype \n  BallInfo = auto class\n    x,y,r,vx,vy: real;\n    c: Color;\n    procedure Move(dt: real) := (x,y) := (x+vx*dt,y+vy*dt);\n    procedure Draw := FillCircle(x,y,r,c);\n    procedure CheckDirection;\n    begin\n      if not x.Between(r,Window.Width-r) then \n        vx := -vx;\n      if not y.Between(r,Window.Height-r) then \n        vy := -vy;\n    end;\n    procedure Step(dt: real);\n    begin\n      Move(dt); \n      CheckDirection;\n      Draw;\n    end;\n    class function CreateRandomBallArray(n: integer): array of BallInfo;\n    begin\n      var rr := 25;\n      Result := ArrGen(n,i->new BallInfo(RandomReal(rr,Window.Width-rr),\n        RandomReal(rr,Window.Height-rr),RandomReal(5,15),\n        RandomReal(-vmax,vmax),RandomReal(-vmax,vmax),RandomColor));\n    end;    \n  end;\n\nbegin\n  Window.Title := 'Ball Reflection. Frame-based animation';\n  \n  var n := 1000;\n  var a := BallInfo.CreateRandomBallArray(n);\n  \n  OnDrawFrame := dt ->\n    foreach var ball in a do\n      ball.Step(dt);\nend."
  },
  {
    "instruction": "Implement 3D cube animation with acceleration ratio and auto-reverse using Graph3D in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin\n  var ss := Cube(0,0,0,1.5,Colors.Red);\n  var anim := ss.AnimMoveByX(10).AutoReverse.Forever.AccelerationRatio(0.5,0.5);\n  anim.Begin;\nend."
  },
  {
    "instruction": "Create a rotating disc with attached spheres using 3D animation in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin\n  View3D.ShowGridLines := False;\n  var disc := Cylinder(0,0,0,0.2,6,Colors.DeepPink);\n\n  var r := 5;  \n  foreach var x in PartitionPoints(0,2*Pi,12) do \n    disc.AddChild(Sphere(r*cos(x),r*sin(x),0.2,0.1,Colors.White));\n  disc.AnimRotate(OrtZ,360,2).AccelerationRatio(1,1).AutoReverse.Forever.Begin;\nend."
  },
  {
    "instruction": "Implement a self-learning animal guessing game using binary decision tree in PascalABC.NET",
    "output": "type\n  TNode = class\n    s: string;\n    left,right: TNode;   \n    constructor(s: string);\n    begin\n      Self.s := s;\n      left := nil;\n      right := nil;\n    end;\n  end;\n\nvar f: text;\n\nprocedure SaveToFile(p: TNode);\nbegin\n  if p=nil then\n  begin\n    writeln(f,'');\n    exit\n  end;\n  writeln(f,p.s);\n  SaveToFile(p.left);\n  SaveToFile(p.right);\nend;\n\nfunction LoadFromFile: TNode;\nvar\n  s: string;\nbegin\n  readln(f,s);\n  if s='' then\n  begin\n    Result := nil;\n    exit\n  end;\n  var p := new TNode(s);\n  p.left := LoadFromFile;\n  p.right := LoadFromFile;\n  Result := p;\nend;\n\nvar\n  p,p1,p2,root: TNode;\n  x: integer;\n  s,q: string;\n\nbegin\n  writeln('Think of an animal');\n  assign(f, 'animals_data.txt');\n  if not FileExists('animals_data.txt') then\n    root := new TNode('Dog')\n  else\n  begin\n    reset(f);\n    root := loadfromfile;\n    close(f);\n  end;\n\n  p := root;\n  while p.left<>nil do\n  begin\n    Print(p.s+'? (0 - No, 1 - Yes):');\n    readln(x);\n    if x=1 then \n      p := p.left\n    else \n      p := p.right\n  end;\n  \n  write('Is it '+p.s+'? (0 - No, 1 - Yes): ');\n  readln(x);\n  if x=1 then\n    writeln('I guessed!')\n  else\n  begin\n    write('I lost. What animal is it? ');\n    readln(s);\n    write('Enter a question that distinguishes this animal from '+p.s+': ');\n    readln(q);\n    p1 := new TNode(s);\n    p2 := new TNode(p.s);\n    p.s := q;\n    p.left := p1;\n    p.right := p2;\n  end;\n  \n  Rewrite(f);\n  SaveToFile(root);\n  Close(f);\nend."
  },
  {
    "instruction": "Create 3D scaling animation with auto-reverse using Graph3D in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin\n  var ss := Cube(0,0,0,1.5,Colors.Red);\n  var anim := ss.AnimScale(3).Forever.AutoReverse;\n  anim.Begin;\nend."
  },
  {
    "instruction": "Show algorithm for determining prime numbers using for loop in PascalABC.NET",
    "output": "// Algorithm for determining prime numbers\n\nbegin\n  var N := ReadInteger('Enter number:');\n  var IsPrime := True;\n  for var i := 2 to Round(Sqrt(N)) do // if number is composite, then one of its factors \u2264 sqrt(N)\n    if N mod i = 0 then\n    begin\n      IsPrime := False;\n      break;\n    end;\n  if IsPrime then\n    Println('Number', N, 'is prime') else Println('Number', N, 'is composite');\nend."
  },
  {
    "instruction": "Show algorithm for calculating polynomial value using Horner's scheme in PascalABC.NET",
    "output": "// Algorithm for calculating polynomial value at point x using Horner's scheme\n\nconst n = 5;\n\nbegin\n  var x := ReadReal('Enter value x:');\n  Print($'Enter polynomial coefficients ({n + 1} pieces):');\n  var a := ReadReal;\n  var s := a;\n  for var i := 1 to n do\n  begin\n    a := ReadReal;\n    s := s * x + a;\n  end;\n  Println('Polynomial value at point', x, 'equals', s);\nend."
  },
  {
    "instruction": "Create various 3D primitives demonstration using Graph3D module in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin\n  Window.Title := '3D Primitives';\n  \n  var rr := Rectangle3D(-3.5,-2,0,3,2,Colors.MediumPurple);\n  rr.Rotate(v3d(0,1,0),30);\n  \n  var arrows := CoordinateSystem(2);\n  \n  var Ar := Arrow(3,0,0,0,0,2,Colors.Tan);\n\n  var p := P3D(5,-5,0);\n  var t := TruncatedCone(p,2,0.9,0.7,False,Colors.Red);\n  p := p.MoveX(-2);\n  TruncatedCone(p,2,0.9,0.7,Colors.BlueViolet);\n  p := p.MoveX(-2);\n  Cylinder(p,2,0.9,False,Colors.Crimson);\n  p := p.MoveX(-2);\n  var cc := Cylinder(p,2,0.9,Colors.Chocolate);\n  p := p.MoveX(-2);\n  var cone := Cone(p,2.5,0.9,Colors.DarkGreen);\n  p := p.MoveX(-2);\n  var c := Sphere(p.MoveZ(0.7),1,Colors.Crimson);\n  Text3D(p.MoveZ(2.3),'Sphere',0.7);\n  \n  p := P3D(5,-2,0);\n  var teapot := Teapot(p.MoveZ(0.9),Colors.ForestGreen);\n  var bb := BillboardText(p.Move(2,0,0.7),'Billboard'+NewLine + '\"Teapot\"',12);\n  p := p.MoveX(-2.75);\n  var cb := Cube(p.MoveZ(0.75),1.5,Colors.DodgerBlue);\n  cb.Scale(1.2);\n  cb.Rotate(V3D(0,0,1),45);\n  p := p.MoveX(-2.75);\n  var b := Box(p,Sz3D(2,1,1),Colors.PaleGreen);\n  b.Rotate(V3D(0,1,0),-30);\n  p := P3D(5,1,0);\n  var ellipsoid := Ellipsoid(p.MoveZ(0.6),1.3,0.8,0.6,Colors.Violet);\n  p := p.MoveX(-7);\n  var pp := Tube(p,2,0.7,0.5,Colors.DodgerBlue);\nend."
  },
  {
    "instruction": "Split string into words using AllDelimiters constant in PascalABC.NET",
    "output": "begin\n  var s := '123@!45  @#$678\\/|?90~;';\n  s.ToWords(AllDelimiters).Println;\nend."
  },
  {
    "instruction": "Demonstrate that all types except pointers are derived from Object in PascalABC.NET",
    "output": "// All types except pointers - derived from Object\nvar \n  i: integer;\n  r: real;\n  o: object;\n\nbegin\n  o := i;\n  Println(o.GetType,TypeName(o));\n  o := r;\n  Println(o.GetType,TypeName(o));\n  if o.GetType = typeof(real) then\n    Println('Variable o has real type');\nend."
  },
  {
    "instruction": "Show how to use the \"&\" symbol to remove keyword attribute in PascalABC.NET",
    "output": "// Example illustrating the use of \"&\" symbol to remove keyword attribute\n\nbegin\n  var &begin,&end: integer;  \n\n  &begin := 1;\n  &end := 2;\n  var t: System.Type := &begin.GetType; // no need to use & in System.Type\n  write(&begin,' ',&end,' ',t);\nend."
  },
  {
    "instruction": "Demonstrate using the \"&\" symbol for explicit template type specification in PascalABC.NET",
    "output": "// Example illustrating the use of \"&\" symbol for explicit template routine type specification\n\nfunction GetDefault<T>: T :=\n  default(T);\n\ntype\n  GenericType<T> = class\n    constructor := exit;\n    static procedure p1 := writeln(typeof(T));\n  end;\n\nbegin\n  // The compiler doesn't distinguish between comparison operator < and opening angle bracket\n  // so we need to use \"&\" to escape \"<\"\n  var o := GetDefault&<byte>;\n  \n  // For template types - usually \"&\" is not needed\n  var a := new GenericType<word>;\n  \n  // However for static method call - it must be placed\n  GenericType&<real>.p1;\n  \nend."
  },
  {
    "instruction": "Create simple linear animation moving a circle across the screen using GraphWPF in PascalABC.NET",
    "output": "uses GraphWPF;\n\nbegin\n  Window.Title := 'Simple Animation';\n  var x := 30;\n  Brush.Color := Colors.Beige;\n  Circle(x,50,20);\n  loop 600 do\n  begin\n    Sleep(10);\n    Window.Clear;\n    x += 1;\n    Circle(x,50,20);\n    Window.Title := '' + (Milliseconds div 100)/10;\n  end;\nend."
  },
  {
    "instruction": "Generate character code table from ASCII 32 to 255 with formatting in PascalABC.NET",
    "output": "begin\n  for var i:=32 to 255 do\n  begin\n    write(i:4,chr(i):2,'  ');\n    if i mod 8 = 7 then writeln;\n  end;\nend."
  },
  {
    "instruction": "Demonstrate child object attachment and rotation in 3D graphics using Graph3D in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin\n  var s := Sphere(0,1,2,2,Colors.Orchid);\n  s.AddChild(Sphere(0,2,1,0.5,Colors.White));\n  s.Rotate(OrtZ,90);\nend."
  },
  {
    "instruction": "Show class constructors and static fields in PascalABC.NET with random person generation example",
    "output": "// Example of using class (static) constructor\ntype \n  Person = class\n  private\n    class arr: array of Person; // Class field. Associated not with class variable, but with class. \n    name: string;\n    age: integer;\n  public\n    class constructor; // Class constructor. Called before creating first class object and before calling any class method\n    begin\n      Println('  Class constructor called');\n      SetLength(arr,3);\n      arr[0] := new Person('Ivanov',20);\n      arr[1] := new Person('Petrova',19);\n      arr[2] := new Person('Popov',35);\n    end;\n    constructor (n: string; a: integer);\n    begin\n      name := n;\n      age := a;\n    end;\n    function ToString: string; override;\n    begin\n      Result := $'Name: {name}   Age: {age}';      \n    end;\n    class function RandomPerson: Person; // Class method. Can only access class fields\n    begin\n      Result := arr[Random(3)];\n    end;\n  end;\n  \nbegin\n  Println('Random persons');\n  for var i:=1 to 5 do\n    Println(Person.RandomPerson); // Calling class method\nend."
  },
  {
    "instruction": "Show how to define methods inside class interface and demonstrate constructor usage in PascalABC.NET",
    "output": "// Method description inside class interface\n// Convenience: methods can be implemented immediately after declaration\n// Inconvenience: for large classes interface is hard to read\ntype \n  Person = class\n  private\n    // Class fields, as a rule, are private. Access to them - through methods and properties\n    name: string;\n    age: integer;\n  public\n    // Constructor implicitly has name Create\n    constructor (n: string; a: integer);\n    begin\n      name := n; age := a;\n    end;\n    procedure Print;\n    begin\n      Println('Name:',name,' Age:',age);\n    end;\n  end;\n\nvar p,p1: Person;\n\nbegin\n  p := new Person('Ivanov',20); // New constructor call syntax (recommended)\n  p.Print;\n  p1 := Person.Create('Popov',19); // Old constructor call syntax (not recommended)\n  p1.Print;\n  // Destructors are absent, instead - automatic garbage collection\nend."
  },
  {
    "instruction": "Create digital clock with frame-based animation using GraphWPF in PascalABC.NET",
    "output": "uses GraphWPF;\n\nbegin\n  Window.Title := 'Digital clock';\n  Font.Size := 180;\n  BeginFrameBasedAnimation(\n    ()->DrawText(Window.ClientRect,DateTime.Now.ToLongTimeString.Replace(' AM','').Replace(' PM',''),Colors.Red),\n    1\n  );\nend."
  },
  {
    "instruction": "Demonstrate 3D object cloning and animation in Graph3D module using PascalABC.NET",
    "output": "uses Graph3D;\nbegin\n  var b := Box(0,0,1,1,3,2,RandomColor);\n  var b1 := b.Clone;\n  b1.MoveBy(3,0,0);\n  b1.AnimRotate(OrtZ,90).Begin;\nend."
  },
  {
    "instruction": "Create hierarchical 3D object structure with cloning and animation in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin\n  var s := Sphere(0,0,0,1,Colors.Red);\n  var c := Cube(0,0,1.5,1,Colors.Blue);\n  var p := Pyramid(0,0,0.5,4,0.5,1,Colors.LightGreen);\n  s.AddChild(c);\n  c.AddChild(p);\n  var s1 := s.Clone;\n  s1.MoveByX(2);\n  var g := Group(s,s1);\n  var g1 := g.Clone;\n  g.MoveByY(-4);\n  s1.AnimRotateAt(OrtZ,360,P3D(-2,0,0)).Begin;\nend."
  },
  {
    "instruction": "Generate clustered data points using MathNet.Numerics for normal distribution in PascalABC.NET",
    "output": "{$reference Mathnet.Numerics.dll}\nuses Mathnet.Numerics;\nuses Coords;\n\nfunction GenerateCluster(X, Y, spread: real; count: integer): array of Point;\nbegin\n  var xx := Generate.Normal(count, X, spread);\n  var yy := Generate.Normal(count, Y, spread);\n  Result := ArrGen(count, i -> Pnt(xx[i],yy[i]));\nend;\n\nbegin\n  Window.Title := 'Cluster generation';\n  var cluster1 := GenerateCluster(5, 3, 0.5, 90);\n  var cluster2 := GenerateCluster(7, -6, 1.5, 105);\n  var cluster3 := GenerateCluster(-7, 2, 1, 44);\n  \n  DrawPoints(cluster1,3);\n  DrawPoints(cluster2,3);\n  DrawPoints(cluster3,PointRadius := 3);\nend."
  },
  {
    "instruction": "Demonstrate colored console output using special character codes in PascalABC.NET",
    "output": "begin\n  Writeln('123456789');\n  Writeln(#65535'123456789');\n  Writeln(#65534'123456789');\n  Writeln(#65533'123456789');\n  Writeln(#65532'123456789');\n  Writeln(#65531'123456789');\nend."
  },
  {
    "instruction": "Fix compilation error by adding missing semicolon in variable declaration in PascalABC.NET",
    "output": "var i: integer;\n\nbegin\n  i := 2;\n  Writeln(i);\nend."
  },
  {
    "instruction": "Fix compilation errors by declaring variable and correcting function name in PascalABC.NET",
    "output": "var r: real;\n\nbegin\n  r := 2.5;\n  Writeln(r);\nend."
  },
  {
    "instruction": "Fix compilation error by using decimal point instead of comma in real number assignment in PascalABC.NET",
    "output": "var k: real;\n\nbegin\n  k := 2.5;\n  Writeln(k);\nend."
  },
  {
    "instruction": "Fix the compilation error by changing the variable type of x to match the assigned value",
    "output": "// Fix compilation errors by changing variable x type\n\nbegin\n  var x: real := 3/5;\nend."
  },
  {
    "instruction": "Demonstrate complex number operations including square root and magnitude calculation in PascalABC.NET",
    "output": "begin\n  var a := new Complex(0,1);\n  Println('Imaginary unit: ', a);\n  \n  var b := Sqrt(a);\n  Println('Principal root of imaginary unit: ', b);\n  \n  var c := a*a;\n  Println('Square of imaginary unit: ', c);\n  \n  var d := Cplx(1,2);\n  Println($'Magnitude of {ObjectToString(d)} equals {d.Magnitude}');\nend."
  },
  {
    "instruction": "Extract and display English consonants by excluding vowels from alphabet in PascalABC.NET",
    "output": "begin\n  var vowel: string := 'aeiouy';\n\n  var all := ('a'..'z').JoinToString;\n  all.Except(vowel).Println;\nend."
  },
  {
    "instruction": "Create interactive 3D pyramid with dynamic property controls using Graph3D and Controls in PascalABC.NET",
    "output": "uses Graph3D, Controls;\n\nbegin\n  var l := LeftPanel(200, Colors.LightGoldenrodYellow);\n  \n  var height := IntegerBox('Height:', 1, 15);\n  height.Value := 5;\n  height.Tooltip := 'Use mouse wheel';\n  var radius := IntegerBox('Radius:', 1, 6);\n  radius.Value := 2;\n  radius.Tooltip := 'Use mouse wheel';\n  var sides := Slider('Number of sides: ', 3, 20);\n  sides.Frequency := 1;\n  sides.Value := 5;\n  \n  var p := Pyramid(Origin, sides.Value, height.Value, radius.Value, Colors.Green);\n  \n  height.ValueChanged := procedure -> begin\n    p.Height := height.Value;\n  end;\n  radius.ValueChanged := procedure -> begin\n    p.Radius := radius.Value;\n  end;\n  sides.ValueChanged := procedure -> begin\n    p.Sides := sides.Value;\n  end;\nend."
  },
  {
    "instruction": "Demonstrate character code functions Ord and Chr with Windows encoding in PascalABC.NET",
    "output": "var \n  i: integer;\n  c: char;\n\nbegin\n  c := 'z';\n  i := Ord(c);\n  writelnFormat('Character {0} code in Windows encoding equals {1}',c,i);\n  i := 193;\n  c := Chr(i);\n  writelnFormat('Character with code {0} in Windows encoding is {1}',i,c);\nend."
  },
  {
    "instruction": "Demonstrate Unicode character code functions OrdUnicode and ChrUnicode in PascalABC.NET",
    "output": "var \n  i: integer;\n  c: char;\n\nbegin\n  c := '\u0414';\n  i := OrdUnicode(c);\n  writelnFormat('Character {0} code in Unicode encoding equals {1}',c,i);\n  i := 1046;\n  c := ChrUnicode(i);\n  writelnFormat('Character with code {0} in Unicode encoding is {1}',i,c);\nend."
  },
  {
    "instruction": "Demonstrate character case conversion functions UpperCase and LowerCase in PascalABC.NET",
    "output": "var c: char;\n\nbegin\n  c := '\u0434';\n  writelnFormat('Character {0} in upper case: {1}',c,UpperCase(c));\n  c := 'F';\n  writelnFormat('Character {0} in lower case: {1}',c,LowerCase(c));\nend."
  },
  {
    "instruction": "Demonstrate standard character functions Ord, Chr, OrdWindows, ChrWindows for different encodings in PascalABC.NET",
    "output": "// Standard functions Ord, Chr, OrdWindows, ChrWindows\n\nbegin\n  Println('sizeof(char) =',sizeof(char));\n  Println;\n  var c: char  := '\u0416';\n  var i: integer := Ord(c);\n  Println($'Character code {c} in Unicode encoding equals {i}');\n  c := Chr(i);\n  Println($'Character with code {i} in Unicode encoding - this is {c}');\n  Println;\n  i := OrdWindows(c);\n  Println($'Character code {c} in Windows encoding equals {i}');\n  c := ChrWindows(i);\n  Println($'Character with code {i} in Windows encoding - this is {c}');\nend."
  },
  {
    "instruction": "Demonstrate the use of ranges and sequences in PascalABC.NET with the following operations: create a character range 'a' to 'z', check if 3 is in range 1..5, iterate through range 1..10, create an array and hash set from range 1..5, and calculate squares of numbers 1 to 9.",
    "output": "begin\n  var diap := 'a'..'z';\n  Println(diap);\n  var g := 3 in 1..5;\n  Println(g);\n  foreach var x in 1..10 do\n    Print(x);\n  var a := Arr(1..5);\n  var h := HSet(1..5);\n  Println(a,h);\n  (1..9).Select(x->x*x).Println;\nend."
  },
  {
    "instruction": "Create and display a dictionary from an array of key-value pairs in PascalABC.NET.",
    "output": "##\nvar pairs := Arr((1,'\u043e\u0434\u0438\u043d'),(2,'\u0434\u0432\u0430'));\nvar d := Dict(pairs);\nPrintln(pairs);\nPrintln(d);"
  },
  {
    "instruction": "Create and use a string dictionary and integer list in PascalABC.NET. Add 'cat' translation for '\u043a\u043e\u0448\u043a\u0430' to dictionary and add numbers 2 and 3 to the list.",
    "output": "##\nvar d := DictStr;\nd['\u043a\u043e\u0448\u043a\u0430'] := 'cat';\nd.Println;\nvar L := LstInt;\nL.Add(2); L.Add(3);\nL.Println;"
  },
  {
    "instruction": "Solve the Cauchy problem for orbital motion using RKF45 method in PascalABC.NET with NumLibABC library.",
    "output": "uses NumLibABC;\n\nprocedure Orbit(t:real; y,yp:array of real);\nbegin\n  var alpha:=Sqr(ArcTan(1.0));\n  var r:=y[0]*y[0]+y[1]*y[1]; r:=r*Sqrt(r)/alpha;\n  yp[0]:=y[2]; yp[1]:=y[3]; yp[2]:=-y[0]/r; yp[3]:=-y[1]/r\nend;\n\nbegin\n  var e:=0.25;\n  var y:=Arr(1.0-e,0.0,0.0,ArcTan(1)*Sqrt((1.0+e)/(1.0-e)));\n  var (abserr,relerr):=(0.0,0.3e-6);\n  var oL:=new RKF45(Orbit, y, abserr, relerr);\n  var (t,tb,th):=(0.0,12.0,0.5);\n  var t_out:=t;\n  repeat\n    oL.Solve(t,t_out);\n    Writeln(t:5:1,oL.y[0]:15:9,oL.y[1]:15:9);\n    case oL.flag of\n    -3,-2,-1,1,8:begin Writeln('Flag=',oL.flag); Exit end;\n    2:t_out:=t+th;\n    end\n  until t>=tb\nend."
  },
  {
    "instruction": "Create a digital clock using GraphABC and System libraries in PascalABC.NET that displays current time in HH:MM:SS format and updates every second.",
    "output": "uses GraphABC,System;\n\nbegin\n  Font.Size := 80;\n  var x0 := (Window.Width - TextWidth('00:00:00')) div 2;\n  var y0 := (Window.Height - TextHeight('00:00:00')) div 2;\n  while True do\n  begin\n    var t := DateTime.Now;\n    var s := string.Format('{0:d2}:{1:d2}:{2:d2}',t.Hour,t.Minute,t.Second);\n    TextOut(x0,y0,s);\n    Sleep(1000);\n  end;\nend."
  },
  {
    "instruction": "Create graphics with random points, shapes and text using Coords library in PascalABC.NET.",
    "output": "uses Coords;\n\nfunction RandomPoint: Point := Pnt(Random(-13,13),Random(-10,10));\n\nbegin\n  DrawPoints(ArrGen(10,i -> RandomPoint),PointRadius := 4);\n  DrawPoints(ArrGen(10,i -> RandomPoint),PointRadius := 6);\n  DrawPoint(2,3,Colors.Red);\n  DrawCircle(1,1,1,Colors.LightBlue);\n  DrawRectangle(3,2,2,1);\n  DrawText(3,2,'Hello');\n  DrawTextUnscaled(0,0,'\u0422\u0435\u043a\u0441\u0442 \u043d\u0435 \u043c\u0430\u0441\u0448\u0442\u0430\u0431\u0438\u0440\u0443\u0435\u0442\u0441\u044f', Size := 20, Color := Colors.Red);\n  DrawText(-4,7,'\u0422\u0435\u043a\u0441\u0442 \u043c\u0430\u0441\u0448\u0442\u0430\u0431\u0438\u0440\u0443\u0435\u0442\u0441\u044f', FontName := 'Courier New', Size := 34);\nend."
  },
  {
    "instruction": "Draw points with labels and calculate distances between them using Coords library in PascalABC.NET.",
    "output": "uses Coords;\n\nbegin\n  Globals.PointRadius := 2.3;\n  Globals.LineWidth := 1.0;\n  var p1 := Pnt(2,3);\n  var p2 := Pnt(-4,7.3);\n  var p3 := Pnt(-5,-3);\n  DrawPoint(p1); \n  DrawPoint(p2);\n  DrawPoint(p3);\n  DrawText(p1,'A', Align := Alignment.LeftBottom, Size := 18);\n  DrawText(p2,'B', Align := Alignment.LeftBottom, Size := 18);\n  DrawText(p3,'C', Align := Alignment.RightTop, Size := 18);\n  DrawLine(p1,p2);\n  DrawLine(p1,p3);\n  DrawLine(p2,p3);\n  DrawText(Middle(p1,p2), p1.Distance(p2).ToString(2), Align := Alignment.Center, BackgroundColor := Colors.LightBlue);\n  DrawText(Middle(p2,p3), p2.Distance(p3).ToString(2), Align := Alignment.Center,\n    BackgroundColor := Colors.White, BorderWidth := 0.5);\n  DrawText(Middle(p1,p3), p1.Distance(p3).ToString(2), Align := Alignment.Center, BackgroundColor := Colors.LightGreen);\nend."
  },
  {
    "instruction": "Count occurrences of number 1 in an array using CountOf method in PascalABC.NET.",
    "output": "begin\n  var a := Arr(1,3,5,7,1,2,1,3,1,5);\n  a.CountOf(1).Print;\nend."
  },
  {
    "instruction": "Demonstrate covariance with sequences of different types in PascalABC.NET.",
    "output": "begin\n  var a: sequence of object;\n  var b: sequence of integer;\n  a := b;\n  a := Arr(1,2,3);\n  a := new List<DateTime>;\nend."
  },
  {
    "instruction": "Create a console drawing application using Crt library in PascalABC.NET with cursor movement and color changing functionality.",
    "output": "uses Crt;\n\nvar\n  draw: boolean;\t\t\t\n  color: integer;\n  \nfunction IsCoordCorrect(x,y: integer): boolean;  \nbegin\n  Result := (x in [1..WindowWidth]) and (y in [1..WindowHeight]);\nend;\n  \nprocedure MyGotoXY(x,y: integer);\nbegin\n  if not IsCoordCorrect(x,y) then  \n    exit;\n  GotoXY(x,y);  \nend;\n\nprocedure DrawSymbol(x,y: integer; c: char);\nbegin\n  if not IsCoordCorrect(x,y) then  \n    exit;\n  GotoXY(x,y);  \n  write(c);\n  GotoXY(x,y);  \nend;\n  \nbegin\n  draw := True;\n  color := Green;\n  ClrScr;\n  SetWindowTitle('\u0420\u0438\u0441\u043e\u0432\u0430\u043d\u0438\u0435 \u043a\u0443\u0440\u0441\u043e\u0440\u043e\u043c (Esc-\u0432\u044b\u0445\u043e\u0434, Num 5 - \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0435 \u0446\u0432\u0435\u0442\u0430)');\n  TextBackGround(color);\n  GotoXY(WindowWidth div 2,WindowHeight div 2);\n  var c: char;\n  repeat\n    c := ReadKey;\n    if c=#32 then \n      draw := not draw;\n    if c=#0 then \n    begin\n      c := ReadKey;\n      case c of                           \n    {5} #12: begin\n              color := color + 1;\n              if color=16 then \n                color := 0;\n              TextBackGround(color);\n            end;\n    {RU}#33: MyGotoXY(WhereX+1,WhereY-1);\n    {RD}#34: MyGotoXY(WhereX+1,WhereY+1);\n    {LD}#35: MyGotoXY(WhereX-1,WhereY+1);\n    {LU}#36: MyGotoXY(WhereX-1,WhereY-1);\n    {L} #37: MyGotoXY(WhereX-1,WhereY);\n    {U} #38: MyGotoXY(WhereX,WhereY-1);\n    {R} #39: MyGotoXY(WhereX+1,WhereY);\n    {D} #40: MyGotoXY(WhereX,WhereY+1);\n        #67: ClrScr;\n      end;\n      if draw then \n        DrawSymbol(WhereX, WhereY,' ');\n    end;\n  until c=#27;\n  TextBackGround(Black);\n  GotoXY(1,25);\nend."
  },
  {
    "instruction": "Display all CRT color combinations in PascalABC.NET.",
    "output": "uses CRT;\n\nbegin\n  SetWindowTitle('\u0421\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u0435 CRT-\u0446\u0432\u0435\u0442\u0430');\n  for var i:=0 to 15 do\n  begin\n    TextBackground(i);\n    for var j:=0 to 15 do\n    begin\n      TextColor(j);\n      write(' CRT');\n    end;\n    writeln;\n  end;\n  HideCursor;\n  TextBackground(0);\n  TextColor(0);\nend."
  },
  {
    "instruction": "Create a 3D cube grid using Graph3D library in PascalABC.NET.",
    "output": "uses Graph3D;\n\nbegin\n  View3D.ShowGridLines := False;\n  View3D.ShowViewCube := False;\n  View3D.ShowCoordinateSystem := False;\n  var w := 1;\n  for var x := -5 to 5 do\n  for var y := -5 to 5 do\n  for var z := -4 to 6 do\n    Cube(x*w,y*w,z*w,w*0.96,RandomColor)\nend."
  },
  {
    "instruction": "Create various graphical shapes and text using GraphWPF library in PascalABC.NET with save/load functionality.",
    "output": "uses GraphWPF;\n\nbegin\n  Window.Title := '\u0412\u0441\u044f\u043a\u0430\u044f \u041a\u0443\u0440\u044c\u044f \u041c\u0443\u0440\u044c\u044f';\n  Pen.Width := 0.5;\n  Brush.Color := RGB(128,200,100);\n  Ellipse(100,100,30,20);\n  Brush.Color := RandomColor;\n  Circle(170,100,20);\n  Brush.Color := RandomColor;\n  Rectangle(220,80,70,50);\n  Line(220,80,220+70,80+50);\n  Brush.Color := RGB(200,200,255);\n  Polygon(Arr(Pnt(20,20),Pnt(20,120),Pnt(120,20)));\n  Brush.Color := Colors.Black;\n  for var i:=0 to 400 do\n    Rectangle(1+2*i,2,0,0);\n  Font.Size := 30;\n  Font.Color := Colors.Red;\n  TextOut(0,0,'Hello');  \n  Font.Size := 40;\n  Font.Color := Colors.Blue;\n  Font.Name := 'Times New Roman';\n  Font.Style := FontStyle.BoldItalic;\n  TextOut(200,0,'\u041f\u0440\u0438\u0432\u0435\u0442'); \n  Sleep(1000);\n  Window.Save('1.png');\n  Window.Title := '\u0421\u043e\u0445\u0440\u0430\u043d\u0438\u043b\u0438';\n  Sleep(1000);\n  Window.Clear;\n  Window.Title := '\u041e\u0447\u0438\u0441\u0442\u0438\u043b\u0438';\n  Sleep(1000);\n  Window.Load('1.png');\n  Window.Title := '\u0417\u0430\u0433\u0440\u0443\u0437\u0438\u043b\u0438';\nend."
  },
  {
    "instruction": "Demonstrate working with DateTime and TimeSpan in PascalABC.NET including date arithmetic and formatting",
    "output": "uses System;\n\nbegin\n  // Getting current date - calling static method\n  var d1 := DateTime.Now; \n  Println(d1);\n  \n  // Date and time after one month\n  var d2 := d1.AddMonths(1);\n  Println(d2);\n\n  // Date and time 12 hours earlier\n  d2 := d1.AddHours(-12);\n  Println(d2);\n\n  // Creating date - calling object constructor (year, month, day)\n  var d3 := new DateTime(2001, 1, 1);\n  Println(d3);\n  \n  // Determining time passed since millennium start (date difference)\n  var ts: TimeSpan := d1.Subtract(d3);\n\n  // Time interval in days (result - real number)\n  Println(ts.TotalDays);\n  \n  // Time interval in days, hours, minutes and seconds\n  Println($'{ts.Days} {ts.Hours}:{ts.Minutes}:{ts.Seconds}');\nend."
  },
  {
    "instruction": "Parse date string, check for leap year, and format DateTime to different string representations in PascalABC.NET.",
    "output": "Uses System;\n\nbegin\n  var s := '03.27.2008 9:58:17';\n  var d: DateTime;\n  if not DateTime.TryParse(s, d) then\n  begin\n    Println('\u0421\u0442\u0440\u043e\u043a\u0430 \u043d\u0435 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0434\u0430\u0442\u044b \u0438 \u0432\u0440\u0435\u043c\u0435\u043d\u0438');\n    Exit;\n  end;\n\n  if DateTime.IsLeapYear(d.Year) then\n     Println('\u0413\u043e\u0434 \u0432\u0438\u0441\u043e\u043a\u043e\u0441\u043d\u044b\u0439')\n  else\n     Println('\u0413\u043e\u0434 \u043d\u0435\u0432\u0438\u0441\u043e\u043a\u043e\u0441\u043d\u044b\u0439');\n  \n  s := d.ToString;\n  Println(s);\n  \n  s := d.ToShortDateString;\n  Println(s);\n\n  s := d.ToShortTimeString;\n  Println(s);\nend."
  },
  {
    "instruction": "Measure code execution time using DateTime in PascalABC.NET.",
    "output": "begin\n  var dt: DateTime := DateTime.Now;\n  var ms := Random(1000);\n  Writeln('Sleep','(',ms,')');\n  Sleep(ms);\n  Println((DateTime.Now-dt).TotalMilliseconds,'ms');\nend."
  },
  {
    "instruction": "Solve system of linear equations using Decomp from NumLibABC library in PascalABC.NET.",
    "output": "uses NumLibABC;\n\nbegin\n  var A:=new real[3,3] ((2,3,-1),(1,-2,1),(1,0,2));\n  var B:=new real[3] (9,3,2);\n  var oL:=new Decomp(A);\n  oL.Solve(B);\n  B.Println;\n  Writeln('cond=',oL.cond)\nend."
  },
  {
    "instruction": "Create a game where squares must be deleted in numerical order using WPFObjects library in PascalABC.NET.",
    "output": "uses WPFObjects;\n\nconst CountSquares = 20;\n\nvar\n  CurrentDigit: integer;\n  Mistakes: integer;\n  StatusRect: RectangleWPF;\n\nprocedure DrawStatusText;\nbegin\n  if CurrentDigit<=CountSquares then\n    StatusRect.Text := $'\u0423\u0434\u0430\u043b\u0435\u043d\u043e \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u043e\u0432: {CurrentDigit-1}     \u041e\u0448\u0438\u0431\u043e\u043a: {Mistakes}'\n  else StatusRect.Text := $'\u0418\u0433\u0440\u0430 \u043e\u043a\u043e\u043d\u0447\u0435\u043d\u0430. \u0412\u0440\u0435\u043c\u044f: {Milliseconds div 1000} \u0441.    \u041e\u0448\u0438\u0431\u043e\u043a: {Mistakes}';\nend;\n\nprocedure MyMouseDown(x,y: real; mb: integer);\nbegin\n  var ob := ObjectUnderPoint(x,y);\n  if (ob<>nil) and (ob is RectangleWPF) and (ob<>StatusRect) then\n    if ob.Number=CurrentDigit then\n    begin\n      ob.Destroy;\n      Inc(CurrentDigit);\n      DrawStatusText;\n    end\n    else\n    begin\n      ob.Color := Colors.Red;\n      Inc(Mistakes);\n      DrawStatusText;\n    end;\nend;\n\nbegin\n  Window.Title := '\u0418\u0433\u0440\u0430: \u0443\u0434\u0430\u043b\u0438 \u0432\u0441\u0435 \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u044b \u043f\u043e \u043f\u043e\u0440\u044f\u0434\u043a\u0443';\n  for var i:=1 to CountSquares do\n  begin\n    var x := Random(Window.Width-50);\n    var y := Random(Window.Height-100);\n    var ob := RectangleWPF.Create(x,y,50,50,Colors.LightGreen,1);\n    ob.FontSize := 25;\n    ob.Number := i;\n  end;\n  StatusRect := RectangleWPF.Create(0,Window.Height-40,Window.Width,40,Colors.LightBlue);\n  CurrentDigit := 1;\n  Mistakes := 0;\n  DrawStatusText;\n  OnMouseDown := MyMouseDown;\nend."
  },
  {
    "instruction": "Display letters/digits and punctuation characters from ASCII range 0-127 in PascalABC.NET.",
    "output": "begin\n  Range(#0,#127).Where(c->char.IsLetterOrDigit(c)).Println;\n  Range(#0,#127).Where(c->char.IsPunctuation(c)).Println;\nend."
  },
  {
    "instruction": "Draw a circle interactively using mouse in GraphWPF. Press and hold mouse button to draw circles with random colors.",
    "output": "uses GraphWPF;\n\nbegin\n  var x1,y1: real;\n  var c: Color;\n  OnMouseDown := procedure(x,y,mb) -> begin\n    (x1,y1) := (x,y);\n    c := RandomColor;\n  end;\n  OnMouseMove := procedure(x,y,mb) -> if mb=1 then\n  begin\n    var r := Sqrt(Sqr(x1-x)+Sqr(y1-y));\n    Window.Clear;\n    Circle(x1,y1,r,c);\n  end;\nend."
  },
  {
    "instruction": "Draw multiple mathematical functions (x*sin(x), sin, cos, exp) using GraphABC with transparent brush.",
    "output": "uses GraphABC;\n\nbegin\n  Brush.Color := ARGB(0,0,0,0);\n  Draw(x->x*sin(x),-20,20);\n  Draw(sin);\n  Draw(cos);\n  Draw(exp);\nend."
  },
  {
    "instruction": "Draw mathematical functions in different scaled rectangles using GraphABC. Implement Scale and Move extension methods for Rectangle.",
    "output": "uses GraphABC;\n\nfunction System.Drawing.Rectangle.Scale(m: real): System.Drawing.Rectangle;\nbegin\n  Result := Self;\n  Result.Width := Trunc(Result.Width * m);\n  Result.Height := Trunc(Result.Height * m)\nend;\n\nfunction System.Drawing.Rectangle.Move(dx,dy: integer): System.Drawing.Rectangle;\nbegin\n  Result := Self;\n  Result.X := Result.X + dx;\n  Result.Y := Result.Y + dy;\nend;\n\nbegin\n  var r := ClientRectangle;\n  r := r.Scale(0.5);\n  var r1 := r.Move(r.Width,0);\n  var r2 := r.Move(0,r.Height);\n  var r3 := r.Move(r.Width,r.Height);\n  Draw(x->x*sin(x),-20,20,r);\n  Draw(sin,r1);\n  Draw(cos,r2);\n  Draw(exp,20,10,r3);\nend."
  },
  {
    "instruction": "Draw multiple function graphs in different window quadrants using GraphWPF: sin(4x)+cos(3x), x\u00b2, exp(x), and x*cos(2x-1).",
    "output": "uses GraphWPF;\n\nbegin\n  Window.Title := '\u0413\u0440\u0430\u0444\u0438\u043a\u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0439';\n  var ww := Window.Width / 2;\n  var hh := Window.Height / 2;\n  DrawGraph(x -> sin(4 * x) + cos(3 * x), -5, 5, 0, 0, ww, hh, 'sin(4 * x) + cos(3 * x)');\n  DrawGraph(x -> x * x, -5, 5, ww - 1, 0, ww, hh, 'x * x');\n  DrawGraph(x -> exp(x), -3, 3, 0, 10, 0, hh-1, ww, hh, 'exp(x)');\n  DrawGraph(x -> x*cos(2*x-1), -15, 15, ww - 1, hh-1, ww, hh, 'x * cos(2*x-1)');\nend."
  },
  {
    "instruction": "Generate and display a pixel matrix with calculated RGB colors using GraphWPF, then measure drawing performance.",
    "output": "uses GraphWPF;\n\nbegin\n  Window.SetSize(640, 480);\n  var m := MatrGen(640,480,(x,y)->RGB(2 * x - y, x - 3 * y, x + y));\n  MillisecondsDelta.Println;  \n  DrawPixels(0,0,m);\n  MillisecondsDelta.Println;  \nend."
  },
  {
    "instruction": "Draw random points using Turtle library. Generate arrays of random coordinates and plot them.",
    "output": "uses Turtle;\n\nbegin\n  Window.Title := 'DrawPoints';\n  var n := 1000;\n  var d := 10;\n  var a := ArrRandomReal(n,-d,d);\n  DrawPoints(a[::2],a[1::2]);\n  a := ArrRandomReal(n,-d,d);\n  DrawPoints(a[::2],a[1::2]);\nend."
  },
  {
    "instruction": "Create parametric trajectory functions and duplicate 3D objects along a spiral path using Graph3D.",
    "output": "uses Graph3D;\n\nfunction ParametricTrajectory(a,b: real; fun: real->Point3D; N: integer) := PartitionPoints(a,b,N).Select(fun);\n\nfunction ParametricCirve3D(a,b: real; fun: real->Point3D; N: integer := 200): SegmentsT;\nbegin\n  var tr := ParametricTrajectory(a,b,fun,N);\n  Result := Polyline3D(tr);\nend;\n\nprocedure DuplicateByTrajectory(c: Object3D; a,b: real; fun: real->Point3D; N: integer);\nbegin\n  c.MoveTo(fun(a));\n  foreach var p in PartitionPoints(a,b,N).Skip(1).Select(fun) do\n  begin\n    var c1 := c.Clone.MoveTo(p);\n    c1.Rotate(OrtZ,3);\n    (c1 as CubeT).Color := RandomColor;\n    c := c1;\n  end;\nend;\n\nbegin\n  var c := Cube(0,0,0,0.7,Colors.Green);\n  DuplicateByTrajectory(c,0,4*Pi,t->P3D(4*cos(t),4*sin(t),0.5*t),40);\nend."
  },
  {
    "instruction": "Show procedures and methods for working with dynamic arrays including sorting, reversing, and searching in PascalABC.NET",
    "output": "// Procedures and methods for working with dynamic array\n\nbegin\n  var a := ArrRandomInteger(10);\n  \n  // Output all array elements\n  a.Println;\n  \n  // Array sorting\n  a.Sort;\n  a.Println;\n\n  // Array reversal\n  a.Reverse;\n  a.Println;\n\n  // Changing array size with element preservation\n  SetLength(a,a.Length+2);\n  a.Println;\n\n  // Searching for element in array\n  var i := a.IndexOf(50);\n  Println(i);\nend."
  },
  {
    "instruction": "Create and display a dynamic array of random integers using SetLength and foreach loop.",
    "output": "var a: array of integer;\n\nbegin\n  var n := 20;\n  SetLength(a,n);\n  for var i:=0 to a.Length-1 do\n    a[i] := Random(1,99);\n  writeln('\u0421\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u043e\u0433\u043e \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u0435\u0441\u043a\u043e\u0433\u043e \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0446\u0435\u043b\u044b\u0445: ');  \n  foreach var x in a do\n    Print(x);\nend."
  },
  {
    "instruction": "Demonstrate that dynamic array assignment creates references, not copies. Show how modifying one array affects another.",
    "output": "var a: array of integer;\n\nbegin\n  writeln('\u041f\u0440\u0438 \u043f\u0440\u0438\u0441\u0432\u0430\u0438\u0432\u0430\u043d\u0438\u0438 \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u0435\u0441\u043a\u0438\u0445 \u043c\u0430\u0441\u0441\u0438\u0432\u043e\u0432 \u0434\u0432\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u043d\u0430\u0447\u0438\u043d\u0430\u044e\u0442 \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0442\u044c \u043d\u0430 \u043e\u0434\u043d\u0443 \u043f\u0430\u043c\u044f\u0442\u044c:');\n  var n := 20;\n  a := new integer[n];\n  for var i:=0 to a.Length-1 do\n    a[i] := i;\n  writeln('\u0414\u043e \u043f\u0440\u0438\u0441\u0432\u0430\u0438\u0432\u0430\u043d\u0438\u044f b[5]: a[5]=',a[5]);\n  var b: array of integer;\n  b := a;\n  b[5] := 666;\n  writeln('\u041f\u043e\u0441\u043b\u0435 \u043f\u0440\u0438\u0441\u0432\u0430\u0438\u0432\u0430\u043d\u0438\u044f b[5]: a[5]=',a[5]);\nend."
  },
  {
    "instruction": "Show how SetLength preserves existing elements when resizing a dynamic array.",
    "output": "var a: array of integer;\n\nbegin\n  writeln('SetLength \u043f\u0440\u0438 \u043f\u043e\u0432\u0442\u043e\u0440\u043d\u043e\u043c \u0432\u044b\u0437\u043e\u0432\u0435 \u043d\u0435 \u043f\u043e\u0440\u0442\u0438\u0442 \u0441\u0442\u0430\u0440\u044b\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b:');\n  SetLength(a,5);\n  for var i:=0 to a.Length-1 do\n    a[i] := i+1;\n  a.Println;\n  SetLength(a,10);\n  a.Println;\nend."
  },
  {
    "instruction": "Demonstrate passing dynamic arrays as parameters. Show when to use var parameter for array creation.",
    "output": "procedure WriteArr(a: array of integer);\nbegin\n  foreach x: integer in a do\n    write(x,' ');\n  writeln;\nend;\n\nprocedure CreateRandomArr(var a: array of integer; n: integer);\nbegin\n  a := new integer[n];\n  for var i:=0 to a.Length-1 do\n    a[i] := Random(10);\nend;\n\nvar a: array of integer;\n\nbegin\n  writeln('\u0421\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u0439 \u0446\u0435\u043b\u044b\u0439 \u043c\u0430\u0441\u0441\u0438\u0432: ');\n  CreateRandomArr(a,30);\n  WriteArr(a);\nend."
  },
  {
    "instruction": "Demonstrate common dynamic array errors: accessing array without memory allocation and index out of bounds.",
    "output": "// Error 1: No memory allocation\nvar a: array of integer;\nbegin\n  a[0] := 666;\nend.\n\n// Error 2: Index out of bounds  \nvar a: array of integer;\nbegin\n  SetLength(a,10);\n  a[10] := 666;\nend."
  },
  {
    "instruction": "Convert number to digits in base 2 and back using School library in PascalABC.NET.",
    "output": "##\nuses School;\nvar lst := 1234.Digits(2);\nlst.Println;\nvar n := lst.DigitsToInt64(2);\nPrintln(n);"
  },
  {
    "instruction": "Demonstrate div and mod operations for digit manipulation in PascalABC.NET",
    "output": "// div and mod operations\n\nbegin\n  var a := ReadInteger('Enter a:');\n  Println('Last digit of number:', a mod 10);\n  Println('Number without last digit:', a div 10);\n  Println('If number a is even, then 0:', a mod 2);\nend.\n\n// div and mod operations\n\nbegin \n  var a: integer := 247;\n  Print('Digits of number in reverse order:');\n  // Output last digit\n  Print(a mod 10);\n  // Discard last digit\n  a := a div 10;\n  Print(a mod 10);\n  a := a div 10;\n  Print(a mod 10);\nend."
  },
  {
    "instruction": "Use Drawman library to draw simple geometric shapes. Move to point, draw line, and return to origin.",
    "output": "uses Drawman;\n\nbegin\n  Task('a1');\n  ToPoint(2,3);\n  PenDown;\n  OnVector(1,2);\n  PenUp;\n  ToPoint(0,0);\nend."
  },
  {
    "instruction": "Download a file from web using System.Net.WebClient and execute it in PascalABC.NET.",
    "output": "uses System.Net;\n\nconst \n  address = 'www.yandex.ru';\n  filename = 'LogoPABCNET2010_Rus.png';\n\nbegin\n  var w := new WebClient();\n  w.DownloadFile('http://pascalabc.net/images/logo/'+filename,filename);\n  Exec(filename);\nend."
  },
  {
    "instruction": "Generate Dragon Curve fractal using GraphABC and Utils libraries in PascalABC.NET with performance measurement.",
    "output": "program Dragon;\n\nuses GraphABC,Utils;\n\nvar\n  x := 200;\n  y := 150;\n  dx := 0;\n  dy := -4;\n  turn: array [1..1000] of Boolean;\n\nbegin\n  SetWindowSize(790,500);\n  Window.Title := '\u041a\u0440\u0438\u0432\u0430\u044f \u0414\u0440\u0430\u043a\u043e\u043d\u0430';\n  var f := True;\n  for var a := 1 to 64 do\n  begin\n    turn[2*a-1] := f;\n    f := not f;\n    turn[2*a] := turn[a];\n  end;\n  var b := 0;\n  var d := 1;\n  f := false;\n  MoveTo(x,y);\n  \n  for var a:=1 to 128 do\n  begin\n    var t: integer;\n    LockDrawing;\n    for var i:=1 to 127*4 do\n    begin\n      b += d; \n      x += dx; \n      y += dy;\n      LineTo(x,y);\n      if f and not turn[b] or not f and turn[b] then\n      begin\n        t := dy;\n        dy := -dx;\n      end\n      else\n      begin\n        t := -dy;\n        dy := dx;\n      end;\n      dx := t;\n    end;\n    b += d; \n    x += dx; \n    y += dy;\n    LineTo(x,y);\n    d := -d;\n    f := not f;\n    if turn[a] then\n    begin\n      t := dy;\n      dy := -dx;\n    end\n    else\n    begin\n      t := -dy;\n      dy := dx;\n    end;\n    dx := t;\n    UnLockDrawing;\n  end;\n  write('\u0412\u0440\u0435\u043c\u044f \u0440\u0430\u0431\u043e\u0442\u044b = ',Milliseconds/1000,' \u0441');\nend."
  },
  {
    "instruction": "Draw a rectangle and an ellipse in a window using GraphWPF",
    "output": "uses GraphWPF;\n\nbegin\n  Pen.Width := 1;\n  Rectangle(0,0,Window.Width-1,Window.Height-1);\n  Ellipse((Window.Width-1)/2,(Window.Height-1)/2,(Window.Width-1)/2,(Window.Height-1)/2);\nend."
  },
  {
    "instruction": "Explain enumerated types in PascalABC.NET with operations like Inc, Dec, Succ, Pred and boundary behavior",
    "output": "// Enumerated type\ntype Months = (January,February,March,April,May,June,\n  July,August,September,October,November,December);\n\nbegin\n  var m: Months := February;\n  writeln(m);\n  // Using enumerated type constants after type name is convenient: after dot intellisense shows list of constants\n  m := Months.April;\n  Println('Next month:',m);\n  Inc(m);\n  Println('Next month:',m);\n  m := Succ(m);  \n  Println('Next month:',m);\n  m := Pred(m);  \n  Println('Previous month:',m);\n  Dec(m);\n  Println('Previous month:',m);\n  Println('Its ordinal number (numbering - from zero):',Ord(m));\n  // No error\n  Println('Month before January - out of bounds:',Pred(Months.January));\n  // No error\n  Println('Month after December - out of bounds:',Succ(Months.December));\nend."
  },
  {
    "instruction": "Work with enumeration type using System namespace to get names and values",
    "output": "// Enumeration type\nuses System;\n\ntype Months = (January,February,March,April,May,June,July,August,September,October,November,December);\n\nbegin\n  var t: &Type := typeof(Months);\n  var names: array of string := Enum.GetNames(t);\n  writeln('Cycle by enumeration type names');\n  foreach name: string in names do\n    write(name,' ');\n  writeln; writeln;\n  \n  var v: &Array := Enum.GetValues(t);\n  var mm: array of Months := new Months[v.Length];\n  writeln('Cycle by array of all enumeration type values');\n  for var i:=0 to v.Length-1 do\n    mm[i] := Months(v.GetValue(i));\n     \n  for var i:=0 to mm.Length-1 do\n    write(mm[i],' ');    \nend."
  },
  {
    "instruction": "Demonstrate EOF function usage for reading until end of input in PascalABC.NET",
    "output": "// Demonstration of EOF function work. Run with Shift-F9, finish with Ctrl-Z\n// Ctrl-Z doesn't work with 3.9\nbegin\n  while not Eof do\n  begin\n    var s := ReadChar;\n    Println('-', Ord(s), '-',CurrentIOSystem.peek);\n  end;\nend."
  },
  {
    "instruction": "Demonstrate EOLN function for reading until end of line",
    "output": "// Demonstration of EOLN function\nbegin\n  while not Eoln do\n  begin\n    var c := ReadChar;\n    Print(c);\n  end;\nend."
  },
  {
    "instruction": "Implement Sieve of Eratosthenes algorithm to find prime numbers up to 100000",
    "output": "// \"Sieve of Eratosthenes\" - computing prime numbers\nconst n = 100000;\n\nbegin\n  var primes := HSet(2..n);\n  \n  for var i:=2 to Round(Sqrt(n)) do\n  begin\n    if not (i in primes) then\n      continue;\n    var x := i*i;\n    while x<=n do\n    begin\n      primes -= x;\n      x += i;\n    end;\n  end;\n\n  Println('Prime numbers <',n,';');\n  Println(primes);\n  Println;\n  Println('Computation time:',Milliseconds/1000);\nend."
  },
  {
    "instruction": "Draw E-squares using recursion with GraphABC",
    "output": "// E-squares. Recursion demonstration\nuses GraphABC;\n\nconst mw = 2.9;\n\nprocedure ESquares(n,x,y,w: integer);\nbegin\n  var w1 := round(w/mw);\n  var h := (w-2*w1) div 3;\n  Brush.Color := clRandom;\n  Rectangle(x,y,x+w,y+w);\n  if n>0 then\n  begin\n    Sleep(1);\n    ESquares(n-1,x+h,y+h,w1);\n    ESquares(n-1,x+w-h-w1,y+h,w1);\n    ESquares(n-1,x+h,y+w-h-w1,w1);\n    ESquares(n-1,x+w-h-w1,y+w-h-w1,w1);\n  end;\nend;\n\nbegin\n  Window.Title := 'Recursion: E-squares';\n  SetWindowSize(750,530);\n  Pen.Color := clWhite;\n  ESquares(4,125,18,490);\nend."
  },
  {
    "instruction": "Create a simple function that returns 3 using exit with parameter",
    "output": "function fff: integer;\nbegin\n  exit(3)\nend;\n\nbegin\n  Print(fff());\nend."
  },
  {
    "instruction": "Implement IsPrime function using exit with parameter for early returns",
    "output": "function IsPrime(n: integer): boolean;\nbegin\n  if n < 2 then exit(False);\n  for var i:=2 to n.Sqrt.Trunc do\n    if n.Divs(i) then\n      exit(False);\n  exit(True);\nend;\n\nbegin\n  IsPrime(17).Print;\n  IsPrime(1).Print;\nend."
  },
  {
    "instruction": "Implement IsPrime as lambda function using exit with parameter",
    "output": "begin\n  var IsPrime: integer \u2192 boolean := n \u2192 begin\n    if n < 2 then exit(False);\n    for var i:=2 to n.Sqrt.Trunc do\n    if n.Divs(i) then\n      exit(False);\n    exit(True);\n  end;\n  \n  IsPrime(17).Print;\n  IsPrime(1).Print;\nend."
  },
  {
    "instruction": "Implement FastPower function using recursion and exit with parameter for efficient exponentiation",
    "output": "function FastPower(a: real; n: integer): real;\nbegin\n  if n = 0 then exit(1); // a^0 = 1\n  if n = 1 then exit(a); // a^1 = a\n  if n < 0 then exit(1 / FastPower(a, -n)); // negative exponent\n  \n  var half := FastPower(a, n div 2);\n  if n mod 2 = 0 then exit(half * half); // even exponent\n  exit(half * half * a); // odd exponent\nend;\n\nbegin\n  Writeln('2^10 = ', FastPower(2, 10)); // 1024\n  Writeln('3^-2 = ', FastPower(3, -2)); // 0.111...\nend."
  },
  {
    "instruction": "Use extended foreach with tuple unpacking for arrays of tuples and sequences",
    "output": "// Extended foreach with value unpacking into variables\nbegin\n  var a := Arr((1,2),(3,4),(5,6));\n  foreach var (x,y) in a do // Tuple unpacking\n    Print(x,y);\n  Println;\n  var b := Arr(|1,2,3|,|4,5|,|6,7,8,9|);\n  foreach var (x,y) in b do // Sequence unpacking\n    Print(x,y);\nend."
  },
  {
    "instruction": "Create GUI application with FormsABC for calculating sum and product of two numbers",
    "output": "uses FormsABC;\n\nvar \n  a,b,sum,prod: IntegerField;\n  d: Button;\n\nprocedure MyClick;\nbegin\n  sum.Value := a.Value + b.Value;\n  prod.Value := a.Value * b.Value;\nend;\n\nbegin\n  a := new IntegerField('a:');\n  b := new IntegerField('b:');\n  LineBreak;\n  sum := new IntegerField('Sum:',220);\n  LineBreak;\n  prod := new IntegerField('Product:',220);\n  LineBreak;\n  EmptyLine(20);\n  d := new Button('Calculate');\n  d.Click += MyClick;\nend."
  },
  {
    "instruction": "Create GUI application using class with FormsABC for calculating sum and product",
    "output": "uses FormsABC;\n\ntype \n  View = class\n  private\n    a,b,sum,prod: IntegerField;\n    procedure MyClick;\n    begin\n      sum.Value := a.Value + b.Value;\n      prod.Value := a.Value * b.Value;\n    end;\n  public\n    constructor Create;\n    begin\n      a := new IntegerField('a:');\n      b := new IntegerField('b:');\n      LineBreak;\n      sum := new IntegerField('Sum:',220);\n      LineBreak;\n      prod := new IntegerField('Product:',220);\n      LineBreak;\n      EmptyLine(20);\n      var d := new Button('Calculate');\n      d.Click += MyClick;\n    end;\n  end;\n\nbegin\n  var v := new View;\nend."
  },
  {
    "instruction": "Use Each method to create dictionary with zeros for range 1 to 10",
    "output": "##\nvar dct := Arr(1..10).Each(x -> 0);\nPrint(dct); // dictionary"
  },
  {
    "instruction": "Use EachCount to get frequency dictionary for characters in string",
    "output": "##\nvar s := '\u043a\u0430\u0440\u0430\u043a\u0430\u0442\u0438\u0446\u0430 \u0442\u0430\u043a \u0438 \u043a\u0430\u0442\u0438\u0442\u0441\u044f';\n// EachCount returns frequency dictionary (element,count)\ns.EachCount.Println"
  },
  {
    "instruction": "Create 3D Earth rotation animation with Graph3D using image material",
    "output": "uses Graph3D;\n\nbegin\n  HideObjects;\n  View3D.Title := 'Earth rotation';\n  View3D.CameraMode := CameraMode.Inspect;\n  View3D.ShowCoordinateSystem := False;\n  View3D.ShowGridLines := False;\n  View3D.ShowViewCube := False;\n  View3D.ShowCameraInfo := False;\n  View3D.BackgroundColor := Colors.Black;\n  \n  var c := Sphere(0,0,0,5,Colors.Wheat);\n  c.Material := ImageMaterial('Earth.jpg');\n  ShowObjects;\n\n  var gr := 0;\n  var dgr := 1;\n  while True do\n  begin\n    c.Rotate(V3D(0,0,1),1);\n    Sleep(10);\n    gr += dgr;\n    if (gr<=0) or (gr>=255) then\n      dgr := - dgr;\n    View3D.BackgroundColor := RGB(gr,gr,gr);\n  end;\nend."
  },
  {
    "instruction": "Use polynomial economization on interval with NumLibABC",
    "output": "uses NumLibABC;\n\n// Polynomial economization on interval\nbegin\n  var x:=ArrGen(8,-0.75,x->x+0.25);\n  var p:=new Polynom(0,1,-1/2,1/3,-1/4,1/5);\n  var r:=p.EconomSym(0.75, 0.05);\n  Println(r.eps,r.n);\n  r.PrintlnBeauty;\n  for var i:=1 to x.Length do\n    Write(r.Value(x[i-1]):0:3,' ')\nend."
  },
  {
    "instruction": "Draw multiple random ellipses using GraphWPF for performance testing",
    "output": "uses GraphWPF;\n \nbegin\n  Window.Title := 'Drawing ellipses';\n  Pen.Width := 1;\n  var n := 20000;\n  for var i:=1 to n do\n  begin\n    if i mod 10000 = 0 then\n      Println(i,MillisecondsDelta); \n    Brush.Color := RandomColor;\n    Ellipse(Random(800),Random(600),Random(20),Random(20));\n  end;\nend."
  },
  {
    "instruction": "Work with typed files in PascalABC.NET: write 10 random numbers to file, then read them and delete file",
    "output": "// Typed files\n// Write 10 numbers to file, on next run - read these numbers and delete file\nconst filename = 'a.dat';\n\nvar f: file of integer;\n\nbegin\n  if not FileExists(filename) then\n  begin\n    assign(f,filename);\n    rewrite(f);\n    writeln('Writing to file ',filename);\n    for var i:=1 to 10 do\n    begin\n      var x := random(100); \n      write(x,' ');\n      write(f,x);\n    end;  \n    close(f);  \n  end\n  else \n  begin\n    assign(f,filename);\n    reset(f);\n    writeln('Reading from file ',filename);\n    for var i:=1 to 10 do\n    begin\n      var x: integer;\n      read(f,x);\n      write(x,' ');\n    end;  \n    close(f);  \n    erase(f);\n  end;  \nend."
  },
  {
    "instruction": "Implement generic function IndexOf<T> that finds index of element in array",
    "output": "// Generic functions\n// Type T inference from parameter types\n\nfunction IndexOf<T>(a: array of T; val: T): integer;\nbegin\n  Result := -1;\n  for var i:=0 to a.Length-1 do\n    if a[i]=val then\n    begin\n      Result := i;\n      exit;\n    end;\nend;\n\nvar a := Arr('\u0412\u0430\u043d\u044f', '\u041a\u043e\u043b\u044f', '\u0421\u0430\u0448\u0430', '\u0421\u0435\u0440\u0435\u0436\u0430');\n\nbegin\n  var s := '\u0421\u0435\u0440\u0435\u0436\u0430';\n  writelnFormat('Index of element with value ''{0}'' is {1}',s,IndexOf(a,s));\nend."
  },
  {
    "instruction": "Find first 3 minimum values in random array using LINQ methods",
    "output": "// First 3 minimums\nbegin\n  ArrRandom(20).Println.Distinct.Order.Take(3).Println;\nend."
  },
  {
    "instruction": "Create waving flag animation using Graph3D with cloth physics",
    "output": "uses Graph3D;\n\nbegin  \n  Window.Caption := 'Waving flag';\n  View3D.HideAll;\n  Cylinder(0,4,0,6,0.07,Colors.Brown);\n  var c := Cloth(0,4,0,3,4,6,'FlagOfRussia.png');\n  c.WindSpeed := 6;\n  c.WindDirection := 180;\n  c.Gravity := 4;\n  c.Damping := 0.999;\n  c.Mass := 0.8;\n  c.Iterations := 20;\n  Sleep(1000);\n  c.Stop;\n  Sleep(1000);\n  c.Start;\nend."
  },
  {
    "instruction": "Create flame animation using GraphABC with pixel manipulation and color palette",
    "output": "uses GraphABC;\n\ntype TByteArray = array of byte;\nconst frames = 25;\n      size   = 250;\n      dxy    = size div 2;\n      dm     = 2*PI/1024;\n      flameh = 4;            \n      Light: byte = 255;\n      \nprocedure FillPallete(ColorsTable: array of Color);\nbegin\n  for var i:=0 to 255 do\n    if(i<128) then\n      ColorsTable[i] := RGB(i,0,i div 2)\n    else\n      ColorsTable[i] := RedColor(i);\nend;\n\nbegin  \n  // Create screen buffer\n  var ScreenBuffer := new TByteArray[size+1];\n  for var i:=0 to size do\n    ScreenBuffer[i] := new byte[size+1];\n  // Create palette\n  var ColorsTable := new Color[256];\n  FillPallete(ColorsTable);\n  // Configure window\n  SetWindowSize(size,size);\n  SetBrushColor(clBlack);\n  FillRectangle(0,0,WindowWidth,WindowHeight);\n  SetSmoothingOff;\n  LockDrawing;\n  // Start animation\n  var x, y, s, tt, xx, yy: Integer;\n  var dt := System.DateTime.Now;\n  var ds := WindowWidth div 4;\n  repeat\n    tt := tt + 1;\n    xx := dxy + Round(ds*Sin(tt*dm));\n    yy := dxy + Round(ds*Cos(tt*dm));\n    ScreenBuffer[xx,yy] := Light;\n    SetPixel(xx,yy,ColorsTable[Light]);\n    for var i:=0 to 5 do begin\n      x := Random(size-1) + 1;\n      y := Random(size-1) + 1;\n      s := ScreenBuffer[Y,X];\n      if s>=flameh then \n        s := s - flameh;\n      if s=0 then \n        continue;\n      ScreenBuffer[y-1,x+1] := s;\n      ScreenBuffer[y-1,x  ] := s;\n      ScreenBuffer[y-1,x-1] := s;\n      ScreenBuffer[y+1,x  ] := s;\n      var c := ColorsTable[s];\n      SetPixel(y-1,x+1,c);\n      SetPixel(y-1,x,  c);\n      SetPixel(y-1,x-1,c);\n      SetPixel(y+1,x,  c);\n    end;\n    if((system.datetime.Now-dt).TotalMilliseconds>1000/frames) then begin\n      dt := System.Datetime.Now;\n      Redraw;\n    end;\n  until False;\nend."
  },
  {
    "instruction": "Demonstrate image flipping using GraphWPF with timer animation",
    "output": "uses GraphWPF,Timers;\n\nbegin\n  var b := new Bitmap('m1.png');\n  b.ScaleX := 0.5;\n  b.ScaleY := 0.5;\n  var b1 := b.Clone;\n  b1.FlipVertical;\n  \n  OnDrawFrame := dt -> \n  begin\n    DrawImage(100,100,b);\n    DrawImage(300,100,b1);\n  end;  \n  \n  var t := new Timer(500);\n  t.TimerProc := procedure -> b.FlipHorizontal;\n  t.Start;\nend."
  },
  {
    "instruction": "Implement FloodFill algorithm using queue and GraphABC for visualization",
    "output": "uses GraphABC;\n\nprocedure DrawCell(a: array [,] of integer; x,y: integer);\nvar sz := 30;\nbegin\n  case a[y,x] of\n0: Brush.Color := Color.White;\n1: Brush.Color := Color.Black;\n2: Brush.Color := Color.Chocolate;\n  end;\n  Rectangle(x*sz,y*sz,x*sz+sz-1,y*sz+sz-1)\nend;\n\nprocedure AddToQueue(a: array [,] of integer; x,y: integer; q: Queue<(integer,integer)>);\nbegin\n  if a[y,x] = 0 then\n  begin\n    q.Enqueue(new Point(x,y));\n    a[y,x] := 2;\n    Sleep(200);\n    DrawCell(a,x,y);\n  end;\nend;\n\nprocedure FloodFill(a: array [,] of integer; x,y: integer);\nbegin\n  var q := new Queue<(integer,integer)>;\n  AddToQueue(a,x,y,q);\n  while not (q.Count=0) do\n  begin\n    (x,y) := q.Dequeue();\n    AddToQueue(a,x+1,y,q);\n    AddToQueue(a,x-1,y,q);\n    AddToQueue(a,x,y+1,q);\n    AddToQueue(a,x,y-1,q);\n  end;\nend;\n\nprocedure ReadFromFile(fname: string; var a: array [,] of integer);\nbegin\n  var f := OpenRead(fname);\n  var dimx,dimy: integer; \n  Readln(f,dimy,dimx);\n  SetLength(a,dimy,dimx);\n  for var y := 0 to dimy-1 do\n  begin\n    for var x := 0 to dimx-1 do\n    begin\n      var c := f.ReadChar;\n      a[y,x]:= if c='*' then 1 else 0;\n    end;\n    f.Readln  \n  end;\n  f.Close;\nend;\n\nprocedure Draw(a: array [,] of integer);\nbegin\n  for var y := 0 to a.RowCount-1 do\n  for var x := 0 to a.ColCount-1 do\n    DrawCell(a,x,y);\nend;\n\nbegin\n  Window.Title := 'FloodFill algorithm illustration';\n  var a: array [,] of integer;\n  ReadFromFile('field.txt',a);\n  Draw(a);\n  FloodFill(a,4,4);\nend."
  },
  {
    "instruction": "Demonstrate different for loop variations with step parameter for integers, chars and enumeration types",
    "output": "type Days = (Mon,Tue,Wed,Thi,Fri,sat);\n\nbegin\n  for var i:=1 to 5 step 2 do\n    Print(i);\n  Println;\n  \n  for var i:='5' to '2' step -2 do\n    Print(i);\n  Println;\n  \n  for var i:=Mon to Sat step 2 do\n    Print(i);\n  Println;\nend."
  },
  {
    "instruction": "Show different ways to generate sequences using for loops in PascalABC.NET",
    "output": "// For loop. Sequence of random numbers\n\nconst n = 20;\n\nbegin\n  Print('Random grades:');\n  for var i := 1 to n do\n    Print(Random(2, 5));\n  Println;\n  Print('Random integers from 1 to 99:');\n  for var i := n downto 1 do\n    Print(Random(1, 99));\n  Println;\nend.\n\n// For loop. Sequence of random numbers\nconst n = 20;\n\nbegin\n  Println('Random integers from 2 to 5:');\n  for var i := 1 to n do\n    Print(Random(2, 5));\n  Println;\n  Println;\n  Println('Random integers from 1 to 99:');\n  for var i := n downto 1 do\n    Print(Random(1, 99));\nend."
  },
  {
    "instruction": "Show multiple approaches to generate even and odd numbers using for loops in PascalABC.NET",
    "output": "// For loop. Step 2\nconst n = 25;\n\nbegin\n  Println('Even numbers from 1 to', 2 * n);\n  for var i := 1 to n do\n    Print(2 * i);\n  Println;\n  Println;\n\n  Println('Even numbers from 1 to', 2 * n);\n  var x := 2;\n  for var i := 1 to n do\n  begin\n    Print(x);\n    x += 2;\n  end;\n  Println;\n  Println;\n\n  Println('Odd numbers from 1 to', 2 * n);\n  for var i := 1 to n do\n    Print(2 * i - 1);\n  Println;\n  Println;\n\n  Println('Odd numbers from 1 to', 2 * n);\n  x := 1;\n  for var i := 1 to n do\n  begin\n    Print(x);\n    x += 2;\n  end;\n  Println;\n  Println;\nend."
  },
  {
    "instruction": "Create MVC pattern GUI application with FormsABC for calculating sum and product",
    "output": "uses FormsABC;\n\ntype \n  Model = class\n    class procedure Calc(x,y: integer; var sum,prod: integer);\n    begin\n      sum := x + y;\n      prod := x * y;\n    end;\n  end;\n  \n  View = class\n  private\n    a,b,sum,prod: IntegerField;\n    procedure MyClick;\n    begin\n      var s,p: integer;\n      Model.Calc(a.Value,b.Value,s,p);\n      sum.Value := s;\n      prod.Value := p;\n    end;\n  public\n    constructor Create;\n    begin\n      a := new IntegerField('a:');\n      b := new IntegerField('b:');\n      LineBreak;\n      sum := new IntegerField('Sum:',220);\n      LineBreak;\n      prod := new IntegerField('Product:',220);\n      LineBreak;\n      EmptyLine(20);\n      var d := new Button('Calculate');\n      d.Click += MyClick;\n    end;\n  end;\n\nbegin\n  var v := new View;\nend."
  },
  {
    "instruction": "Use faststring for efficient string manipulation with replace operations",
    "output": "// 6.0 sec PascalABC.NET vs 11.4 sec Python\nbegin\n  var mx := 0;\n  for var n := 4 to 9999 do\n  begin\n    var s: faststring := '4' + '1' * n;\n\n    while ('411' in s) or ('1111' in s) do\n      s.Replace('411', '14', 1).Replace('1111', '1', 1);\n    \n    mx := max(mx, s.ToString.Sum(d -> d.todigit));\n  end;\n  print(mx, Milliseconds / 1000);\nend."
  },
  {
    "instruction": "Show for loop for generating Fibonacci numbers in PascalABC.NET",
    "output": "// For loop. Fibonacci numbers\nconst n = 25;\n\nbegin\n  var a := 1;\n  var b := 1;\n  Println('Fibonacci numbers:');\n  Print(a,b);\n  for var i := 3 to n do\n  begin\n    var c := a + b;\n    Print(c);\n    a := b;\n    b := c;\n  end;\n  Println;\nend."
  },
  {
    "instruction": "Show for loop for finding maximum value from input numbers in PascalABC.NET",
    "output": "// For loop. Maximum from entered numbers\n\nconst n = 10;\n\nbegin\n  Println('Enter', n, 'numbers');\n  var max := real.MinValue; // smallest real number\n  for var i := 1 to n do\n  begin\n    var x := ReadReal;\n    if x > max then\n      max := x;\n  end;\n  Println('Maximum equals', max);\nend."
  },
  {
    "instruction": "Show for loop with break statement for searching values in PascalABC.NET",
    "output": "// For loop. Search for value. Break operator\nconst n = 10;\n\nbegin\n  var k := ReadInteger('Enter number to search:');\n  Println('Enter', n, 'numbers');\n  var found := False;\n  for var i := 1 to n do\n  begin\n    var x := ReadInteger;\n    if x = k then\n    begin\n      found := True;\n      break;\n    end;\n  end;\n  if found then\n    Println('Found') \n  else Println('Not found');\nend."
  },
  {
    "instruction": "Demonstrate the capabilities of foreach operator with different data structures in PascalABC.NET",
    "output": "// Example illustrating foreach operator capabilities\n\nbegin\n  var a: array of integer := [1,3,5,7,9];\n  Write('foreach over regular array: ':35);\n  foreach x: integer in a do\n    Print(x);\n  Println;  \n  \n  var s: set of integer := [2..5,10..14];\n  Write('foreach over set: ':35);\n  foreach var x in s do\n    Print(x);\n  Println;  \n  \n  var l := new List<integer>;\n  l.Add(7); l.Add(2); l.Add(5);\n  Write('foreach over dynamic array: ':35);\n  foreach var x in l do\n    Print(x);\n  Println;  \n\n  Write('foreach over range: ':35);\n  foreach var x in 1..10 do\n    Print(x);\n  Println;  \nend."
  },
  {
    "instruction": "Use foreach loop with index to iterate through array elements",
    "output": "begin\n  var index := 0;\n  var a := Arr(3, 5, 7);\n  foreach var x in a index i do\n    Println(i, x);\nend."
  },
  {
    "instruction": "Demonstrate foreach loop with various container types including static array, dynamic array, set, and list",
    "output": "// Example illustrates all possible container types\n// that can be iterated using foreach operator\n\nconst n = 10;\n\nvar \n  a: array [1..n] of integer;\n  b: array of integer;\n  s: set of integer;\n  l: List<integer>;\n\nbegin\n  for var i:=1 to n do \n    a[i] := Random(100);\n  // Foreach loop over static array\n  foreach var x in a do\n    Print(x);\n  writeln;  \n    \n  SetLength(b,n);\n  for var i:=0 to n-1 do \n    b[i] := Random(100);\n  \n  // Foreach loop over dynamic array\n  foreach var x in b do\n    Print(x);\n  writeln;  \n  \n  s := [2..5,10..14];\n  // Foreach loop over set\n  foreach var x in s do\n    Print(x);\n  writeln;  \n  \n  l := new List<integer>;\n  l.AddRange(b);\n  l.Reverse;\n  // Foreach loop over list\n  foreach var x in l do\n    Print(x);\n  writeln;  \n  \nend."
  },
  {
    "instruction": "Iterate over character set using foreach loop",
    "output": "// Loop over set. Order - not alphabetical, since sets are implemented based on hash tables\nbegin\n  foreach var c in ['a'..'z'] do\n    Write(c);\nend."
  },
  {
    "instruction": "Implement IEnumerable interface for custom Fibonacci generator class to use in foreach loop",
    "output": "// Example illustrates class implementation of IEnumerable interface \n// for using it in foreach operator\ntype\n  // Fibonacci numbers generator\n  FibGen = class(IEnumerable<integer>, IEnumerator<integer>)\n  private\n    a,b,n,i: integer;\n  public\n    constructor Create(n: integer);\n    begin\n      i := -1;\n      a := 0;\n      b := 1;\n      Self.n := n;\n    end;\n    function Get_Current: integer;\n    begin\n      if i=0 then \n        Result := 1\n      else Result := b;\n    end;\n    function System.Collections.IEnumerator.Get_Current: object := Get_Current;\n    function GetEnumerator: IEnumerator<integer> := Self;\n    function System.Collections.IEnumerable.GetEnumerator: System.Collections.IEnumerator := Self;\n    function MoveNext: boolean;\n    begin\n      i += 1;\n      Result := i<n;\n      if i=0 then exit;\n      (a,b) := (b,a+b);\n    end;\n    property Current: integer read Get_Current;\n    procedure Reset;\n    begin\n    end;\n    procedure Dispose;\n    begin\n    end;\n  end;\n\nbegin\n  writeln('Fibonacci numbers');\n  var f := new FibGen(25);\n  foreach var x in f do\n    Print(x);\nend."
  },
  {
    "instruction": "Show nested for loops for creating different patterns including multiplication table and star patterns in PascalABC.NET",
    "output": "// Nested for loops. Multiplication table\nconst n = 9;\n\nbegin\n  Println('Multiplication table');\n  for var i := 1 to n do\n  begin\n    for var j := 1 to n do\n      Print($'{i*j,4}');\n    Println;\n  end;\nend.\n\n// Nested for loops\nconst n = 6;\n\nbegin\n  for var i:=1 to n do\n  begin\n    for var j:=1 to i do\n      Write('*');\n    Writeln;  \n  end;\n  Writeln;  \n  for var i:=1 to n do\n  begin\n    for var j:=1 to 3*n do\n      if Odd(i+j) then \n        Write('*')\n      else Write(' ');  \n    Writeln;  \n  end;  \nend."
  },
  {
    "instruction": "Create patterns using nested for loops with stars and spaces",
    "output": "// Nested for loops\nconst n = 6;\n\nbegin\n  for var i:=1 to n do\n  begin\n    for var j:=1 to i do\n      write('*');\n    writeln;  \n  end;\n  writeln;  \n  for var i:=1 to n do\n  begin\n    for var j:=1 to 3*n do\n      if Odd(i+j) then \n        write('*')\n      else write(' ');  \n    writeln;  \n  end;  \nend."
  },
  {
    "instruction": "Show nested for loops with GraphABC for creating grid of colored squares in PascalABC.NET",
    "output": "// Nested for loops. Grid of squares\nuses GraphABC;\n\nconst \n  sz = 35;\n  zz = 5;\n\nbegin\n  var h := sz+zz;\n  for var nx:=0 to Window.Width div h - 1 do\n  for var ny:=0 to Window.Height div h - 1 do\n  begin\n    Brush.Color := clRandom;\n    Rectangle(zz+nx*h,zz+ny*h,zz+nx*h+sz,zz+ny*h+sz);\n  end;  \nend."
  },
  {
    "instruction": "Create Windows form with WebBrowser component to display website",
    "output": "// Illustration of WebBrowser component usage\n{$apptype windows}\n{$reference System.Windows.Forms.dll}\n\nuses \n  System.Windows.Forms,\n  System.Net;\n\nbegin\n  var myForm := new Form; \n  var w := new WebBrowser;\n  w.Url := new System.Uri('http://pascalabc.net');\n  w.Dock := Dockstyle.Fill; \n  myForm.Controls.Add(w);\n  myForm.WindowState := FormWindowState.Maximized; \n  Application.Run(myForm);\nend."
  },
  {
    "instruction": "Implement fraction class with operator overloading for addition and subtraction",
    "output": "// Operator overloading. \"Fraction\" class\ntype \n  Frac = record\n  private\n    n,m: integer;\n  public\n    constructor (n,m: integer);\n    begin\n      Self.n := n; \n      Self.m := m;\n    end;\n    class function operator+(f1,f2: Frac): Frac; // operator is overloaded as class function\n    begin\n      Result.n := f1.n*f2.m+f1.m*f2.n;\n      Result.m := f1.n*f1.m;\n    end;\n    class function operator-(f1,f2: Frac): Frac;\n    begin\n      Result.n := f1.n*f2.m-f1.m*f2.n;\n      Result.m := f1.n*f1.m;\n    end;\n    function ToString: string; override; // Need to override this function to output Frac type variables in write\n    begin\n      Result := Format('{0}/{1}',n,m);\n    end;\n  end;\n\nbegin\n  var f := new Frac(2,3);\n  var f1 := new Frac(1,2);\n  writelnFormat('{0} + {1} = {2} ',f,f1,f+f1);\n  // f+f1 is translated by compiler to Frac.operator+(f,f1)\n  writelnFormat('{0} - {1} = {2} ',f,f1,f-f1);\nend."
  },
  {
    "instruction": "Calculate expression with ordinary fractions using NumLibABC",
    "output": "uses NumLibABC;\n\n// calculation of expression with ordinary fractions\nbegin\n   var r:=((Frc(5,5,9)-Frc(7,18))/35+(Frc(40,63)-Frc(8,21))/20+\n      (Frc(83,90)-Frc(41,50))/2)*50;\n   r.Print   \nend."
  },
  {
    "instruction": "Calculate sum of all two-digit numbers using for loop",
    "output": "// For loop. Sum of all two-digit numbers\n\nbegin\n  var s := 0;\n  for var i:=10 to 99 do\n    s += i; \n  Println('Sum of all two-digit numbers =',s);  \nend."
  },
  {
    "instruction": "Calculate power of number using for loop and compare with standard operator",
    "output": "// For loop. Calculating a to the power n\n\nbegin\n  var a := ReadlnReal('Enter a:');\n  var n := ReadlnInteger('Enter n:');\n\n  var p := 1.0;\n  for var i:=1 to n do\n    p *= a; \n  Println($'{a} to the power {n} = {p}');\n  \n  Println($'Standard operation {a} ** {n} = {a ** n}');  \nend."
  },
  {
    "instruction": "Show for loop for creating function table with real numbers in PascalABC.NET",
    "output": "// For loop. Function table\nvar \n  a: real := 0;\n  b: real := 4;\n  n: integer := 16;\n\nbegin\n  var h := (b-a)/n;\n  var x := a;\n  for var i:=0 to n do\n  begin\n    Println($'{x:f2}  {Sqrt(x):f4}');  \n    x += h;\n  end;\nend."
  },
  {
    "instruction": "Create a red cube that rotates continuously around the Z-axis with auto-reverse animation",
    "output": "uses Graph3D;\n\nbegin\n  var ss := Cube(0,0,0,1.5,Colors.Red);\n  var anim := ss.AnimRotate(OrtZ,360).Forever.AutoReverse;\n  anim.Begin;\nend."
  },
  {
    "instruction": "Create a green cylinder and a red cube that rotates around point (3,0,0) on the Z-axis forever",
    "output": "uses Graph3D;\n\nbegin\n  Cylinder(Origin,6,0.3,Colors.Green);\n  var ss := Cube(-3,0,0,1.5,Colors.Red);\n  var anim := ss.AnimRotateAt(OrtZ,360,P3D(3,0,0),2).Forever;\n  anim.Begin;\nend."
  },
  {
    "instruction": "Create a green box with combined animations: move on Z-axis, scale on Z-axis, and move on X-axis simultaneously",
    "output": "uses Graph3D;\n\nbegin\n  var jmp := 0.3;\n  var time := 0.5;\n  var c := Box(0,0,2,1,2,4,Colors.Green);\n  var a := c.AnimMoveByZ(-0.4,time).AutoReverse.Forever * c.AnimScaleZ(0.95,time).AutoReverse.Forever * c.AnimMoveByX(1*10,time*10);\n  a.Begin;\nend."
  },
  {
    "instruction": "Create a parametric trajectory and animate a blue sphere moving along it forever",
    "output": "uses Graph3D;\n\nfunction ParametricTrajectory(a,b: real; N: integer; fun: real->Point3D) := PartitionPoints(a,b,N).Select(fun);\n\nbegin\n  var tr := ParametricTrajectory(0,2*Pi,100,t->P3D(8*cos(t),4*sin(t),0));\n  Polyline3D(tr);\n  var b := Sphere(tr.First,1,Colors.Blue);\n  b.AnimMoveTrajectory(tr.Skip(1),5).Forever.Begin;\nend."
  },
  {
    "instruction": "Create a blue sphere and animate it moving along a rectangular trajectory forever",
    "output": "uses Graph3D;\n\nbegin\n  var b := Sphere(Origin,1,Colors.Blue);\n  \n  var (p1,p2,p3,p4) := (P3D(3,0,0),P3D(3,3,0),P3D(0,3,0),P3D(0,0,0));\n  \n  b.MoveTo(p1);\n  b.AnimMoveTrajectory(Arr(p2,p3,p4,p1),3).Forever.Begin;\nend."
  },
  {
    "instruction": "Create a blue box with sequential and parallel animations: move to point p1 with scaling, then move to point p2 with scaling, then rotate around Z-axis",
    "output": "uses Graph3D;\n\nbegin\n  Window.Title := 'a+b+c - sequential execution, a*b - parallel execution';\n  var s := Box(0,0,0,3,1,2,Colors.Blue);\n  var p1 := P3D(5,0,0);\n  var p2 := P3D(5,5,0);\n  var OrtZ := V3D(0,0,1);\n  var an := s.AnimMoveTo(p1,1.Sec)*s.AnimScale(1.5,1.Sec) + \n            s.AnimMoveTo(p2,1.Sec)*s.AnimScale(1,1.Sec) + \n            s.AnimRotate(OrtZ,90,1.Sec);\n  an.Begin;\nend."
  },
  {
    "instruction": "Create a blue box and animate it with sequential movement: first move on Y-axis, then move on X-axis",
    "output": "uses Graph3D;\n\nbegin\n  var s := Box(0,0,0,3,1,2,Colors.Blue);\n  var an := Animate.Sequence(\n    s.AnimMoveByY(5),\n    s.AnimMoveByX(5)\n  );\n  an.Begin;\nend."
  },
  {
    "instruction": "Create a blue box that moves to point (5,0,0) and display text when animation completes",
    "output": "uses Graph3D;\n\nbegin\n  var t := Text3D(0,-7,1,'Animation start...',2);\n  var s := Box(0,0,0,3,1,2,Colors.Blue);\n  var an := s.AnimMoveTo(P3D(5,0,0),2).WhenCompleted(procedure -> t.Text := 'End!');\n  an.Begin\nend."
  },
  {
    "instruction": "Approximate tabular function using Chebyshev polynomials with least squares method",
    "output": "uses NumLibABC;\n\nbegin\n  var e:=0.1;\n  var x:=ArrGen(12,i->0.25*i-2); x.Println;\n  var y:=x.Select(z->2*z-5*Sqr(z)+8*z*Sqr(z)).ToArray; y.Println;\n  var oL:=new ApproxCheb(x,y,e);\n  oL.f.Println;  // approximated values\n  Println(oL.r,oL.tol);  // suggested polynomial degree and calculated error\n  oL.MakeCoef; // decoded coefficients\n  oL.c.Println;\nend."
  },
  {
    "instruction": "Draw arrows between points using mathematical coordinate system",
    "output": "uses GraphWPF;\n\nbegin\n  Parameters.ArrowSizeAcross := 4;\n  Parameters.ArrowSizeAlong := 10;\n  SetMathematicCoords;\n  var (p1,p2,p3) := (Pnt(0,0),Pnt(2,3),Pnt(4,-1));\n  Arrow(p1,p2);\n  Arrow(p2,p3);\n  Arrow(p3,p1);\nend."
  },
  {
    "instruction": "Draw arcs and sectors with different radii and angles",
    "output": "uses GraphWPF;\n\nbegin\n  Window.Title := 'Arcs and sectors';\n  var (x,y) := (200,Window.Height/2);\n  Circle(x,y,5);\n  for var i:=1 to 18*2 do\n    Arc(x,y,5*i,0,10*i);\n  (x,y) := (600,Window.Height/2);  \n  for var i:=1 to 12 do\n  begin\n    Brush.Color := RandomColor;\n    Sector(x,y,180,30*(i-1),30*i);\n  end;\nend."
  },
  {
    "instruction": "Draw a directed weighted graph using dictionary representation",
    "output": "uses GraphWPF;\n\nbegin\n  var graph := Dict(\n    ('A',Dict(('B',2),('E',5))),\n    ('C',Dict(('B',7),('D',9))),\n    ('D',Dict(('B',34))),\n    ('E',Dict(('C',12),('B',66)))\n  );\n  var dPoints := new Dictionary<char,Point>;\n  var R := 200;\n  var n := ('A'..'E').Count;\n  var Phi := 0.0; \n  for var c := 'A' to 'E' do\n  begin  \n    dPoints[c] := Window.Center + R * Vect(Cos(Phi),Sin(Phi));\n    Phi += 2 * Pi/n;\n  end;\n  \n  Window.Title := 'Directed graph drawing';\n  var Radius := 10;\n  foreach var kv in dPoints do\n  begin\n    var p := kv.Value;\n    Circle(p,Radius);\n    TextOut(p.x,p.y,kv.Key,Alignment.Center);\n  end;\n  foreach var k1 in graph.Keys do\n  foreach var k2 in graph[k1].Keys do\n  begin\n    var weight := graph[k1][k2];\n    var (p1,p2) := (dPoints[k1],dPoints[k2]);\n    var v := p2 - p1;\n    var pp1 := p1 + v.Norm * Radius;\n    var pp2 := p2 - v.Norm * Radius;\n    Arrow(pp1,pp2);\n    var cc := p1 + v/2;\n    var txt := weight.ToString;\n    var sz := TextSize(txt);\n    FillRectangle(cc.X - sz.Width/2, cc.Y - sz.Height/2, sz.Width, sz.Height);\n    TextOut(cc.x,cc.y,weight,Alignment.Center);\n  end;\nend."
  },
  {
    "instruction": "Implement arithmetic expression evaluator using pattern matching for constants, addition, multiplication, and negation",
    "output": "type\n  Expr = interface\n  end;\n  Cons = auto class(Expr)\n    r: real;\n  end;\n  Add = auto class(Expr)\n    left,right: Expr;\n  end;\n  Mult = auto class(Expr)\n    left,right: Expr;\n  end;\n  Neg = auto class(Expr)\n    ex: Expr;\n  end;\n  \nfunction ConsC(r: real) := new Cons(r);\nfunction AddC(l,r: Expr) := new Add(l,r);\nfunction MultC(l,r: Expr) := new Mult(l,r);\nfunction NegC(ex: Expr) := new Neg(ex);\n\nfunction Eval(e: Expr): real;\nbegin\n  match e with\n    Cons(c): Result := c;\n    Neg(n): Result := -Eval(n);\n    Add(l,r): Result := Eval(l) + Eval(r);\n    Mult(l,r): Result := Eval(l) * Eval(r);\n  end;\nend;  \n  \nbegin\n  var r := AddC(NegC(ConsC(2)),MultC(ConsC(3),ConsC(4)));\n  Eval(r).Print;\nend."
  },
  {
    "instruction": "Implement arithmetic expression simplifier that handles constants, variables, addition, multiplication, and negation with algebraic simplification rules",
    "output": "type\n  Expr = interface\n  end;\n  V = auto class(Expr)\n    name: string;\n  end;\n  Cons = auto class(Expr)\n    r: real;\n  end;\n  Add = auto class(Expr)\n    left,right: Expr;\n  end;\n  Mult = auto class(Expr)\n    left,right: Expr;\n  end;\n  Neg = auto class(Expr)\n    ex: Expr;\n  end;\n  \nfunction NegC(ex: Expr) := new Neg(ex);  \nfunction ConsC(r: real) := new Cons(r);  \nfunction AddC(ex1,ex2: Expr) := new Add(ex1,ex2);  \nfunction MultC(ex1,ex2: Expr) := new Mult(ex1,ex2);  \nfunction VC(name: string) := new V(name);  \n  \nfunction Simplify(e: Expr): Expr; forward;\n\nfunction Simplify1(e: Expr): Expr;\nbegin\n  match e with\n    Mult(Cons(c),Cons(c1)): Result := ConsC(c*c1);\n    Mult(Cons(1.0),ex): Result := Simplify(ex);\n    Mult(Cons(0.0),ex): Result := ConsC(0);\n    Add(Cons(0.0),ex): Result := Simplify(ex);\n    Add(ex,Cons(0.0)): Result := Simplify(ex);\n    Add(Cons(c),Cons(c1)): Result := ConsC(c+c1); \n    Add(Cons(c),ex): Result := AddC(ex,ConsC(c)); // constants at the end!\n    Mult(Cons(c),ex): Result := MultC(ex,ConsC(c));\n    Add(Add(ex,Cons(c)),Cons(c1)): Result := AddC(ex,ConsC(c+c1)); // associativity\n    Mult(Mult(ex,Cons(c)),Cons(c1)): Result := MultC(ex,ConsC(c*c1)); // associativity\n    Neg(Cons(c)): Result := ConsC(-c); \n    else Result := e;\n  end;\nend;\n\nfunction Simplify(e: Expr): Expr;\nbegin\n  match e with\n    Mult(e1,e2): Result := Simplify1(MultC(Simplify(e1),Simplify(e2)));\n    Add(e1,e2): Result := Simplify1(AddC(Simplify(e1),Simplify(e2)));\n    Neg(e1): Result := Simplify1(NegC(Simplify(e1)));\n    else Result := e;\n  end;\nend;\n\nfunction Str(e: Expr): string;\nbegin\n  match e with\n    Mult(l,r): Result := Str(l) + ' * ' + Str(r);\n    Add(l,r): Result := Str(l) + ' + ' + Str(r);\n    Neg(n): Result := '-' + Str(n);\n    Cons(c): Result := c.ToString;\n    V(x): Result := x;\n  end;\nend;\n  \nbegin\n  var r: Expr := AddC(ConsC(1),AddC(MultC(ConsC(1),VC('x')),ConsC(1)));\n  r := AddC(r,MultC(ConsC(0),AddC(ConsC(2),VC('a'))));\n  r := AddC(r,ConsC(2));\n  Str(r).Println;\n  r := Simplify(r);\n  Str(r).Println;\nend."
  },
  {
    "instruction": "Measure performance of array slicing operation",
    "output": "begin\n  var s := Arr(1..1000);\n  var s1: array of integer;\n  var n := 100000000;\n  MillisecondsDelta;\n  loop n do\n    s1 := s[1:11];\n  MillisecondsDelta.Println;\nend."
  },
  {
    "instruction": "Measure performance of array slice assignment operation",
    "output": "begin\n  var s := Arr(1..10);\n  Milliseconds;\n  var n := 100000000;\n  MillisecondsDelta.Println;\n  loop n do\n    s[0:10] := s;\n  MillisecondsDelta.Println;\nend."
  },
  {
    "instruction": "Demonstrate array initialization with empty collections and nested arrays",
    "output": "begin\n  var a: array of array of integer := [[],[],[1]];\n  Println(a,TypeName(a));\n  var b := [[],[1],[]];\n  Println(b,TypeName(b));\n  var aa: array of array of array of integer := [[[],[2]],[]];\n  Print(aa,TypeName(aa));\nend."
  },
  {
    "instruction": "Calculate r to the power of 8 using auxiliary variables for intermediate results",
    "output": "begin\n  var r := ReadlnReal('Enter r: ');\n  var r2,r4,r8: real; // auxiliary variables\n  r2 := r * r;\n  r4 := r2 * r2;\n  r8 := r4 * r4;\n  Println(r,'to the power of 8 =',r8);\nend."
  },
  {
    "instruction": "Swap values of two variables using a temporary variable",
    "output": "var x,y: real;\n\nbegin\n  Write('Enter x,y: ');\n  Readln(x,y);\n  var v: real; // temporary variable\n  v := x;\n  x := y;\n  y := v;\n  Writeln('New values x,y: ',x,' ',y);\nend."
  },
  {
    "instruction": "Define and use functions in short programs in PascalABC.NET",
    "output": "##\n// In short programs you can describe subroutines\nfunction Add(a,b: integer) := a + b;\n\nPrint(Add(2,3));"
  },
  {
    "instruction": "Create function table for sin using PartitionPoints and PrintLines",
    "output": "// Output table of sin function values\n\n##\nPartitionPoints(0,Pi,20).Select(x->$'({x:f4}, {sin(x):f7})').PrintLines;"
  },
  {
    "instruction": "Show garbage collection in PascalABC.NET by setting variables to nil",
    "output": "// Garbage collection: to free object assign nil to variable\nbegin\n  var L := new List<integer>;\n  L.Add(3);\n  L.Add(5);\n  L.Add(2);\n  \n  foreach var x in L do\n    Print(x);\n  L := nil; // after this, memory occupied by dynamic array will be collected by garbage collector \nend."
  },
  {
    "instruction": "Show runtime error handling for non-numeric input and demonstrate proper input validation",
    "output": "// Enter non-number\n// See what runtime error looks like\n\nbegin\n  var s: string;\n  var i: integer;\n  repeat\n    try\n      s := ReadString('Enter integer:');\n      i := StrToInt(s);\n      break;\n    except\n      on e: Exception do\n        Println('Invalid input. Please enter a valid integer.');\n    end;\n  until false;\n  Println('You entered:', i);\nend."
  },
  {
    "instruction": "Compare performance of global variables vs block variables in PascalABC.NET",
    "output": "// Comparison of global and block variable performance.\n// See also file BlockVars.pas\nvar \n  s: real := 0; \n  i: real := 1;\n\nbegin\n  while i<1000000000 do\n  begin\n    s += 1/i;\n    i += 1;\n  end;  \n  writeln(s);\n  writeln('Calculation time = ',Milliseconds/1000,' s');\nend."
  },
  {
    "instruction": "Implement Golomb sequence with caching for efficient recursive calculation",
    "output": "// Golomb sequence G(n) is such unique non-decreasing sequence \n// of natural numbers, in which n appears exactly G(n) times\n// 1 2 2 3 3 4 4 4 5 5 5 6 6 6 6 \u2026\n// Without caching execution time is huge due to repeated recursive calls\n[Cache]\nfunction G(n: int64): int64 := n = 1 ? 1 : 1 + G(n - G(G(n - 1)));\n\nbegin\n  var n := 100000;\n  (1..n).Sum(i -> G(i)).Print;\n  Milliseconds.Print;\nend."
  },
  {
    "instruction": "Show common compilation and runtime errors in PascalABC.NET with their fixes",
    "output": "// Common errors and their fixes in PascalABC.NET\n\n// Error 1: Missing semicolon\nvar i: integer; // Fixed: added semicolon\n\nbegin\n  i := 2;\n  \n  // Error 2: Using undeclared variable\n  var r: real := 2.5; // Fixed: declared variable\n  Println(r);\n  \n  // Error 3: Type mismatch\n  var x: real := 3/5; // Fixed: changed to real type\n  \n  // Error 4: Wrong decimal separator\n  var k: real := 2.5; // Fixed: used dot instead of comma\n  \n  // Error 5: Integer division by zero (runtime)\n  var divisor: integer := 0;\n  if divisor <> 0 then\n    Println(2 div divisor) // Fixed: added validation\n  else\n    Println('Cannot divide by zero');\n  \n  // Error 6: Invalid input (runtime)\n  var inputStr: string;\n  var number: integer;\n  repeat\n    try\n      inputStr := ReadString('Enter integer:');\n      number := StrToInt(inputStr);\n      break;\n    except\n      Println('Please enter a valid integer');\n    end;\n  until false;\n  \n  Println('All errors fixed successfully!');\nend."
  },
  {
    "instruction": "Define custom function and create its value table using for loop",
    "output": "// Function definition. Output table of its values\n\nfunction MyFun(x: real): real;\nbegin\n  Result := x*sin(x);\nend;\n\nconst \n  a = 0.0;\n  b = 2*Pi;\n  n = 10;\n\nbegin\n  var h := (b-a)/n;\n  var x := a;\n  writeln('Table of MyFun function values:');\n  for var i := 0 to n do\n  begin\n    writeln(x:5:2,MyFun(x):10:4);\n    x += h;\n  end;  \nend."
  },
  {
    "instruction": "Implement Power function using for loop for exponentiation",
    "output": "// Power function\n\nfunction Power(x: real; n: integer): real;\nbegin\n  Result := 1;\n  for var i:=1 to n do\n    Result *= x;\nend;\n\nvar \n  x: real; \n  n: integer;\n\nbegin\n  x := 2; n := 5;  \n  writelnFormat('{0} to the power {1} = {2}',x,n,Power(x,n));\nend."
  },
  {
    "instruction": "Show how to use variable number of parameters (params) in PascalABC.NET functions",
    "output": "// Variable number of parameters \nfunction Sum(params arg: array of integer): integer;\nbegin\n  Result := 0;\n  foreach var x in arg do\n    Result += x;\nend;\n\nbegin\n  Println(Sum(1,2,3));\n  Println(Sum(4,5,6,7));\nend."
  },
  {
    "instruction": "Create interactive function graph with transformation parameters using GraphWPF",
    "output": "uses\n  GraphWPF;\n\nvar\n  h := 0.01;\n  mx := 2.0;\n  my := 0.35;\n  dy := 0.0;\n  dx := 0.0;\n  f: real -> real := x -> x * sin(x);\n\nconst\n  boundx = 5;\n  boundy = 3;\n\nfunction Transform(f: real -> real): real -> real;\nbegin\n  Result := x -> my * f(mx * (x + dx)) + dy;\nend;\n\nprocedure DrawGraphic(f: real -> real);\nbegin\n  Window.Clear;\n  DrawGraph(f, -boundx, boundx, -boundy, boundy); \n  Window.Title := Format('mx={0:f2}  my={1:f2}  dx={2:f2}  dy={3:f2}', mx, my, dx, dy);\nend;\n\nvar ArrowKeys := HSet(Key.Left, Key.Right, Key.Up, Key.Down, Key.Home, Key.&End, Key.PageUp, Key.PageDown);\n\nprocedure KeyDown(k: Key);\nbegin\n  var g := Transform(f);\n  case k of\n    Key.Left:     my -= h;\n    Key.Right:    my += h;\n    Key.Up:       mx -= h;\n    Key.Down:     mx += h;\n    Key.Home:     dx += h;\n    Key.PageUp:   dx -= h;\n    Key.PageDown: dy += h;\n    Key.End:      dy -= h;\n  end;\n  if k in ArrowKeys then\n    DrawGraphic(g);\nend;\n\nbegin\n  DrawGraphic(Transform(f));\n  OnKeyDown := KeyDown;\nend."
  },
  {
    "instruction": "Create Brownian motion animation with various graphical objects using ABCObjects",
    "output": "// Changing properties of graphical objects\n// Brownian motion of graphical objects\nuses ABCObjects,GraphABC;\n\nprocedure MoveAll(a,b: integer);\nbegin\n  for var j:=0 to Objects.Count-1 do\n    Objects[j].moveOn(a,b);\nend;\n\nbegin\n//  LockDrawingObjects;\n  Window.Title := 'Brownian motion of objects';\n  var sq := new SquareABC(30,5,90,clSkyBlue);\n  var r := new RectangleABC(10,10,100,180,RGB(255,100,100));\n  var rr := new RoundRectABC(200,180,180,50,20,clRandom);\n  var rsq:= new RoundSquareABC(20,180,80,10,clRandom);\n  var c := new CircleABC(160,55,70,clGreen);\n  var z := new StarABC(200,150,70,135,5,clRandom);\n  z.Filled := False;\n  var el := new EllipseABC(5,55,65,50,clRandom);\n  el.Bordered := False;\n  var t := new TextABC(100,170,15,'Hello, ABCObjects!');\n  var br := new BoardABC(200,20,7,5,20,20);\n  br.Filled := False;\n  z.Height := 200;\n  z.Radius := 70;\n  sq.Width := 120;\n  t.TransparentBackground := False;\n  t.BackgroundColor := clYellow;\n  t.FontName := 'Times New Roman';\n  t.FontSize := 20;\n  c.Height := 50;\n  c.Scale(2);\n  MoveAll(160,110);\n  \n  while True do\n  begin\n    for var j:=0 to Objects.Count-1 do\n      Objects[j].moveOn(Random(-1,1),Random(-1,1));\n//    RedrawObjects;\n  end;\nend."
  },
  {
    "instruction": "Create Brownian motion animation with WPFObjects for better performance",
    "output": "// Changing properties of graphical objects\n// Brownian motion of graphical objects\nuses WPFObjects;\n\nprocedure MoveAll(a,b: integer);\nbegin\n  for var j:=0 to Objects.Count-1 do\n    Objects[j].moveOn(a,b);\nend;\n\nbegin\n  Window.Title := 'Brownian motion of objects';\n  HideObjects;\n  var sq := new SquareWPF(30,5,90,Colors.SkyBlue,1);\n  var r := new RectangleWPF(10,10,100,180,RGB(255,100,100),1);\n  var rr := new RoundRectWPF(200,180,180,50,20,RandomColor,1);\n  var rsq:= new RoundSquareWPF(20,180,80,10,RandomColor,1);\n  var c := new CircleWPF(160,55,70,Colors.Green);\n  var z := new StarWPF(200,150,70,135,5,EmptyColor,1);  \n  var el := new EllipseWPF(5,55,65,50,RandomColor,2,RandomColor);\n  var t := new TextWPF(100,170,40,'Hello, WPFObjects!'); //\n  t.BackgroundColor := Colors.Yellow;\n  t.FontName := 'Times New Roman';\n  //var br := new BoardWPF(200,20,7,5,20,20);\n  //br.Filled := False;\n  z.Height := 220;\n  z.Radius := 160;\n  sq.Width := 120;\n  //t.FontSize := 40;\n  c.Height := 50;\n  c.Scale(2);\n  MoveAll(160,110);\n  ShowObjects;\n  \n  while True do\n  begin\n    for var j:=0 to Objects.Count-1 do\n      Objects[j].MoveOn(Random(-1,1),Random(-1,1));\n    Sleep(10);\n  end;\nend."
  },
  {
    "instruction": "Clone graphical objects recursively to create fractal pattern using ABCObjects",
    "output": "// Cloning graphical objects. \n// Graphical objects container. Nested containers\nuses GraphABC,ABCObjects;\n\n/// Create four graphical objects from one\nprocedure Four(var g: ObjectABC);\nbegin\n  var w := 8*g.Width div 7;\n  var f := ContainerABC.Create(0,0);\n  f.Add(g);\n  g := g.Clone;;\n  g.moveon(w,0);\n  g := g.Clone;\n  g.moveon(0,w);\n  g := g.Clone;\n  g.moveon(-w,0);\n  g := f;\nend;\n\nbegin\n  LockDrawingObjects;\n  SetWindowSize(630,630);\n  \n  var g: ObjectABC := new SquareABC(0,0,14,clYellow);\n  Four(g);\n  Four(g);\n  Four(g);\n  Four(g);\n  Four(g);\n  UnLockDrawingObjects;\nend."
  },
  {
    "instruction": "Implement object dragging with mouse using ABCObjects",
    "output": "// Moving graphical objects with mouse\nuses ABCObjects,GraphABC;\n\nvar \n  ob: ObjectABC;\n  sx,sy: integer;\n\nprocedure MyMouseDown(x,y,mb: integer);\nbegin\n  ob := ObjectUnderPoint(x,y);\n  if ob<>nil then\n  begin\n    sx := ob.Left - x;\n    sy := ob.Top - y;\n  end; \nend;\n\nprocedure MyMouseMove(x,y,mb: integer);\nbegin\n  if ob<>nil then\n    ob.Position := new Point(x+sx,y+sy);\nend;\n\nprocedure MyMouseUp(x,y,mb: integer);\nbegin\n  ob := nil;\nend;\n\n\nbegin\n  Window.Title := 'Move objects with mouse';\n  for var i:=1 to 10 do\n  begin\n    var p := new PictureABC(Random(Window.Width-100),Random(Window.Height-100),'demo.bmp');\n    p.Transparent := True;\n  end;  \n  OnMouseDown := MyMouseDown;\n  OnMouseMove := MyMouseMove;\n  OnMouseUp := MyMouseUp;\nend."
  },
  {
    "instruction": "Implement object intersection detection using Intersect method in ABCObjects",
    "output": "// Illustration of Intersect method for graphical objects\nuses ABCObjects,GraphABC;\n\nvar Destroyer: CircleABC;\n\nprocedure CheckPulyaIntersects;\nbegin\n  for var i:=Objects.Count-1 downto 0 do\n  begin\n    if (Destroyer.Intersect(Objects[i])) and (Objects[i]<>Destroyer) then\n      Objects[i].Destroy;\n  end;    \nend;\n\nbegin\n  Window.Title := 'Destroyer: Intersect method for object intersection';\n  for var i:=1 to 500 do\n    new RectangleABC(Random(WindowWidth-200)+100,Random(WindowHeight-100),Random(200),Random(200),clRandom);\n  Destroyer := new CircleABC(10,WindowHeight div 2,100,clBlack);\n  Destroyer.FontColor := clYellow;\n  Destroyer.Text := 'Destroyer';\n\n  for var i:=1 to 900 do\n  begin\n    Destroyer.MoveOn(1,0);\n    CheckPulyaIntersects;\n  end;\nend."
  },
  {
    "instruction": "Implement object intersection detection using IntersectionList in WPFObjects",
    "output": "uses WPFObjects;\n\nvar Destroyer: CircleWPF;\n\nprocedure CheckPulyaIntersects;\nbegin\n  Destroyer.IntersectionList.ForEach(procedure(o)->o.Destroy);\nend;\n\nbegin\n  HideObjects;\n  Window.SetSize(640,480);\n  Window.Title := 'Destroyer: Intersect method for object intersection';\n  loop 500 do\n    new RectangleWPF(Random(Window.Width.Round-200)+100,Random(Window.Height.Round-100),Random(200),Random(200),clRandom);\n  Destroyer := new CircleWPF(10,Window.Height / 2,100,Colors.Black);\n  Destroyer.SetText('Destroyer',30,'Arial',Colors.Yellow);\n  ShowObjects;\n\n  loop 900 do\n  begin\n    Destroyer.MoveOn(1,0);\n    CheckPulyaIntersects;\n    Sleep(1);\n  end;\nend."
  },
  {
    "instruction": "Create parametric motion animation with ABCObjects along Lissajous and astroid curves",
    "output": "// Motion along trajectory\nuses ABCObjects,GraphABC;\n\nconst\n/// Step along curve parameter\n  step = 0.03;\n/// Time delay, ms\n  delay = 10;\n\ntype\n  PointR = record\n    x,y: real;\n  end;\n\nfunction Position(t: real): PointR; // astroid\nbegin\n  var si := sin(1.5 * t);\n  var co := cos(1.5 * t);\n  Result.x := si*si*si;\n  Result.y := co*co*co;\nend;\n\nfunction Position1(t: real): PointR; // Lissajous figure\nbegin\n  Result.x := cos(4*t);\n  Result.y := cos(2.97221*t + 2*Pi/3);\nend;\n\nfunction LogicalToScreen(p: PointR): Point;\nbegin\n  var ww := WindowWidth div 2;\n  var hh := WindowHeight div 2;\n  Result.x := round((ww - 50) * p.x + ww);\n  Result.y := round((hh - 50) * p.y + hh);\nend;\n\nprocedure InitScreen;\nbegin\n  SetBrushColor(clMoneyGreen);\n  Rectangle(10,10,WindowWidth-10,WindowHeight-10);\n  var p := LogicalToScreen(Position1(0));\n  MoveTo(p.x,p.y);\nend;\n\nbegin\n  Window.IsFixedSize := True;\n  Window.Title := 'Motion along trajectory';\n  SetWindowSize(640,480);\n  CenterWindow;\n\n  InitScreen;\n  var c := new CircleABC(200,200,25,clGreen);\n  var d := new StarABC(200,200,40,20,5,clYellow);\n\n  var t: real := 0;\n  while True do\n  begin\n    c.Center := LogicalToScreen(Position1(t));\n    d.Center := LogicalToScreen(Position(t));\n    if t<20*Pi then\n      LineTo(c.Center.x,c.Center.y)\n    else\n    begin\n      t := 0;\n      InitScreen;\n    end;\n    t += step;\n    Sleep(delay);\n  end;\nend."
  },
  {
    "instruction": "Create parametric motion animation with WPFObjects for smoother graphics",
    "output": "// Motion along trajectory\nuses WPFObjects,GraphWPF;\n\nconst\n/// Step along curve parameter\n  step = 0.02;\n/// Time delay, ms\n  delay = 5;\n\ntype\n  PointR = record\n    x,y: real;\n  end;\n\nfunction Position(t: real): PointR; // astroid\nbegin\n  var si := sin(1.7 * t);\n  var co := cos(1.5 * t);\n  Result.x := si*si*si;\n  Result.y := co*co*co;\nend;\n\nfunction Position1(t: real): PointR; // Lissajous figure\nbegin\n  Result.x := cos(4*t);\n  Result.y := cos(2.97221*t + 2*Pi/3);\nend;\n\nfunction LogicalToScreen(p: PointR): GPoint;\nbegin\n  var ww := Window.Width / 2;\n  var hh := Window.Height / 2;\n  Result.x := Round((ww - 50) * p.x + ww);\n  Result.y := Round((hh - 50) * p.y + hh);\nend;\n\nprocedure InitScreen;\nbegin\n  Brush.Color := Colors.LightGreen;\n  Rectangle(10,10,Window.Width-20,Window.Height-20);\n  var p := LogicalToScreen(Position1(0));\n  MoveTo(p.x,p.y);\nend;\n\nbegin\n  //Window.IsFixedSize := True;\n  Window.Title := 'Motion along trajectory';\n  Window.SetSize(640,480);\n  Window.CenterOnScreen;\n\n  InitScreen;\n  var c := new CircleWPF(200,200,25,Colors.Green);\n  var d := new StarWPF(200,200,40,20,5,Colors.Yellow);\n\n  var t: real := 0;\n  while True do\n  begin\n    c.Center := LogicalToScreen(Position1(t));\n    d.Center := LogicalToScreen(Position(t));\n    if t<20*Pi then\n      LineTo(c.Center.x,c.Center.y)\n    else\n    begin\n      t := 0;\n      InitScreen;\n    end;\n    t += step;\n    Sleep(delay);\n  end;\nend."
  },
  {
    "instruction": "Create and use sprites with multiple states and frames using ABCSprites",
    "output": "// Creating sprite and its states\nuses GraphABC,ABCSprites,ABCObjects,Events;\n\nvar s: SpriteABC;\n\nbegin\n  Window.Title := 'Sprite creation';\n  SetWindowSize(400,300);\n  CenterWindow;\n  \n  // Creating sprite and adding frames to it\n  s := new SpriteABC(150,100,'SpriteFrames\\multi1.bmp');\n  s.Add('SpriteFrames\\multi2.bmp');\n  s.Add('SpriteFrames\\multi3.bmp');\n  s.Add('SpriteFrames\\multi2.bmp');\n  s.Add('SpriteFrames\\multi4.bmp');\n  s.Add('SpriteFrames\\multi5.bmp');\n  \n  // Adding states to sprite\n  s.AddState('fly',4); // Fly - 4 frames\n  s.AddState('stand',1); // Stand - 1 frame\n  s.AddState('sit',1); // Sit - 1 frame\n  \n  // Setting sprite animation speed (1..10)\n  s.Speed := 9;\n  \n  // Saving sprite to \"long\" image and creating sprite info file\n  s.SaveWithInfo('spr.png');\nend."
  },
  {
    "instruction": "Switch sprite states on mouse click using ABCSprites",
    "output": "// Switching sprite states with mouse click\nuses GraphABC,ABCSprites,ABCObjects,Events;\n\nvar\n  s: SpriteABC;\n  t: TextABC;\n\nprocedure MyMouseDown(x,y,mb: integer);\nbegin\n  if s.PtInside(x,y) then\n  begin\n    // Transition to next sprite state\n    if s.State<s.StateCount then\n      s.State := s.State + 1\n    else s.State := 1;\n    t.Text := 'Sprite state: ' + s.StateName;\n  end;\nend;\n  \nbegin\n  Window.Title := 'Click mouse on sprite';\n  SetWindowSize(400,300);\n  CenterWindow;\n  s := new SpriteABC(150,100,'spr.spinf');\n  t := new TextABC(55,30,15,'Sprite state: '+s.StateName,clRed);\n  OnMouseDown := MyMouseDown;\nend."
  },
  {
    "instruction": "Create basic graphics program with lines using GraphABC",
    "output": "// Graphics. Lines. Window sizes. Window title\nuses GraphABC;\n\nbegin\n  Window.Title := 'First graphics program';\n  Line(0,0,Window.Width-1,Window.Height-1);\n  Line(0,Window.Height-1,Window.Width-1,0);\nend."
  },
  {
    "instruction": "Show how to use GraphABC module for drawing random pixels and measuring performance in PascalABC.NET",
    "output": "// Graphics. Point. Random color. Performance speed\nuses GraphABC;\n\nbegin\n  for var i:=1 to 100000 do\n    SetPixel(Random(Window.Width),Random(Window.Height),clRandom);\n  Println('Working time:',Milliseconds/1000,'seconds');  \nend."
  },
  {
    "instruction": "Demonstrate pen and brush properties in GraphABC",
    "output": "// Graphics. Pen and brush properties\nuses GraphABC;\n\nbegin\n  Window.Title := 'Pen and brush properties';\n  Pen.Color := Color.Red;\n  Pen.Width := 3;\n  Pen.Style := psDashDot;\n  Brush.Style := bsHatch;\n  Brush.Color := Color.Green;\n  Brush.Hatch := bhDiagonalBrick;\n  Brush.HatchBackgroundColor := Color.Bisque;\n  Rectangle(20, 20, Window.Width - 20, Window.Height - 20);\nend."
  },
  {
    "instruction": "Use Draw and Fill procedures for rectangle animation in GraphABC",
    "output": "// Graphics. Draw and Fill - procedures\nuses GraphABC;\n\nbegin\n  Window.Title := 'Draw and Fill - procedures';\n  for var i := 1 to 100 do\n  begin\n    Pen.Color := clRandom;\n    var x := Random(Window.Width-100);\n    var y := Random(Window.Height-100);\n    DrawRectangle(x,y,x+Random(100),y+Random(100));\n    Sleep(30);\n  end;\n  for var i := 1 to 100 do\n  begin\n    Brush.Color := clRandom;\n    var x := Random(Window.Width-100);\n    var y := Random(Window.Height-100);\n    FillRectangle(x,y,x+Random(100),y+Random(100));\n    Sleep(30);\n  end;\nend."
  },
  {
    "instruction": "Create pie chart using Pie procedure in GraphABC",
    "output": "// Graphics. Pie\nuses GraphABC;\n\nconst r = 200;\n\nbegin\n  Window.Title := 'Pie chart';\n  var x := Window.Center.X;\n  var y := Window.Center.Y;\n  Brush.Color := clRandom;\n  Pie(x,y,r,0,30);  \n  Brush.Color := clRandom;\n  Pie(x,y,r,30,110);  \n  Brush.Color := clRandom;\n  Pie(x,y,r,110,160);  \n  Brush.Color := clRandom;\n  Pie(x,y,r,160,280);  \n  Brush.Color := clRandom;\n  Pie(x,y,r,280,360);  \nend."
  },
  {
    "instruction": "Demonstrate transparency using ARGB colors in GraphABC",
    "output": "// Graphics. Transparency\nuses GraphABC;\n\nbegin\n  Window.Title := 'Transparency demonstration';\n  \n  Brush.Color := clRed;\n  FillRectangle(50,50,100,Window.Height - 50);\n  Brush.Color := clGreen;\n  FillRectangle(150,50,200,Window.Height - 50);\n  Brush.Color := clBlue;\n  FillRectangle(250,50,300,Window.Height - 50);\n  Brush.Color := ARGB(127,255,0,0);\n  FillRectangle(20,100,420,150);\n  Brush.Color := ARGB(63,0,127,0);\n  FillRectangle(20,200,420,250);\n  Brush.Color := ARGB(31,0,0,255);\n  FillRectangle(20,300,420,350);\nend."
  },
  {
    "instruction": "Save and load graphic window to/from file using GraphABC",
    "output": "// Graphics. Saving graphic window image to file and loading from file \nuses GraphABC;\n\nconst \n  delay = 500;\n  filename = 'GraphWindow.bmp';\n\nbegin\n  Window.Title := 'Window.Save and Window.Load';\n  SetWindowSize(320,240);\n  \n  for var x:=0 to Window.Width - 1 do\n  for var y:=0 to Window.Height - 1 do\n    SetPixel(x,y,RGB(x-2*y,y+x,y-2*x));\n  \n  Window.Save(filename);\n  for var i := 1 to 5 do\n  begin\n    Window.Clear;\n    Sleep(delay);\n    Window.Load(filename);\n    Sleep(delay);\n  end;\nend."
  },
  {
    "instruction": "Demonstrate anti-aliasing effects in GraphABC",
    "output": "// Graphics. Anti-aliasing\nuses GraphABC;\n\nbegin\n  Window.Title := 'Anti-aliasing demonstration';\n  TextOut(40,20,'With anti-aliasing');\n  Pen.Width := 2;\n  \n  Ellipse(40,60,300,200);\n  Line(340,60,600,130);\n  Line(600,130,340,200);\n  \n  SetSmoothingOff;\n  TextOut(40,240,'Without anti-aliasing');\n  Ellipse(40,280,300,420);\n  Line(340,280,600,350);\n  Line(600,350,340,420);\nend."
  },
  {
    "instruction": "Create stopwatch using RealNumber property in ABCObjects",
    "output": "uses ABCObjects,GraphABC;\n\nconst \n/// x-axis margin\n  zx = 100;\n/// y-axis margin\n  zy = 50;\n\nbegin\n  Window.IsFixedSize := True;\n  Window.Title := 'Stopwatch';\n  var r := new RoundRectABC(zx,zy,Window.Width-2*zx,Window.Height-2*zy,100,clMoneyGreen);\n  r.BorderWidth := 5;\n  r.BorderColor := clGreen;\n  for var i:=1 to 1000 do\n  begin\n    r.RealNumber := i/10;\n    Sleep(100);\n  end;\nend."
  },
  {
    "instruction": "Create stopwatch using RealNumber property in WPFObjects",
    "output": "uses WPFObjects;\n\nconst\n  /// x-axis margin\n  zx = 100;\n  /// y-axis margin\n  zy = 50;\n\nbegin\n  Window.IsFixedSize := True;\n  Window.Title := 'Stopwatch';\n  var r := new RoundRectWPF(zx, zy, Window.Width - 2 * zx, Window.Height - 2 * zy, 100, Colors.LightGreen, 5, Colors.Green);\n  r.FontSize := 200;\n  for var i := 1 to 1000 do\n  begin\n    r.RealNumber := i/10;\n    Sleep(100);\n  end;\nend."
  },
  {
    "instruction": "Demonstrate ScaleX and ScaleY properties for PictureABC with horizontal scaling animation",
    "output": "// ScaleX and ScaleY properties of PictureABC class\nuses ABCObjects,GraphABC;\n\nconst delay = 2;\n\nvar p: PictureABC;\n\nbegin\n  Window.Title := 'Movement and horizontal scaling of picture';\n  SetWindowSize(640,260);\n  p := PictureABC.Create(100,100,'demo.bmp');\n  while True do\n  begin\n    for var x:=100 to 450 do\n    begin\n      Sleep(delay);\n      p.MoveOn(1,0);\n    end;\n    for var i:=100 downto -100 do\n    begin\n      Sleep(delay);\n      var w := p.Width;\n      p.ScaleX := i/100;\n      p.MoveOn(w - p.Width,0);\n    end;\n    for var x:=450 downto 100 do\n    begin\n      Sleep(delay);\n      p.MoveOn(-1,0);\n    end;\n    for var i:=-100 to 100 do\n    begin\n      Sleep(delay);\n      p.ScaleX:=i/100;\n    end;\n  end;\nend."
  },
  {
    "instruction": "Create text cloning effect with color gradient using ABCObjects",
    "output": "// Cloning graphical objects\nuses ABCObjects,GraphABC;\n\nvar bt: TextABC;\n  \nbegin\n  var x := 224;\n  bt := new TextABC(60,110,110,'Hello!',RGB(x,x,x));\n  while x>32 do\n  begin\n    Sleep(40);\n    x -= 32;\n    bt := bt.Clone;\n    bt.Color := RGB(x,x,x);\n    bt.MoveOn(7,7);\n  end;\nend."
  },
  {
    "instruction": "Animate star properties - increase points count and rotate using ABCObjects",
    "output": "// Changing properties of StarABC object\nuses ABCObjects,GraphABC;\n\nvar z: StarABC;\n\nbegin\n  z := new StarABC(WindowWidth div 2,WindowHeight div 2,WindowHeight div 2 - 5,WindowHeight div 4 + 16,6,clRed);\n  for var i:=1 to 20 do\n  begin\n    Sleep(100);\n    z.Count := z.Count + 1;\n  end;\n  for var i:=1 to 180 do\n  begin\n    Sleep(10);\n    z.Angle := z.Angle + 1;\n  end;\nend."
  },
  {
    "instruction": "Animate star properties with manual rotation using WPFObjects",
    "output": "// Changing properties of StarWPF object\nuses WPFObjects, GraphWPF;\n\nbegin\n  var z := new StarWPF(Window.Width / 2, Window.Height / 2, Window.Height / 2 - 5, Window.Height / 4 + 16, 6, Colors.Red);\n  loop 20 do\n  begin\n    Sleep(100);\n    z.Count += 1;\n  end;\n  loop 200 do\n  begin\n    Sleep(10);\n    z.Rotate(1);\n  end;\nend."
  },
  {
    "instruction": "Animate star properties with automatic rotation using WPFObjects",
    "output": "// Changing properties of StarWPF object\nuses WPFObjects;\n\nbegin\n  var z := new StarWPF(Window.Width / 2, Window.Height / 2, Window.Height / 2 - 5, Window.Height / 4 + 16, 6, Colors.Red);\n  loop 20 do\n  begin\n    Sleep(100);\n    z.Count += 1;\n  end;\n  z.AnimRotate(200,2);\nend."
  },
  {
    "instruction": "Work with objects as sequences using pattern matching in WPFObjects",
    "output": "uses WPFObjects;\n\nfunction GenRandomWPF: ObjectWPF;\nbegin\n  var x := Random(Window.Width);\n  var y := Random(Window.Height);\n  case Random(3) of\n    0: Result := new CircleWPF(x,y,Random(15,20),RandomColor);\n    1: Result := new EllipseWPF(x,y,Random(15,60),Random(15,60),RandomColor); \n    2: Result := new RegularPolygonWPF(x,y,Random(15,30),Random(3,8),RandomColor);\n  end;\nend;\n\nbegin\n  loop 100 do\n    GenRandomWPF;\n  \n  Sleep(1000);\n  foreach var o in Objects.Seq do\n    match o with\n      CircleWPF(c): c.Radius += 10;\n      EllipseWPF(e): e.AnimMoveBy(Random(-50,50),Random(-50,50),1);\n      RegularPolygonWPF(r) when r.Count<6: r.SetBorder;  \n    end\nend."
  },
  {
    "instruction": "Create interactive standard colors palette with ABCObjects using reflection",
    "output": "uses \n  GraphABC,\n  ABCObjects,\n  System.Reflection;\n\nconst lim = 127 + 32;\n\nvar \n  CurrentBackColor := clWhite;\n  InfoString: RectangleABC;\n\nprocedure ChangeInfoStringText(colorName: string);\nbegin\n  var c := Color.FromName(colorName);\n  InfoString.Text := string.Format('Color.{0}: (R: {1}  G: {2}  B: {3})   (H: {4:f1}  S: {5:f1}  B: {6:f1})',colorName,c.R,c.G,c.B,c.GetHue,c.GetSaturation,c.GetBrightness);\n  InfoString.Color := c;\n  if c.R*c.R+c.G*c.G+c.B*c.B <= 3*lim*lim then \n    InfoString.FontColor := clWhite\n  else InfoString.FontColor := clBlack;\n  if c.A = 0 then \n   InfoString.FontColor := clGray;\nend;\n\nprocedure CreateStandardColors(backColor: Color);\nbegin\n  ClearWindow(backColor);\n  var t := typeof(Color);\n  var mi := t.GetProperties();\n  var y := 10;\n  var x := 10;\n  var h := Window.Width div 5 - 11;\n  foreach m: PropertyInfo in mi do\n  begin\n    if m.GetGetMethod(true).IsStatic then\n    begin\n      var c := Color(m.GetValue(nil,nil)); \n      var r := new RectangleABC(x,y,h,22,c);\n      r.Text := m.Name;\n      r.TextScale := 0.9;\n      r.Bordered := False;\n      if c.R*c.R+c.G*c.G+c.B*c.B <= 3*lim*lim then \n        r.FontColor := clWhite\n      else r.FontColor := clBlack;\n      if c.A = 0 then \n        r.FontColor := clGray;\n      y += 25;\n      if y > Window.Height-40 then\n      begin\n        y := 10;\n        x += h + 10;\n      end;  \n    end;\n  end;\nend;\n\nvar \n  ob: ObjectABC;\n  dx,dy: integer;\n\nprocedure MouseDown(x,y,mb: integer);\nbegin\n  ob := ObjectUnderPoint(x,y);\n  if ob=InfoString then\n    ob := nil;\n  if ob<>nil then\n  begin\n    ob.ToFront;\n    dx := x - ob.Left;\n    dy := y - ob.Top;\n    var c := ob.Color;\n    if (mb=2) then \n      ob.Scale(2)\n    else ob.Color := Color.FromArgb(128,c.R,c.G,c.B);\n  end;  \nend;\n\nprocedure MouseUp(x,y,mb: integer);\nbegin\n  if ob<>nil then\n  begin\n    if (mb=2) then \n      ob.Scale(0.5)\n    else\n    begin\n      var c := ob.Color;\n      if ob.Text = 'Transparent' then\n        ob.Color := Color.FromArgb(0,c.R,c.G,c.B)\n      else ob.Color := Color.FromArgb(255,c.R,c.G,c.B);\n    end;  \n    ob:= nil;\n  end;\nend;\n\nprocedure MouseMove(x,y,mb: integer);\nbegin\n  if (ob<>nil) and (mb=1) then\n  begin\n    ob.ToFront;\n    ob.Left := x - dx;\n    ob.Top := y - dy;\n  end;\n  if ob=nil then\n  begin\n    InfoString.Text := '';\n    InfoString.Color := CurrentBackColor;\n  end;\n  var ob1 := ObjectUnderPoint(x,y);\n  if ob1=InfoString then\n    ob1 := nil;\n  if (ob1<>nil) and (mb=0) then\n    ChangeInfoStringText(ob1.Text);\nend;\n\nprocedure KeyDown(Key: integer);\nbegin\n  if Key=vk_Space then\n  begin\n    if CurrentBackColor=clWhite then \n    begin\n      CurrentBackColor := clBlack;\n      InfoString.BorderColor := clWhite;\n    end  \n    else \n    begin\n      CurrentBackColor := clWhite;\n      InfoString.BorderColor := clBlack;\n    end;  \n    ClearWindow(CurrentBackColor);\n    RedrawObjects;\n  end;  \nend;\n\nbegin\n  SetWindowSize(1024,768);\n  Window.IsFixedSize := True;\n  Window.CenterOnScreen;\n  Window.Title := 'Standard colors (press Space to change background color)';\n  CreateStandardColors(CurrentBackColor);\n  InfoString := new RectangleABC(10,Window.Height-30,Window.Width-20,25);\n  OnMouseMove := MouseMove;\n  OnMouseDown := MouseDown;\n  OnMouseUp := MouseUp;\n  OnKeyDown := KeyDown;\nend."
  },
  {
    "instruction": "Create interactive standard colors palette with WPFObjects using reflection",
    "output": "uses \n  GraphWPF,\n  WPFObjects,\n  System.Reflection;\n\nconst lim = 127 + 32;\n\nvar \n  CurrentBackColor := Colors.White;\n  InfoString: RectangleWPF;\n\nprocedure ChangeInfoStringText(colorName: string);\nbegin\n  var c := Colors.LightGray;//Color.FromName(colorName);\n  InfoString.Text := $'Colors.{colorName}: (R: {c.R}  G: {c.G}  B: {c.B})';\n  InfoString.Color := c;\n  if c.R*c.R+c.G*c.G+c.B*c.B <= 3*lim*lim then \n    InfoString.FontColor := Colors.White\n  else InfoString.FontColor := Colors.Black;\n  if c.A = 0 then \n    InfoString.FontColor := Colors.Gray;\nend;\n\nprocedure CreateStandardColors(backColor: Color);\nbegin\n  Window.Clear(backColor);\n  var t := typeof(Colors);\n  var mi := t.GetProperties();\n  var y := 10.0;\n  var x := 10.0;\n  var h := Window.Width / 5 - 11;\n  foreach m: PropertyInfo in mi do\n  begin\n    if m.GetGetMethod(true).IsStatic then\n    begin\n      var c := Color(m.GetValue(nil,nil)); \n      var r := new RectangleWPF(x,y,h,22,c);\n      r.Text := m.Name;\n      r.FontSize := 16;//.TextScale := 0.9;\n      //r.Bordered := False;\n      if c.R*c.R+c.G*c.G+c.B*c.B <= 3*lim*lim then \n        r.FontColor := Colors.White\n      else r.FontColor := Colors.Black;\n      if c.A = 0 then \n        r.FontColor := Colors.Gray;\n      y += 25;\n      if y > Window.Height-40 then\n      begin\n        y := 10;\n        x += h + 10;\n      end;  \n    end;\n  end;\nend;\n\nvar \n  ob: ObjectWPF;\n  dx,dy: real;\n\nprocedure MouseDown(x,y: real; mb: integer);\nbegin\n  ob := ObjectUnderPoint(x,y);\n  if ob=InfoString then\n    ob := nil;\n  if ob<>nil then\n  begin\n    ob.ToFront;\n    dx := x - ob.Left;\n    dy := y - ob.Top;\n    var c := ob.Color;\n    if (mb=2) then \n      ob.ScaleFactor := 2\n    else ob.Color := Color.FromArgb(128,c.R,c.G,c.B);\n  end;  \nend;\n\nprocedure MouseUp(x,y: real; mb: integer);\nbegin\n  if ob<>nil then\n  begin\n    if (mb=2) then \n      ob.Scale(0.5)\n    else\n    begin\n      var c := ob.Color;\n      if ob.Text = 'Transparent' then\n        ob.Color := Color.FromArgb(0,c.R,c.G,c.B)\n      else ob.Color := Color.FromArgb(255,c.R,c.G,c.B);\n    end;  \n    ob:= nil;\n  end;\nend;\n\nprocedure MouseMove(x,y: real; mb: integer);\nbegin\n  if (ob<>nil) and (mb=1) then\n  begin\n    ob.ToFront;\n    ob.Left := x - dx;\n    ob.Top := y - dy;\n  end;\n  if ob=nil then\n  begin\n    InfoString.Text := '';\n    InfoString.Color := CurrentBackColor;\n  end;\n  var ob1 := ObjectUnderPoint(x,y);\n  if ob1=InfoString then\n    ob1 := nil;\n  if (ob1<>nil) and (mb=0) then\n    ChangeInfoStringText(ob1.Text);\nend;\n\nprocedure KeyDown(k: Key);\nbegin\n  if k=Key.Space then\n  begin\n    if CurrentBackColor=Colors.White then \n    begin\n      CurrentBackColor := Colors.Black;\n      InfoString.BorderColor := Colors.White;\n    end  \n    else \n    begin\n      CurrentBackColor := Colors.White;\n      InfoString.BorderColor := Colors.Black;\n    end;  \n    Window.Clear(CurrentBackColor);\n    //RedrawObjects;\n  end;  \nend;\n\nbegin\n  Window.SetSize(1024,768);\n  //Window.IsFixedSize := True;\n  Window.CenterOnScreen;\n  Window.Title := 'Standard colors (press Space to change background color)';\n  CreateStandardColors(CurrentBackColor);\n  InfoString := new RectangleWPF(10,Window.Height-30,Window.Width-20,25,Colors.LightGray);\n  OnMouseMove := MouseMove;\n  OnMouseDown := MouseDown;\n  OnMouseUp := MouseUp;\n  OnKeyDown := KeyDown;\nend."
  },
  {
    "instruction": "Create a basic 'Hello World' program in PascalABC.NET",
    "output": "// First program\nprogram HelloWorld;\nbegin\n  Writeln('\u041f\u0440\u0438\u0432\u0435\u0442, \u043c\u0438\u0440!');\nend."
  },
  {
    "instruction": "Implement depth-first traversal of a directed graph in PascalABC.NET",
    "output": "// Depth-first traversal of directed graph\nprocedure TraverseDepth(gr: array of array of integer; p: array of boolean; x: integer);\nbegin\n  Print(x);\n  p[x] := True;\n  foreach var y in gr[x] do\n    if not p[y] then\n      TraverseDepth(gr,p,y);\nend;\n\nbegin\n  var gr := [[1, 2], [3], [1, 4], [5], [6], [4, 7], [], []];\n  var p := [False] * gr.Count;\n  TraverseDepth(gr,p,0);  \nend."
  },
  {
    "instruction": "Demonstrate coordinate system transformations in GraphABC with rotation and scaling",
    "output": "// Demonstration of coordinate system transformations\nuses GraphABC;\n\nbegin\n  Window.Title := 'Coordinate system transformations';\n  Window.IsFixedSize := True;\n\n  // Rotation\n  Coordinate.Angle := 30; \n  // Scale\n  Coordinate.Scale := 3;\n  // Coordinate origin - in window center\n  Coordinate.Origin := Window.Center;\n\n  Brush.Color := clMoneyGreen;\n  Ellipse(-50,-20,50,20);\n  Line(-70,0,70,0);\n  Line(0,-40,0,40);\nend."
  },
  {
    "instruction": "Create circular pattern using coordinate transformations in GraphABC",
    "output": "// Demonstration of coordinate system transformations\nuses GraphABC;\n\nbegin\n  Window.Title := 'Coordinate system transformations';\n  Window.IsFixedSize := True;\n\n  Coordinate.Origin := Window.Center;\n  Circle(0,0,200);\n  for var i := 1 to 12 do\n  begin\n    Circle(0,180,10);\n    Coordinate.Angle := Coordinate.Angle + 30; \n  end;  \nend."
  },
  {
    "instruction": "Create rotating ellipse animation using coordinate transformations in GraphABC",
    "output": "uses GraphABC;\n\nbegin\n  Coordinate.Origin := Window.Center;\n  Coordinate.SetMathematic;\n  while True do\n  begin\n    LockDrawing;\n    ClearWindow;\n    Ellipse(-120,-70,120,70);\n    Line(0,0,200,0);\n    Line(0,0,0,200);\n    Redraw;\n    Coordinate.Angle := Coordinate.Angle + 1;\n    Sleep(100);\n  end;\nend."
  },
  {
    "instruction": "Demonstrate font properties and styles in GraphABC with different fonts and colors",
    "output": "// Demonstration of working with fonts\nuses GraphABC;\n\nbegin\n  Window.Title := 'Fonts';\n  SetWindowSize(760,460);\n  Font.Name := 'Arial';\n  Font.Style := fsBoldItalic;\n  for var i:=4 to 14 do\n  begin\n    Font.Size := 2*i;\n    Font.Color := clRandom;\n    TextOut(30,2*i*i-15,'PascalABC.NET');\n  end;\n  Font.Name := 'Times New Roman';\n  Font.Style := fsBoldUnderline;\n  for var i:=4 to 14 do\n  begin\n    Font.Size := 2*i;\n    Font.Color := clRandom;\n    TextOut(400,2*i*i-15,'PascalABC.NET');\n  end;\nend."
  },
  {
    "instruction": "Center text in window using TextWidth and TextHeight functions in GraphABC",
    "output": "// Demonstration of using TextWidth and TextHeight\nuses GraphABC;\n\nconst s = 'Width & Height';\n  \nbegin\n  Window.Title := 'Centered text';\n  Window.IsFixedSize := True;\n  SetWindowSize(700,300);\n  Window.Center;\n  Font.Name := 'Times';\n  Font.Size := 50;\n  var tw := TextWidth(s);\n  var th := TextHeight(s);\n  TextOut((Window.Width-tw) div 2,(Window.Height-th) div 2,s);\nend."
  },
  {
    "instruction": "Use Polyline, Polygon, Curve, and ClosedCurve procedures with coordinate translation in GraphABC",
    "output": "// Procedures Polyline, Polygon, Curve, ClosedCurve\n// Coordinate system origin translation\nuses GraphABC;\n\nvar a: array of Point := (new Point(0,0), new Point(50,170), new Point(100,100), new Point(150,170), new Point(200,0));\n\nbegin\n  Window.Title := 'Drawing by point array';\n  Brush.Color := Color.Beige;\n  Coordinate.SetOrigin(60,30);\n  Polyline(a);\n  Coordinate.OriginX := 360;\n  Polygon(a);\n  Coordinate.Origin := new Point(60,250);\n  Curve(a);\n  Coordinate.OriginX := 360;\n  ClosedCurve(a);\nend."
  },
  {
    "instruction": "Implement Tower of Hanoi algorithm with graphical visualization in GraphABC",
    "output": "// Tower of Hanoi\nuses GraphABC;\n\ntype\n  /// Disk type\n  DiskType = record\n    /// Disk diameter\n    Sz: integer;\n    /// Disk color\n    Color: GraphABC.Color;\n  end;\n  /// Type of disk array on rod\n  DiskArr = array of DiskType;\n\nconst\n  /// Number of disks\n  CountDisks = 8;\n  /// Disk height\n  DiskHeight = 12;\n  /// Disk width increment\n  DiskWidthDelta = 12;\n  h = CountDisks * DiskWidthDelta * 2 + 20; \n  /// y-coordinate of disk pyramid base\n  y0 = DiskHeight * CountDisks + 80;\n  hh = 30;\n  /// x-coordinate of first rod\n  x1 = h div 2 + hh;\n  /// x-coordinate of second rod\n  x2 = x1 + h;\n  /// x-coordinate of third rod\n  x3 = x2 + h;\n  /// Pause, ms\n  delay = 50;\n\nvar\n  /// Array of disk pyramids \n  Tower: array [1..3] of DiskArr;\n  /// Array of disk counts in pyramids\n  DisksInTower: array [1..3] of integer;\n  /// Move number\n  MoveNumber: integer;\n\n/// Drawing pyramid\nprocedure DrawTower(a: DiskArr; n: integer; x0,y0: integer);\nbegin\n  Brush.Color := clBlack;\n  Rectangle(x0-5,y0,x0+5,y0-DiskHeight*CountDisks-10);\n  for var i:=0 to n-1 do\n  begin\n    Brush.Color := a[i].Color;\n    Rectangle(x0-a[i].sz*DiskWidthDelta,y0-DiskHeight*(i-1),x0+a[i].sz*DiskWidthDelta,y0-DiskHeight*i+1)\n  end;\nend;\n\n/// Drawing all pyramids and info string\nprocedure DrawAll;\nbegin\n  DrawTower(Tower[1],DisksInTower[1],x1,y0);\n  DrawTower(Tower[2],DisksInTower[2],x2,y0);\n  DrawTower(Tower[3],DisksInTower[3],x3,y0);\n  Brush.Color := clWhite;\n  TextOut(20,20,'Number of disk moves = '+MoveNumber);\n  Redraw;\nend;\n\n/// Moving disk from rod FromN to rod ToN\nprocedure MoveDisk(FromN, ToN: integer);\nbegin\n  Inc(MoveNumber);\n  Inc(DisksInTower[ToN]);\n  Tower[ToN][DisksInTower[ToN]-1] := Tower[FromN][DisksInTower[FromN]-1];\n  Dec(DisksInTower[FromN]);\n  Sleep(delay);\n  ClearWindow;\n  DrawAll;\nend;\n\n/// Main recursive procedure of \"Tower of Hanoi\" algorithm\nprocedure MoveTower(n: integer; FromN, ToN, WorkN: integer);\nbegin\n  if n=0 then exit;\n  MoveTower(n-1, FromN, WorkN, ToN);\n  MoveDisk(FromN, ToN);\n  MoveTower(n-1, WorkN, ToN, FromN);\nend;\n\n/// Array initialization\nprocedure InitTowers;\nbegin\n  SetLength(Tower[1],CountDisks);\n  SetLength(Tower[2],CountDisks);\n  SetLength(Tower[3],CountDisks);\n  DisksInTower[1] := CountDisks;\n  DisksInTower[2] := 0;\n  DisksInTower[3] := 0;\n  for var i:=0 to DisksInTower[1]-1 do\n  begin\n    Tower[1][i].Sz := DisksInTower[1]-i+1;\n    Tower[1][i].Color := clRandom;\n  end;\nend;\n\n/// Window initialization\nprocedure InitWindow;\nbegin\n  SetWindowSize(x3+x1,y0+50);\n  CenterWindow;\n  Window.Title := 'Tower of Hanoi';\n  Font.Size := 14;\n  Font.Name := 'Arial';\nend;\n\nbegin\n  InitWindow;\n  InitTowers;\n  LockDrawing;\n  DrawAll;\n  MoveTower(CountDisks,1,3,2);\nend."
  },
  {
    "instruction": "Demonstrate transparency effect with random colored circles in GraphABC",
    "output": "// Transparency illustration\nuses GraphABC;\n \nbegin\n  for var Transparency:=0 to 255 do\n  begin\n    Brush.Color := ARGB(Transparency,Random(256),Random(256),Random(256));\n    FillCircle(Random(Window.Width),Random(Window.Height),Random(20,60));\n    sleep(100);\n  end;\nend."
  },
  {
    "instruction": "Use if statement in full form to compare two numbers in PascalABC.NET",
    "output": "// Conditional operator. Full form\nvar \n  x: integer := 5;\n  y: integer := 3;\n\nbegin\n  if x<y then\n    writeln(x,'<',y)\n  else writeln(y,'<',x);\nend."
  },
  {
    "instruction": "Show different types of conditional statements in PascalABC.NET including if-else and case statements",
    "output": "// Conditional operator. Full form\n\nbegin\n  var x: integer := 5;\n  var y: integer := 3;\n  if x < y then\n    Println(x, '<', y)\n  else Println(y, '<', x);\nend.\n\n// Conditional operator. Short form\n\nbegin\n  var pass := ReadString('Enter password:');\n  if pass = 'NET' then\n    Println('Password correct');\nend.\n\n// Conditional operator. Logical conditions with or and and\n\nbegin\n  var x := ReadInteger('Enter x (from 1 to 99):');\n  if (x >= 1) and (x <= 9) then\n    Println('Single-digit number');\n  // Odd \u2014 function returning True if x is odd\n  if Odd(x) and (x >= 10) and (x <= 99) then\n    Println('Odd two-digit number');\n  if (x = 3) or (x = 9) or (x = 27) or (x = 81) then\n    Println('Power of three');\nend.\n\n// Nested conditional operators\n\nbegin\n  var x := ReadInteger('Enter grade (1..5):');\n  if x = 1 then\n    Println('One')\n  else if x = 2 then\n    Println('Two')\n  else if x = 3 then\n    Println('Three')\n  else if x = 4 then\n    Println('Four')\n  else if x = 5 then\n    Println('Five')\n  else Println('No such grade');\nend.\n\n// Selection operator\n\nbegin\n  var x := ReadInteger('Enter grade (1..5):');\n  case x of\n    1: Println('One');\n    2: Println('Two');\n    3: Println('Three');\n    4: Println('Four');\n    5: Println('Five');\n  else\n    Println('No such grade');\n  end;\nend.\n\n// Selection operator\n\nbegin\n  var day := ReadInteger('Enter day of week number (1..7):');\n  case day of\n    1..5: Println('Weekday');\n    6,7: Println('Weekend');\n  else Println('Invalid day of week');\n  end;\nend.\n\n// Selection operator\n\nbegin\n  var c := ReadChar('Enter character:');\n  case c of\n    '0'..'9': Println('This is digit');\n    'a'..'z', 'A'..'Z': Println('This is English letter');\n    '\u0430'..'\u044f', '\u0410'..'\u042f': Println('This is Russian letter');\n  end;\nend."
  },
  {
    "instruction": "Demonstrate naive animation with flickering effect in GraphABC",
    "output": "// Graphics. Example of \"naive\" animation. Flickering effect\nuses GraphABC;\n\nbegin\n  Window.Title := 'Simple animation demonstration';\n  var y := 200;\n  Brush.Color := clGreen;\n  for var x := 70 to 500 do\n  begin\n    Window.Clear(clWhite);    \n    Circle(x,y,50);\n    Sleep(3);\n  end;\nend."
  },
  {
    "instruction": "Implement smooth animation without flickering using LockDrawing and Redraw in GraphABC",
    "output": "// Graphics. Using LockDrawing-Redraw. No flickering\nuses GraphABC;\n\nbegin\n  Window.Title := 'Animation without flickering';\n  var y := 200;\n  Brush.Color := clGreen;\n  // Disable drawing in window\n  LockDrawing;\n  for var x := 70 to 500 do\n  begin\n    Window.Clear(clWhite);    \n    Circle(x,y,50);\n    // Redraw window from off-screen buffer\n    Redraw;\n    Sleep(3);\n  end;\nend."
  },
  {
    "instruction": "Create function graph plotting procedure with Y-axis scaling and window resize handling in GraphABC",
    "output": "// Procedure drawGraph for drawing function graph in full window\n// with Y-axis scaling\n// Redraws graph when window size changes\nuses GraphABC;\n\nfunction f(x: real) := x*sin(x)*exp(-0.1*x);\n\n// l (logical) - logical coordinates\n// s (screen) - physical coordinates\nprocedure drawGraph(x1,x2: real; f: real -> real);\n var\n  xl0,wl,yl0,hl: real;\n  xs0,ws,ys0,hs: integer;\n\n function LtoSx(xl: real) := round(ws/wl*(xl-xl0)+xs0);\n function LtoSy(yl: real) := round(hs/hl*(yl-yl0)+ys0);\n function StoLx(xs: integer) := wl/ws*(xs-xs0)+xl0;\n\nbegin // drawGraph\n  xs0 := 0;\n  ys0 := WindowHeight-1;\n  ws := WindowWidth;\n  hs := WindowHeight-1;\n  \n  xl0 := x1;\n  wl := x2-x1;\n\n  var yi: array of real;\n  SetLength(yi,ws+1);\n\n  var min := real.MaxValue;\n  var max := real.MinValue;\n  for var xi:=0 to ws do\n  begin\n    yi[xi] := f(StoLx(xi+xs0));\n    if yi[xi]<min then \n      min := yi[xi];\n    if yi[xi]>max then \n      max := yi[xi];\n  end;\n  \n  yl0 := min;\n  hl := -(max-min);\n\n  // Draw coordinate system axes\n  Line(0,LtoSy(0),ws,LtoSy(0));\n  Line(LtoSx(0),0,LtoSx(0),hs);\n\n  Pen.Color := clBlue;\n  MoveTo(xs0,LtoSy(yi[0]));\n  for var xi:=xs0+1 to xs0+ws do\n    LineTo(xi,LtoSy(yi[xi-xs0]));\nend;\n\nprocedure Resize;\nbegin\n  ClearWindow;\n  drawGraph(0,60,f);\n  Redraw;\nend;\n\nbegin\n  LockDrawing;\n  SetWindowCaption('Function graph: scaling');\n  drawGraph(0,60,f);\n  Redraw;\n  OnResize := Resize;\nend."
  },
  {
    "instruction": "Create 3D function plot using GraphABC (legacy code from KuMir/PMir)",
    "output": "// Example from KuMir/PMir package\n// Published almost without changes\n// Precious as memory :)\nUses GraphABC;\n\nvar Xmin,Xmax,Xstep: real;\n    Ymin,Ymax,Ystep,asp: real;\n    dx: integer;\n\nfunction f(x,y:real): integer;\nvar r: real;\nbegin\n  r := x*x+y*y+1;\n  f := round(5*asp*(cos(r)/r+0.1))\nend;\n\nprocedure gr(N : integer);\nvar X,Y: real; \n    i,j,k,Z0,dy: integer; \n    pred: array [1..100] of integer;\n    jj,maxX,maxY: integer;\nbegin\n  Xmin := -4;\n  Xmax := 4;\n  Ymin := -3;\n  Ymax := 3;\n  maxX := 600;\n  maxY := 400;\n  Xstep := dx*(Xmax-Xmin)/maxX; \n  X := Xmin;\n  Ystep := (Ymax-Ymin)/N;     \n  Y := Ymin;\n  dy := maxY div N div 2;        \n  asp := maxY/8;\n  for i := 1 to N do\n  begin\n    pred[i] := maxY-i*dy-f(X,Y);\n    Y := Y + Ystep\n  end;\n  for jj := 1 to maxX div dx do \n  begin\n    j := jj*dx;\n    X := X + Xstep;\n    Y := Ymin; Z0 := maxY;\n    for i := 1 to N do \n    begin\n      k := maxY-i*dy-f(X,Y);\n      if k<Z0 then\n      begin\n        Line(j-dx,pred[i],j,k);\n        Z0 := k\n      end;\n      pred[i] := Z0;\n      Y := Y+Ystep\n    end;\n  end;\nend;\n\nbegin\n  SetWindowCaption('Function graph of two variables');\n  SetWindowSize(600,400);\n  dx := 2; { X-axis resolution }\n  gr(100); { number of lines by Y <= MaxN }\nend."
  },
  {
    "instruction": "Create simple rotating coordinate system animation using GraphABC",
    "output": "// Illustration of simplest GraphABC capabilities\nuses GraphABC;\n\nbegin\n  Coordinate.Origin := Window.Center;\n  Coordinate.SetMathematic;\n  Brush.Color := Color.LightSkyBlue;\n  while True do\n  begin\n    LockDrawing;\n    ClearWindow;\n    Ellipse(-120,-70,120,70);\n    Line(0,0,200,0);\n    Line(0,0,0,200);\n    Redraw;\n    Coordinate.Angle := Coordinate.Angle + 1;\n    Sleep(100);\n  end;\nend."
  },
  {
    "instruction": "Create group animation with rotating prisms and pyramids using Graph3D",
    "output": "uses Graph3D;\n\nbegin\n  View3D.ShowGridLines := False;\n  \n  var a := new GroupAnimation;\n  \n  var p := P3D(9,-3,0);\n  var sz := 1.3;\n  var h := 4;\n  for var n:=3 to 10 do\n  begin\n    var pr := Prism(p,n,sz,4,Colors.Beige);\n    var prw := PrismWireFrame(p,n,sz+0.01,4);\n    p := p.MoveX(-2*sz-0.3);\n    a += pr.AnimRotate(OrtZ,360,10).Forever;\n    a += prw.AnimRotate(OrtZ,360,10).Forever;\n  end;\n\n  p := P3D(9,3,0);\n  for var n:=3 to 10 do\n  begin\n    var pr := Pyramid(p,n,sz,4,Colors.Beige);\n    var prw := PyramidWireFrame(p,n,sz+0.01,4);\n    p := p.MoveX(-2*sz-0.3);\n    a += pr.AnimRotate(OrtZ,360,10).Forever;\n    a += prw.AnimRotate(OrtZ,360,10).Forever;\n  end;\n  a.Begin;\nend."
  },
  {
    "instruction": "Create forever rotating cubes animation using Graph3D GroupAnimation",
    "output": "uses Graph3D;\n\nbegin\n  var c := Cube(-2,0,0,2,Colors.Beige);\n  var c1 := Cube(2,0,0,2,Colors.Green);\n  var a := c.AnimRotate(OrtZ,360,4).Forever * c1.AnimRotate(OrtZ,360,1).Forever;\n  a.Begin;\nend."
  },
  {
    "instruction": "Create and manipulate groups of 3D objects using Graph3D",
    "output": "uses Graph3D;\n\nbegin\n  var b := Box(0,0,0,3,1,2,Colors.Blue);\n  var s := Sphere(0,0,2,1,Colors.Green);\n \n  var g := Group(b,s);\n  g.MoveByY(-4);\n  var g1 := g.Clone;\n  g.MoveByY(3);\n  var gg := Group(g,g1);\n  gg.MoveByX(3);\nend."
  },
  {
    "instruction": "Use if-then-else as expression to find minimum of two numbers in PascalABC.NET",
    "output": "begin\n  var (a,b) := (2,3);\n  var min: integer;\n  min := if a<b then a else b;\n  Print(min)\nend."
  },
  {
    "instruction": "Use nested if-then-else expressions to determine quadrant based on coordinates in PascalABC.NET",
    "output": "begin\n  var (x,y) := (5,-3);\n  var q := \n    if x>0 then\n      if y>0 then\n        1\n      else 4\n    else\n      if y>0 then\n        2\n      else 3;\n        \n  Print(q)\nend."
  },
  {
    "instruction": "Implement indexer properties with a visual array of colored squares using GraphABC",
    "output": "// Indexer properties. Array of colored squares \nuses GraphABC;\n\nconst \n  sz = 50;\n  dim = 10;\n  delay = 500;\n\ntype \n  /// \n  VisualArray = class\n  private\n    a: array of Color;\n    procedure SetItem(i: integer; x: Color); // Procedure setting color of i-th square\n    begin\n      if (i<0) or (i>=a.Length) then\n        raise new System.ArgumentException('Index out of bounds: '+IntToStr(i));\n      a[i] := x;\n      Draw(i);\n    end;\n    function GetItem(i: integer): Color; // Function returning color of i-th square\n    begin\n      if (i<0) or (i>=a.Length) then\n        raise new System.ArgumentException('Index out of bounds: '+IntToStr(i));\n      Result := a[i];\n    end;\n  public\n    constructor (n: integer);\n    begin\n      a := ArrFill(n,Color.White);\n      Draw;\n    end;\n    /// Draws i-th square\n    procedure Draw(i: integer);\n    begin\n      Brush.Color := a[i];\n      Rectangle(sz+sz*i,sz,sz+sz*(i+1)+1,sz+sz);\n    end;\n    /// Draws array of colored squares\n    procedure Draw;\n    begin\n      for var i:=0 to a.Length-1 do\n        Draw(i);\n    end;\n    /// Default indexer property\n    property Item[i: integer]: Color read GetItem write SetItem; default;\n  end;\n\nvar arr: VisualArray;\n\nbegin\n  Window.Title := 'Indexer properties illustration';\n  arr := new VisualArray(dim);\n  Window.SetSize(sz*(dim+2),3*sz);\n  arr[0] := clGreen; // arr.Items[0] = arr[0] since Items property is default property\n  Sleep(delay);\n  arr[1] := clBlack;\n  Sleep(delay);\n  arr[2] := clYellow;\n  Sleep(delay);\n  arr[3] := clGray;\n  Sleep(delay);\n  arr[4] := clRed;\n  Sleep(delay);\n  arr[5] := clMagenta;\n  Sleep(delay);\n  arr[6] := clBrown;\n  Sleep(delay);\n  arr[7] := clMoneyGreen;\n  Sleep(delay);\n  arr[8] := clOlive;\n  Sleep(delay);\n  arr[9] := clLinen;\nend."
  },
  {
    "instruction": "Implement infix (in-order) traversal of binary tree using recursion and yield sequence in PascalABC.NET",
    "output": "type Node<T> = auto class\n  data: T;\n  left,right: Node<T>;\nend;\n\nfunction CNode<T>(x: T; l: Node<T> := nil; \n  r: Node<T> := nil): Node<T> := new Node<T>(x,l,r);\n\nfunction Infix<T>(root: Node<T>): sequence of T;\nbegin\n  if root = nil then exit;\n  yield sequence Infix(root.left);\n  yield root.data;\n  yield sequence Infix(root.right);\nend;\n\nbegin\n  var root := CNode(1,CNode(2,CNode(3),CNode(4)),CNode(5));\n  Infix(root).Print;\nend."
  },
  {
    "instruction": "Demonstrate inheritance, polymorphism and virtual methods with Person, Pupil and Teacher classes",
    "output": "// Inheritance. Polymorphism and virtual functions\ntype \n  Person = class\n  private\n    name: string;\n    age: integer;\n  public\n    constructor (n: string; a: integer);\n    begin\n      name := n; age := a;\n    end;\n    procedure Print; virtual; // Virtual function. Overridden in derived classes\n    begin\n      var s := GetType.ToString;\n      write('Type: ',Copy(s,pos('.',s)+1,Length(s)):7,'   Name: ',name,'   Age: ',age);\n    end;\n    procedure Println;\n    begin\n      Print;\n      writeln;\n    end;\n  end;\n  \n  Pupil = class(Person) // Pupil - inheritor of Person\n  private\n    clas: integer;\n  public\n    constructor (n: string; a,c: integer);\n    begin\n      inherited Create(n,a); // Call inherited constructor\n      clas := c;\n    end;\n    procedure Print; override;\n    begin\n      inherited Print;\n      write('   Class: ',clas);\n    end;\n  end;\n  \n  Teacher = class(Person)\n  private\n    predm: string;\n  public\n    constructor (n: string; a: integer; p: string);\n    begin\n      inherited Create(n,a); // Call inherited constructor\n      predm := p;\n    end;\n    procedure Print; override;\n    begin\n      inherited Print;\n      write('   Subject: ',predm);\n    end;\n  end;\n  \nvar a: array of Person := new Person[4]; // Polymorphic container - container of base class objects. Can contain objects of derived classes\n\nbegin\n  a[0] := new Pupil('\u0412\u043e\u0432\u0430',11,5);\n  a[1] := new Teacher('\u041c\u0430\u0440\u044c\u044f \u0418\u0432\u0430\u043d\u043e\u0432\u043d\u0430',30,'\u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0442\u0438\u043a\u0430');\n  a[2] := new Person('\u0418\u0432\u0430\u043d\u043e\u0432',65);\n  a[3] := new Pupil('\u0412\u0430\u0441\u044f',12,6);\n  \n  for var i:=0 to a.Length-1 do\n    a[i].Println;\nend."
  },
  {
    "instruction": "Explain how to use record field initializers in PascalABC.NET with automatic type inference",
    "output": "// Record field initializers\ntype \n  Frac = record\n    num: integer := 0;\n    denom := 1; // automatic type inference - denom: integer\n  end;\n  \n\nbegin\n  var f: Frac;  \n  var f1: Frac := (num: 2; denom: 3);\n  Println(f.num,'/',f.denom);\n  Println(f1.num,'/',f1.denom);\nend."
  },
  {
    "instruction": "Demonstrate InRange method behavior with different data types in PascalABC.NET",
    "output": "begin\n  // Behavior changed!! Now range [6,2] is considered empty\n  5.InRange(6,2).Println; \n\n  // Universal InRange. Should support IEnumerable<T> interface\n  InRange(5,2,6).Println;\n\n  var dt1 := DateTime.Create(2025,04,16);\n  var dt2 := DateTime.Create(2025,04,29);\n  var dt3 := DateTime.Now;\n  InRange(dt2,dt1,dt3).Println; \nend."
  },
  {
    "instruction": "Use logical conditions with AND and OR operators in if statements in PascalABC.NET",
    "output": "// Conditional operator. Logical conditions with or and and\nvar x: integer;\n\nbegin\n  writeln('Enter x (from 1 to 99): ');\n  readln(x);\n  if (x>=1) and (x<=9) then \n    writeln('Single-digit number');\n  // Odd - function returning True only if x is odd\n  if Odd(x) and (x>=10) and (x<=99) then \n    writeln('Odd two-digit number');\n  if (x=3) or (x=9) or (x=27) or (x=81) then \n    writeln('Power of three');\nend."
  },
  {
    "instruction": "Use nested if statements for grade evaluation in PascalABC.NET",
    "output": "// Nested conditional operators\nvar x: integer;\n\nbegin\n  writeln('Enter grade (1..5): ');\n  readln(x);\n  if (x=1) then \n    writeln('One')\n  else if (x=2) then \n    writeln('Two')\n  else if (x=3) then \n    writeln('Three')\n  else if (x=4) then \n    writeln('Four')\n  else if (x=5) then \n    writeln('Five')  \n  else writeln('No such grade')  \nend."
  },
  {
    "instruction": "Demonstrate nested conditional operators for finding antonyms in PascalABC.NET",
    "output": "// Nested conditional operators. Antonyms\n\nbegin\n  var s := ReadString('Enter word from list (black,high,light,joy,smart):');\n  Print('Antonym: ');\n  if s = 'black' then\n    Println('white')\n  else if s = 'high' then\n    Println('low')\n  else if s = 'light' then\n    Println('darkness')\n  else if s = 'joy' then\n    Println('sorrow')\n  else if s = 'smart' then\n    Println('stupid')\n  else Println('No such word in list');\nend."
  },
  {
    "instruction": "Create a PascalABC.NET program that checks if a leaderboard of players is ordered by points in descending order, and if not, sorts it correctly. The program should use the IsOrderedByDescending method and display appropriate messages.",
    "output": "type\n  Player = auto class\n    Name: string; Points: integer;\n  end;  \n\nfunction GetPlayers := [\n  new Player('Alice', 120),\n  new Player('Bob', 95),\n  new Player('Charlie', 130),\n  new Player('Diana', 110)\n];\n\nbegin\n  var leaderboard := GetPlayers;\n  Println(leaderboard);\n  if not leaderboard.IsOrderedByDescending(p -> p.Points) then\n    Println('Leaderboard is incorrectly arranged!');\n\n  leaderboard := leaderboard.OrderByDescending(p -> p.Points).ToArray;\n  Println(leaderboard);\n  if leaderboard.IsOrderedByDescending(p -> p.Points) then\n    Println('Now the leaderboard is correctly arranged!');\nend."
  },
  {
    "instruction": "Create a 3D graphics program in PascalABC.NET that allows controlling a blue box using keyboard keys. Use left/right/up/down arrows for movement and X/Y/Z keys for rotation around respective axes.",
    "output": "uses Graph3D;\n\nbegin\n  View3D.ShowViewCube := False;\n  var s := Box(0,0,0,3,1,2,Colors.Blue);\n  OnKeyDown := k -> \n    case k of\n    Key.Left: s.MoveBy(1,0,0);\n    Key.Right: s.MoveBy(-1,0,0);\n    Key.Up: s.MoveBy(0,-1,0);\n    Key.Down: s.MoveBy(0,1,0);\n    Key.X: s.Rotate(OrtX,10);\n    Key.Y: s.Rotate(OrtY,10);\n    Key.Z: s.Rotate(OrtZ,10);\n    end;\nend."
  },
  {
    "instruction": "Create a frame-based animation in PascalABC.NET for moving a sphere using keyboard controls. Implement smooth movement with W/A/S/D and arrow keys, using velocity and direction vectors.",
    "output": "uses Graph3D;\n\nbegin\n  Window.Title := 'Ball movement - frame-based animation'; \n  View3D.Title := 'Use keys:';\n  View3D.SubTitle := 'W,A,S,D,Arrows - movement';\n  var c := Sphere(0,0,0,1,Colors.SeaGreen);\n  c.Direction := V3D(-1,0,0);\n  c.Velocity := 5;\n  \n  var kl,kr,ku,kd: boolean;\n  \n  BeginFrameBasedAnimationTime(dt -> begin\n    if kr then \n      c.Direction := V3D(-1,c.Direction.Y,0)\n    else if kl then \n      c.Direction := V3D(1,c.Direction.Y,0)\n    else c.Direction := V3D(0,c.Direction.Y,0);  \n    if ku then \n      c.Direction := V3D(c.Direction.X,-1,0)\n    else if kd then \n      c.Direction := V3D(c.Direction.X,1,0)\n    else c.Direction := V3D(c.Direction.X,0,0);\n    c.MoveTime(dt);\n  end);\n  \n  OnKeyDown := k ->\n  begin\n    case k of\n      Key.w,Key.Up:    begin ku := true; kd := false; end; \n      Key.s,Key.Down:  begin kd := true; ku := false; end;\n      Key.a,Key.Left:  begin kl := true; kr := false; end;\n      Key.d,Key.Right: begin kr := true; kl := false; end;\n    end;  \n  end;\n  OnKeyUp := k ->\n  begin\n    case k of\n      Key.w,Key.Up:    ku := false;\n      Key.s,Key.Down:  kd := false;\n      Key.a,Key.Left:  kl := false;\n      Key.d,Key.Right: kr := false;\n    end;  \n  end;\nend."
  },
  {
    "instruction": "Create a shooting game in PascalABC.NET using ABCObjects where the player controls a rectangle at the bottom and shoots bullets at colored enemy rectangles. Implement keyboard controls, collision detection, scoring system, and game states.",
    "output": "uses ABCObjects,GraphABC,Timers;\n\nconst \n  clPlayer = Color.BurlyWood;\n\nvar\n  kLeftKey,kRightKey: boolean;\n  kSpaceKey: integer;\n  Player: RectangleABC;\n  t: Timer;\n  EndOfGame: boolean;\n  StaticObjectsCount: integer;\n  Wins: integer;\n  Falls: integer;\n  InfoString: RectangleABC;\n  NewGame: RoundRectABC;\n\ntype\n  Pulya = class(CircleABC)\n  public\n    constructor Create(x,y: integer);\n    procedure Move; override;\n  end;\n  \n  Enemy = class(RectangleABC)\n  public\n    constructor Create(x,y,w: integer);\n    procedure Move; override;\n  end;\n\nconstructor Pulya.Create(x,y: integer);\nbegin\n  inherited Create(x,y,5,clRed);\n  dx := 0; \n  dy := -5;\nend;\n\nprocedure Pulya.Move; \nbegin\n  inherited Move; \n  if Top<0 then\n    Visible := False;\n  for var j:=StaticObjectsCount to Objects.Count-1 do\n    if (Objects[j]<>Self) and Intersect(Objects[j]) then\n    begin\n      Objects[j].Visible := False;\n      Visible := False;\n    end;\nend;\n\nconstructor Enemy.Create(x,y,w: integer);\nbegin\n  inherited Create(x,y,w,20,clRandom);\n  if Random(2)=0 then\n    dx := 5\n  else dx := -5;\n  dy := 0;\nend;\n\nprocedure Enemy.Move; \nbegin\n  if Random(2)<>0 then \n    Exit;\n  if Random(10)=0 then \n    dy := 5;\n  if (Left<0) or (Left+Width>Window.Width) or (Random(30)=0) then\n    dx := -dx;\n  inherited Move;\n  if dy<>0 then \n    dy := 0;\n  if Top>Window.Height-50 then\n    EndOfGame := True;\nend;\n\nfunction NumberOfEnemies: integer;\nbegin\n  Result := 0;\n  for var i:=0 to Objects.Count-1 do\n    if Objects[i] is Enemy then\n      Result += 1;\nend;\n\nprocedure CreateObjects;\nbegin\n  Player := new RectangleABC(280,WindowHeight-30,100,20,clPlayer);\n  for var i:=1 to 100 do\n  begin\n    var r1 := new Enemy(Random(WindowWidth-50),40+Random(10),50);\n    r1.TextVisible := True;\n    r1.Number := i;\n  end;\nend;\n\nprocedure DestroyObjects;\nbegin\n  for var i:=Objects.Count-1 downto StaticObjectsCount do\n    Objects[i].Destroy;\nend;\n\nprocedure MoveObjects;\nbegin\n  for var i:=StaticObjectsCount+1 to Objects.Count-1 do\n    Objects[i].Move;\nend;\n\nprocedure DestroyKilledObjects;\nbegin\n  for var i:=ObjectsCount-1 downto StaticObjectsCount+1 do\n    if not Objects[i].Visible then\n      Objects[i].Destroy;\nend;\n\nprocedure KeyDown(Key: integer);\nbegin\n  case Key of\nvk_Left:  kLeftKey := True;\nvk_Right: kRightKey := True;\nvk_Space: if kSpaceKey=2 then kSpaceKey := 1;\n  end;\nend;\n\nprocedure KeyUp(Key: integer);\nbegin\n  case Key of\nvk_Left:  kLeftKey := False;\nvk_Right: kRightKey := False;\nvk_Space: kSpaceKey := 2;\n  end;\nend;\n\nprocedure ChangeInfoString;\nbegin\n  InfoString.Text := 'Enemies: '+IntToStr(NumberOfEnemies)+'      Wins: '+IntToStr(Wins)+'      Losses: '+IntToStr(Falls);\nend;\n\nprocedure KeyPress(Key: char);\nbegin\n  if (Key in ['G','\u041f','g','\u043f']) and EndOfGame then\n  begin\n    NewGame.Visible := False;\n    EndOfGame := False;\n    t.Start;\n    CreateObjects;\n    kSpaceKey := 2;\n    kLeftKey := False;\n    kRightKey := False;\n  end;\nend;\n\nprocedure MouseUp(x,y,mb: integer);\nbegin\n  if NewGame.PTInside(x,y) then\n    KeyPress('G');\nend;\n\nprocedure TimerProc;\nbegin\n  if kLeftKey and (Player.Left>0) then\n    Player.MoveOn(-10,0);\n  if kRightKey and (Player.Left+Player.Width<WindowWidth) then\n    Player.MoveOn(10,0);\n  if kSpaceKey=1 then\n  begin\n    new Pulya(Player.Left+Player.Width div 2,Player.Top-10);\n    kSpaceKey := 0;\n  end;\n  MoveObjects;\n  DestroyKilledObjects;\n  RedrawObjects;\n  ChangeInfoString;\n  var n := NumberOfEnemies;\n  if n=0 then\n    EndOfGame := True;\n  if EndOfGame then\n  begin\n    if t.Enabled=False then Exit;  \n    t.Stop;\n    if n>0 then\n      Falls += 1\n    else Wins += 1;\n    NewGame.Visible := True;\n    DestroyObjects;\n    ChangeInfoString;\n    RedrawObjects;\n  end;\nend;\n\nbegin\n  Window.Title := 'Shooter';\n  Window.IsFixedSize := True;\n  ClearWindow(clBlack);\n  LockDrawingObjects;\n  EndOfGame := True;\n  InfoString := new RectangleABC(0,0,Window.Width,38,Color.DarkBlue);\n  InfoString.Bordered := False;\n  InfoString.FontColor := clWhite;\n  InfoString.TextScale := 0.9;\n  \n  var zz := 100;\n  NewGame := new RoundRectABC(zz,200,400,200,30,Color.Violet);\n  NewGame.Center := Window.Center;\n  NewGame.Text := 'G - New Game';\n  StaticObjectsCount := Objects.Count;\n  ChangeInfoString;\n  RedrawObjects;\n\n  OnKeyDown := KeyDown;\n  OnKeyPress := KeyPress;\n  OnKeyUp := KeyUp;\n  OnMouseUp := MouseUp;\n\n  t := new Timer(1,TimerProc);\nend."
  },
  {
    "instruction": "Demonstrate interface implementation with multiple interfaces and cross-casting in PascalABC.NET",
    "output": "// Illustration of interface usage\ntype\n  IShape = interface\n    procedure Draw;\n    property X: integer read;\n    property Y: integer read;\n  end;\n\n  ICloneable = interface\n    function Clone: Object;\n  end;\n\n  Point = class(IShape,ICloneable)\n  private\n    xx,yy: integer;\n  public\n    constructor Create(x,y: integer);\n    begin\n      xx := x; yy := y;\n    end;  \n    procedure Draw; begin end;\n    property X: integer read xx;\n    property Y: integer read yy;\n    function Clone: Object;\n    begin\n      Result := new Point(xx,yy);\n    end;\n  end;\n  \nbegin\n  var p: Point := new Point(2,3);\n  var ish: IShape := p;\n  var icl: ICloneable := p;\n\n  Println(ish.X,ish.Y);\n\n  var p1: Point := Point(icl.Clone);\n  p := nil;\n  Println(p1.X,p1.Y);\n\n  Println(ish is Point);\n  Println(ish is ICloneable); // Cross cast!\nend."
  },
  {
    "instruction": "Implement sorting of Student objects in PascalABC.NET using IComparer interface with different comparison criteria (by name and by age). Create custom comparer classes and demonstrate array sorting.",
    "output": "uses System,System.Collections.Generic;\n\ntype \n  Student = class\n  private\n    name: string;\n    age,course,group: integer;\n  public\n    constructor (n: string; a,c,g: integer);\n    begin\n      name := n; \n      age := a;\n      course := c;\n      group := g;\n    end;\n    function ToString: string; override;\n    begin\n      Result := Format('Name: {0,9}   Age: {1}   Course: {2}   Group: {3}',name,age,course,group);\n    end;\n  end;\n  \n  SortByName = class(IComparer<Student>)\n  public\n    function Compare(s1,s2: Student): integer;\n    begin\n      Result := string.Compare(s1.name,s2.name);\n    end;\n  end;\n\n  SortByAge = class(IComparer<Student>)\n  public\n    function Compare(s1,s2: Student): integer;\n    begin\n      Result := s1.age - s2.age;\n    end;\n  end;\n  \nprocedure WriteArray<T>(prompt: string; a: array of T);\nbegin\n  writeln(prompt);\n  foreach x: T in a do\n    writeln(x);\n  writeln;  \nend;\n  \nvar a: array of Student;  \n\nbegin\n  SetLength(a,5);\n  a[0] := new Student('Ivanova',18,2,3);\n  a[1] := new Student('Kozlov',19,3,10);\n  a[2] := new Student('Sidorova',22,5,1);\n  a[3] := new Student('Krikunov',17,1,2);\n  a[4] := new Student('Likhachev',25,4,8);\n  WriteArray('Original array:',a);\n  &Array.Sort(a,new SortByName);\n  WriteArray('Sort by name: ',a);\n  &Array.Sort(a,new SortByAge);\n  WriteArray('Sort by age: ',a);\nend."
  },
  {
    "instruction": "Create a PascalABC.NET program that demonstrates finding elements in an array using lambda expressions with the Array.FindIndex method on Student objects.",
    "output": "uses System,System.Collections.Generic;\n\ntype \n  Student = class\n  private\n    name: string;\n    age,course,group: integer;\n  public\n    constructor (n: string; a,c,g: integer);\n    begin\n      name := n; \n      age := a;\n      course := c;\n      group := g;\n    end;\n    function ToString: string; override;\n    begin\n      Result := Format('Name: {0,9}   Age: {1}   Course: {2}   Group: {3}',name,age,course,group);\n    end;\n  end;\n  \nprocedure WriteArray<T>(prompt: string; a: array of T);\nbegin\n  writeln(prompt);\n  foreach x: T in a do\n    writeln(x);\n  writeln;  \nend;\n  \nvar a: array of Student;  \n\nbegin\n  SetLength(a,5);\n  a[0] := new Student('Ivanova',18,2,3);\n  a[1] := new Student('Kozlov',19,3,10);\n  a[2] := new Student('Sidorova',22,5,1);\n  a[3] := new Student('Krikunov',17,1,2);\n  a[4] := new Student('Likhachev',25,4,8);\n  WriteArray('Original array:',a);\n  \n  writeln('Index of Kozlov = ',&Array.FindIndex(a,(s: Student)-> s.name = 'Kozlov'));\nend."
  },
  {
    "instruction": "Create a PascalABC.NET program that demonstrates currying with function types, using nested lambda expressions to generate a multiplication table.",
    "output": "type int = integer;\n\nbegin\n  var f: int -> int -> int := i -> j -> i*j;\n  MatrGen(10,10,(i,j)->f(i)(j)).Println;  \nend."
  },
  {
    "instruction": "Demonstrate window property manipulation in PascalABC.NET by toggling the IsFixedSize property of a GraphWPF window.",
    "output": "uses GraphWPF;\n\nbegin\n  Window.IsFixedSize := True;\n  Print(Window.IsFixedSize);\n  Window.IsFixedSize := False;\n  Print(Window.IsFixedSize);\nend."
  },
  {
    "instruction": "Create a PascalABC.NET program that processes a string by checking if words are integers or real numbers using IsInteger and IsReal methods, then calculates their sums separately.",
    "output": "begin\n  var s := '123.4 3 5 6.6 a v 67';\n  var (si,sr) := (0,0.0);\n  foreach var w in s.ToWords do\n    if w.IsInteger then\n      si += w.ToInteger\n    else if w.IsReal then\n      sr += w.Toreal;\n  Print(si,sr);  \nend."
  },
  {
    "instruction": "Implement Conway's Game of Life on a toroidal grid in PascalABC.NET using GraphWPF with optimization through uniform grid hashing. The program should handle cell updates efficiently and display generation information.",
    "output": "uses GraphWPF;\n\nconst \n  w = 4.0;\n  m = 300;\n  n = 220;\n  x0 = 0;\n  y0 = 21;\n  mk = 15;\n  nk = 10;\n\nvar\n  configuration,NeighborsA,NeighborsB: array [0..n+1,0..m+1] of byte;\n  updateA,updateB: array [1..nk,1..mk] of boolean;\n  CountCells: integer;\n  updateFlag: boolean;\n  generation: integer;\n  configurationVisual: DrawingVisual;\n  infoVisual: DrawingVisual;\n\nprocedure DrawConfiguration;\nbegin\n  DrawOnVisual(configurationVisual,dc->begin\n    for var i:=1 to n do\n    for var j:=1 to m do\n      if configuration[i,j]=1 then\n        DrawRectangleDC(dc,x0+(j-1)*w+0.5,y0+(i-1)*w+0.5,w-1,w-1,Brushes.Black,nil);\n  end);  \nend;\n\nprocedure DrawInfo;\nbegin\n  DrawOnVisual(infoVisual,dc->begin\n    TextOutDC(dc,14,0,'Generation: '+generation);\n    TextOutDC(dc,Window.Width - 110,0,'Cells: '+CountCells);\n  end);  \nend;\n\nprocedure DrawField;\nbegin\n  var hm := m div mk;\n  var hn := n div nk;\n  Pen.Color := Colors.LightGray;\n  for var i:=0 to m do\n    if i mod hm <> 0 then\n      Line(x0+i*w,y0,x0+i*w,y0+n*w);\n  for var i:=0 to n do\n    if i mod hn <> 0 then\n      Line(x0,y0+i*w,x0+m*w,y0+i*w);\n  Pen.Color := Colors.Gray;\n  for var i:=0 to m do\n    if i mod hm = 0 then\n      Line(x0+i*w,y0,x0+i*w,y0+n*w);\n  for var i:=0 to n do\n    if i mod hn = 0 then\n      Line(x0,y0+i*w,x0+m*w,y0+i*w);\n  FlushDrawingToBitmap;\nend;\n\nprocedure IncNeighbors(i,j: integer);\nbegin\n  var i1,i2,j1,j2: integer;\n  if i=1 then i1:=n else i1:=i-1;\n  if i=n then i2:=1 else i2:=i+1;\n  if j=1 then j1:=m else j1:=j-1;\n  if j=m then j2:=1 else j2:=j+1;\n  NeighborsB[i1,j1] += 1;\n  NeighborsB[i1,j]  += 1;\n  NeighborsB[i1,j2] += 1;\n  NeighborsB[i,j1]  += 1;\n  NeighborsB[i,j2]  += 1;\n  NeighborsB[i2,j1] += 1;\n  NeighborsB[i2,j]  += 1;\n  NeighborsB[i2,j2] += 1;\nend;\n\nprocedure DecNeighbors(i,j: integer);\nbegin\n  var i1,i2,j1,j2: integer;\n  if i=1 then i1:=n else i1:=i-1;\n  if i=n then i2:=1 else i2:=i+1;\n  if j=1 then j1:=m else j1:=j-1;\n  if j=m then j2:=1 else j2:=j+1;\n  NeighborsB[i1,j1] -= 1;\n  NeighborsB[i1,j]  -= 1;\n  NeighborsB[i1,j2] -= 1;\n  NeighborsB[i,j1]  -= 1;\n  NeighborsB[i,j2]  -= 1;\n  NeighborsB[i2,j1] -= 1;\n  NeighborsB[i2,j]  -= 1;\n  NeighborsB[i2,j2] -= 1;\nend;\n\nprocedure SetCell(i,j: integer);\nbegin\n  if configuration[i,j] = 0 then\n  begin\n    configuration[i,j] := 1;\n    updateFlag := True;\n    IncNeighbors(i,j);\n    CountCells += 1;\n  end;\nend;\n\nprocedure UnSetCell(i,j: integer);\nbegin\n  if configuration[i,j] = 1 then\n  begin\n    configuration[i,j] := 0;\n    updateFlag := True;\n    DecNeighbors(i,j);\n    CountCells -= 1;\n  end;\nend;\n\nprocedure ProcessCell(i,j: integer);\nbegin\n  case NeighborsA[i,j] of\n0..1,4..9: UnSetCell(i,j);\n3: SetCell(i,j);\n  end; \nend;\n\nprocedure NextGen;\nbegin\n  var hm := m div mk;\n  var hn := n div nk;\n  for var ik:=1 to nk do\n  begin\n    for var jk:=1 to mk do\n    begin\n      updateFlag := False;\n      var ifirst := (ik-1)*hn+1;\n      var ilast := (ik-1)*hn+hn;\n      var jfirst := (jk-1)*hm+1;\n      var jlast := (jk-1)*hm+hm;\n      if updateA[ik,jk] then\n      begin\n        for var i:=ifirst to ilast do\n        for var j:=jfirst to jlast do\n          ProcessCell(i,j);\n      end\n      else\n      begin\n        var ik1,jk1,ik2,jk2: integer;\n        if ik=1 then ik1:=nk else ik1:=ik-1;\n        if ik=nk then ik2:=1 else ik2:=ik+1;\n        if jk=1 then jk1:=mk else jk1:=jk-1;\n        if jk=mk then jk2:=1 else jk2:=jk+1;\n        var l := updateA[ik,jk1];\n        var r := updateA[ik,jk2];\n        var u := updateA[ik1,jk];\n        var d := updateA[ik2,jk];\n        var lu := updateA[ik1,jk1];\n        var ld := updateA[ik2,jk1];\n        var ru := updateA[ik1,jk2];\n        var rd := updateA[ik2,jk2];\n        if u then\n          for var j:=jfirst+1 to jlast-1 do\n            ProcessCell(ifirst,j);\n        if d then\n          for var j:=jfirst+1 to jlast-1 do\n            ProcessCell(ilast,j);\n        if l then\n          for var i:=ifirst+1 to ilast-1 do\n            ProcessCell(i,jfirst);\n        if r then\n          for var i:=ifirst+1 to ilast-1 do\n            ProcessCell(i,jlast);\n        if u or l or lu then\n          ProcessCell(ifirst,jfirst);\n        if u or r or ru then\n          ProcessCell(ifirst,jlast);\n        if d or l or ld then\n          ProcessCell(ilast,jfirst);\n        if d or r or rd then\n          ProcessCell(ilast,jlast);\n      end;\n      updateB[ik,jk] := updateFlag;\n    end;\n  end;\nend;\n\nprocedure InitWindow;\nbegin\n  if (m mod mk<>0) or (n mod nk<>0) then\n  begin\n    Writeln('Cluster size does not match field size. Program terminated');\n    exit\n  end;\n  Window.SetSize(x0+m*w,y0+n*w);\n  Window.CenterOnScreen;\n  Window.Title := 'Game of Life';\n  Font.Name := 'Arial';\n  Font.Size := 14;\nend;\n\nprocedure InitArrays;\nbegin\n  for var i:=0 to n+1 do\n  for var j:=0 to m+1 do\n    configuration[i,j] := 0;\n  NeighborsB := configuration;\n  NeighborsA := NeighborsB;\n  for var ik:=1 to nk do\n  for var jk:=1 to mk do\n    updateB[ik,jk] := True;\n  updateA := updateB;\n  CountCells := 0;\nend;\n\nvar yc := n div 2;\nvar xc := m div 2;\n\nprocedure InitConfiguration;\nbegin\n  SetCell(yc,xc);\n  SetCell(yc,xc+1);\n  SetCell(yc,xc+2);\n  SetCell(yc-1,xc+2);\n  SetCell(yc+1,xc+1);\nend;\n\nbegin\n  InitWindow;\n  InitArrays;\n  InitConfiguration;\n  \n  DrawField;\n  configurationVisual := CreateVisual;\n  infoVisual := CreateVisual;\n  \n  DrawConfiguration;\n  DrawInfo;\n  \n  MillisecondsDelta;\n  generation := 0;\n  while True do\n  begin\n    generation += 1;\n    NeighborsA := NeighborsB;\n    updateA := updateB;\n    NextGen;\n    DrawConfiguration;\n    if generation mod 10 = 0 then\n      DrawInfo;\n    if generation mod 1000 = 0 then\n      Writeln('Generation ',generation,': ',MillisecondsDelta/1000,' s');\n  end;\nend."
  },
  {
    "instruction": "Show how to use LinkedList (doubly linked list) from standard library with iterators in PascalABC.NET",
    "output": "// Using LinkedList - doubly linked list of standard library - and its iterator\n\nbegin\n  var L: LinkedList<integer> := new LinkedList<integer>;\n\n  L.AddLast(3);\n  L.AddLast(5);\n  L.AddLast(7);\n  L.AddFirst(2);\n  Println(L);\n  \n  var a := new integer[10];\n  L.CopyTo(a,0);\n  Println(a);\n  \n  var lit: LinkedListNode<integer> := L.Find(5);\n  L.AddBefore(lit,777);\n  Println(L);\nend."
  },
  {
    "instruction": "Create PascalABC.NET programs demonstrating LINQ operations including generating sequences, mathematical ranges, and character ranges.",
    "output": "begin\n  Range(1,20).Select(x->x*x).Println;\n  PartitionPoints(0.0,1.0,10).Println;\n  Range('a','z').Println;\nend."
  },
  {
    "instruction": "Implement prime number generation in PascalABC.NET using LINQ with both sequential and parallel execution for performance comparison.",
    "output": "function IsPrime(x: integer): boolean;\nbegin\n  var sqx := Round(Sqrt(x));\n  var i := 2;\n  while (i <= sqx) and (x mod i <> 0) do\n    i += 1;\n  Result := i > sqx; \nend;\n\nvar n := 3000000;\n\nbegin\n  writeln(Range(2,n).Where(IsPrime).Count);\n  writeln(Milliseconds);\n  writeln(Range(2,n).AsParallel.Where(IsPrime).Count);\n  writeln(MillisecondsDelta);\nend."
  },
  {
    "instruction": "Solve the knapsack problem in PascalABC.NET using backtracking to find all subsets of items that exactly fill the knapsack capacity.",
    "output": "const Sz=100;\n\ntype IntArr = array [1..Sz] of integer;\n\nprocedure PrintArr(const A: IntArr; n: integer);\nbegin\n  for var i:=1 to n do\n    Print(A[i]);\n  Println;\nend;\n\nprocedure TrySolve(n: integer; const B: IntArr; nb: integer);\nvar\n  Subset: IntArr;\n  space: integer;\n  ns: integer;\n\n  procedure TrySolve0(i: integer);\nbegin\n    if space=0 then \n      PrintArr(Subset,ns)\n    else if (space<0) or (i>nb) then \n      exit\n    else\n    begin\n      TrySolve0(i+1);\n      ns += 1; \n      Subset[ns] := B[i]; \n      space := space - B[i];\n      TrySolve0(i+1);\n      space := space + B[i]; \n      ns -= 1;\n    end;\n  end;\n  \nbegin\n  space:=n;\n  TrySolve0(1);\nend;\n\nprocedure FillArr(var B: IntArr; var n: integer);\nbegin\n  n:=5;\n  B[1]:=8; B[2]:=5; B[3]:=13; B[4]:=3; B[5]:=15;\nend;\n\nvar\n  B: IntArr;\n  nb: integer;\n\nbegin\n  FillArr(B,nb);\n  TrySolve(23,B,5);\nend."
  },
  {
    "instruction": "Create PascalABC.NET programs that demonstrate DLL usage, including calling functions and accessing variables from external libraries.",
    "output": "{$reference mydll.dll}\n\nbegin\n  PrintPascalABCNET;\n  writeln(n);\n  writeln(add(2,3));\nend."
  },
  {
    "instruction": "Build a LEGO structure in 3D using Graph3D in PascalABC.NET with different colored blocks stacked on top of each other.",
    "output": "uses Graph3D;\n\nbegin\n  var l := Lego(-4,-1,0,8,4,1,Colors.Green);\n  Lego(-2,0,0.4,4,2,1,Colors.Blue);\n  Lego(-1,0,0.8,1,1,1,Colors.Red);\n  Lego(-1,1,0.8,2,1,1,Colors.Yellow);\nend."
  },
  {
    "instruction": "Compare performance between array and list operations in PascalABC.NET by measuring execution time for large-scale element assignments.",
    "output": "begin\n  var n := 300000000;\n  var a := ArrFill(n,1);\n  var l := Lst(a);\n  MillisecondsDelta;\n  for var i:=0 to n-1 do\n    a[i] := 2;\n  MillisecondsDelta.Println;\n  for var i:=0 to n-1 do\n    l[i] := 2;\n  MillisecondsDelta.Println;\nend."
  },
  {
    "instruction": "Send an email using System.Net.Mail in PascalABC.NET with proper SMTP server configuration and message formatting.",
    "output": "uses System.Net.Mail;\n\nconst \n  SMTPServerName = 'mail.spark-mail.ru';\n\nbegin\n  var fromSender := 'ivanov@mail.ru';\n  var toReceiver := 'petrov@yandex.ru';\n  var subject := 'Proba';\n  var body := 'Hello!' + NewLine + 'I am robot!';\n  var message := new MailMessage(fromSender, toReceiver, subject, body);\n  \n  var mailClient := new SmtpClient(SMTPServerName);\n  mailClient.Send(message);\nend."
  },
  {
    "instruction": "Demonstrate lambda expression syntax in PascalABC.NET showing different ways to write procedure assignments with side effects.",
    "output": "begin\n  var f: procedure(x: integer);\n  var sum := 0;\n  f := x -> begin sum += x end;\n  f := x -> (sum += x);\nend."
  },
  {
    "instruction": "Create fractal visualizations in PascalABC.NET using the Paporotnik library to draw multiple fractal patterns in a single window.",
    "output": "uses GraphABC, Paporotnik, PaporotnikData;\n\nconst \n  Iterations = 300000;         \n  Height     = 600;            \n  Fast       = false;\n  Width      = Height div 2;        \n  WindowWidth= Width * 3;        \n  Brightness = 170;\n\nvar \n  Paprotnik := new PaporotnikFractal(PaprotnikData);\n  SimplePaprotnik := new PaporotnikFractal(SimplePaprotnikData);\n  Elka := new PaporotnikFractal(ElkaData);\n\nbegin\n  InitWindow(200, 50, WindowWidth , Height, clBlack);\n  Paprotnik.Draw(0, 0, Iterations, Height, Brightness, fast);\n  SimplePaprotnik.Draw(Width, 0, Iterations, Height, Brightness, fast);\n  Elka.Draw(Width*2, 0, Iterations, Height, Brightness, fast);\nend."
  },
  {
    "instruction": "Measure performance of list slicing operations in PascalABC.NET by timing repeated slice operations on large lists.",
    "output": "begin\n  var s := Lst(1..1000);\n  var s1: List<integer>;\n  Milliseconds;\n  var n := 10000000;\n  MillisecondsDelta.Println;\n  loop n do\n    s1 := s[1:11];\n  MillisecondsDelta.Println;\nend."
  },
  {
    "instruction": "Benchmark list slice assignment performance in PascalABC.NET by timing repeated slice assignments on lists.",
    "output": "begin\n  var s := Lst(1..10);\n  Milliseconds;\n  var n := 100000000;\n  MillisecondsDelta.Println;\n  loop n do\n    s[0:10] := s;\n  MillisecondsDelta.Println;\nend."
  },
  {
    "instruction": "Generate the Mandelbrot fractal set in PascalABC.NET using GraphWPF by iterating complex numbers and coloring pixels based on iteration count.",
    "output": "uses GraphWPF;\n\nconst\n  max = 10;\n  coef1 = 0.5;\n  coef2 = 0.88;\n  scalex = 0.0035;\n  scaley = 0.0035;\n  dx = 430;\n  dy = 300;\n\nbegin\n  Window.Title := 'Fractals: Mandelbrot Set';\n  Window.SetSize(600,600);\n  Window.CenterOnScreen;\n  var m := Window.Width.Round;\n  var n := Window.Height.Round;\n  var a := new Color[m,n];\n  for var ix:=0 to m-1 do\n  for var iy:=0 to n-1 do\n  begin\n    var cx := scalex * (ix - dx);\n    var cy := scaley * (iy - dy);\n    var c := Cplx(cx,cy);\n    var z := Cplx(0,0);\n    var i := 1;\n    while i<255 do\n    begin\n      z := z*z+c; \n      if z.Magnitude>max then break;\n      i += 1;\n    end;\n    if i>=255 then a[ix,iy] := Colors.Red\n      else a[ix,iy] := RGB(255,255-i,255-i);\n  end;\n  DrawPixels(0,0,a);\n  Writeln('Calculation time = ',Milliseconds/1000,' s');\nend."
  },
  {
    "instruction": "Demonstrate delegate pattern matching in PascalABC.NET by storing different function types in a System.Delegate variable and using match to invoke them.",
    "output": "begin\n  var s: real->real := x -> x * x;\n  var add: (real,real)->real := (x, y)-> x + y;\n  var d: System.Delegate := s;  \n  d := add;\n  match d with\n    Func<real, real>(var i): Print(i(2));\n    Func2<real, real, real>(var i): Print(i(2,3));\n  end;\nend."
  },
  {
    "instruction": "Implement the 'Matches' game in PascalABC.NET where players take turns removing 1-3 matches, with computer AI and win/lose conditions.",
    "output": "const InitialCount=15;\n\nvar\n  Count: integer;\n  Num: integer;\n  Player: integer;\n\nbegin\n  Player := 1;\n  Count := InitialCount;\n  repeat\n    if Player=1 then\n    begin\n      var Correct: boolean;\n      repeat\n        Write('Your turn. There are ',Count,' matches. ');\n        Write('How many matches do you take? ');\n        Readln(Num);\n        Correct := (Num>=1) and (Num<=3) and (Num<=Count);\n        if not Correct then\n          writeln('Incorrect! Repeat input!');\n      until Correct;\n    end\n    else\n    begin\n      Num := Random(1,3);\n      if Num>Count then \n        Num := Count;\n      Writeln('My turn. I took ',Num,' matches');\n    end;\n    Count -= Num;\n    if Player=1 then \n      Player := 2\n    else Player := 1;\n  until Count=0;\n  if Player=1 then\n    Writeln('You won!')\n  else Writeln('You lost!');\nend."
  },
  {
    "instruction": "Use tuple pattern matching with when conditions in PascalABC.NET to compare two variables and print the relationship between them.",
    "output": "begin\n  var (a,b) := (3,2);\n  match (a,b) with\n  (var x,var y) when x < y: Print('a < b');\n  (var x,var y) when x = y: Print('a = b');\n  (var x,var y) when x > y: Print('a > b');\n  end;\nend."
  },
  {
    "instruction": "Create 3D objects with different material properties in PascalABC.NET using Graph3D, combining diffuse, specular, and emissive materials.",
    "output": "uses Graph3D;\n\nbegin\n  var m := DiffuseMaterial(Colors.Green) + SpecularMaterial(128,30) + EmissiveMaterial(RGB(0,64,0));\n  Sphere(4,0,0,2,m);\n  Cube(8,0,0,4,RainbowMaterial);\n  Cube(0,0,0,4,DiffuseMaterial(Colors.Green) + ImageMaterial('dog.jpg',0.5,0.5));\nend."
  },
  {
    "instruction": "Demonstrate material properties variation in PascalABC.NET by creating spheres with different specular and emissive parameters arranged in rows.",
    "output": "uses Graph3D;\n\nbegin\n  for var i:=0 to 6 do\n    Sphere(6-2*i,-3,0,1,\n      Materials.Diffuse(Colors.Green) + \n      Materials.Specular(255-32*i,100));\n  for var i:=0 to 6 do\n    Sphere(6-2*i,0,0,1,\n      Materials.Diffuse(Colors.Green) +\n      Materials.Specular(255,100-15*i));\n  for var i:=0 to 6 do\n    Sphere(6-2*i,3,0,1,\n      Materials.Diffuse(Colors.Green) + \n      Materials.Specular(128,100) + \n      Materials.Emissive(GrayColor(15*i)));\nend."
  },
  {
    "instruction": "Search for a specific value in a random matrix using goto statement for early exit from nested loops in PascalABC.NET.",
    "output": "const \n  sz = 10;\n  m = 4;\n  n = 5;\n\ntype Matrix = array [1..sz,1..sz] of integer;\n\nlabel 1;\n\nvar matr: Matrix;\n\nbegin\n  for var i := 1 to m do\n  for var j := 1 to n do\n    matr[i,j] := Random(100);\n  for var i := 1 to m do\n  begin\n    for var j := 1 to n do\n      write(matr[i,j]:3);\n    writeln;\n  end;  \n  var found5 := False;\n  for var i := 1 to m do\n  for var j := 1 to n do\n    if matr[i,j]=5 then\n    begin\n      found5 := True;\n      goto 1;\n    end;\n1: \n  if found5 then \n    writeln('Element 5 found')\n  else writeln('Element 5 not found')  \nend."
  },
  {
    "instruction": "Create and manipulate dynamic matrix arrays in PascalABC.NET with functions for creation, random filling, and display.",
    "output": "type Matrix = array of array of integer;\n\nfunction CreateMatrix(m,n: integer): Matrix;\nbegin\n  SetLength(Result,m);\n  for var i:=0 to m-1 do\n    SetLength(Result[i],n);\nend;\n\nprocedure FillMatrByRandom(matr: Matrix);\nbegin\n  for var i:=0 to matr.Length-1 do\n  for var j:=0 to matr[0].Length-1 do\n    matr[i][j] := Random(100);  \nend;\n\nprocedure WriteMatrix(matr: Matrix);\nbegin\n  for var i := 0 to matr.Length-1 do\n  begin\n    for var j := 0 to matr[0].Length-1 do\n      write(matr[i,j]:3);\n    writeln;\n  end;  \nend;\n\nvar matr: Matrix;\n\nbegin\n  var m := 5;\n  var n := 7;\n  matr := CreateMatrix(m,n);\n  FillMatrByRandom(matr);\n  WriteMatrix(matr);\nend."
  },
  {
    "instruction": "Perform linear algebra operations in PascalABC.NET using NumLibABC to calculate matrix determinant of complex expression.",
    "output": "uses NumLibABC;\n\nbegin\n  var A:=new Matrix(2,4,-3,0,4,-1,2,-7,5,6);\n  var B:=new Matrix(2,3,8,1,-5,6,7,2);\n  var C:=new Matrix(3,4,1,-1,7,0,3,2,9,4,5,0,-2,-4);\n  var M:=(((A-B*C).Transpose)*A).Det;\n  Writeln(M)\nend."
  },
  {
    "instruction": "Generate random mazes using recursive backtracking algorithm in PascalABC.NET with GraphWPF visualization.",
    "output": "uses GraphWPF;\n\nconst \n  w = 60;\n  h = 40;\n  cellSize = 10;\n  wallColor = Colors.Black;\n  pathColor = Colors.White;\n  startColor = Colors.Green;\n  endColor = Colors.Red;\n\nvar maze := MatrGen(w*2+1, h*2+1, (x,y) -> True);\n\nvar dirs := Arr(\n    (0, -2),\n    (2,  0),\n    (0,  2),\n    (-2, 0)\n  );\n\nprocedure DrawCell(x, y: integer; c: Color)\n  := FillRectangle(x*cellSize/2, y*cellSize/2, \n       cellSize/2, cellSize/2, c);\n\nprocedure GenerateMaze(x, y: integer);\nbegin\n  maze[x, y] := false;\n  dirs.Shuffle;\n  foreach var (dx, dy) in dirs do\n  begin\n    var (nx, ny) := (x + dx, y + dy);\n    if (nx in 1..w*2-1) and (ny in 1..h*2-1) and maze[nx, ny] then\n    begin\n      var (wx, wy) := (x + dx div 2, y + dy div 2);\n      maze[wx, wy] := false;\n      GenerateMaze(nx, ny);\n    end;\n  end;\nend;\n\nprocedure DrawMaze;\nbegin\n  Window.SetSize(w*cellSize + 5, h*cellSize + 5);\n  Window.Clear(Colors.White);\n  for var x := 0 to w*2 do\n    for var y := 0 to h*2 do\n      if maze[x, y] then\n        DrawCell(x, y, wallColor)\n      else DrawCell(x, y, pathColor);\n  DrawCell(0, 1, startColor);\n  DrawCell(w*2, h*2-1, endColor);\nend;\n\nbegin\n  Window.Title := 'Random Maze Generator';\n  GenerateMaze(1, 1);\n  DrawMaze;\nend."
  },
  {
    "instruction": "Call Windows API MessageBox function from PascalABC.NET using external DLL declaration.",
    "output": "function MessageBox(h:integer;m,c:string;t:integer):integer;\nexternal 'User32.dll' name 'MessageBox';\n\nbegin\n  MessageBox(0,'Hello!','Message',0);\nend."
  },
  {
    "instruction": "Compare performance between static array and matrix filling operations in PascalABC.NET for large datasets.",
    "output": "const n = 20000;\n\nvar a: array [1..n,1..n] of real;\n\nbegin\n  for var i:=1 to n do\n  for var j:=1 to n do\n    a[i,j] := 1;\n  Println(MillisecondsDelta/1000);\n  var m := MatrFill(n,n,1);\n  Println(MillisecondsDelta/1000);\nend."
  },
  {
    "instruction": "Calculate Pi using Monte Carlo method in PascalABC.NET by generating random points and counting those inside unit circle.",
    "output": "begin\n  var n := 10000000;\n  var pp := (1..n).Select(x->(Random(),Random())).Where(p->sqr(p[0])+sqr(p[1])<1).Count/n*4;\n  Print(pp);\nend."
  },
  {
    "instruction": "Create animated mosaic pattern in PascalABC.NET by randomly swapping colored squares in a grid with continuous animation.",
    "output": "uses GraphABC;\n\nconst \n  w  = 25;\n  w1 = 1;\n  m  = 50;\n  n  = 70;\n  x0 = 0;\n  y0 = 0;\n  delay = 10;\n\nvar a: array [0..n,0..m] of Color;\n\nbegin\n  Window.Title := 'Mosaic';\n  Window.SetSize(800,600);\n  for var i:=0 to n-1 do\n  for var j:=0 to m-1 do\n  begin\n    a[i,j] := clRandom;\n    Brush.Color := a[i,j];\n    FillRect(x0+i*w,y0+j*w,x0+(i+1)*w-w1,y0+(j+1)*w-w1);\n  end;\n  var k := 0;\n  while true do\n  begin\n    k += 1;\n    if k mod 1000 = 0 then \n    begin\n      k := 0;\n      Sleep(delay);\n    end;  \n    var i := Random(1,n-2);\n    var j := Random(1,m-2);\n    var di := Random(-1,1);\n    var dj := Random(-1,1);\n    var i1 := i+di; \n    var j1 := j+dj;\n    Swap(a[i,j],a[i1,j1]);\n    Brush.Color := a[i,j];\n    FillRect(x0+i*w,y0+j*w,x0+(i+1)*w-w1,y0+(j+1)*w-w1);\n    Brush.Color := a[i1,j1];\n    FillRect(x0+i1*w,y0+j1*w,x0+(i1+1)*w-w1,y0+(j1+1)*w-w1);\n  end;\nend."
  },
  {
    "instruction": "Handle mouse and keyboard events in PascalABC.NET using GraphWPF to draw circles on mouse click and print key codes.",
    "output": "uses GraphWPF;\n\nbegin\n  OnMouseDown := (x,y,mb) -> if mb=1 then Circle(x,y,5);\n  OnKeyDown := k -> Print(k);\nend."
  },
  {
    "instruction": "Generate the Mandelbrot fractal set in PascalABC.NET using GraphABC by iterating complex numbers and setting pixels based on iteration count.",
    "output": "uses GraphABC;\n\nconst\n  max = 10;\n  coef1 = 0.5;\n  coef2 = 0.88;\n  scalex = 0.0035;\n  scaley = 0.0035;\n  dx = 430;\n  dy = 300;\n\nbegin\n  Window.Title := 'Fractals: Mandelbrot Set';\n  SetWindowSize(600,600);\n  CenterWindow;\n  for var ix:=0 to Window.Width-1 do\n  for var iy:=0 to Window.Height-1 do\n  begin\n    var cx := scalex * (ix - dx);\n    var cy := scaley * (iy - dy);\n    var c := Cplx(cx,cy);\n    var z := Cplx(0,0);\n    var i := 1;\n    while i<255 do\n    begin\n      z := z*z+c; \n      if z.Magnitude>max then break;\n      i += 1;\n    end;\n    if i>=255 then SetPixel(ix,iy,clRed)\n      else SetPixel(ix,iy,RGB(255,255-i,255-i));\n  end;\n  writeln('Calculation time = ',Milliseconds/1000,' s');\nend."
  },
  {
    "instruction": "Create mouse drawing applications in PascalABC.NET using different approaches: GraphABC for simple drawing and Windows Forms for advanced drawing with random colors.",
    "output": "// Simple mouse drawing with GraphABC\nuses GraphABC;\n\nbegin\n  Window.Title := 'Mouse Drawing';\n  OnMouseDown := (x,y,mb) -> MoveTo(x,y);\n  OnMouseMove := (x,y,mb) -> if mb=1 then LineTo(x,y);\nend.\n\n// Advanced mouse drawing with Windows Forms\n{$apptype windows}\n{$reference 'System.Windows.Forms.dll'}\n{$reference 'System.Drawing.dll'}\n\nuses \n  System, \n  System.Drawing, \n  System.Windows.Forms;\n\ntype\n  MyForm = class(Form)\n  private\n    g: Graphics;\n    x,y: integer;\n  public  \n    constructor;\n    begin\n      Size := new System.Drawing.Size(640,480);\n      StartPosition := FormStartPosition.CenterScreen;\n      Text := 'Mouse Drawing on Form';\n      MouseDown\t+= OnMouseDown;\n      MouseMove\t+= OnMouseMove;\n      Resize\t+= OnResize;\n      g := Graphics.FromHwnd(Handle);\n    end;\n    procedure OnMouseDown(sender: object; e: MouseEventArgs);\n    begin\n      x := e.x;\n      y := e.y;\n    end; \n    procedure OnMouseMove(sender: object; e: MouseEventArgs);\n    begin\n      if e.Button = System.Windows.Forms.MouseButtons.Left then \n      begin\n        g.DrawLine(new Pen(Color.FromARGB(PABCSystem.Random(255),PABCSystem.Random(255),PABCSystem.Random(255))),x,y,e.x,e.y);\n        x := e.x;\n        y := e.y;\n        writeln(e.x,' ',e.y);\n      end;\n    end; \n    procedure OnResize(sender: object; e: EventArgs);\n    begin\n      g := Graphics.FromHwnd(Handle);\n    end;\n  end;\n    \nbegin\n  Application.Run(new MyForm);\nend."
  },
  {
    "instruction": "Implement mouse event handling in PascalABC.NET using GraphWPF for drawing with custom pen settings and screenshot saving functionality.",
    "output": "uses GraphWPF;\n\nbegin\n  Window.Title := 'Mouse Drawing';\n  Pen.Color := Colors.Blue;\n  Pen.Width := 3;\n  OnMouseDown := (x,y,mb) -> MoveTo(x,y);\n  OnMouseMove := (x,y,mb) -> if mb=1 then LineTo(x,y);\n  OnKeyDown := k -> if k = Key.Space then Window.Save('a.png');\nend."
  },
  {
    "instruction": "Create mouse interaction examples in PascalABC.NET showing different event handling patterns including circle drawing on click and continuous line drawing.",
    "output": "// Draw circles on mouse click\nuses GraphABC;\n\nbegin\n  OnMouseDown := (x,y,mb) -> Circle(x,y,5);\nend.\n\n// Continuous line drawing with mouse\nuses GraphABC;\n\nprocedure MouseDown(x,y,mb: integer);\nbegin\n  MoveTo(x,y);\nend;\n\nprocedure MouseMove(x,y,mb: integer);\nbegin\n  if mb=1 then LineTo(x,y);\nend;\n\nbegin\n  OnMouseDown := MouseDown;\n  OnMouseMove := MouseMove;\nend."
  },
  {
    "instruction": "Implement frame-based animation with keyboard controls in PascalABC.NET using WPFObjects for smooth object movement.",
    "output": "uses WPFObjects;\n\nbegin\n  var c := new CircleWPF(Window.Center, 20, Colors.Green);\n  \n  OnDrawFrame := dt -> begin\n    c.MoveTime(dt);    \n  end;\n  \n  OnKeyDown := k -> begin\n    case k of\n      Key.Left: c.Direction := Direction.Left;\n      Key.Right: c.Direction := Direction.Right;\n      Key.Up: c.Direction := Direction.Up;\n      Key.Down: c.Direction := Direction.Down;\n    end;\n  end;\n  \n  OnKeyUp := k -> begin\n    c.Direction := Direction.Zero;\n  end;\nend."
  },
  {
    "instruction": "Demonstrate 3D object manipulation in PascalABC.NET using Graph3D for cloning, rotating, and positioning boxes in 3D space.",
    "output": "uses Graph3D;\n\nbegin\n  var b := Box(0,0,0,3,1,2,Colors.Blue);\n  var b1 := b.Clone.RotateAt(OrtZ,90,P3D(1.5,0,0)).MoveByX(-0.5);\n  b1 := b.Clone.RotateAt(OrtZ,-90,P3D(-1.5,0,0)).MoveByX(0.5);\n  View3D.BackgroundColor := Colors.Black;\n  View3D.ShowGridLines := False;\nend."
  },
  {
    "instruction": "Demonstrate multidimensional array slicing operations in PascalABC.NET with various slice patterns including reverse indexing and partial slices.",
    "output": "begin\n  var m := MatrByRow(||1,2,3,4|,|5,6,7,8|,|9,10,11,12||);\n  Println(m[:,:]);           // [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n  Println(m[::1,::1]);       // [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n  Println(m[1:3,1:4]);       // [[6,7,8],[10,11,12]]\n  Println(m[::2,::3]);       // [[1,4],[9,12]]\n  Println(m[::-2,::-1]);     // [[12,11,10,9],[4,3,2,1]] \n  Println(m[^2::-1,^2::-1]); // [[7,6,5],[3,2,1]] \n  Println(m[:^1,:^1]);       // [[1,2,3],[5,6,7]] \n  Println(m[1,:]);           // One-dimensional array [5,6,7,8] \n  Println(m[^1,:]);          // One-dimensional array [9,10,11,12] \n  Println(m[:,^1]);          // One-dimensional array [4,8,12] \nend."
  },
  {
    "instruction": "Show how to create and use DLL libraries in PascalABC.NET including both PascalABC.NET DLLs and native DLLs",
    "output": "// DLL library\nlibrary MyDll;\n\nconst n = 10;\n\nfunction add(a,b: integer): integer;\nbegin\n  Result := a + b;\nend;\n\nprocedure PrintPascalABCNET;\nbegin\n  Println('PascalABC.NET');\nend;\n\nend.\n\n// This is the main program\n// Names from dll-library written in PascalABC.NET can be used without connecting namespaces\n{$reference mydll.dll}\n\nbegin\n  PrintPascalABCNET;\n  Println(n);\n  Println(add(2,3));\nend.\n\n{$platformtarget x86}\n// Calling function from regular dll\nfunction add(a,b: integer): integer; external 'NativeDll.dll' name 'add'; // external function declaration\n\nbegin // main program\n  Println(add(2,3));\nend."
  },
  {
    "instruction": "Implement mathematical algorithms in PascalABC.NET including square root calculation using iterative method and Newton's method for equation solving.",
    "output": "// Square root using iterative method\nfunction MySqrt(x: real): real;\nbegin\n  var eps := 1e-15;\n  (var a, var b) := (x, real.MaxValue);\n  while abs(b-a) >= eps do\n    (a,b) := (b,(a + x / a) / 2);\n  Result := b;  \nend;\n\nbegin\n  Println(MySqrt(2));\n  Println(MySqrt(3));\n  Println(MySqrt(4));\nend.\n\n// Newton's method for equation solving\nfunction f(x: real) := exp(x) - 4;\nfunction df(x: real) := exp(x);\n\nfunction NewtonMethod(x, eps: real): real;\nbegin\n  while abs(f(x)) > eps do\n    x := x - f(x) / df(x); \n  Result := x;\nend;\n\nbegin\n  var x := 0.5;\n  var eps := 0.00001;\n  var root := NewtonMethod(x, eps);\n  Println('Equation root: ', root);\nend."
  },
  {
    "instruction": "Show how to create and use modules in PascalABC.NET with simplified structure and documentation comments",
    "output": "/// Module of simplified structure\nunit MyUnit; // module name must match file name\n\n// Documentation comments are displayed when hovering over name with mouse cursor\n/// Returns maximum element in array\nfunction Max(a: array of integer): integer;\nbegin\n  Result := integer.MinValue;\n  foreach var x in a do\n    if x > Result then \n      Result := x;\nend;\n\nend.\n\nuses MyUnit; // connected module\n\nvar a: array of integer := (1,5,3,7,3,6,4,5,1,8,3,5,6);\n\nbegin\n  Println('Maximum element in array =',Max(a));\nend."
  },
  {
    "instruction": "Create PascalABC.NET modules with different structures including initialization/finalization sections, and array utilities.",
    "output": "// Module with initialization/finalization\nunit MyUnit; \n\ninitialization\n  writeln('Initialization section. Executed before main program')\nfinalization\n  writeln('Finalization section. Executed after main program')\nend.\n\n// Module with array utilities\nunit MyUnit;\n\nconst Size = 100;\n\ntype IntArr = array [1..Size] of integer;\n\nvar Delimiter: string := ' ';\n\nprocedure FillArr(var a: IntArr; n: integer);\nbegin\n  for var i:=1 to n do\n    a[i] := Random(100);\nend;\n\nprocedure WriteArr(const a: IntArr; n: integer);\nbegin\n  for var i:=1 to n do\n    write(a[i],Delimiter);\n  writeln;  \nend;\n\nfunction Min(const a: IntArr; n: integer): integer;\nbegin\n  Result := a[1];\n  for var i:=1 to n do\n    if Result>a[i] then \n      Result := a[i];\nend;\n\nend."
  },
  {
    "instruction": "Demonstrate named parameter usage in PascalABC.NET procedures with default parameter values and explicit naming.",
    "output": "procedure p(s: string; x: integer := 1; y: integer := 2; z: integer := 3);\nbegin\n  Print(s,x,y,z);\nend;\n\nbegin\n  p('Hello', z := 33, y := 22);\nend."
  },
  {
    "instruction": "Create multiple unit modules in PascalABC.NET with same-named procedures and demonstrate resolution using module name qualification.",
    "output": "// Unit MyA\nunit MyA; \n\nprocedure p;\nbegin\n  writeln('MyA.p');\nend;\n\nbegin\nend.\n\n// Unit MyB\nunit MyB; \n\nprocedure p;\nbegin\n  writeln('MyB.p');\nend;\n\nbegin\nend.\n\n// Main program using both units\nuses MyA,MyB;\n\nbegin\n  p; // Calls MyB.p\n  MyA.p; // Calls MyA.p using module qualification\nend."
  },
  {
    "instruction": "Implement Conway's Game of Life with advanced features in PascalABC.NET including colony types, mouse interaction, and performance optimization.",
    "output": "uses GraphABC;\n\nconst \n  w =3;\n  w1=1;\n  k=20;\n  m=300;\n  n=220;\n  graphW=0;\n  mk=m div k;\n  nk=n div k;\n  mm=m+1;\n  nn=n+1;\n  x0=1;\n  y0=21;\n  ClearColor=clBlack;\n  FillColor=clLimeGreen;\n\nvar  \n  FiledColor := RGB(0,40,0);\n  FiledColor2 := RGB(0,70,0);\n  a,b,sosedia,sosedib:array of array of byte;\n  obnovA,obnovB: array of array of boolean;\n  count: integer;\n\nprocedure AssignArray(var arr:array of array of boolean; n,m:integer);\nbegin\n  SetLength(arr,n);\n  for var i:=0 to n-1 do\n    SetLength(arr[i],m);\nend;\n\nprocedure AssignArray(var arr:array of array of byte; n,m:integer);\nbegin\n  SetLength(arr,n);\n  for var i:=0 to n-1 do\n    SetLength(arr[i],m);\nend;\n\nprocedure CopyArray(arr1,arr2:array of array of byte);\nbegin\n  for var i:=0 to arr1.Length-1 do \n    arr1[i].CopyTo(arr2[i],0);\nend;\n\nprocedure CopyArray(arr1,arr2:array of array of boolean);\nbegin\n  for var i:=0 to arr1.Length-1 do \n    arr1[i].CopyTo(arr2[i],0);\nend;\n\ntype\n  ColonyType = (Big, LD, RD, LU, RU);\n\nprocedure AddColonyType(xc,yc:integer; ctype:ColonyType);\nbegin\n case ctype of\n    ColonyType.Big:begin\n      // Implementation for Big colony type\n    end;\n    ColonyType.LD:begin\n      // Implementation for LD colony type\n    end;\n  end;\n  CopyArray(sosedib,sosedia);\n  for var ik:=1 to nk do\n    for var jk:=1 to mk do\n      obnovB[ik,jk]:=true;\n  CopyArray(obnovB,obnovA);\nend;\n\nbegin\n  // Main game loop implementation\n  SetConsoleIO;\n  AssignArray(obnovA,nk+1,mk+1);\n  AssignArray(obnovB,nk+1,mk+1);\n  AssignArray(a,nn+1,mm+1);\n  AssignArray(b,nn+1,mm+1);\n  AssignArray(sosedia,nn+1,mm+1);\n  AssignArray(sosedib,nn+1,mm+1);\n  SetWindowCaption('Game of Life');\n  // Game initialization and main loop\nend."
  },
  {
    "instruction": "Demonstrate operator overloading for a Fraction record with arithmetic and comparison operations in PascalABC.NET",
    "output": "// Operator overloading\ntype \n  Frac = record\n  private\n    num,denom: integer;\n  public  \n    constructor (n,d: integer);\n    begin\n      num := n;\n      denom := d;\n    end;\n    class function operator+(a,b: Frac): Frac; \n    begin\n      Result := new Frac(a.num*b.denom+b.num*a.denom,a.denom*b.denom); \n    end; \n    class function operator-(a,b: Frac): Frac; \n    begin\n      Result := new Frac(a.num*b.denom-b.num*a.denom,a.denom*b.denom); \n    end; \n    class function operator*(a,b: Frac): Frac; \n    begin\n      Result := new Frac(a.num*b.num,a.denom*b.denom); \n    end;\n    class function operator/(a,b: Frac): Frac; \n    begin\n      Result := new Frac(a.num*b.denom,a.denom*b.num); \n    end;\n    class function operator=(a,b: Frac): boolean; \n    begin\n      Result := (a.num = b.num) and (a.denom = b.denom);\n    end; \n    class function operator<>(a,b: Frac): boolean; \n    begin\n      Result := not (a=b);\n    end; \n    class function operator<(a,b: Frac): boolean; \n    begin\n      Result := a.num/real(a.denom)<b.num/real(b.denom);\n    end; \n    class function operator<=(a,b: Frac): boolean; \n    begin\n      Result := a.num/real(a.denom)<=b.num/real(b.denom);\n    end; \n    class function operator>(a,b: Frac): boolean; \n    begin\n      Result := a.num/real(a.denom)>b.num/real(b.denom);\n    end; \n    class function operator>=(a,b: Frac): boolean; \n    begin\n      Result := a.num/real(a.denom)>=b.num/real(b.denom);\n    end; \n    class procedure operator+=(var a: Frac; b: Frac); \n    begin\n      a := a + b;\n    end; \n    class function operator-(a: Frac): Frac; \n    begin\n      Result := new Frac(-a.num,a.denom);\n    end; \n    class function operator+(a: Frac): Frac; \n    begin\n      Result := a;\n    end; \n    function ToString: string; override;\n    begin\n      Result := Format('{0}/{1}',num,denom);\n    end;\n  end;\n\nvar \n  f := new Frac(1,2);\n  f1 := new Frac(3,5);\n\nbegin\n  Println($'{f} + {f1} = {f+f1}');\n  Println($'{f} - {f1} = {f-f1}');\n  Println($'{f} * {f1} = {f*f1}');\n  Println($'{f} / {f1} = {f/f1}');\n  Println(f1 = f);\n  f += f1;\n  Println(-f);\nend."
  },
  {
    "instruction": "Demonstrate function overloading with different parameter types in PascalABC.NET",
    "output": "// Overloading subroutine names\nprocedure proc(i: integer);\nbegin\n  Println('integer');\nend;\n\nprocedure proc(c: char);\nbegin\n  Println('char');\nend;\n\nprocedure proc(r: real);\nbegin\n  Println('real');\nend;\n\nbegin\n  proc(1);\n  proc(2.5);\n  proc('d');\nend."
  },
  {
    "instruction": "Create a GUI application in PascalABC.NET using FormsABC to draw the Mandelbrot fractal with configurable parameters and threading support.",
    "output": "uses\n  System.Drawing, \n  System.Windows.Forms,\n  System.Threading,\n  FormsABC; \n\nprocedure DrawMandelbrot(g: Graphics; w,h: integer; scale: real; dx,dy: integer);\nconst max = 10;\nbegin\n  for var ix:=0 to w-1 do\n  for var iy:=0 to h-1 do\n  begin\n    var x := 0.0;\n    var y := 0.0;\n    var cx := scale * (ix - dx);\n    var cy := scale * (iy - dy);\n    var i := 1;\n    while i<255 do\n    begin\n      var x1 := x*x-y*y+cx;\n      var y1 := 2*x*y+cy;\n      x := x1;\n      y := y1;\n      if (abs(x)>max) and (abs(y)>max) then break;\n      i += 1;\n    end;\n    if i>=255 then \n      g.FillRectangle(Brushes.Red,ix,iy,1,1)\n    else \n      g.FillRectangle(new SolidBrush(Color.FromArgb(255,255-i,255-i)),ix,iy,1,1)\n  end;\nend;\n\nvar \n  Scale := new RealField('Scale: ');\n  l1 := new FlowBreak;\n  dx := new IntegerField('dx: ');\n  l2 := new FlowBreak;\n  dy := new IntegerField('dy: ');\n  l3 := new FlowBreak(20);\n  b := new Button(' Draw ');\n  p: PaintBox;\n\nprocedure Draw;\nbegin\n  var g := p.Graphics;\n  DrawMandelbrot(g,p.Width,p.Height,Scale.Value,dx.Value,dy.Value);\n  p.Invalidate;\nend;\n\nprocedure My(o: Object);\nbegin\n  Draw;\nend;\n\nprocedure Click;\nbegin\n  ThreadPool.QueueUserWorkItem(My);\nend;\n\nbegin\n  MainForm.Title := 'Mandelbrot Set';\n  MainForm.SetSize(700, 600);\n  MainPanel.Dock := Dockstyle.Left;\n  MainPanel.Width := 120;\n  Scale.Value := 0.0035;\n  dx.Value := 430;\n  dy.Value := 280;\n  b.Click += Click;\n  ParentControl := MainForm;\n  p := new PaintBox;\n  p.Dock := DockStyle.Fill;\n  ThreadPool.QueueUserWorkItem(My);\nend."
  },
  {
    "instruction": "Find and display palindromes in a string using PascalABC.NET LINQ operations, filtering words that read the same forwards and backwards.",
    "output": "begin\n  var s := ' hello  aha paap   zz ';\n  s.ToWords.Where(w -> w.Inverse = w).OrderBy(s->s.Length).Println(',');\nend."
  },
  {
    "instruction": "Create a fern fractal module in PascalABC.NET with configurable fractal parameters and drawing methods for different fern types.",
    "output": "unit Paporotnik;\n\nuses GraphABC;\n\ntype\n  PaporotnikFractalInitalData = record\n    data: array of array of real; \n    P0,P1,P2,P3:real;\n  end;\n  \n  PaporotnikFractal = class\n  private\n    data: array of array of real; \n    P0,P1,P2,P3:real;\n  public\n    constructor(initdata: PaporotnikFractalInitalData);\n    begin\n      data := initdata.data;\n      P0 := initdata.P0;\n      P1 := initdata.P1;\n      P2 := initdata.P2;\n      P3 := initdata.P3;\n    end;\n    procedure Draw(x0,y0,Iterations,Height,Brightness: integer; fast: boolean);\n    begin\n      var plotx, ploty, x, y : real;\n      var Size := Height/11;\n      var Width := Height div 2;\n      var dx := Width div 2;\n      var dc := Iterations div Brightness;\n      if fast then\n        LockDrawing;\n      for var i:=1 to Iterations do begin\n        var P := Random(100);    \n        var rnd := P<P0 ? 0 : P<P1+P0 ? 1 : P<P2+P1+P0 ? 2 : 3;\n        plotx := data[rnd,0]*x + data[rnd,1]*y;\n        ploty := data[rnd,2]*x + data[rnd,3]*y + data[rnd,5];\n        x := plotx;\n        y := ploty;\n        SetPixel(x0+Round(x*Size) + dx, y0+Height - Round(y*Size), GreenColor(byte(30 + (i div dc))));\n      end;\n      if fast then\n        UnlockDrawing;      \n    end;\n  end;\n\nend."
  },
  {
    "instruction": "Implement parallel programming patterns in PascalABC.NET including parallel invocation, task-based prime checking, and parallel for loops with thread synchronization.",
    "output": "// Parallel file downloads\nUses System,System.Net,System.Threading.Tasks;\n\nbegin\n  Parallel.Invoke (\n    procedure -> begin (new WebClient()).DownloadFile ('http://yandex.ru', 'yandex.html') end,\n    procedure -> begin (new WebClient()).DownloadFile ('http://pascalabc.net', 'pabc.html') end\n  );\nend.\n\n// Task-based prime number checking\ntype\n  Int = class\n    N: int64;\n    constructor(NN: int64);\n    begin\n      N := NN;\n    end;\n    function IsPrime: boolean;\n    begin\n      Result := True;\n      for var i: int64 := 2 to round(sqrt(N)) do\n        if N mod i = 0 then\n        begin\n          Result := False;\n          exit;\n        end;\n    end;\n  end;\n\ntype\n  BTask = Task<boolean>;\n\nbegin\n  var ss: array of int64 := (1265713689122381, 1265713689122461, 1265713689142451, 1265713689542501);\n  var tb := new BTask[4];\n  for var i := 0 to ss.Length - 1 do\n    tb[i] := Task.Factory.StartNew((new Int(ss[i])).IsPrime);\n  for var i := 0 to tb.Length - 1 do\n    writeln(tb[i].Result);\n  writeln(Milliseconds);  \nend.\n\n// Parallel for with thread-safe list\ntype\n  ListSimple = class\n    l := new List<int64>();\n    procedure AddPrime(N: int64);\n    begin\n      var Result := True;\n      for var i: int64 := 2 to round(sqrt(N)) do\n        if N mod i = 0 then\n        begin\n          Result := False;\n          break;\n        end;\n      lock l do \n        if Result then\n          l.Add(N);\n    end;\n  end;\n\nvar hh := 1000;\n\nbegin\n  var ls := new ListSimple;\n  var ii: int64 := 1265713689181;\n  Parallel.For(ii,ii+hh,ls.AddPrime);\n  Println(ls.l.Count);\nend."
  },
  {
    "instruction": "Create functions with variable number of parameters in PascalABC.NET for string concatenation and formatted output similar to Writeln.",
    "output": "// Variable parameter string concatenation\nfunction Concat(params strs: array of string): string;\nbegin\n  var sb := new StringBuilder;\n  foreach var x in strs do\n    sb.Append(x);\n  Result := sb.ToString;\nend;\n\nbegin\n  Writeln(Concat('Pascal','ABC','.NET'));\nend.\n\n// Variable parameter output procedure\nprocedure MyWriteln(params args: array of object);\nbegin\n  foreach var x in args do\n    Write(x);\n  WriteLn;\nend;\n\nvar \n  a: integer := 777;\n  b: boolean := True;\n  r: real := 3.1415;\n\nbegin\n  MyWriteln(a,' ',b,' ',r);\nend."
  },
  {
    "instruction": "Demonstrate array operations in PascalABC.NET including partial sums, incremental differences, and permutation generation.",
    "output": "// Partial sums and incremental differences\nbegin\n  var a := Arr(1..10);\n  a.Println;\n  var ps := a.PartialSum;\n  ps.Println;\n  ps.Incremental.Println;\nend.\n\n// Permutation generation\nbegin\n  var a := Arr(1..4);\n  repeat\n    a.Println;\n  until not NextPermutation(a);\nend.\n\n// Not in operator\nbegin\n  var a := Arr(1,3,5);\n  if 4 not in a then\n    Print('4 not in ' + a.JoinToString(','));\nend."
  },
  {
    "instruction": "Create a particle system in PascalABC.NET using Graph3D with configurable particle properties like lifetime, velocity, acceleration, and emission rate.",
    "output": "uses Graph3D;\n\nbegin\n  View3D.BackgroundColor := Colors.Black;\n  var ps := ParticleSystem(0,0,0,'smoke.png');\n  ps.LifeTime := 5;\n  ps.FadeOutTime := 0;\n  ps.VelocityDamping := 0.999;\n  ps.AngularVelocity := 10;\n  ps.SizeRate := 1;\n  ps.AccelerationDirection := V3D(3,0,-1);\n  ps.Acceleration := 4;\n  ps.AccelerationSpreading := 10;\n  ps.EmitRate := 100;\n  ps.StartRadius := 0;\n  ps.StartSize := 0.5;\n  ps.StartDirection := V3D(0,0,1);\n  ps.StartSpreading := 10;\n  ps.StartVelocity := 4;\n  ps.StartVelocityRandomness := 2;\n  ps.Position := P3D(0, 0, 0);\nend."
  },
  {
    "instruction": "Implement frame-based animation in PascalABC.NET using GraphWPF with smooth object movement controlled by time delta.",
    "output": "uses GraphWPF;\n\nbegin\n  var x0 := 100.0;\n  var v := 100;\n  OnDrawFrame := dt -> \n  begin\n    x0 += v * dt;\n    Circle(x0,100,30,Colors.Yellow);\n  end; \nend."
  },
  {
    "instruction": "Create fractal data modules in PascalABC.NET defining different fern fractal configurations including curved fern, straight fern, and fir tree patterns.",
    "output": "unit PaporotnikData;\n\nuses Paporotnik;\n\nvar\n  PaprotnikData: PaporotnikFractalInitalData := (\n    data: (( 0.0000,  0.0000,  0.0000,  0.1600, 0, 0.0000),\n           ( 0.8500,  0.0400, -0.0400,  0.8500, 0, 1.6000),\n           ( 0.1667, -0.2887,  0.2887,  0.1667, 0, 1.6000),\n           (-0.1667,  0.2887,  0.2887,  0.1667, 0, 0.4400));\n    P0: 3; \n    P1: 83;\n    P2: 7; \n    P3: 7);\n    \n  SimplePaprotnikData: PaporotnikFractalInitalData := (\n    data: (( 0.00,  0.00, 0.00, 0.16, 0, 0.00),\n           ( 0.85,  0.00, 0.00, 0.85, 0, 1.60),\n           ( 0.20, -0.26, 0.23, 0.22, 0, 1.60),\n           (-0.20,  0.26, 0.23, 0.22, 0, 1.60));\n    P0: 3; \n    P1: 83;\n    P2: 7; \n    P3: 7);\n\n  ElkaData: PaporotnikFractalInitalData := (\n    data: (( 0.1000,  0.0000,  0.0000,  0.1600, 0, 0.0000),\n           ( 0.8500,  0.0000,  0.0000,  0.8500, 0, 1.6000),\n           (-0.1667, -0.2887,  0.2887, -0.1667, 0, 1.6000),\n           (-0.1667,  0.2887, -0.2887, -0.1667, 0, 1.6000));\n    P0: 1; \n    P1: 85;\n    P2: 7; \n    P3: 7);\n\nend."
  },
  {
    "instruction": "Create a unit test procedure for the ApproxCheb class in PascalABC.NET that tests polynomial approximation with Chebyshev coefficients. The procedure should compare computed values with expected values within a given tolerance.",
    "output": "procedure TestApproxCheb(s:string; a,b:array of real; eps:real);\n// a - array of computed values\n// b - array of expected values\n// eps - allowable absolute error of solutions\nbegin\n  for var i:=0 to a.Length-1 do begin\n    var Msg:=s+': found: '+a[i]+', expected '+b[i];\n    Assert(Abs(Abs(a[i])-Abs(b[i]))<=eps,Msg);\n    end\nend;"
  },
  {
    "instruction": "Create a unit test procedure for the Decomp class in PascalABC.NET that tests matrix decomposition and linear system solving. The procedure should check for matrix singularity and compare computed solutions with expected values.",
    "output": "procedure TestDecomp(s:string; a:array[,] of real; b:array of real;\n    roots:array of real; eps:real);\n// a - system matrix;\n// b - right-hand side vector;\n// roots - vector of reference solutions;\n// eps - maximum absolute error of solutions\nbegin\n  var oD:=new Decomp(a);\n  var Msg:=s+': cond='+oD.cond+' matrix singularity detected';\n  var Flag:=oD.cond+1=oD.cond;\n  Assert(not Flag,Msg);\n  if not Flag then begin\n    oD.Solve(b);\n    var sum:=b.Zip(roots,(p,q)->Abs(Abs(p)-Abs(q))).Sum;\n    Msg:=s+': unacceptable error '+sum+' > '+eps+NewLine+\n        'Received : '+b.JoinIntoString(' ')+NewLine+\n        'Expected: '+roots.JoinIntoString(' ');\n    Assert(sum<=eps,Msg);\n    end\nend;"
  },
  {
    "instruction": "Create a unit test procedure for the Factors class in PascalABC.NET that tests polynomial factorization. The procedure should compare computed factors with expected integer roots.",
    "output": "procedure TestFactors(s:string; a:array of integer; roots:array of integer);\n// a - polynomial coefficients;\n// aroots - vector of reference solutions;\nbegin\n  var oL:=new Factors(a);\n  var r:=oL.Factorize;\n  var r1:=r.Rows.SelectMany(x->x);\n  var Msg:=s+': error.'+Newline+r1.JoinIntoString+': received'+NewLine+\n      roots.JoinIntoString+': expected';\n  if r1.Count=roots.Count then begin\n    var s1:=r1.Zip(roots,(i,j)->i-j).Sum;\n    Assert(s1=0,Msg)\n    end\n  else\n    Assert(false,Msg)\nend;"
  },
  {
    "instruction": "Create a unit test procedure for the FMin class in PascalABC.NET that tests single-variable function minimization. The procedure should compare found minimum points and function values with expected values within given tolerances.",
    "output": "procedure TestFMin(s:string; f:real->real; a,b,etx,ety,epsx,epsy:real);\n// etx - expected argument value\n// etx - expected function value\n// epsx - allowable absolute error for argument\n// epsy - allowable absolute error for function\nbegin\n  var oL:=new FMin(f,a,b);\n  var (x,y):=(oL.x,oL.Value);\n  var Msg:=s+': found argument: '+x+', expected '+etx;\n  Assert(Abs(x-etx)<=epsx,Msg);\n  Msg:=s+': function value: '+y+', expected '+ety;\n  Assert(Abs(y-ety)<=epsy,Msg);\nend;"
  },
  {
    "instruction": "Create a unit test procedure for the FMinN class in PascalABC.NET that tests multi-variable function minimization using the Hooke-Jeeves method. The procedure should compare found arguments and function values with expected values.",
    "output": "procedure TestFMinN1(s:string; f:function(x:array of real):real;\n    xb:array of real; etx:array of real; ety,epsx,epsy:real);\n// xb - array of arguments\n// etx - array of expected argument values\n// etx - expected function value\n// epsx - allowable absolute error for argument\n// epsy - allowable absolute error for function\nbegin\n  var oL:=new FMinN(xb,f);\n  var x:=oL.HJ;\n  var y:=f(x);\n  var Msg:=s+':'+NewLine+'found arguments  : '+\n      x.Select(t->Format('{0}',t)).JoinIntoString+NewLine+\n      'expected arguments: '+\n      etx.Select(t->Format('{0}',t)).JoinIntoString;\n  for var i:=0 to x.Length-1 do\n    if Abs(x[i]-etx[i])>epsx then begin\n      Assert(false,Msg);\n      break\n    end;\n  Msg:=s+': function value: '+y+', expected '+ety;\n  Assert(Abs(y-ety)<=epsy,Msg);\nend;"
  },
  {
    "instruction": "Create a unit test procedure for the Fraction class in PascalABC.NET that tests fraction arithmetic operations. The procedure should compare computed fractions with expected results.",
    "output": "procedure TestFraction(s:string; res,ans:Fraction);\n// result comparison res=ans\nbegin\n  Assert(res=ans,s+': received '+res.ToString+', expected '+ans.ToString)\nend;"
  },
  {
    "instruction": "Create unit test procedures for the Matrix class in PascalABC.NET that test scalar, vector, and matrix operations with error tolerance checking.",
    "output": "procedure TestMatrixS(s:string; a,r,eps:real);\n// a - found value;\n// r - expected value;\n// eps - maximum allowable absolute error\nbegin\n  var Msg:=s+': error exceeds allowable.'+Newline+'Received value '+\n      a+', expected value '+r;\n  Assert(Abs(a-r)<=eps,Msg)\nend;\n\nprocedure TestMatrixV(s:string; a,r:Vector; eps:real);\n// a - vector of found values;\n// r - vector of expected values;\n// eps - maximum allowable absolute error\nbegin\n  for var i:=0 to a.Length-1 do\n    Assert(Abs(a.Value[i]-r.Value[i])<=eps,\n        s+': error exceeds allowable.'+Newline+'Received value '+\n        a.Value[i]+', expected value '+r.Value[i])\nend;\n\nprocedure TestMatrixM(s:string; a,r:Matrix; eps:real);\n// a - computed matrix;\n// r - reference matrix;\n// eps - maximum allowable absolute error\nbegin\n  for var i:=0 to a.RowCount-1 do\n    for var j:=0 to a.ColCount-1 do\n      Assert(Abs(a.Value[i,j]-r.Value[i,j])<=eps,\n          s+': error exceeds allowable.'+Newline+'Received value a['+\n          i+','+j+']='+a.Value[i,j]+', expected value '+r.Value[i,j])\nend;"
  },
  {
    "instruction": "Create a unit test procedure for the PolRt class in PascalABC.NET that tests polynomial root finding. The procedure should handle complex roots and compare them with expected values within tolerance.",
    "output": "procedure TestPolRt(s:string; a:Polynom; roots:array of complex; eps:real);\n// roots - array of expected root values\n// eps - maximum absolute error of solutions\nbegin\n  var oP:=new PolRt(a);\n  if oP.ier>0 then begin\n    var Msg:=s+': test failed, error with code '+oP.ier;\n    Assert(false,Msg)\n    end\n  else begin\n    var r:=oP.Value;\n    for var i:=0 to r.Length-1 do begin\n      var Msg:=s+': found: ('+r[i].Real+','+r[i].Imaginary+'), expected ('+\n        roots[i].Real+','+roots[i].Imaginary+')';\n      Assert(Complex.Abs(r[i]-roots[i])<=eps,Msg);\n      end\n    end  \nend;"
  },
  {
    "instruction": "Create unit test procedures for the Polynom class in PascalABC.NET that test polynomial evaluation, economization, and arithmetic operations.",
    "output": "procedure TestPolynomD(s:string; res,lim:real; n1,n2:integer);\n// res - computed value\n// lim - maximum allowable value for res\n// also checks condition n2<n1\nbegin\n  Assert(n1>n2,s+': no economization occurred');\n  Assert(res<=lim,s+': deviation '+res+' exceeds '+lim);\nend;\n\nprocedure TestPolynomV(s:string; p:Polynom; x,r,eps:real);\n// \u0445 - argument for polynomial evaluation\n// r - expected value\n// eps - maximum absolute error of solution\nbegin\n  var a:=p.Value(x);\n  var Msg:=s+': found: '+a+', expected '+r;\n  Assert(Abs(a-r)<=eps,Msg)\nend;"
  },
  {
    "instruction": "Create a unit test procedure for the Quanc8 class in PascalABC.NET that tests numerical integration with adaptive quadrature. The procedure should compare computed integrals with expected values.",
    "output": "procedure TestQuanc8(s:string; a,b:real; F:real->real; ae,re,r2,eps:real);\n// cres - analytically found integral value\n// eps - allowable absolute error of solution\nbegin\n  var Msg:string;\n  var oQ:=new Quanc8(f,a,b,ae,re);\n  var r1:=oQ.Value;\n  if r1[2]=0 then begin\n    Msg:=s+': computed '+r1[0]+', expected '+r2;\n    Assert(Abs(r1[0]-r2)<=eps,Msg)\n    end\n  else begin\n    Msg:=s+': computed '+r1[0]+', expected '+r2+', errest='+r1[1]+', flag='+r1[2];\n    Assert(Abs(r1[0]-r2)<=eps,Msg)\n    end\nend;"
  },
  {
    "instruction": "Create a unit test procedure for the RKF45 class in PascalABC.NET that tests Runge-Kutta-Fehlberg ODE solving. The procedure should compare control sums with expected values.",
    "output": "procedure TestRKF45(s:string; res,ans,eps:real);\nbegin\n  Assert(Abs(res-ans)<=eps,s+': control sum '+res+', expected '+ans)\nend;"
  },
  {
    "instruction": "Create a unit test procedure for the RootsIsolation class in PascalABC.NET that tests root isolation for functions. The procedure should verify that roots fall within the found intervals.",
    "output": "procedure TestRootsIsolation(s:string; f:real->real; a,b,h:real;\n    t:array of real);\n// f - function\n// a,b - search interval boundaries\n// h - search step\n// t - reference array of function zeros\nbegin\n  var oRI:=new RootsIsolation(f,a,b,h);\n  var r:=oRI.Value;\n  for var i:=0 to t.Length-1 do begin\n    var Msg:=s+': zero point '+t[i]+' not in interval ['+r[i][0]+';'+r[i][1]+']';\n    Assert(t[i].Between(r[i][0],r[i][1]),Msg)\n    end;\nend;"
  },
  {
    "instruction": "Create a unit test procedure for the Spline class in PascalABC.NET that tests spline interpolation accuracy. The procedure should compare spline values with original function values.",
    "output": "procedure TestSpline(st:string; x:real; F:real->real; eps:real; S:Spline);\n// eps - relative error in percent\nbegin\n  var r1:=F(x);\n  var r2:=S.Value(x);\n  var Msg:=st+': F('+x+')='+r1+', received '+r2;\n  Assert(Abs((r1-r2)/r1)<=eps/100,Msg);\nend;"
  },
  {
    "instruction": "Create a unit test procedure for the Svenn class in PascalABC.NET that tests interval search for function minimization. The procedure should verify that the found interval contains the expected minimum.",
    "output": "procedure TestSvenn(s:string; f:real->real; x0,t,a,b:real);\n// f - function\n// x0 - initial search point\n// t - search step\n// a,b - expected interval (result should belong to it)\nbegin\n  var oS:=new Svenn(f,x0,t);\n  var r:=oS.Value;\n  var Msg:=s+': no solution found, expected ['+a+';'+b+']';\n  Assert(r[2]=0,Msg);\n  Msg:=s+': interval ['+a+';'+b+'] not within ['+r[0]+';'+r[1]+']';\n  Assert(a.Between(r[0],r[1]) and b.Between(r[0],r[1]),Msg)\nend;"
  },
  {
    "instruction": "Create unit test procedures for the Vector class in PascalABC.NET that test vector operations including modulus, orthogonalization, cross products, and angles.",
    "output": "procedure TestVector1(s:string; a,r,eps:real);\n// a - found value;\n// r - expected value;\n// eps - maximum allowable absolute error\nbegin\n  var Msg:=s+': error exceeds allowable.'+Newline+'Received value '+\n      a+', expected value '+r;\n  Assert(Abs(a-r)<=eps,Msg)\nend;\n\nprocedure TestVectorN(s:string; a,r:Vector; eps:real);\n// a - vector of found values;\n// r - vector of expected values;\n// eps - maximum allowable absolute error\nbegin\n  for var i:=0 to a.Length-1 do\n    Assert(Abs(a.Value[i]-r.Value[i])<=eps,\n        s+': error exceeds allowable.'+Newline+'Received value '+\n        a.Value[i]+', expected value '+r.Value[i])\nend;"
  },
  {
    "instruction": "Create a unit test procedure for the Zeroin class in PascalABC.NET that tests root finding for functions. The procedure should compare found roots with expected values within tolerance.",
    "output": "procedure TestZeroin(s:string; a,b:real; F:real->real; root,eps:real);\n// root - exact root value\n// eps - absolute error of root value\nbegin\n  var oZ:=new Zeroin(F,eps);\n  var x:=oZ.Value(a,b);\n  var Msg:=s+': root: '+x+', expected '+root;\n  Assert(Abs(x-root)<=eps,Msg);\nend;"
  },
  {
    "instruction": "Create a Person class in PascalABC.NET with external method implementation. The class should have private name and age fields, a constructor, and a Print method. Show both old and new syntax for constructor calls.",
    "output": "type \n  Person = class\n  private\n    name: string;\n    age: integer;\n  public\n    constructor (n: string; a: integer);\n    procedure Print;\n  end;\n\nconstructor Person.Create(n: string; a: integer);\nbegin\n  name := n; age := a;\nend;\n\nprocedure Person.Print;\nbegin\n  writeln('\u0418\u043c\u044f: ',name,'  \u0412\u043e\u0437\u0440\u0430\u0441\u0442: ',age);\nend;\n\nvar p: Person;\n\nbegin\n  p := new Person('\u0418\u0432\u0430\u043d\u043e\u0432',20);\n  p.Print;\nend."
  },
  {
    "instruction": "Create a Person class in PascalABC.NET with internal method implementation. The class should have private fields and public constructor and Print methods implemented directly in the class interface.",
    "output": "type \n  Person = class\n  private\n    name: string;\n    age: integer;\n  public\n    constructor (n: string; a: integer);\n    begin\n      name := n; age := a;\n    end;\n    procedure Print;\n    begin\n      writeln('\u0418\u043c\u044f: ',name,'  \u0412\u043e\u0437\u0440\u0430\u0441\u0442: ',age);\n    end;\n  end;\n\nvar p,p1: Person;\n\nbegin\n  p := new Person('\u0418\u0432\u0430\u043d\u043e\u0432',20);\n  p.Print;\n  p1 := Person.Create('\u041f\u043e\u043f\u043e\u0432',19);\n  p1.Print;\nend."
  },
  {
    "instruction": "Create a multiplication table test application in PascalABC.NET using GraphWPF. The program should generate random multiplication questions, track answers, and provide a grade after 10 questions.",
    "output": "uses GraphWPF,Controls,Sounds;\n\nvar x, y: integer;\n\nprocedure NextQuestion;\nbegin\n  Window.Clear;\n  (x, y) := Random2(2, 9);  \n  DrawText(GraphWindow.ClientRect,$'{x} \u00d7 {y} = ?');\nend;\n\nfunction \u041e\u0446\u0435\u043d\u043a\u0430(\u0412\u0435\u0440\u043d\u044b\u0445\u041e\u0442\u0432\u0435\u0442\u043e\u0432: integer): integer;\nbegin\n  case \u0412\u0435\u0440\u043d\u044b\u0445\u041e\u0442\u0432\u0435\u0442\u043e\u0432 of\n    10, 9: \u041e\u0446\u0435\u043d\u043a\u0430 := 5;\n    8, 7:  \u041e\u0446\u0435\u043d\u043a\u0430 := 4;\n    4..6:  \u041e\u0446\u0435\u043d\u043a\u0430 := 3;\n    else   \u041e\u0446\u0435\u043d\u043a\u0430 := 2;\n  end;  \nend;\n\nbegin\n  Window.Title := '\u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0442\u0430\u0431\u043b\u0438\u0446\u044b \u0443\u043c\u043d\u043e\u0436\u0435\u043d\u0438\u044f';\n  Font.Size := 40;\n  var l := LeftPanel(200);\n  l.FontSize := 16;\n  var sb := StatusBar;\n  NextQuestion;\n\n  var \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 := IntegerBox('\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043e\u0442\u0432\u0435\u0442:',0,100);\n  var b := Button('\u041e\u0442\u0432\u0435\u0442\u0438\u0442\u044c');\n  var \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e\u041e\u0442\u0432\u0435\u0442\u043e\u0432 := IntegerBlock('\u041e\u0442\u0432\u0435\u0442\u043e\u0432:');\n  var \u0412\u0435\u0440\u043d\u044b\u0445\u041e\u0442\u0432\u0435\u0442\u043e\u0432 := IntegerBlock('\u0412\u0435\u0440\u043d\u044b\u0445 \u043e\u0442\u0432\u0435\u0442\u043e\u0432:');\n  \n  b.Click := procedure \u2192 begin\n    if x * y = \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 then\n    begin\n      sb.Text := '\u0412\u0435\u0440\u043d\u043e!';\n      \u0412\u0435\u0440\u043d\u044b\u0445\u041e\u0442\u0432\u0435\u0442\u043e\u0432 += 1;\n    end  \n    else \n    begin\n      sb.Text := '\u041d\u0435\u0432\u0435\u0440\u043d\u043e :(';\n    end;  \n    \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e\u041e\u0442\u0432\u0435\u0442\u043e\u0432 += 1;\n    \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 := 0;\n    if \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e\u041e\u0442\u0432\u0435\u0442\u043e\u0432 = 10 then\n    begin\n      MessageBox.Show('\u0422\u0435\u0441\u0442 \u043e\u043a\u043e\u043d\u0447\u0435\u043d.'#10#10'\u0412\u0435\u0440\u043d\u044b\u0445 \u043e\u0442\u0432\u0435\u0442\u043e\u0432: ' + \n        \u0412\u0435\u0440\u043d\u044b\u0445\u041e\u0442\u0432\u0435\u0442\u043e\u0432.Value + #10#10 + '\u041e\u0446\u0435\u043d\u043a\u0430: ' + \u041e\u0446\u0435\u043d\u043a\u0430(\u0412\u0435\u0440\u043d\u044b\u0445\u041e\u0442\u0432\u0435\u0442\u043e\u0432));\n      \u0412\u0435\u0440\u043d\u044b\u0445\u041e\u0442\u0432\u0435\u0442\u043e\u0432 := 0;\n      \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e\u041e\u0442\u0432\u0435\u0442\u043e\u0432 := 0;\n    end;\n    NextQuestion;\n  end;\n  OnResize := procedure \u2192 begin\n    Window.Clear;\n    DrawText(GraphWindow.ClientRect,$'{x} \u00d7 {y} = ?');\n  end;\nend."
  },
  {
    "instruction": "Create an improved multiplication table test in PascalABC.NET using procedures for better code organization. Include separate procedures for test completion, drawing, and next question generation.",
    "output": "uses GraphWPF,Controls,Sounds;\n\nfunction \u041e\u0446\u0435\u043d\u043a\u0430(\u0412\u0435\u0440\u043d\u044b\u0445\u041e\u0442\u0432\u0435\u0442\u043e\u0432: integer): integer;\nbegin\n  case \u0412\u0435\u0440\u043d\u044b\u0445\u041e\u0442\u0432\u0435\u0442\u043e\u0432 of\n    10, 9: \u041e\u0446\u0435\u043d\u043a\u0430 := 5;\n    8, 7:  \u041e\u0446\u0435\u043d\u043a\u0430 := 4;\n    4..6:  \u041e\u0446\u0435\u043d\u043a\u0430 := 3;\n    else   \u041e\u0446\u0435\u043d\u043a\u0430 := 2;\n  end;  \nend;\n\nbegin\n  Window.Title := '\u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0442\u0430\u0431\u043b\u0438\u0446\u044b \u0443\u043c\u043d\u043e\u0436\u0435\u043d\u0438\u044f';\n  Font.Size := 60;\n  var l := LeftPanel(200);\n  l.FontSize := 16;\n  var sb := StatusBar;\n\n  var \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 := IntegerBox('\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043e\u0442\u0432\u0435\u0442:',0,100);\n  var b := Button('\u041e\u0442\u0432\u0435\u0442\u0438\u0442\u044c');\n  var \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e\u041e\u0442\u0432\u0435\u0442\u043e\u0432 := IntegerBlock('\u041e\u0442\u0432\u0435\u0442\u043e\u0432:');\n  var \u0412\u0435\u0440\u043d\u044b\u0445\u041e\u0442\u0432\u0435\u0442\u043e\u0432 := IntegerBlock('\u0412\u0435\u0440\u043d\u044b\u0445 \u043e\u0442\u0432\u0435\u0442\u043e\u0432:');\n  \n  var \u0422\u0435\u0441\u0442\u041e\u043a\u043e\u043d\u0447\u0435\u043d := procedure \u2192 begin\n    MessageBox.Show('\u0422\u0435\u0441\u0442 \u043e\u043a\u043e\u043d\u0447\u0435\u043d.'+#10#10+'\u0412\u0435\u0440\u043d\u044b\u0445 \u043e\u0442\u0432\u0435\u0442\u043e\u0432: ' + \n      \u0412\u0435\u0440\u043d\u044b\u0445\u041e\u0442\u0432\u0435\u0442\u043e\u0432.Value + #10#10 + '\u041e\u0446\u0435\u043d\u043a\u0430: ' + \u041e\u0446\u0435\u043d\u043a\u0430(\u0412\u0435\u0440\u043d\u044b\u0445\u041e\u0442\u0432\u0435\u0442\u043e\u0432));\n    \u0412\u0435\u0440\u043d\u044b\u0445\u041e\u0442\u0432\u0435\u0442\u043e\u0432 := 0;\n    \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e\u041e\u0442\u0432\u0435\u0442\u043e\u0432 := 0;\n  end;\n  \n  var x, y: integer;\n\n  var \u041d\u0430\u0440\u0438\u0441\u043e\u0432\u0430\u0442\u044c\u0422\u0435\u0441\u0442 := procedure \u2192 begin\n    Window.Clear;\n    DrawText(GraphWindow.ClientRect,$'{x} \u00d7 {y} = ?');\n  end;\n\n  var \u0421\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0439\u0412\u043e\u043f\u0440\u043e\u0441 := procedure \u2192 begin\n    (x, y) := Random2(2, 9);\n    \u041d\u0430\u0440\u0438\u0441\u043e\u0432\u0430\u0442\u044c\u0422\u0435\u0441\u0442;\n  end;\n  \u0421\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0439\u0412\u043e\u043f\u0440\u043e\u0441;\n  \n  b.Click := procedure \u2192 begin\n    if x * y = \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 then\n    begin\n      sb.Text := '\u0412\u0435\u0440\u043d\u043e!';\n      \u0412\u0435\u0440\u043d\u044b\u0445\u041e\u0442\u0432\u0435\u0442\u043e\u0432 += 1;\n    end  \n    else \n    begin\n      sb.Text := '\u041d\u0435\u0432\u0435\u0440\u043d\u043e :(';\n    end;  \n    \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e\u041e\u0442\u0432\u0435\u0442\u043e\u0432 += 1;\n    \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 := 0;\n    if \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e\u041e\u0442\u0432\u0435\u0442\u043e\u0432 = 10 then\n      \u0422\u0435\u0441\u0442\u041e\u043a\u043e\u043d\u0447\u0435\u043d;\n    \u0421\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0439\u0412\u043e\u043f\u0440\u043e\u0441;\n  end;\n  OnResize := \u041d\u0430\u0440\u0438\u0441\u043e\u0432\u0430\u0442\u044c\u0422\u0435\u0441\u0442;\nend."
  },
  {
    "instruction": "Create a network ping utility in PascalABC.NET that pings a server and displays its IP address and response time.",
    "output": "uses System.Net.NetworkInformation;\n\nconst address = 'www.yandex.ru';\n\nbegin\n  var p := new Ping();\n  try\n    var res := p.Send(address);\n    writeln('IP \u0430\u0434\u0440\u0435\u0441 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: ',res.Address);\n    writeln('\u0412\u0440\u0435\u043c\u044f \u043e\u0442\u043a\u043b\u0438\u043a\u0430: ',res.RoundtripTime,' \u043c\u0441');\n  except\n    on e: Exception do\n      write(e.Message);\n  end;    \nend."
  },
  {
    "instruction": "Create a 3D planet rotation animation in PascalABC.NET using Graph3D. Show two spheres rotating around each other with different rotation speeds.",
    "output": "uses Graph3D;\n\nbegin\n  Window.Title := '\u0412\u0440\u0430\u0449\u0435\u043d\u0438\u0435 \u043f\u043b\u0430\u043d\u0435\u0442';\n  View3D.ShowCoordinateSystem := False;\n  View3D.ShowGridLines := False;\n  View3D.ShowViewCube := False;\n  View3D.BackgroundColor := Colors.Black;\n\n  var s := Sphere(2,0,0,0.5,Colors.Red);\n  var ss := Sphere(0,0,0,1,Colors.Blue);\n  Sphere(0,0,0,2,DiffuseMaterial(Colors.Yellow)+SpecularMaterial(32));\n  var g := Group(s,ss);\n  g.MoveBy(-7,0,0);\n  var anim := s.AnimRotateAt(OrtZ,360*100,P3D(-2,0,0),2*100)\n    * g.AnimRotateAt(OrtZ,360*100,P3D(7,0,0),10*100)\n  ;\n   \n  anim.Begin;\nend."
  },
  {
    "instruction": "Create a solar system animation in PascalABC.NET with Earth, Moon, and Sun using texture maps and orbital trajectories.",
    "output": "uses Graph3D;\n\nbegin\n  Window.Title := '\u0412\u0440\u0430\u0449\u0435\u043d\u0438\u0435 \u043f\u043b\u0430\u043d\u0435\u0442';\n  View3D.HideAll;\n  View3D.BackgroundColor := Colors.Black;\n  \n  var s := Sphere(0,0,0,30);\n  s.BackMaterial := ImageMaterial('skymap.jpg');\n\n  var Sun := Sphere(0,0,0,2,ImageMaterial('sunmap.jpg'));\n  var Earth := Sphere(-7,0,0,1,ImageMaterial('earthmap.jpg'));\n  var Moon := Sphere(2,0,0,0.5,ImageMaterial('moonmap.jpg'));\n  Earth.AddChild(Moon);\n  \n  var tr := ParametricTrajectory(0,2*Pi,100,t->P3D(7*cos(t),7*sin(t),0));\n  Polyline3D(tr,1.2,GrayColor(70));\n  \n  Moon.AnimRotateAt(OrtZ,360,P3D(-2,0,0),2.sec).Forever.Begin;\n  Earth.AnimRotateAtAbsolute(OrtZ,360,Origin,20.sec).Forever.Begin;\n  Earth.AnimRotate(OrtZ,-360,5.sec).Forever.Begin;\n  Sun.AnimRotate(OrtZ,-360,20.sec).Forever.Begin;\nend."
  },
  {
    "instruction": "Create a frame-based planet rotation animation in PascalABC.NET using OnDrawFrame event for continuous animation.",
    "output": "uses Graph3D;\n\nbegin\n  Window.Title := '\u0412\u0440\u0430\u0449\u0435\u043d\u0438\u0435 \u043f\u043b\u0430\u043d\u0435\u0442';\n  View3D.HideAll;\n  \n  var s := Sphere(0,0,0,30);\n  s.BackMaterial := ImageMaterial('skymap.jpg');\n\n  var earth := Sphere(-7,0,0,1,ImageMaterial('earthmap.jpg'));\n  var moon := Sphere(2,0,0,0.5,ImageMaterial('moonmap.jpg'));\n  earth.AddChild(moon);\n  var Sun := Sphere(0,0,0,2,ImageMaterial('sunmap.jpg'));\n  Sun.AnimRotate(OrtZ,-360,20.sec).Forever.Begin;\n  \n  var tr := ParametricTrajectory(0,2*Pi,100,t->P3D(7*cos(t),7*sin(t),0));\n  Polyline3D(tr,1.2,GrayColor(80));\n  \n  var tr1 := ParametricTrajectory(0,2*Pi,100,t->P3D(2*cos(t),2*sin(t),0));\n  var pl1 := Polyline3D(tr1,1.2,GrayColor(80));\n  earth.AddChild(pl1);\n\n  OnDrawFrame := dt -> begin\n    moon.RotateAt(OrtZ,360*dt/3,P3D(-2,0,0));\n    earth.RotateAtAbsolute(OrtZ,360*dt/6,Origin);\n  end;\nend."
  },
  {
    "instruction": "Create a 3D visualization of Platonic solids in PascalABC.NET using Graph3D. Display icosahedron, dodecahedron, tetrahedron, and octahedron with optional circumscribed spheres.",
    "output": "uses Graph3D;\n\nbegin\n  var \u0420\u0438\u0441\u043e\u0432\u0430\u0442\u044c\u041e\u043f\u0438\u0441\u0430\u043d\u043d\u044b\u0435\u0421\u0444\u0435\u0440\u044b := True;\n  var p := P3D(6,0,0);\n  var p1 := p;\n  var h := -4;\n  Icosahedron(p,2,Colors.Green);\n  p.Offset(h,0,0);\n  Dodecahedron(p,2,Colors.Blue);\n  p.Offset(h,0,0);\n  Tetrahedron(p,2,Colors.Red);\n  p.Offset(h,0,0);\n  Octahedron(p,2,Colors.Magenta);\n  \n  p := p1;\n  if \u0420\u0438\u0441\u043e\u0432\u0430\u0442\u044c\u041e\u043f\u0438\u0441\u0430\u043d\u043d\u044b\u0435\u0421\u0444\u0435\u0440\u044b then\n    loop 4 do\n    begin\n      var s := Sphere(p,2.0,DiffuseMaterial(Colors.Gold.ChangeAlpha(64))+SpecularMaterial(64));\n      s.BackMaterial := nil;\n      p.Offset(h,0,0);\n    end;\nend."
  },
  {
    "instruction": "Create a complete Platonic solids visualization in PascalABC.NET including cube with all five solids and their circumscribed spheres.",
    "output": "uses Graph3D;\n\nbegin\n  Window.Title := '\u041f\u043b\u0430\u0442\u043e\u043d\u043e\u0432\u044b \u0442\u0435\u043b\u0430';\n  var \u0420\u0438\u0441\u043e\u0432\u0430\u0442\u044c\u041e\u043f\u0438\u0441\u0430\u043d\u043d\u044b\u0435\u0421\u0444\u0435\u0440\u044b := True;\n  var p := P3D(8,0,0);\n  var p1 := p;\n  var h := -4;\n  Icosahedron(p,2,Colors.Green);\n  p.Offset(h,0,0);\n  Dodecahedron(p,2,Colors.Blue);\n  p.Offset(h,0,0);\n  Tetrahedron(p,2,Colors.Red);\n  p.Offset(h,0,0);\n  Octahedron(p,2,Colors.Magenta);\n  p.Offset(h,0,0);\n  Cube(p,2*2/Sqrt(3),Colors.Brown);\n  \n  p := p1;\n  if \u0420\u0438\u0441\u043e\u0432\u0430\u0442\u044c\u041e\u043f\u0438\u0441\u0430\u043d\u043d\u044b\u0435\u0421\u0444\u0435\u0440\u044b then\n    loop 5 do\n    begin\n      var s := Sphere(p,2.0,DiffuseMaterial(Colors.Gold.ChangeAlpha(64))+SpecularMaterial(64));\n      s.BackMaterial := nil;\n      p.Offset(h,0,0);\n    end;\nend."
  },
  {
    "instruction": "Create various types of graphs in PascalABC.NET using PlotWPF including line graphs, marker graphs, and grid layouts.",
    "output": "uses PlotWPF;\n\nbegin\n  var g := new GridWPF(2,2,10);\n\n  var c := new LineGraphWPF(0,Pi,v -> v*Sin(v*10));\n  c.PlotRect := Rect(0,0,10,10);\n  c.Graph[0].ChangeData(0,Pi,x->x*x);\n  c.Graph[0].Color := Colors.Green;\n  c.Graph[0].Thickness := 3;\n  c.AddLineGraph(0,Pi,v -> Sqrt(v));\n  \n  var c2 := new LineGraphWPF(0,Pi,v -> Sin(v*10)-Cos(v*7));\n  \n  var c4 := new MarkerGraphWPF(|1.0,2,3,4,5|,|5.0,15,7,12,2|);\n  c4.AddLineGraph(|1.0,2,3,4,5|,|5.0+1,15+1,7+1,12+1,2+1|);\n  c4.AddMarkerGraph(|1.0,2,3,4,5|,|5.0+1,15+1,7+1,12+1,2+1|,Colors.Bisque,MarkerType.Diamond,8);\n  c4.Graph[0].Thickness := 0.7;\n  c4.Graph[1].MarkerType := MarkerType.Box;\n  c4.Graph[2].Thickness := 0.7;\n\n  var gg := new GridWPF(2,2,3);\n  new LineGraphWPF(0,2,x->Cos(10*x));\n  new LineGraphWPF(0,2,x->Sqrt(x));\n  new LineGraphWPF(0,2,x->Sin(10*x));\n  new LineGraphWPF(0,2,x->exp(x));\nend."
  },
  {
    "instruction": "Demonstrate typed pointers in PascalABC.NET by creating integer pointers and manipulating values through pointer dereferencing.",
    "output": "var\n  i: integer := 5;\n  j: integer := 3;\n  p: ^integer;\n  \nbegin\n  writeln('\u0418\u0441\u0445\u043e\u0434\u043d\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445 i \u0438 j: ',i,' ',j);\n  p := @i;\n  writeln('\u041f\u043e \u0430\u0434\u0440\u0435\u0441\u0443 ',p,' \u043d\u0430\u0445\u043e\u0434\u0438\u0442\u0441\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 ',p^);\n  p^ := 2;\n  p := @j;\n  writeln('\u041f\u043e \u0430\u0434\u0440\u0435\u0441\u0443 ',p,' \u043d\u0430\u0445\u043e\u0434\u0438\u0442\u0441\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 ',p^);\n  p^ += 1;\n  writeln('\u041d\u043e\u0432\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445 i \u0438 j: ',i,' ',j);\nend."
  },
  {
    "instruction": "Explain pointer restrictions in PascalABC.NET regarding reference types and exceptions for strings and dynamic arrays",
    "output": "// Pointers to reference types are prohibited. Exception: pointers to strings and dynamic arrays\ntype\n  A = class\n    i: integer;\n  end;\n\nbegin\n  var p: ^record field: A; end; // error \nend."
  },
  {
    "instruction": "Demonstrate untyped pointers in PascalABC.NET with type casting to manipulate different data types through the same pointer variable.",
    "output": "var\n  i: integer := 5;\n  r: real := 3.14;\n  p: pointer;\n  \ntype \n  pinteger = ^integer;\n  preal = ^real;\n  \nbegin\n  writeln('\u0418\u0441\u0445\u043e\u0434\u043d\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445 i \u0438 r: ');\n  writeln(i,' ',r);\n  p := @i; \n  pinteger(p)^ := 8;\n  p := @r;\n  preal(p)^ += 1;\n  writeln('\u041d\u043e\u0432\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445 i \u0438 r: ');\n  writeln(i,' ',r);\nend."
  },
  {
    "instruction": "Demonstrate dynamic memory allocation in PascalABC.NET using New and Dispose procedures for pointer management.",
    "output": "var p: ^real;\n  \nbegin\n  New(p);\n  p^ := 3;\n  writeln('\u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0432 \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u0435\u0441\u0441\u043a\u043e\u0439 \u043f\u0430\u043c\u044f\u0442\u0438 = ',p^);\n  Dispose(p);\nend."
  },
  {
    "instruction": "Compare two approaches for creating linked lists in PascalABC.NET: using references (recommended) vs using pointers",
    "output": "// Using references instead of pointers for creating singly linked list\n// We recommend this approach\ntype \n  Node = class\n    data: integer;\n    next: Node;\n    constructor (d: integer; n: Node);\n    begin\n      data := d;\n      next := n;\n    end;\n  end;\n  \nbegin\n  // Variable of type \"class\" represents a reference to object allocated by constructor\n  var first: Node := nil;\n  // Add to beginning of singly linked list\n  first := new Node(3,first);\n  first := new Node(7,first);\n  first := new Node(5,first);\n  \n  // Output singly linked list. ^ are absent\n  Println('Contents of singly linked list (using references instead of pointers):');\n  var p := first;\n  while p<>nil do\n  begin\n    Print(p.data);\n    p := p.next;\n  end;\n  \n  // Destruction of singly linked list\n  first := nil; // Garbage collector will collect memory that no one points to anymore\nend.\n\n// Dynamic memory allocation\n// Using pointers for creating singly linked list\ntype \n  PNode = ^TNode;\n  TNode = record\n    data: integer;\n    next: PNode;\n  end;\n\nfunction NewNode(d: integer; n: PNode): PNode;\nbegin\n  New(Result);\n  Result^.data := d;\n  Result^.next := n;\nend;\n\nbegin\n  var first: PNode := nil;\n  \n  // Add to beginning of singly linked list\n  first := NewNode(3,first);\n  first := NewNode(7,first);\n  first := NewNode(5,first);\n  \n  // Output singly linked list\n  Println('Contents of singly linked list:');\n  var p := first;\n  while p<>nil do\n  begin\n    Print(p^.data);\n    p := p^.next;\n  end;\n  \n  // Destruction of singly linked list\n  p := first;\n  while p<>nil do\n  begin\n    var p1 := p;\n    p := p^.next;\n    Dispose(p1); // Memory must be returned\n  end;\nend."
  },
  {
    "instruction": "Demonstrate permutations, combinations, and Cartesian products in PascalABC.NET using both arrays and sequences.",
    "output": "var a := Arr(1,3,5,7);\na.Permutations.Println;\na.Cartesian(2).Println;\na.Permutations(2).Println;\na.Combinations(2).Println;\nPrintln;\nvar s := Seq(1,3,5,7);\ns.Permutations.Println;\ns.Cartesian(2).Println;\ns.Permutations(2).Println;\ns.Combinations(2).Println;"
  },
  {
    "instruction": "Create a recursive permutation algorithm in PascalABC.NET that generates all permutations of numbers from 1 to n.",
    "output": "const n = 4;\n\nprocedure Perm(a: array of integer; m: integer);\nbegin\n  if m=1 then\n    a.Println;\n  for var i:=0 to m-1 do\n  begin\n    Swap(a[i],a[m-1]);\n    Perm(a,m-1);\n    Swap(a[i],a[m-1]);\n  end;  \nend;\n\nbegin\n  var a := Range(1,n).ToArray;\n  Perm(a,n);\nend."
  },
  {
    "instruction": "Create a procedural variable example in PascalABC.NET that demonstrates assigning different functions to the same procedural variable and calling them.",
    "output": "function add(a,b: integer): integer;\nbegin\n  Result := a + b;\nend;\n\nfunction mult(a,b: integer): integer;\nbegin\n  Result := a * b;\nend;\n\nvar p: function (a,b: integer): integer;\n  \nbegin\n  p := add;\n  writeln('\u0421\u0443\u043c\u043c\u0430 2 \u0438 3 \u0440\u0430\u0432\u043d\u0430 ',p(2,3));\n  p := mult;\n  writeln('\u041f\u0440\u043e\u0438\u0437\u0432\u0435\u0434\u0435\u043d\u0438\u0435 2 \u0438 3 \u0440\u0430\u0432\u043d\u043e ',p(2,3));\nend."
  },
  {
    "instruction": "Create a procedure in PascalABC.NET that takes a procedural variable as a parameter to apply operations to array elements. Include examples of multiplication and printing procedures.",
    "output": "procedure for_each(a: array of real; p: procedure(var r: real));\nbegin\n  for var i := 0 to a.Length-1 do\n    p(a[i]);\nend;\n\nprocedure mult2(var r: real);\nbegin\n  r := 2*r\nend;\n\nprocedure print(var r: real);\nbegin\n  write(r,' ');\nend;\n\nvar a: array of real := (1,2,3,6,7);\n\nbegin\n  writeln('\u0421\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 \u043c\u0430\u0441\u0441\u0438\u0432\u0430: ');\n  for_each(a,print); \n  writeln;\n  for_each(a,mult2);\n  writeln('\u0421\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u043f\u043e\u0441\u043b\u0435 \u0443\u043c\u043d\u043e\u0436\u0435\u043d\u0438\u044f \u0435\u0433\u043e \u044d\u043b\u0435\u043c\u0435\u0442\u043e\u0432 \u043d\u0430 2: ');\n  for_each(a,print);\nend."
  },
  {
    "instruction": "Create a simplified version of procedural variable usage in PascalABC.NET with lambda-style procedure definitions for array operations.",
    "output": "procedure for_each(a: array of real; p: procedure(var r: real));\nbegin\n  for var i := 0 to a.Length-1 do\n    p(a[i]);\nend;\n\nprocedure mult2(var r: real) := r := 2*r;\n\nprocedure print(var r: real) := write(r,' ');\n\nvar a: array of real := (1,2,3,6,7);\n\nbegin\n  for_each(a,print); writeln;\n  for_each(a,mult2);\n  for_each(a,print);\nend."
  },
  {
    "instruction": "Show all possible ways to initialize procedural variables in PascalABC.NET using delegates with += and -= operations",
    "output": "// All possible ways to initialize procedural variable\n// Procedural type is implemented through .NET delegates, +=, -= operations are available for it\n\nprocedure pp;\nbegin\n  Println('Call of regular procedure');\nend;\n\ntype \n  A = class\n  private\n    x: integer;\n  public  \n    constructor Create(xx: integer);\n    begin\n      x := xx;\n    end;\n    procedure pp;\n    begin\n      Println('Call of class method, field value equals',x);\n    end;\n    class procedure ppstatic; \n    begin\n      Println('Call of class static method');\n    end;\n  end;\n\nbegin\n  var p: procedure;\n\n  p := pp;\n  var a1: A := new A(5);\n  p += a1.pp;\n  p += A.ppstatic;\n  p;\n  Println;\n  p -= pp;\n  p;\nend."
  },
  {
    "instruction": "Create a 3D point light visualization in PascalABC.NET using Graph3D. Include a sphere as light source, cylinder, and textured ground plane with point lighting.",
    "output": "uses Graph3D;\n\nbegin\n  var p := P3D(-3,3,3);\n  Sphere(p,0.3,Colors.White);\n  View3D.ShowGridLines := false;\n  Cylinder(0,0,0,5,2,True,Colors.Yellow);\n  Rectangle3D(0,0,-0.01,15,15,OrtZ,OrtX,ImageMaterial('\u0442\u0440\u0430\u0432\u0430.jpg',0.2,0.2));\n  Sleep(2000);\n  Lights.AddPointLight(GrayColor(64),p);\nend."
  },
  {
    "instruction": "Create a polynomial root finding example in PascalABC.NET using NumLibABC to find all roots of a polynomial with real coefficients.",
    "output": "uses NumLibABC;\n\nbegin\n  var p:=new Polynom(-609, -283 ,294, -38, -5,1);\n  var oL:=new PolRt(p);\n  if oL.ier=0 then oL.Value.Println\n  else Writeln('\u041e\u0448\u0438\u0431\u043a\u0430: ier=',oL.ier);\nend."
  },
  {
    "instruction": "Create polynomial operations examples in PascalABC.NET including polynomial evaluation, integration, and differentiation using NumLibABC.",
    "output": "uses NumLibABC;\n\nbegin\n   var u:=(new Polynom(2, -6, 0, 3.8, 0, 1)).Value(-7.16);\n   Println(u);\n   \n   var t:=new Polynom(1, -7, 12, -3, -2);\n   var (p,q):=(t.PInt, t.PDif);\n   p.PrintlnBeauty; q.PrintlnBeauty;\nend."
  },
  {
    "instruction": "Create polynomial arithmetic examples in PascalABC.NET including addition, subtraction, multiplication, and polynomial division with quotient and remainder.",
    "output": "uses NumLibABC;\n\nbegin\n  var a:=new Polynom(6.5,-4,2.12,1);\n  var b:=new Polynom(3,0,-3.8);\n  var c:=new Polynom(ArrGen(5,i->i*i+1.0));\n      (-c +(a-2*b)*a+11.5*(1-b)).Println;\n  \n  a:=new Polynom(3,0,-72,12,0,-1,2);\n  b:=new Polynom(-1,0,2,1);\n  var (p,q):=a/b;\n  Print('\u0427\u0430\u0441\u0442\u043d\u043e\u0435'); p.PrintlnBeauty;\n  Print('\u043e\u0441\u0442\u0430\u0442\u043e\u043a'); b.PrintlnBeauty\nend."
  },
  {
    "instruction": "Create an interactive 3D teapot in PascalABC.NET that can be moved using arrow keys for navigation in 3D space.",
    "output": "uses Graph3D;\n\nbegin\n  View3D.Title := '\u0414\u0432\u0438\u0433\u0430\u0439\u0442\u0435 \u0447\u0430\u0439\u043d\u0438\u043a \u043f\u0440\u0438 \u043f\u043e\u043c\u043e\u0449\u0438 \u0441\u0442\u0440\u0435\u043b\u043e\u043a';\n  var t := Teapot(0, 0, 1, Colors.Green);\n  OnKeyDown := k -> begin\n    case k of\n   Key.Left: t.X += 1; \n   Key.Right: t.X -= 1; \n   Key.Down: t.Y += 1; \n   Key.Up: t.Y -= 1; \n   Key.PageUp: t.Z += 1; \n   Key.PageDown: t.Z -= 1; \n    end;\n  end;\nend."
  },
  {
    "instruction": "Create a 3D coordinate system visualization in PascalABC.NET with three colored planes (XY, XZ, YZ) and coordinate axes with labels.",
    "output": "uses Graph3D;\n\nbegin\n  View3D.ShowGridLines := False;\n  \n  Camera.Position := P3D(12,16,24);\n  Camera.LookDirection := Camera.Position.Multiply(-1).ToVector3D;\n\n  var sz := 12;\n  var alpha := 100;\n  var planeXZ := Rectangle3D(0,0,0,sz,sz,V3D(0,1,0),Colors.Green.ChangeAlpha(alpha));\n  var planeXY := Rectangle3D(0,0,0,sz,sz,V3D(0,0,1),Colors.Blue.ChangeAlpha(alpha));\n  var planeYZ := Rectangle3D(0,0,0,sz,sz,V3D(1,0,0),V3D(0,1,0),Colors.Red.ChangeAlpha(alpha));\n  BillboardText(sz/2,sz/2,0,'XY',20);\n  BillboardText(0,sz/2,sz/2,'YZ',20);\n  BillboardText(sz/2,0,sz/2,'XZ',20);\n  var len := 8;\n  CoordinateSystem(len,0.3);\n  BillboardText(len+0.5,0,0,'X',20);\n  BillboardText(0,len+0.5,0,'Y',20);\n  BillboardText(0,0,len+0.5,'Z',20);\nend."
  },
  {
    "instruction": "Create a camera rotation animation in PascalABC.NET that orbits around a teapot object with continuous circular camera movement.",
    "output": "uses Graph3D;\n\nbegin\n  Window.Title := '\u0412\u0440\u0430\u0449\u0435\u043d\u0438\u0435 \u043a\u0430\u043c\u0435\u0440\u044b';\n  var tp := Teapot(0,0,2,Colors.Green);\n  tp.Scale(2);\n  Camera.Position := P3D(8,16,20);\n  Camera.LookDirection := Camera.Position.Multiply(-1).ToVector3D;\n  var d := 26.0;\n  var t := 0.0;\n  while True do\n  begin\n    Sleep(10);\n    Camera.Position := P3D(15*cos(t),15*sin(t),10);\n    Camera.UpDirection := V3D(0,0,1);\n    Camera.LookDirection := Camera.Position.Multiply(-1).ToVector3D;\n    t += 2*Pi/360/2;\n  end;\n  \n  Camera.LookDirection := Camera.Position.Multiply(-1).ToVector3D;\nend."
  },
  {
    "instruction": "Create a prime number generator in PascalABC.NET that finds and prints large prime numbers starting from a random number.",
    "output": "begin\n  Println('\u0411\u043e\u043b\u044c\u0448\u0438\u0435 \u043f\u0440\u043e\u0441\u0442\u044b\u0435 \u0447\u0438\u0441\u043b\u0430: ');\n  var count := 0;\n  var beg := Random(1000000000)+2;\n  for var i:=beg to beg+5000 do\n  begin\n    var f := True;\n    var j := 2;\n    var r := Round(Sqrt(i));\n    while f and (j<=r) do\n      if i mod j = 0 then f := False\n        else j += 1;\n    if f then\n    begin\n      Print(i);\n      count += 1;\n      if count mod 8 = 0 then \n        Println;\n    end;\n  end;\nend."
  },
  {
    "instruction": "Show how to use Print procedure for output with space-separated data in PascalABC.NET",
    "output": "/// Output using Print - data is separated by spaces\nbegin\n  Print(1,2,3)\nend."
  },
  {
    "instruction": "Create a 3D group animation in PascalABC.NET where a box and sphere rotate together around a fixed point using Group object.",
    "output": "uses Graph3D;\n\nbegin\n  var b := Box(0,0,0,6,1,2,Colors.Blue);\n  var s := Sphere(0,0,2,1,Colors.Green);\n\n  var g := Group(b,s);\n  g.AnimRotateAt(OrtZ,360,P3D(3,0,0),2).Begin;\nend."
  },
  {
    "instruction": "Create a 3D group animation with multiple objects in PascalABC.NET where an array of boxes rotates together as a group.",
    "output": "uses Graph3D;\n\nbegin\n  var bb := ArrGen(15,i -> Object3D(Box(0.5*i,0,0,0.1,6,2,RandomColor)));\n  var g := Group(bb).MoveByX(-5);\n  g.AnimRotateAt(ortZ,360,P3D(-1,0,0),2).Forever.Begin;  \nend."
  },
  {
    "instruction": "Create a procedure in PascalABC.NET that demonstrates all basic arithmetic operations on two integer parameters.",
    "output": "procedure Operations(a,b: integer);\nbegin\n  writeln(a,' + ',b,' = ',a+b);\n  writeln(a,' - ',b,' = ',a-b);\n  writeln(a,' * ',b,' = ',a*b);\n  writeln(a,' / ',b,' = ',a/b);\n  writeln(a,' div ',b,' = ',a div b);\n  writeln(a,' mod ',b,' = ',a mod b);\nend;\n\nbegin\n  Operations(5,3);\n  writeln;\n  Operations(7,4);\nend."
  },
  {
    "instruction": "Create a procedure in PascalABC.NET that uses var parameters to return both division quotient and modulus results from a single operation.",
    "output": "procedure DivMod(a,b: integer; var d,m: integer);\nbegin\n  d := a div b;\n  m := a mod b;\nend;\n\nvar \n  a,b: integer;\n  d,m: integer;\n\nbegin\n  a := 7;\n  b := 3;\n  DivMod(a,b,d,m);\n  writelnFormat('{0} div {1} = {2};  {0} mod {1} = {3}',a,b,d,m);\n  a := 23;\n  b := 5;\n  DivMod(a,b,d,m);\n  writelnFormat('{0} div {1} = {2};  {0} mod {1} = {3}',a,b,d,m);\nend."
  },
  {
    "instruction": "Create a record type and procedure in PascalABC.NET that demonstrates parameter packing using records for drawing lines between points.",
    "output": "uses GraphABC;\n\ntype \n  Point = record\n    x,y: integer;\n    constructor (xx,yy: integer);\n    begin\n      x := xx;\n      y := yy;\n    end;\n  end;\n\nprocedure Line(p1,p2: Point);\nbegin\n  GraphABC.Line(p1.x,p1.y,p2.x,p2.y);\nend;\n\nbegin\n  var p1 := new Point(10,10);\n  var p2 := new Point(10,210);\n  var p3 := new Point(210,10);\n  Line(p1,p2);\n  Line(p2,p3);\n  Line(p3,p1);\nend."
  },
  {
    "instruction": "Explain how to use automatic variable type inference and variable declaration in a for loop header in PascalABC.NET",
    "output": "// Automatic variable type inference\n// Variable declaration in for loop header\nbegin\n  var x := 2;\n  for var i:=1 to 10 do\n  begin\n    Print(x);\n    x += 2;\n  end;  \nend."
  },
  {
    "instruction": "Implement complex fish ecosystem simulation with predator-prey behavior using GraphABC in PascalABC.NET",
    "output": "uses GraphABC;\n \nconst types = 3;\n      rmax = 4;\n      CanEat = rmax;\n      eps = 0.00001;\n      epsustupi = 0.1;\n      strahkraj = 3;\n      ustupi = CanEat*10;\n      BkColor = clBlack;\n      Height = 600;\n      Width = 780;\n      xmin = 10;\n      ymin = 10;\n      xmax = Width - 100;\n      ymax = Height - 140;\n\nType\nfishtype = class\n           c : color;\n           public\n    CanRazm, MaxKol, Kol, MaxLife, MinFood: integer;\n           Speed, See: real;\n           constructor create(ac:color; aCanRazm, aMaxKol, aMaxLife, aMinFood:integer; aSpeed, aSee: real);\n             begin\n             c:= ac; CanRazm:= aCanRazm; MaxKol:= aMaxKol; Kol:= 1;\n             MaxLife:= aMaxLife; MinFood:= aMinFood; Speed:= aSpeed; See:= aSee\n             end;\n           procedure ShowKol(y: integer);\n             var s: string;\n             begin\n             SetFontColor(c);\n             TextOut(xmax + 20, y, '      ');\n             s := IntToStr(kol);\n             TextOut(xmax + 20, y, s);\n             end;\n           end;\n\nvar opisanie: array[0..types] of fishtype;\n\nType\nfish = class\n       x, y, r, dx0, dy0: real;\n       tip, life, razm, status, food: integer;\n       next, prev: fish;\n       constructor Create(ax, ay, ar: real; atip: integer; aprev, anext: fish);\n         begin\n         x:= ax; y:= ay; r:= ar; tip:= atip; prev:= aprev; next:= anext;\n         life:= 0; razm:= 0; dx0:= random; dy0:= random; status:= 1; food:= 0;\n         end;\n       procedure show;\n         begin\n         SetPenColor(opisanie[tip].c);\n         circle(round(x), round(y), round(r))\n         end;\n       procedure hide;\n         begin\n         SetPenColor(BkColor);\n         circle(round(x), round(y), round(r))\n         end;\n       procedure Destroy;\n         begin\n         hide;\n         opisanie[tip].kol:= opisanie[tip].kol - 1;\n         opisanie[tip].ShowKol(tip*40 + 20);\n         end;\n       procedure moveto(dx, dy: real);\n         begin\n         hide;\n         x:= x + dx; y:= y + dy;\n         if x > xmax then x:= xmax;\n         if x < xmin then x:= xmin;\n         if y > ymax then y:= ymax;\n         if y < ymin then y:= ymin;\n         show\n         end;\n\n       procedure MakeDeti(var mama, StartAkula, KonAkula, StartKilka, KonKilka : fish);\n         var d: fish;\n         begin\n         razm:= 0;\n         food:= 0;\n         d:= fish.create(x, y, r, tip, mama, next);\n         next.prev:= d;\n         next:= d;\n         if mama = KonAkula then KonAkula:= d;\n         if mama = KonKilka then KonKilka:= d;\n         opisanie[tip].kol:= opisanie[tip].kol + 1;\n         opisanie[tip].ShowKol(tip*40 + 20);\n         end;\n\n       procedure step(var ribka, StartAkula, KonAkula, StartKilka, KonKilka : fish);\n         var \n             dx, dy, d, dx2, dy2, dmin: real;\n             t, trup, found: fish;\n             FoundOhot: boolean;\n         begin\n         status:= 1;\n         dx:= 0; dy:= 0;\n         if tip > 0 then\n           begin\n           t:= StartAkula;\n           if t<>nil then\n             repeat\n             d:= sqrt((x - t.x)*(x - t.x) + (y - t.y)*(y - t.y));\n             if d < opisanie[tip].See then\n               begin\n               if d < eps then d:= eps;\n               dx2:= (x - t.x)/(d*d);\n               dy2:= (y - t.y)/(d*d);\n               dx:= dx + dx2;\n               dy:= dy + dy2;\n               status:= 2;\n               end;\n             t:= t.next\n             until t = KonAkula.next;\n           if x - xmin < opisanie[tip].See then dx:= dx + 1/((x - xmin + eps)*strahkraj);\n           if xmax - x < opisanie[tip].See then dx:= dx + 1/((x - xmax - eps)*strahkraj);\n           if y - ymin < opisanie[tip].See then dy:= dy + 1/((y - ymin + eps)*strahkraj);\n           if ymax - y < opisanie[tip].See then dy:= dy + 1/((y - ymax - eps)*strahkraj);\n           d:= sqrt(dx*dx + dy*dy);\n           if d < eps then\n             begin\n             dx:= 2*status*random()*opisanie[tip].Speed - status*opisanie[tip].Speed;\n             dy:= 2*status*random()*opisanie[tip].Speed - status*opisanie[tip].Speed\n             end\n                      else\n             begin\n             dx:= status*opisanie[tip].Speed*dx/d;\n             dy:= status*opisanie[tip].Speed*dy/d\n             end\n           end\n                     else\n           begin\n           dmin:= 11000;\n           t:= StartAkula;\n           while t<>ribka do\n             begin\n             d:= sqrt((x - t.x)*(x - t.x) + (y - t.y)*(y - t.y));\n             if (d < dmin) and (abs(dx0 - t.dx0) < epsustupi) and\n                (abs(dy0 - t.dy0) < epsustupi) then dmin:= d;\n             t:= t.next\n             end;\n           FoundOhot:= dmin < ustupi;\n           dmin:= 11000;\n           found:= nil;\n           t:= StartKilka;\n           if (t<>nil) and (life > 100) and not FoundOhot then\n             repeat\n             d:= sqrt((x - t.x)*(x - t.x) + (y - t.y)*(y - t.y));\n             if d < dmin then\n               begin\n               dmin:= d;\n               found:= t\n               end;\n             t:= t.next\n             until t = KonKilka.next;\n           if (found <> nil) and (dmin < opisanie[tip].See) then\n             begin\n             status:= 2;\n             dx:= found.x - x;\n             dy:= found.y - y;\n             if dmin < CanEat + status*opisanie[tip].Speed then\n               begin\n               found.next.prev:= found.prev;\n               found.prev.next:= found.next;\n               if found = StartKilka then\n                 StartKilka:= StartKilka.next;\n               if found = KonKilka then\n                 KonKilka:= KonKilka.prev;\n               found.destroy;\n        found := nil;\n               food:= food + 1\n               end\n             end\n                           else\n             if (x <= xmin) or (x >= xmax) or (y <= ymin) or (y >= ymax) then\n               begin\n               dx:= 2*status*random()*opisanie[tip].Speed - status*opisanie[tip].Speed;\n               dy:= 2*status*random()*opisanie[tip].Speed - status*opisanie[tip].Speed\n               end\n                                                                         else\n               begin\n               dx:= dx0; dy:= dy0\n               end;\n           d:= sqrt(dx*dx + dy*dy);\n           if d > eps then\n             begin\n             dx:= status*opisanie[tip].Speed*dx/d;\n             dy:= status*opisanie[tip].Speed*dy/d;\n             end\n           end;\n         moveto(dx, dy);\n         dx0:= dx; dy0:= dy;\n         life:= life + 1; razm:= razm + 1;\n         if opisanie[tip].Kol >= opisanie[tip].MaxKol then Razm:= 0;\n         if (razm > opisanie[tip].CanRazm) and (food >= opisanie[tip].minfood) then\n           MakeDeti(ribka, StartAkula, KonAkula, StartKilka, KonKilka);\n           if life > opisanie[tip].MaxLife then\n             begin\n             trup:= ribka; ribka:= ribka.prev;\n             trup.next.prev:= trup.prev;\n             trup.prev.next:= trup.next;\n             if trup = StartKilka then\n               StartKilka:= StartKilka.next;\n             if trup = KonKilka then\n               KonKilka:= KonKilka.prev;\n             if trup = StartAkula then\n               StartAkula:= StartAkula.next;\n             if trup = KonAkula then\n               KonAkula:= KonAkula.prev;\n             if trup = trup.next then ribka:= nil;\n             if trup <> nil then \n             trup.destroy;\n        trup := nil;\n             end\n         end;\n       end;\n\nfunction getAllCount:integer;\nvar i,c:integer;\nbegin\n  c:=0;\n  for i:=0 to types do\n    c:=c+opisanie[i].Kol;\n  getAllCount:=c;\nend;\n\nvar i: integer;\n    p, q, StartAkula, StartKilka, KonAkula, KonKilka, tek: fish;\n\nbegin\n  SetSmoothing(False);\n  SetWindowSize(Width, Height);\n  SetWindowLeft(200);\n  SetWindowTop(50);\n  SetWindowCaption('Battle for Life');\n  SetFontSize(7);\n  SetFontName('Arial');\n  SetBrushColor(BkColor);\n  FillRectangle(0, 0, Width, Height);\n  SetFontColor(clWhite);\n  TextOut(10, ymax + 20, 'Author: Ivanov S.O.          e-mail: ssyy@yandex.ru');\n  TextOut(10, ymax + 20+1*18, 'Program simulates behavior of several fish schools. Right - current fish counts');\n  TextOut(10, ymax + 20+2*18, 'By changing parameters in code, you can influence battle outcome.');\n  TextOut(10, ymax + 20+3*18, 'Default: red - predators, eat any fish from other schools, do not breed');\n  TextOut(10, ymax + 20+4*18, 'until they eat; blue - prey, slowest but breed fastest; green - prey');\n  TextOut(10, ymax + 20+5*18, 'faster than blue but breed slower; yellow - fastest among prey but few.');\n  SetFontSize(12);\n  StartAkula:= nil;\n  StartKilka:= nil;\n  KonAkula:= nil;\n  KonKilka:= nil;\n  \n  opisanie[3]:= fishtype.create(clYellow, 300,     15,     1500,    -1,      0.99,    50);\n  opisanie[2]:= fishtype.create(clGreen,  150,     50,     1500,    -1,      0.9,     50);\n  opisanie[1]:= fishtype.create(clBlue,   30,      50,     500,     -1,      0.7,     35);\n  opisanie[0]:= fishtype.create(clRed,    1000,    40,     5000,     1,       1,     500);\n  SetPenColor(clWhite);\n  rectangle(round(xmin - rmax - 1), round(ymin - rmax - 1),\n            round(xmax + rmax + 1), round(ymax + rmax + 1));\n  q:= fish.create(xmin + 10, ymax - 10, rmax, 0, nil, nil);\n  p:= fish.create(xmin + 10, ymin + 10, rmax, 1, q, q);\n  q.next:= p; q.prev:= p;\n  StartAkula:= q; KonAkula:= q;\n  StartKilka:= p; KonKilka:= p;\n  p:= fish.create(xmax - 10, ymin + 10, rmax, 2, KonKilka, StartAkula);\n  StartAkula.prev:= p;\n  KonKilka.next:= p; KonKilka:= p;\n  p:= fish.create(xmax - 10, ymax - 10, rmax, 3, KonKilka, StartAkula);\n  StartAkula.prev:= p;\n  KonKilka.next:= p; KonKilka:= p;\n  for i:= 0 to types do opisanie[i].ShowKol(i*40 + 20);\n  tek:= StartKilka;\n  repeat\n   tek:= tek.next;\n   tek.step(tek, StartAkula, KonAkula, StartKilka, KonKilka);\n  until (tek = nil);\nend."
  },
  {
    "instruction": "Implement performance benchmarking using Utils module in PascalABC.NET",
    "output": "uses Utils;\n\nprocedure Test1;\nbegin\n  var n := 1000000;\n  var s := 0.0;\n  for var i:=1 to n do\n    s += Sin(i);\nend;\n\nbegin\n  Benchmark(Test1).Println;\n\n  var n := 100000000;\n  var Sq := ArrRandomInteger(n,0,MaxInt-1);\n  Benchmark(()->\n  begin\n    var Min := Sq.Min;\n  end,1).Println;\nend."
  },
  {
    "instruction": "Demonstrate BigInteger literals and calculations in PascalABC.NET",
    "output": "begin\n  Println(25bi ** 25 + 17bi ** 17);\n  \n  var p := 1bi;\n  for var i:=2 to 50 do\n    p *= i;\n  Println($'50! = {p}');  \nend."
  },
  {
    "instruction": "Calculate factorial of 100 using BigInteger in PascalABC.NET",
    "output": "begin\n  var n := 100;\n  var f: BigInteger := 1;\n  for var i:=2 to n do\n    f := f * i;\n  Print($'{n}! = {f}');\nend."
  },
  {
    "instruction": "Use Sum, Average and Product methods with BigInteger sequences in PascalABC.NET",
    "output": "begin\n  var s := SeqGen(10,i->BigInteger(i)**i);\n  Print(s.Sum,s.Product,s.Average);\nend."
  },
  {
    "instruction": "Implement ball reflection simulation in console mode using CRT module in PascalABC.NET",
    "output": "uses CRT;\n\nconst \n  w = 80; \n  h = 24;\n\nvar\n  ax,ay: integer;\n  vx,vy: integer;\n  a: array [1..w,1..h] of char;\n\nprocedure CleanA;\nbegin\n  for var j := 1 to h do\n  for var i := 1 to w do\n    A[i,j] := ' '\nend;\n\nprocedure HorizWall(x,y,L: integer);\nbegin\n  for var i := x to x+L-1 do\n    A[i,y] := '*'\nend;\n\nprocedure VertWall(x,y,L: integer);\nbegin\n  for var j := y to y+L-1 do\n    A[x,j] := '*'\nend;\n\nprocedure Fill;\nbegin\n  CleanA;\n  HorizWall(1,1,w);\n  HorizWall(1,h,w);\n  VertWall(1,1,h);\n  VertWall(w,1,h);\n  HorizWall(49,9,31);\n  HorizWall(49,14,31);\nend;\n\nprocedure DrawScreen;\nbegin\n  TextColor(White);\n  ClrScr;\n  for var j := 1 to h do\n  for var i := 1 to w do\n    write(A[i,j])\nend;\n\nfunction FilledInFront: boolean;\nbegin\n  Result := (A[ax+vx,ay]<>' ') or (A[ax,ay+vy]<>' ') or (A[ax+vx,ay+vy]<>' ')\nend;\n\nprocedure ChangeDirection;\nbegin\n  if A[ax+vx,ay]<>' ' then \n    vx := -vx;\n  if A[ax,ay+vy]<>' ' then \n    vy := -vy;\n  if (A[ax+vx,ay]=' ') and (A[ax,ay+vy]=' ') and (A[ax+vx,ay+vy]<>' ') then\n  begin\n    vx := -vx;\n    vy := -vy\n  end;\n  Sleep(10);\nend;\n\nprocedure ShowBall;\nbegin\n  GotoXY(ax,ay);\n  write('B');\nend;\n\nprocedure HideBall;\nbegin\n  GotoXY(ax,ay);\n  write(' ');\nend;\n\nprocedure SetBallCoords(x,y: integer);\nbegin\n  ax := x;\n  ay := y\nend;\n\nprocedure SetBallVeloc(vx0,vy0: integer);\nbegin\n  vx := vx0;\n  vy := vy0\nend;\n\nprocedure MoveTo(x,y: integer);\nbegin\n  HideBall;\n  SetBallCoords(x,y);\n  ShowBall\nend;\n\nprocedure MoveBy(dx,dy: integer);\nbegin\n  MoveTo(ax+dx,ay+dy);\nend;\n\nBEGIN\n  SetWindowTitle('Billiard (CRT nostalgia)');\n  HideCursor;\n  Fill;\n  DrawScreen;\n  SetBallCoords(70,13);\n  SetBallVeloc(1,1);\n  TextColor(Yellow);\n  ShowBall;\n  repeat\n    Delay(20);\n    if FilledInFront then \n      ChangeDirection;\n    MoveBy(vx,vy);\n  until KeyPressed;\nEND."
  },
  {
    "instruction": "Implement bisection method for root finding in PascalABC.NET",
    "output": "function f(x: real) := exp(x) - 4;\n\nfunction BisectionMethod(a, b, eps: real): real;\nbegin\n  var fa := f(a);\n  while abs(b - a) > eps do\n  begin\n    var c := (a + b) / 2;\n    var fc := f(c);\n    if fc = 0 then\n      break;\n    if fa * fc < 0 then\n      b := c\n    else\n      (a, fa) := (c, fc);\n  end;\n  Result := (a + b) / 2;\nend;\n\nbegin\n  var (a, b) := (0.0, 3.0);\n  var eps := 0.000001;\n  var root := BisectionMethod(a, b, eps);\n  Println('Equation root:', root);\nend."
  },
  {
    "instruction": "Show how to swap values of two variables using a temporary variable in PascalABC.NET",
    "output": "// Swapping values of two variables using a third variable\n\nbegin\n  var (x,y) := ReadReal2('Enter x,y:');\n  \n  var v := x; // auxiliary variable\n  x := y;\n  y := v;\n  \n  Println($'New values x,y: {x} {y}');\nend."
  },
  {
    "instruction": "Compare performance of block variables vs global variables in PascalABC.NET",
    "output": "begin\n  var s := 0.0;\n  var i: real := 1;\n  while i<1000000000 do\n  begin\n    s += 1/i;\n    i += 1;\n  end;  \n  writeln(s);\n  writeln('Calculation time = ',Milliseconds/1000,' s');\nend."
  },
  {
    "instruction": "Implement word game with letter boards and word validation in PascalABC.NET using GraphABC",
    "output": "uses GraphABC,ABCObjects,ABCButtons;\n\nconst \n  freqcharstr='\u0430\u0430\u0430\u0430\u0430\u0430\u0430\u0430\u0430\u0430\u0430\u0430\u0430\u0430\u0430\u0430\u0430\u0430\u0430\u0430\u0430\u0430\u0430\u0430\u0430\u0430\u0431\u0431\u0431\u0431\u0431\u0432\u0432\u0432\u0432\u0432\u0432\u0432\u0432\u0433\u0433\u0433\u0433\u0434\u0434\u0434\u0434\u0434\u0434\u0434\u0435\u0435\u0435\u0435\u0435\u0435\u0435\u0435\u0435\u0435\u0435\u0435\u0435\u0435\u0435\u0435\u0435\u0435\u0435\u0435\u0435\u0436\u0436\u0437\u0437\u0437\u0437\u0438\u0438\u0438\u0438\u0438\u0438\u0438\u0438\u0438\u0438\u0438\u0438\u0438\u0438\u0438\u0438\u0438\u0438\u0438\u0439\u043a\u043a\u043a\u043a\u043a\u043a\u043a\u043a\u043a\u043a\u043a\u043a\u043a\u043a\u043a\u043b\u043b\u043b\u043b\u043b\u043b\u043b\u043b\u043b\u043b\u043b\u043c\u043c\u043c\u043c\u043c\u043c\u043d\u043d\u043d\u043d\u043d\u043d\u043d\u043d\u043d\u043d\u043d\u043d\u043d\u043d\u043d\u043d\u043d\u043e\u043e\u043e\u043e\u043e\u043e\u043e\u043e\u043e\u043e\u043e\u043e\u043e\u043e\u043e\u043e\u043e\u043e\u043e\u043e\u043e\u043e\u043e\u043e\u043f\u043f\u043f\u043f\u043f\u043f\u043f\u043f\u0440\u0440\u0440\u0440\u0440\u0440\u0440\u0440\u0440\u0440\u0440\u0440\u0440\u0440\u0440\u0440\u0440\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0442\u0442\u0442\u0442\u0442\u0442\u0442\u0442\u0442\u0442\u0442\u0442\u0442\u0442\u0442\u0443\u0443\u0443\u0443\u0443\u0443\u0444\u0444\u0445\u0445\u0446\u0446\u0446\u0447\u0447\u0447\u0448\u0448\u0449\u044b\u044b\u044c\u044c\u044c\u044c\u044c\u044d\u044e\u044f\u044f\u044f\u044f';\n\nconst\n  MaxWordLen = 12;\n  scorehits: array [1..MaxWordLen] of integer = (0,1,2,4,7,11,16,22,29,37,46,56);\n\ntype \n  MySquareABC = class(SquareABC) end;\n\nvar\n  MainBoard: ObjectBoardABC;\n  WordBoard: ObjectBoardABC;\n  cur: integer;\n  moves: integer;\n  score: integer;\n  Status: RectangleABC;\n\nfunction WordExists(s: string): boolean;\nvar\n  f: text;\n  str: string;\nbegin\n  s := LowerCase(s);\n  Result := False;\n  assign(f,'words.txt');\n  reset(f);\n  while not eof(f) do\n  begin\n    readln(f,str);\n    if s=str then\n    begin\n      Result := True;\n      break;\n    end;\n  end;\n  close(f);\nend;\n\nprocedure MyMouseDown(x,y,mb: integer);\nbegin\n  if mb=1 then\n  begin\n    if cur>WordBoard.DimX then\n      exit;\n    var ob := ObjectUnderPoint(x,y);\n    if (ob is MySquareABC) and ob.Visible then\n    begin\n      var ob1 := WordBoard[cur,1];\n      ob1.Visible := True;\n      ob1.Text := ob.Text;\n      Inc(cur);\n      ob.Visible := False;\n      var s := '';\n      for var i:=1 to cur-1 do\n        s := s + WordBoard[i,1].Text;\n      if WordExists(s) then\n        WordBoard.Color := clYellow\n      else WordBoard.Color := clSkyBlue\n    end;\n  end\n  else\n  begin\n    for var xx:=1 to cur-1 do\n      WordBoard[xx,1].Visible := False;\n    for var xx:=1 to MainBoard.DimX do\n    for var yy:=1 to MainBoard.DimY do\n      MainBoard[xx,yy].Visible:=True;\n    cur := 1;\n    WordBoard.Color := clSkyBlue\n  end;\nend;\n\nprocedure BtNewClick;\nbegin\n  score := 0;\n  moves := 0;\n  Status.Text := 'Moves: '+IntToStr(moves)+'   Score: '+IntToStr(score);\n  MyMouseDown(1,1,2);\n  for var xx:=1 to MainBoard.DimX do\n  for var yy:=1 to MainBoard.DimY do\n    MainBoard[xx,yy].Text := UpCase(freqcharstr[Random(255)+1]);\nend;\n\nprocedure BtWordClick;\nbegin\n  if WordBoard.Color<>clYellow then\n    exit;\n  Inc(score,scorehits[cur-1]);\n  Inc(moves);\n  for var xx:=1 to cur-1 do\n    WordBoard[xx,1].Visible:=False;\n  for var xx:=1 to MainBoard.DimX do\n  for var yy:=1 to MainBoard.DimY do\n    if not MainBoard[xx,yy].Visible then\n    begin\n      MainBoard[xx,yy].Visible:=True;\n      MainBoard[xx,yy].Text:=UpCase(freqcharstr[Random(255)+1]);\n    end;\n  cur := 1;\n  WordBoard.Color := clSkyBlue;\n  Status.Text := 'Moves: '+IntToStr(moves)+'   Score: '+IntToStr(score);\nend;\n\nprocedure BtPleaseClick;\nvar\n  f: text;\n  str,maxstr: string;\n  arr,work: array ['\u0430'..'\u044f'] of integer;\n  maxlen: integer;\n\n  function CanConstructWord(s: string): boolean;\n  begin\n    work := arr;\n    Result := True;\n    for var i:=1 to Length(s) do\n    begin\n      Dec(work[s[i]]);\n      if work[s[i]]<0 then\n      begin\n        Result := False;\n        break;\n      end;\n    end;\n  end;\n\nbegin\n  maxlen := 0;\n  maxstr := '';\n  for var c:='\u0430' to '\u044f' do\n    arr[c]:=0;\n  for var xx:=1 to MainBoard.DimX do\n  for var yy:=1 to MainBoard.DimY do\n    Inc(arr[LowCase(MainBoard[xx,yy].Text[1])]);\n  assign(f,'words.txt');\n  reset(f);\n  while not eof(f) do\n  begin\n    readln(f,str);\n    if CanConstructWord(str) and (Length(str)>maxlen) and (Length(str)<=MaxWordLen) then\n    begin\n      maxlen := Length(str);\n      maxstr := str;\n    end;\n  end;\n  close(f);\n  writeln(maxstr);\nend;\n\nprocedure InitWindow;\nbegin\n  SetWindowSize(640,480);\n  Window.IsFixedSize := True;\n  Window.Title := 'Know Russian Words!';\n  Brush.Color := clMoneyGreen;\n  FillRect(0,0,WindowWidth,WindowHeight);\nend;\n\nprocedure InitGameVars;\nbegin\n  cur := 1;\n  moves := 0;\n  score := 0;\nend;\n\nprocedure InitButtons;\nbegin\n  var btword := new ButtonABC(70,410,180,30,'Say Word',clGray);\n  var btnew := new ButtonABC(280,410,100,30,'New Game',clLightGray);\n  var btplease := new ButtonABC(410,410,160,30,'Hint',clGray);\n  btword.OnClick := BtWordClick;\n  btnew.OnClick := BtNewClick;\n  btplease.OnClick := BtPleaseClick;\nend;\n\nprocedure InitInterface;\nbegin\n  Status := new RectangleABC(70,350,500,30,clSkyBlue);\n  Status.Text := 'Moves: 0   Score: 0';\n  WordBoard := new ObjectBoardABC(20,40,MaxWordLen,1,50,50,clSkyBlue);\n  MainBoard := new ObjectBoardABC(220,120,4,4,50,50,clMoneyGreen);\n  MainBoard.BorderColor := clGreen;\n  for var x:=1 to WordBoard.DimX do\n  begin\n    WordBoard[x,1] := new SquareABC(0,0,WordBoard.CellSizeX-6,clWhite);\n    WordBoard[x,1].Visible := False;\n  end;\n  for var x:=1 to MainBoard.DimX do\n  for var y:=1 to MainBoard.DimY do\n  begin\n    MainBoard[x,y] := new MySquareABC(0,0,MainBoard.CellSizeX-6,clWhite);\n    MainBoard[x,y].Text := UpCase(freqcharstr[Random(freqcharstr.Length)+1]);\n  end;\nend;\n\nbegin\n  SetConsoleIO;\n  InitWindow;\n  InitGameVars;\n  InitInterface;\n  InitButtons;\n  OnMouseDown := MyMouseDown;\nend."
  },
  {
    "instruction": "Demonstrate boolean type and logical expressions with and, or, not operators in PascalABC.NET",
    "output": "// Boolean type. Logical expressions with and, or and not\n\nbegin\n  var x: integer := ReadInteger('Enter x (from 1 to 9):');\n  var b: boolean := x=5;\n  Println('x=5?',b);\n  b := (x>=3) and (x<=5);\n  Println('x=3,4 or 5?',b);\n  b := (x=3) or (x=4) or (x=5);\n  Println('x=3,4 or 5?',b);\n  b := not Odd(x);\n  Println('x - even?',b);\nend."
  },
  {
    "instruction": "Explain boxing and unboxing of value types in PascalABC.NET with exception handling",
    "output": "// Boxing-unboxing of value types\nvar \n  i: integer := 2;\n  r: real := 3.14;\n  o: object;\n\nbegin\n  o := i; // Boxing: object of value type integer is boxed into object of reference type, \n          // which is assigned to variable o\n          // Type conversion during boxing - implicit\n  Println(integer(o)); // Unboxing: value is extracted from boxed object        \n                       // Type conversion during unboxing - explicit\n  o := r;\n  Println(real(o));\n  \n  try // When type conversion is incorrect, InvalidCastException is generated\n    Println(shortint(o));\n  except\n    on e: Exception do\n      Println(e.GetType);\n  end;\nend."
  },
  {
    "instruction": "Demonstrate function caching using Cache attribute in PascalABC.NET",
    "output": "[Cache]\nfunction fib(n: integer): integer := \n  if n in 1..2 then 1 \n  else fib(n-1) + fib(n-2);\n\nfunction fib1(n: integer): integer := \n  if n in 1..2 then 1 \n  else fib1(n-1) + fib1(n-2);\n  \nbegin\n  Println(fib(42),MillisecondsDelta/1000);\n  Println(fib1(42),MillisecondsDelta/1000);\nend."
  },
  {
    "instruction": "Create integral calculator with GUI using FormsABC in PascalABC.NET",
    "output": "uses FormsABC;\n\ntype Fun = function (x: real): real;\n  \nvar funs: array of Fun := (sin,cos,sqr);\n\nfunction CalcIntegral(a,b: real; N: integer; f: Fun): real;\nbegin\n  Result := 0;\n  var x := a;\n  var h := (b-a)/N;\n  for var i:=0 to N-1 do\n  begin\n    Result += f(x);\n    x += h;\n  end;\n  Result *= h;\nend;\n\nvar \n  a := new RealField('a:');\n  f1 := new FlowBreak;\n  b := new RealField('b:');\n  f2 := new FlowBreak;\n  N := new IntegerField('N:');\n  f3 := new FlowBreak;\n  tl := new TextLabel('Function: ');\n  f4 := new FlowBreak;\n  cb := new ComboBox;\n  f5 := new FlowBreak(50);\n  s1 := new Space(20);\n  ok := new Button('Calculate');\n  tb: TextBox;\n\nprocedure MyClick;\nbegin\n  var f := funs[cb.SelectedIndex];\n  var res := CalcIntegral(a.Value,b.Value,N.Value,f);\n  tb.AddLine(Format('Integral({0},{1},{2},{3}) = {4}',a.Value,b.Value,N.Value,cb.SelectedValue,res.ToString));\nend;\n\nprocedure InitControls;\nbegin\n  MainForm.Title := 'Definite Integral Calculation';\n  MainForm.SetSize(500,350);\n  MainForm.CenterOnScreen;\n  b.Value := 1;\n  N.Value := 10;\n  cb.Items.Add('sin');\n  cb.Items.Add('cos');\n  cb.Items.Add('x^2');\n  cb.SelectedIndex := 0;\n  ok.Click += MyClick;\n  mainPanel.Dock := DockStyle.Left;\n  mainPanel.Width := 150;\n  ParentControl := MainForm;\n  tb := new TextBox;\n  tb.Dock := DockStyle.Fill;\nend;\n\nbegin\n  InitControls;\nend."
  },
  {
    "instruction": "Show different ways to perform calculations and output results in PascalABC.NET using constants and direct values",
    "output": "// Output of calculation results\nbegin\n  Println('Calculations:');\n// Output empty string\n  Println;\n  Println('121 + 363 =',121+363);\n  Println('121 - 363 =',121-363);\n  Println('121 * 363 =',121*363);\n  Println('121 / 363 =',121/363);\nend.\n\n// Output of calculation results. Named constants are used\nconst \n  a = 121;\n  b = 363;\n\nbegin\n  Println('Calculations:');\n  Println;\n  Println(a,'+',b,'=',a+b);\n  Println(a,'-',b,'=',a-b);\n  Println(a,'*',b,'=',a*b);\n  Println(a,'/',b,'=',a/b);\nend."
  },
  {
    "instruction": "Show how to use assignment operators += -= *= /= in PascalABC.NET",
    "output": "// Assignments += -= *= /=\n\nbegin\n  var i: integer := 1;\n  Println('i := 1; i = ',i);\n  i += 2; // Increase by 2\n  Println('i += 2; i = ',i);\n  i *= 3; // Multiply by 3\n  Println('i *= 3; i = ',i);\n  Println;\n  var r: real := 6;\n  Println('r := 6; r = ',r);\n  r /= 2;\n  Println('r /= 2; r = ',r);\nend."
  },
  {
    "instruction": "Explain how to use interpolated strings with formatting options in PascalABC.NET",
    "output": "/// Using interpolated strings\nbegin\n  var Pi := 3.1415;\n  // Setting output field width\n  Println($'{Pi,10:f}');\n  // Left alignment in output field\n  Println($'{Pi,-10:f}|');\n  // Setting number of decimal places for real number\n  Println($'{Pi:f3}');\n  // Output curly braces\n  Println($'{{}}Output curly braces in interpolated string {Pi}');\nend."
  },
  {
    "instruction": "Create auto class Point with methods and implicit conversion in PascalABC.NET",
    "output": "type \n  Point = auto class\n    x,y: integer;\n    procedure MoveBy(dx,dy: integer) := (x,y) := (x+dx,y+dy);\n    function Distance(p: Point) := sqrt(sqr(x-p.x)+sqr(y-p.y));\n    class function operator implicit(t: (integer,integer)): Point := new Point(t[0],t[1]);\n  end;\n  \nbegin\n  var p: Point;\n  p := (2,3);\n  Println(p);\nend."
  },
  {
    "instruction": "Create a non-recursive solution to the 8 queens problem in PascalABC.NET using LINQ-style operations with permutations and combinations to find valid queen placements.",
    "output": "## (1..8).Permutations\n.Where(v->v.Numerate.Combinations(2)\n       .All(\\(\\(a,b),\\(c,d)) -> abs(a-c)<>abs(b-d)))\n.PrintLines"
  },
  {
    "instruction": "Create a type compatibility matrix in PascalABC.NET that shows the result types of ternary conditional operations between different numeric types including shortint, byte, smallint, word, integer, longword, int64, uint64, BigInteger, single, real, and decimal.",
    "output": "begin\n  var i0: shortint;\n  var i1: byte;\n  var i2: smallint;\n  var i3: word;\n  var i4: integer;\n  var i5: longword;\n  var i6: int64;\n  var i7: uint64;\n  var i8: BigInteger;\n  var i9: single;\n  var ia: real;\n  var ib: decimal;\n  \n  var n := 12;\n  \n  var b := new string[12,12];\n  \n  b[0,0] := (True ? i0 : i0).GetType.ToString.Substring(7).ToWords('.').Last.PadLeft(n);\n  b[0,1] := (True ? i0 : i1).GetType.ToString.Substring(7).ToWords('.').Last.PadLeft(n);\n  b[0,2] := (True ? i0 : i2).GetType.ToString.Substring(7).ToWords('.').Last.PadLeft(n);\n  b[0,3] := (True ? i0 : i3).GetType.ToString.Substring(7).ToWords('.').Last.PadLeft(n);\n  b[0,4] := (True ? i0 : i4).GetType.ToString.Substring(7).ToWords('.').Last.PadLeft(n);\n  b[0,5] := (True ? i0 : i5).GetType.ToString.Substring(7).ToWords('.').Last.PadLeft(n);\n  b[0,6] := (True ? i0 : i6).GetType.ToString.Substring(7).ToWords('.').Last.PadLeft(n);\n  b[0,7] := (True ? i0 : i7).GetType.ToString.Substring(7).ToWords('.').Last.PadLeft(n);\n  b[0,8] := (True ? i0 : i8).GetType.ToString.Substring(7).ToWords('.').Last.PadLeft(n);\n  b[0,9] := (True ? i0 : i9).GetType.ToString.Substring(7).ToWords('.').Last.PadLeft(n);\n  b[0,10] := (True ? i0 : ia).GetType.ToString.Substring(7).ToWords('.').Last.PadLeft(n);\n  b[0,11] := (True ? i0 : ib).GetType.ToString.Substring(7).ToWords('.').Last.PadLeft(n);\n  b.Println(8);\nend."
  },
  {
    "instruction": "Implement the QuickSort algorithm in PascalABC.NET using the classic Hoare partitioning method with recursive sorting of subarrays.",
    "output": "function Partition(a: array of integer; l,r: integer): integer;\nbegin\n  var i := l - 1;\n  var j := r + 1;\n  var x := a[l];\n  while True do\n  begin\n    repeat\n      i += 1;\n    until a[i]>=x;\n    repeat\n      j -= 1;\n    until a[j]<=x;\n    if i<j then \n      Swap(a[i],a[j])\n    else \n    begin\n      Result := j;\n      exit;\n    end;\n  end;\nend;\n  \nprocedure QuickSort(a: array of integer; l,r: integer);\nbegin\n  if l>=r then exit;\n  var j := Partition(a,l,r);\n  QuickSort(a,l,j);\n  QuickSort(a,j+1,r);\nend;\n\nconst n = 20;\n\nbegin\n  var a := ArrRandom(n);\n  Println('\u0414\u043e \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0438: ');\n  Println(a);\n  QuickSort(a,0,a.Length-1);\n  Println('\u041f\u043e\u0441\u043b\u0435 \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0438: ');\n  Println(a);\nend."
  },
  {
    "instruction": "Create a functional-style QuickSort implementation in PascalABC.NET using array slicing and filtering operations for educational purposes.",
    "output": "function QS(a: array of integer): array of integer := \n  if a.Length < 2 then \n    a\n  else \n    QS(a[1:].FindAll(y->y<=a[0])) + a[:1] + QS(a[1:].FindAll(y->y>a[0]));\n\nbegin\n  var a := ArrRandom(20);\n  a.Println;\n  var b := QS(a);\n  b.Println;\nend."
  },
  {
    "instruction": "Create a LINQ-style QuickSort implementation in PascalABC.NET using sequence operations with Where, Skip, and First methods.",
    "output": "function QuickSort(a: sequence of integer): sequence of integer;\nbegin\n  if a.Count = 0 then\n    Result := a\n  else \n  begin\n    var head := a.First();\n    var tail := a.Skip(1);\n    Result := QuickSort(tail.Where(x->x<=head)) + \n              head + \n              QuickSort(tail.Where(x->x>head));\n  end;\nend; \n\nbegin\n  var a := ArrRandom(20);\n  a.Println;\n  QuickSort(a).Println;\nend."
  },
  {
    "instruction": "Solve the N-Queens problem in PascalABC.NET using backtracking with recursive placement and safety checking for diagonal conflicts.",
    "output": "function IsSafe(board: array of integer; row, col: integer): boolean;\nbegin\n  Result := True;\n  for var i := 0 to row - 1 do\n    if (board[i] = col) or\n       (board[i] - i = col - row) or\n       (board[i] + i = col + row) then\n    begin\n      Result := False;\n      exit; \n    end;\nend;\n\nprocedure SolveNQueens(board: array of integer; row: integer);\nbegin\n  if row = 8 then\n    board.Println\n  else\n    for var col := 0 to 7 do\n      if IsSafe(board, row, col) then\n      begin\n        board[row] := col;\n        SolveNQueens(board, row + 1);\n      end;\nend;\n\nbegin\n  var board := [0] * 8; \n  SolveNQueens(board, 0);\nend."
  },
  {
    "instruction": "Create a raindrop ripple animation in PascalABC.NET using GraphABC that simulates expanding circles from random drop positions.",
    "output": "uses GraphABC;\n\nconst speed = 2;\n\nprocedure Kaplia(x0,y0: integer);\nbegin\n  var r := 1;\n  for var i:=0 to 63 do\n  begin\n    Pen.Color := RGB(i*4,i*4,i*4);\n    Circle(x0,y0,r);\n    if i mod speed = 0 then Sleep(10);\n    Pen.Color := clWhite;\n    Circle(x0,y0,r);\n    r += 2;    \n  end;\nend;\n\nconst z=50;\n\nbegin\n  Window.Title := '\u041a\u0430\u043f\u043b\u0438 \u0434\u043e\u0436\u0434\u044f';\n  SetWindowSize(800,600);\n  while True do\n    Kaplia(Random(z,WindowWidth-z),Random(z,WindowHeight-z));\nend."
  },
  {
    "instruction": "Show random number generation and dice throwing simulation in PascalABC.NET",
    "output": "// Random number generation\n\nbegin\n  var i := Random(100);\n  Println('Random integer in range 0..99:', i);\n  i := Random(2,5);\n  Println('Random integer in range 2..5:', i);\n  var r := Random;\n  Println('Random real in range [0,1):', r);\nend.\n\n// Dice throwing\n\nbegin\n  var (k1,k2) := Random2(1,6);\n  Println($'Dice points: {k1} {k2}');\n  Println($'Sum of points: {k1+k2}');\nend."
  },
  {
    "instruction": "Generate random numbers in specific ranges in PascalABC.NET including integers, reals, and characters using range syntax.",
    "output": "begin\n  Random(1..9).Println;\n  Random(1.0..2.0).Println;\n  Random('a'..'z').Println;\nend."
  },
  {
    "instruction": "Create a vector record type Vec3 in PascalABC.NET with arithmetic operators, normalization, and cross product for 3D graphics applications.",
    "output": "type\n  Vec3 = record\n    x, y, z: real;\n    class function operator+(v1, v2: Vec3): Vec3 := new Vec3(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);\n    class function operator-(v1, v2: Vec3): Vec3 := new Vec3(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);\n    class function operator-(v: Vec3): Vec3 := new Vec3(-v.x, -v.y, -v.z);\n    class function operator*(v: Vec3; r: real): Vec3 := new Vec3(v.x * r, v.y * r, v.z * r);\n    class function operator/(v: Vec3; r: real): Vec3 := new Vec3(v.x / r, v.y / r, v.z / r);\n    class function operator*(r: real; v: Vec3): Vec3 := new Vec3(v.x * r, v.y * r, v.z * r);\n    class function operator*(v1, v2: Vec3): real := v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n    function norm := Sqrt(x * x + y * y + z * z);\n    function normalize(l: real := 1): Vec3 := Self/norm;\n    function cross(v: Vec3): Vec3 := new Vec3(y * v.z - z * v.y, z * v.x - x * v.z, x * v.y - y * v.x);\n    constructor(xx,yy,zz: real); begin x := xx; y := yy; z := zz end;\n  end;"
  },
  {
    "instruction": "Create a sphere-ray intersection function in PascalABC.NET for ray tracing that calculates if and where a ray intersects a sphere.",
    "output": "type\n  TSphere = auto class \n    center: vec3;\n    radius: real;\n    material: TMaterial;\n    function RayIntersect(orig, dir: vec3; var t0: real): boolean;\n    begin\n      var L := center - orig;\n      var tca := L * dir;\n      var d2 := L * L - tca * tca;\n      if d2 > radius * radius then\n        begin Result := false; exit end;\n      var thc := Sqrt(radius * radius - d2);\n      t0 := tca - thc;\n      if t0 < 1e-3 then\n        t0 := tca + thc;\n      if t0 < 1e-3 then\n        Result := false\n      else Result := true;\n    end;\n  end;"
  },
  {
    "instruction": "Create a reflection function in PascalABC.NET for ray tracing that calculates the reflection direction of a vector off a surface normal.",
    "output": "function Reflect(I, N: vec3) := I - N * 2 * (I * N);"
  },
  {
    "instruction": "Create a refraction function in PascalABC.NET for ray tracing using Snell's law to calculate the refracted ray direction.",
    "output": "function Refract(I, N: vec3; eta_t: real; eta_i: real := 1): vec3;\nbegin\n  var cosi := -max(-1.0, min(1.0, I * N));\n  if cosi < 0 then\n    begin Result := Refract(I, -N, eta_i, eta_t); exit end;\n  var eta := eta_i / eta_t;\n  var k := 1 - eta * eta * (1 - cosi * cosi);\n  Result := if k < 0 then v3(1, 0, 0) else I * eta + N * (eta * cosi - Sqrt(k));\nend;"
  },
  {
    "instruction": "Create a scene intersection function in PascalABC.NET for ray tracing that finds the closest intersection point between a ray and objects in the scene.",
    "output": "function scene_intersect(orig, dir: vec3; spheres: array of TSphere; var hit, N: vec3; var material: TMaterial): boolean;\nbegin\n  var spheres_dist := real.MaxValue;\n  foreach var s in spheres do \n  begin\n    var dist_i: real;\n    if s.RayIntersect(orig, dir, dist_i) and (dist_i < spheres_dist) then\n    begin\n      spheres_dist := dist_i;\n      hit := orig + dir * dist_i;\n      N := (hit - s.center).normalize();\n      material := s.material;\n    end;\n  end;\n  \n  var checkerboard_dist := real.MaxValue;\n  if abs(dir.y) > 1e-3 then \n  begin\n    var d := -(orig.y + 4) / dir.y;\n    var pt := orig + dir * d;\n    if (d > 1e-3) and (abs(pt.x) < 10) and (pt.z < -10) and (pt.z > -30) and (d < spheres_dist) then \n    begin\n      checkerboard_dist := d;\n      hit := pt;\n      N := v3(0, 1, 0);\n      material.diffuse_color := if (Trunc(0.5 * hit.x + 1000) + Trunc(0.5 * hit.z)) and 1 = 1 then v3(0.3, 0.3, 0.3) else v3(0.3, 0.2, 0.1);\n    end;\n  end;\n  Result := min(spheres_dist, checkerboard_dist) < 1000;\nend;"
  },
  {
    "instruction": "Create a ray casting function in PascalABC.NET for ray tracing that calculates the color of a pixel by tracing rays through the scene with reflection and refraction.",
    "output": "function cast_ray(orig, dir: vec3; spheres: array of TSphere; lights: array of TLight; depth: integer := 0): vec3;\nbegin\n  var point,N: Vec3;\n  var material := new TMaterial;\n  \n  if (depth > 4) or not scene_intersect(orig, dir, spheres, point, N, material) then\n    begin Result := v3(0.2, 0.7, 0.8); exit end;\n  \n  var reflect_dir := Reflect(dir, N).normalize();\n  var refract_dir := Refract(dir, N, material.refractive_index).normalize();\n  var reflect_color := cast_ray(point, reflect_dir, spheres, lights, depth + 1);\n  var refract_color := cast_ray(point, refract_dir, spheres, lights, depth + 1);\n  \n  var (diffuse_light_intensity, specular_light_intensity) := (0.0, 0.0);\n  foreach var light in lights do\n  begin\n    var light_dir := (light.position - point).normalize;\n    \n    var shadow_pt, trashnrm: vec3;\n    var trashmat: TMaterial;\n    if scene_intersect(point, light_dir, spheres, shadow_pt, trashnrm, trashmat) and\n                ((shadow_pt - point).norm < (light.position - point).norm) then\n      continue;\n    \n    diffuse_light_intensity += light.intensity * max(0, light_dir * N);\n    specular_light_intensity += max(0, -Reflect(-light_dir, N) * dir) ** material.specular_exponent * light.intensity;\n  end;\n  Result := material.diffuse_color * diffuse_light_intensity * material.albedo.x0 + \n      v3(1.0, 1.0, 1.0) * specular_light_intensity * material.albedo.x1 + reflect_color * material.albedo.x2 + refract_color * material.albedo.x3;\nend;"
  },
  {
    "instruction": "Create an enhanced ray casting function in PascalABC.NET with colored lighting, emission effects, gradient sky, and light attenuation.",
    "output": "function cast_ray(orig, dir: vec3; spheres: array of TSphere; lights: array of TLight; depth: integer := 0): vec3;\nbegin\n  var point,N: Vec3;\n  var material := new TMaterial;\n  \n  if (depth > 5) or not scene_intersect(orig, dir, spheres, point, N, material) then\n  begin\n    var t := 0.5 * (dir.y + 1.0);\n    Result := (1.0 - t) * v3(1.0, 1.0, 1.0) + t * v3(0.3, 0.7, 1.0);\n    exit;\n  end;\n  \n  var emission_intensity := 1.0;\n  if material.emission.norm > 0 then\n  begin\n    var found_sphere: TSphere := nil;\n    foreach var s in spheres do\n    begin\n      var dist_to_center := (point - s.center).norm;\n      if dist_to_center <= s.radius + 0.001 then\n      begin\n        found_sphere := s;\n        break;\n      end;\n    end;\n    \n    if found_sphere <> nil then\n    begin\n      var dist_from_center := (point - found_sphere.center).norm;\n      var radius_ratio := dist_from_center / found_sphere.radius;\n      emission_intensity := 1.0 - radius_ratio * radius_ratio;\n      emission_intensity := max(0.1, emission_intensity);\n    end;\n  end;\n  \n  var result_color := material.emission * emission_intensity;\n  \n  var reflect_dir := Reflect(dir, N).normalize();\n  var refract_dir := Refract(dir, N, material.refractive_index).normalize();\n  var reflect_color := cast_ray(point, reflect_dir, spheres, lights, depth + 1);\n  var refract_color := cast_ray(point, refract_dir, spheres, lights, depth + 1);\n  \n  var (diffuse_light_intensity, specular_light_intensity) := (0.0, 0.0);\n  var color_influence := new Vec3(0, 0, 0);\n  \n  foreach var light in lights do\n  begin\n    var light_dir := (light.position - point).normalize;\n    var light_distance := (light.position - point).norm;\n    \n    var shadow_pt, trashnrm: vec3;\n    var trashmat: TMaterial;\n    if scene_intersect(point, light_dir, spheres, shadow_pt, trashnrm, trashmat) and\n                ((shadow_pt - point).norm < light_distance) then\n      continue;\n    \n    var attenuation := 1.0 / (1.0 + 0.01 * light_distance);\n    \n    diffuse_light_intensity += light.intensity * max(0, light_dir * N) * attenuation;\n    specular_light_intensity += max(0, -Reflect(-light_dir, N) * dir) ** material.specular_exponent * light.intensity * attenuation;\n    \n    var light_contrib := light.color * light.intensity * max(0, light_dir * N) * attenuation;\n    color_influence := color_influence + light_contrib;\n  end;\n  \n  var diffuse_component := v3(material.diffuse_color.x * color_influence.x, \n                              material.diffuse_color.y * color_influence.y, \n                              material.diffuse_color.z * color_influence.z) * material.albedo.x0;\n  \n  result_color := result_color + diffuse_component + \n      v3(1.0, 1.0, 1.0) * specular_light_intensity * material.albedo.x1 + \n      reflect_color * material.albedo.x2 + \n      refract_color * material.albedo.x3;\n  \n  Result := result_color;\nend;"
  },
  {
    "instruction": "Create a render function in PascalABC.NET for ray tracing that generates an image by casting rays for each pixel with parallel processing.",
    "output": "function render(width,height: integer; spheres: array of TSphere; lights: array of TLight): array [,] of Color;\nbegin\n  Result := new Color[width,height];  \n  {$omp parallel for}\n  for var j := 0 to height - 1 do\n  begin\n    for var i := 0 to width - 1 do\n    begin\n      var dir_x := (i + 0.5) - width / 2;\n      var dir_y := -(j + 0.5) + height / 2;\n      var dir_z := -height / (2 * tan(PI / 6));\n      var c := cast_ray(v3(0, 0, 0), v3(dir_x, dir_y, dir_z).normalize(), spheres, lights);\n      var max := max(c.x, c.y, c.z);\n      if max > 1 then\n        c := c / max;\n      Result[i,j] := RGB(Trunc(255*c.x),Trunc(255*c.y),Trunc(255*c.z));\n    end;\n  end;\nend;"
  },
  {
    "instruction": "Create an enhanced render function in PascalABC.NET with supersampling anti-aliasing for better image quality in ray tracing.",
    "output": "function render(width,height: integer; spheres: array of TSphere; lights: array of TLight): array [,] of Color;\nbegin\n  Result := new Color[width,height];  \n  var samples := 3;\n  var inv_samples := 1.0 / (samples * samples);\n  \n  {$omp parallel for}\n  for var j := 0 to height - 1 do\n  begin\n    for var i := 0 to width - 1 do\n    begin\n      var final_color := v3(0, 0, 0);\n      \n      for var sy := 0 to samples - 1 do\n        for var sx := 0 to samples - 1 do\n        begin\n          var offset_x := (sx + 0.5) / samples;\n          var offset_y := (sy + 0.5) / samples;\n          \n          var dir_x := (i + offset_x) - width / 2;\n          var dir_y := -(j + offset_y) + height / 2;\n          var dir_z := -height / (2 * tan(PI / 6));\n          \n          var sample_color := cast_ray(v3(0, 0, 0), v3(dir_x, dir_y, dir_z).normalize(), spheres, lights);\n          final_color := final_color + sample_color;\n        end;\n      \n      var c := final_color * inv_samples;\n      var max_val := max(c.x, max(c.y, c.z));\n      if max_val > 1 then\n        c := c / max_val;\n      \n      c.x := c.x.Clamp(0.0, 1.0);\n      c.y := c.y.Clamp(0.0, 1.0);\n      c.z := c.z.Clamp(0.0, 1.0);\n      \n      Result[i,j] := RGB(Trunc(255*c.x),Trunc(255*c.y),Trunc(255*c.z));\n    end;\n  end;\nend;"
  },
  {
    "instruction": "Create material definition functions in PascalABC.NET for ray tracing with different material properties like refractive index, albedo, and specular exponent.",
    "output": "function Material(ri: real; alb: vec4; dif: vec3; spec: real) := new TMaterial(ri, alb, dif, spec); \n\nfunction Material(ri: real; alb: vec4; dif: vec3; spec: real; em: vec3 := new Vec3(0,0,0)) := new TMaterial(ri, alb, dif, spec, em); \n\nfunction Sphere(center: vec3; radius: real; material: TMaterial) := new TSphere(center, radius, material);\n\nfunction Light(position: Vec3; intensity: real) := new TLight(position, intensity); \n\nfunction Light(position: Vec3; intensity: real; color: Vec3) := new TLight(position, intensity, color);"
  },
  {
    "instruction": "Create an enhanced scene intersection function in PascalABC.NET with wavy checkerboard pattern and improved material handling for ray tracing.",
    "output": "function scene_intersect(orig, dir: vec3; spheres: array of TSphere; var hit, N: vec3; var material: TMaterial): boolean;\nbegin\n  var spheres_dist := real.MaxValue;\n  foreach var s in spheres do \n  begin\n    var dist_i: real;\n    if s.RayIntersect(orig, dir, dist_i) and (dist_i < spheres_dist) then\n    begin\n      spheres_dist := dist_i;\n      hit := orig + dir * dist_i;\n      N := (hit - s.center).normalize();\n      material := s.material;\n    end;\n  end;\n  \n  var checkerboard_dist := real.MaxValue;\n  if abs(dir.y) > 1e-3 then \n  begin\n    var d := -(orig.y + 4) / dir.y;\n    var pt := orig + dir * d;\n    if (d > 1e-3) and (abs(pt.x) < 15) and (pt.z < -8) and (pt.z > -35) and (d < spheres_dist) then \n    begin\n      checkerboard_dist := d;\n      hit := pt;\n      N := v3(0, 1, 0);\n      \n      material := new TMaterial;\n      var wave := 0.1 * sin(pt.x * 0.5) * sin(pt.z * 0.3);\n      var checker := (Trunc(0.5 * hit.x + 1000) + Trunc(0.5 * hit.z)) and 1;\n      \n      if checker = 1 then\n        material.diffuse_color := v3(0.4 + wave, 0.4 + wave, 0.4 + wave)\n      else\n        material.diffuse_color := v3(0.2 + wave, 0.15 + wave, 0.1 + wave);\n      \n      material.albedo := v4(0.8, 0.2, 0.0, 0.0);\n      material.specular_exponent := 20;\n      material.refractive_index := 1.0;\n      material.emission := v3(0, 0, 0);\n    end;\n  end;\n  \n  Result := min(spheres_dist, checkerboard_dist) < 1000;\nend;"
  },
  {
    "instruction": "Create a Robot programming example in PascalABC.NET for educational purposes that demonstrates basic movement and painting operations.",
    "output": "uses Robot;\n\nbegin\n  Task('a1');\n  Right; Right; Right; Right; \n  Up;\n  Left; Paint;\n  Left; Paint;\n  Left; Paint;\n  Left; Paint;\n  Left; \nend."
  },
  {
    "instruction": "Show basic input/output operations and calculations with user input in PascalABC.NET",
    "output": "// Output of calculation results. Variables and input procedure are used\n\nbegin\n  var (a,b) := ReadlnInteger2('Enter a and b:');\n  Println;\n  Println(a,'+',b,'=',a+b);\n  Println(a,'-',b,'=',a-b);\n  Println(a,'*',b,'=',a*b);\n  Println(a,'/',b,'=',a/b);\nend.\n\n// First program\n\nprogram HelloWorld; // This line is optional\n\nbegin\n  Println('Hello, world!');\nend.\n\n// String input\n\nbegin\n  var \u0438\u043c\u044f := ReadString('Enter your name:');\n  Println($'Hello, {\u0438\u043c\u044f}!');\nend."
  },
  {
    "instruction": "Demonstrate that real division by zero doesn't cause runtime errors in PascalABC.NET",
    "output": "// With real division by 0 no error occurs \n\nbegin\n  var r: real := 0;\n  Print(1/r); // Output: Infinity\nend."
  },
  {
    "instruction": "Create record type examples in PascalABC.NET with enumerated types, record assignment, and field initialization using with statement.",
    "output": "type\n  SexType = (Male, Female);\n  Person = record\n    Name: string;\n    Age, Weight: integer;\n    Sex: SexType;\n  end;\n  \nprocedure WritePerson(const p: Person);\nbegin\n  writelnFormat('\u0424\u0430\u043c\u0438\u043b\u0438\u044f: {0}   \u041f\u043e\u043b: {1}   \u0412\u043e\u0437\u0440\u0430\u0441\u0442: {2}   \u0412\u0435\u0441: {3}',p.Name,p.Sex,p.Age,p.Weight);\nend;\n  \nvar \n  p: Person := (Name: '\u0418\u0432\u0430\u043d\u043e\u0432'; Age: 20; Weight: 64; Sex: Male);\n  p1: Person;  \nbegin\n  p1 := p;\n  var p2: Person;\n  p2.Name := '\u041f\u0435\u0442\u0440\u043e\u0432\u0430';\n  p2.Age := 18;\n  p2.Weight := 50;\n  p2.Sex := Female;\n  WritePerson(p2);\n  \n  var p3: Person;\n  with p3 do\n  begin\n    Name := '\u0421\u0438\u0434\u043e\u0440\u043e\u0432';\n    Age := 24;\n    Weight := 80;\n    Sex := Male;\n  end;\n  WritePerson(p3);\nend."
  },
  {
    "instruction": "Create a class with properties in PascalABC.NET that demonstrates read-only and read-write properties with validation in setter methods.",
    "output": "type \n  Person = class\n  private\n    nm: string;\n    ag: integer;\n    procedure SetAge(a: integer);\n    begin\n      if a<0 then\n        a := 0;\n      ag := a;  \n    end;\n  public\n    constructor (n: string; a: integer);\n    begin\n      nm := n; ag := a;\n    end;\n    property Name: string read nm;\n    property Age: integer read ag write SetAge;\n    procedure Print;\n    begin\n      writeln('\u0418\u043c\u044f: ',nm,'  \u0412\u043e\u0437\u0440\u0430\u0441\u0442: ',ag);\n    end;\n  end;\n\nvar p: Person := new Person('\u0418\u0432\u0430\u043d\u043e\u0432', 20);\n\nbegin\n  writeln('\u0418\u043c\u044f: ',p.Name);\n  p.Age := -1;\n  writeln('\u0412\u043e\u0437\u0440\u0430\u0441\u0442: ',p.Age);\nend."
  },
  {
    "instruction": "Create a 3D pyramid animation in PascalABC.NET using Graph3D with rotation animation.",
    "output": "uses Graph3D;\n\nbegin\n  var p := Pyramid(0,0,0,5,2,2,Colors.Red);\n  p.AnimRotate(OrtZ,360,5).Begin\nend."
  },
  {
    "instruction": "Create a numerical integration example in PascalABC.NET using Quanc8 adaptive quadrature to compute the integral of sin(x)/x.",
    "output": "uses NumLibABC;\n\nbegin\n  var f:real->real := x->x=0?1.0:sin(x)/x;\n  var oL := new Quanc8(f,0,2,1e-7,0);\n  Writeln(oL.Value);\nend."
  },
  {
    "instruction": "Create a singly linked list using references instead of pointers in PascalABC.NET",
    "output": "type \n  Node = class\n    data: integer;\n    next: Node;\n    constructor (d: integer; n: Node);\n    begin\n      data := d;\n      next := n;\n    end;\n  end;\n\nvar first: Node;\n  \nbegin\n  first := nil;\n  first := new Node(3,first);\n  first := new Node(7,first);\n  first := new Node(5,first);\n  \n  writeln('Singly linked list contents (using references instead of pointers): ');\n  var p := first;\n  while p<>nil do\n  begin\n    write(p.data,' ');\n    p := p.next;\n  end;\n  \n  first := nil;\nend."
  },
  {
    "instruction": "Demonstrate type reflection in PascalABC.NET by showing all members of DateTime type",
    "output": "// Type reflection. All members of DateTime type are displayed\nuses System,System.Reflection;\n\nbegin\n  var bf := BindingFlags.Public or BindingFlags.NonPublic or BindingFlags.Instance or BindingFlags.Static;\n  var t: &Type := typeof(DateTime);\n  var mi := t.GetMembers(bf);\n  foreach var m: MemberInfo in mi do\n    Println(m);\nend."
  },
  {
    "instruction": "Create a 3D scene with boxes and spheres using Graph3D in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin\n  var b := Box(0,0,0,3,1,2,Colors.Blue);\n  var s := Sphere(0,0,2,1,Colors.Green);\n  var b1 := b.Clone;\n  var s1 := s.Clone;\n \n  var g := Group(b,s);\n  var g1 := Group(b1,s1);\n  g1.MoveByY(3);\n  g.AddChild(g1[0]);\n  b1.MoveByY(3);\nend."
  },
  {
    "instruction": "Create another 3D scene with grouped objects using Graph3D in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin\n  var b := Box(0,0,0,3,1,2,Colors.Blue);\n  var s := Sphere(0,0,2,1,Colors.Green);\n  var b1 := Box(0,-3,0,3,1,2,Colors.Blue);\n  var s1 := Sphere(0,-3,2,1,Colors.Green);\n \n  var g := Group(b,s);\n  var g1 := Group(b1,s1);\n  g.AddChild(g1[0]);\n  Sleep(1000);\n  g.MoveByX(3);\n  Sleep(1000);\n  g1.MoveByY(4);\nend."
  },
  {
    "instruction": "Show repeat loop for input validation in PascalABC.NET",
    "output": "// Repeat loop. Input control\nbegin\n  var mark: integer;\n  repeat\n    Println('Enter grade (2..5):');\n    mark := ReadInteger;\n    if (mark < 2) or (mark > 5) then\n      Println('Grade is incorrect. Repeat input');\n  until (mark >= 2) and (mark <= 5);\n  Println('You entered grade', mark);\nend."
  },
  {
    "instruction": "Show while and repeat loops for implementing Euclidean algorithm in PascalABC.NET",
    "output": "// While loop. Euclidean algorithm for finding greatest common divisor\nbegin\n  var (A, B) := ReadInteger2('Enter two integers:');\n  while B <> 0 do\n    (A, B) := (B, A mod B);\n  Println('Greatest common divisor =', A);\nend.\n\n// Repeat loop. Euclidean algorithm for finding greatest common divisor\nbegin\n  Print('Enter two integers:');\n  var A := ReadInteger;\n  var B := ReadInteger;\n  repeat\n    var C := A mod B;\n    A := B;\n    B := C;\n  until B = 0;\n  Println('Greatest common divisor =', A);\nend."
  },
  {
    "instruction": "Isolate roots of equation using table method in PascalABC.NET with NumLibABC",
    "output": "uses NumLibABC;\n\nbegin\n  var f:real->real:=t->sin(t)/(1+Sqr(Exp(t)))-0.1;\n  var (a,b,h):=(-10,5,0.5);\n  var oL:=new RootsIsolation(f,a,b,h);\n  Println(oL.Value)\nend."
  },
  {
    "instruction": "Create a Rubik's cube simulation with 3D graphics - cube creation procedure in PascalABC.NET",
    "output": "uses Graph3D;\n\nvar InnerColor := RGB(70,70,70);\nvar sec := 0.5;\nvar g := new Object3D[3,3,3];\n\nprocedure CreateCube;\nbegin\n  var a := 1.03;\n\n  for var x := 0 to 2 do\n  for var y := 0 to 2 do\n  for var z := 0 to 2 do\n    if (x,y,z) <> (1,1,1) then\n    begin\n      var b := Box(0+x*a-a,0+y*a-a,-0.5+z*a-a,1,1,0.01,z=0 ? Colors.White : InnerColor);\n      var b3 := Box(0+x*a-a,0+y*a-a,0.5+z*a-a,1,1,0.01,z=2 ? Colors.Yellow : InnerColor);\n      \n      var b1 := Box(0.5+x*a-a,0+y*a-a,0+z*a-a,0.01,1,1,x=2 ? Colors.Red : InnerColor);\n      var b4 := Box(-0.5+x*a-a,0+y*a-a,0+z*a-a,0.01,1,1,x=0 ? Colors.Orange : InnerColor);\n    \n      var b2 := Box(0+x*a-a,0.5+y*a-a,0+z*a-a,1,0.01,1,y=2 ? Colors.Green : InnerColor);\n      var b5 := Box(0+x*a-a,-0.5+y*a-a,0+z*a-a,1,0.01,1,y=0 ? Colors.Blue : InnerColor);\n    \n      g[x,y,z] := Group(b,b1,b2,b3,b4,b5);\n    end;  \nend;"
  },
  {
    "instruction": "Implement generic shift procedures for Rubik's cube rotation in PascalABC.NET",
    "output": "procedure ShiftLeft<T>(var a,b,c,d: T);\nbegin\n  var v := a;\n  a := b;\n  b := c;\n  c := d;\n  d := v;\nend;\n\nprocedure ShiftRight<T>(var a,b,c,d: T);\nbegin\n  var v := d;\n  d := c;\n  c := b;\n  b := a;\n  a := v;\nend;"
  },
  {
    "instruction": "Implement right rotation procedure for Rubik's cube in PascalABC.NET",
    "output": "procedure RightRotate(n: integer := 1);\nbegin\n  IsAnimated := True;\n  var y := 2;\n  if n = 0 then exit;\n  for var x := 0 to 2 do\n  for var z := 0 to 2 do\n    g[x,y,z].AnimRotateAtAbsolute(OrtY,-90*n,Origin,sec*Abs(n),EndAnim).Begin;\n  \n  if n>0 then\n    loop Abs(n) do\n    begin  \n      ShiftLeft(g[1,y,0],g[0,y,1],g[1,y,2],g[2,y,1]);\n      ShiftLeft(g[2,y,0],g[0,y,0],g[0,y,2],g[2,y,2]);\n    end\n  else   \n    loop Abs(n) do\n    begin  \n      ShiftRight(g[1,y,0],g[0,y,1],g[1,y,2],g[2,y,1]);\n      ShiftRight(g[2,y,0],g[0,y,0],g[0,y,2],g[2,y,2]);\n    end\nend;"
  },
  {
    "instruction": "Implement scene initialization for Rubik's cube in PascalABC.NET",
    "output": "procedure InitScene;\nbegin\n  View3D.ShowGridLines := False;\n  Camera.Position := P3D(10,6,6);\n  Camera.LookDirection := V3D(-10,-6,-6);\n  Window.Title := 'Rubik''s Cube';\n  View3D.Title := 'Face rotation:';\n  View3D.SubTitle := 'F,B - front-back'#10'U,D - up-down'#10'L,R - left-right';\n  Lights.AddDirectionalLight(Colors.DarkGray,V3D(-2.0,0,0));\n  Lights.AddDirectionalLight(Colors.Gray,V3D(2.0,0,0));\n  Lights.AddDirectionalLight(RGB(150,150,150),V3D(0,0,2));\n  Lights.AddDirectionalLight(RGB(50,50,50),V3D(0,0,-2));\n  Lights.AddDirectionalLight(Colors.Gray,V3D(0,2,0));\nend;"
  },
  {
    "instruction": "Define Vec3 record with mathematical operations for ray tracing in PascalABC.NET",
    "output": "type\n  Vec3 = record\n    x, y, z: real;\n    class function operator+(v1, v2: Vec3): Vec3 := new Vec3(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);\n    class function operator-(v1, v2: Vec3): Vec3 := new Vec3(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);\n    class function operator-(v: Vec3): Vec3 := new Vec3(-v.x, -v.y, -v.z);\n    class function operator*(v: Vec3; r: real): Vec3 := new Vec3(v.x * r, v.y * r, v.z * r);\n    class function operator/(v: Vec3; r: real): Vec3 := new Vec3(v.x / r, v.y / r, v.z / r);\n    class function operator*(r: real; v: Vec3): Vec3 := new Vec3(v.x * r, v.y * r, v.z * r);\n    class function operator*(v1, v2: Vec3): real := v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n    function norm := Sqrt(x * x + y * y + z * z);\n    function normalize(l: real := 1): Vec3 := Self/norm;\n    function cross(v: Vec3): Vec3 := new Vec3(y * v.z - z * v.y, z * v.x - x * v.z, x * v.y - y * v.x);\n    constructor(xx,yy,zz: real); begin x := xx; y := yy; z := zz end;\n  end;"
  },
  {
    "instruction": "Implement sphere-ray intersection function for ray tracing in PascalABC.NET",
    "output": "type\n  TSphere = auto class \n    center: vec3;\n    radius: real;\n    material: TMaterial;\n    function RayIntersect(orig, dir: vec3; var t0: real): boolean;\n    begin\n      var L := center - orig;\n      var tca := L * dir;\n      var d2 := L * L - tca * tca;\n      if d2 > radius * radius then\n        begin Result := false; exit end;\n      var thc := Sqrt(radius * radius - d2);\n      t0 := tca - thc;\n      if t0 < 1e-3 then\n        t0 := tca + thc;\n      if t0 < 1e-3 then\n        Result := false\n      else Result := true;\n    end;\n  end;"
  },
  {
    "instruction": "Implement reflection and refraction functions for ray tracing in PascalABC.NET",
    "output": "function Reflect(I, N: vec3) := I - N * 2 * (I * N);\n\nfunction Refract(I, N: vec3; eta_t: real; eta_i: real := 1): vec3;\nbegin\n  var cosi := -max(-1.0, min(1.0, I * N));\n  if cosi < 0 then\n    begin Result := Refract(I, -N, eta_i, eta_t); exit end;\n  var eta := eta_i / eta_t;\n  var k := 1 - eta * eta * (1 - cosi * cosi);\n  Result := if k < 0 then v3(1, 0, 0) else I * eta + N * (eta * cosi - Sqrt(k));\nend;"
  },
  {
    "instruction": "Implement scene intersection function for ray tracing with checkerboard pattern in PascalABC.NET",
    "output": "function scene_intersect(orig, dir: vec3; spheres: array of TSphere; var hit, N: vec3; var material: TMaterial): boolean;\nbegin\n  var spheres_dist := real.MaxValue;\n  foreach var s in spheres do \n  begin\n    var dist_i: real;\n    if s.RayIntersect(orig, dir, dist_i) and (dist_i < spheres_dist) then\n    begin\n      spheres_dist := dist_i;\n      hit := orig + dir * dist_i;\n      N := (hit - s.center).normalize();\n      material := s.material;\n    end;\n  end;\n  \n  var checkerboard_dist := real.MaxValue;\n  if abs(dir.y) > 1e-3 then \n  begin\n    var d := -(orig.y + 4) / dir.y;\n    var pt := orig + dir * d;\n    if (d > 1e-3) and (abs(pt.x) < 15) and (pt.z < -8) and (pt.z > -35) and (d < spheres_dist) then \n    begin\n      checkerboard_dist := d;\n      hit := pt;\n      N := v3(0, 1, 0);\n      \n      material := new TMaterial;\n      var wave := 0.1 * sin(pt.x * 0.5) * sin(pt.z * 0.3);\n      var checker := (Trunc(0.5 * hit.x + 1000) + Trunc(0.5 * hit.z)) and 1;\n      \n      if checker = 1 then\n        material.diffuse_color := v3(0.4 + wave, 0.4 + wave, 0.4 + wave)\n      else\n        material.diffuse_color := v3(0.2 + wave, 0.15 + wave, 0.1 + wave);\n      \n      material.albedo := v4(0.8, 0.2, 0.0, 0.0);\n      material.specular_exponent := 20;\n      material.refractive_index := 1.0;\n      material.emission := v3(0, 0, 0);\n    end;\n  end;\n  \n  Result := Min(spheres_dist, checkerboard_dist) < 1000;\nend;"
  },
  {
    "instruction": "Implement main ray casting function with lighting and materials in PascalABC.NET",
    "output": "function cast_ray(orig, dir: vec3; spheres: array of TSphere; lights: array of TLight; depth: integer := 0): vec3;\nbegin\n  var point,N: Vec3;\n  var material := new TMaterial;\n  \n  if (depth > 5) or not scene_intersect(orig, dir, spheres, point, N, material) then\n  begin\n    var t := 0.5 * (dir.y + 1.0);\n    Result := (1.0 - t) * v3(1.0, 1.0, 1.0) + t * v3(0.3, 0.7, 1.0);\n    exit;\n  end;\n  \n  var emission_intensity := 1.0;\n  if material.emission.norm > 0 then\n  begin\n    var found_sphere: TSphere := nil;\n    foreach var s in spheres do\n    begin\n      var dist_to_center := (point - s.center).norm;\n      if dist_to_center <= s.radius + 0.001 then\n      begin\n        found_sphere := s;\n        break;\n      end;\n    end;\n    \n    if found_sphere <> nil then\n    begin\n      var dist_from_center := (point - found_sphere.center).norm;\n      var radius_ratio := dist_from_center / found_sphere.radius;\n      emission_intensity := 1.0 - radius_ratio * radius_ratio;\n      emission_intensity := max(0.1, emission_intensity);\n    end;\n  end;\n  \n  var result_color := material.emission * emission_intensity;\n  \n  var reflect_dir := Reflect(dir, N).normalize();\n  var refract_dir := Refract(dir, N, material.refractive_index).normalize();\n  var reflect_color := cast_ray(point, reflect_dir, spheres, lights, depth + 1);\n  var refract_color := cast_ray(point, refract_dir, spheres, lights, depth + 1);\n  \n  var (diffuse_light_intensity, specular_light_intensity) := (0.0, 0.0);\n  var color_influence := new Vec3(0, 0, 0);\n  \n  foreach var light in lights do\n  begin\n    var light_dir := (light.position - point).normalize;\n    var light_distance := (light.position - point).norm;\n    \n    var shadow_pt, trashnrm: vec3;\n    var trashmat: TMaterial;\n    if scene_intersect(point, light_dir, spheres, shadow_pt, trashnrm, trashmat) and\n                ((shadow_pt - point).norm < light_distance) then\n      continue;\n    \n    var attenuation := 1.0 / (1.0 + 0.01 * light_distance);\n    \n    diffuse_light_intensity += light.intensity * max(0, light_dir * N) * attenuation;\n    specular_light_intensity += max(0, -Reflect(-light_dir, N) * dir) ** material.specular_exponent * light.intensity * attenuation;\n    \n    var light_contrib := light.color * light.intensity * max(0, light_dir * N) * attenuation;\n    color_influence := color_influence + light_contrib;\n  end;\n  \n  var diffuse_component := v3(material.diffuse_color.x * color_influence.x, \n                              material.diffuse_color.y * color_influence.y, \n                              material.diffuse_color.z * color_influence.z) * material.albedo.x0;\n  \n  result_color := result_color + diffuse_component + \n      v3(1.0, 1.0, 1.0) * specular_light_intensity * material.albedo.x1 + \n      reflect_color * material.albedo.x2 + \n      refract_color * material.albedo.x3;\n  \n  Result := result_color;\nend;"
  },
  {
    "instruction": "Fix integer division by zero runtime error with proper validation",
    "output": "// See what runtime error looks like with integer division by 0\n\nbegin\n  var i: integer := 0;\n  if i <> 0 then\n    Print(2 div i)\n  else\n    Println('Error: Division by zero is not allowed');\nend."
  },
  {
    "instruction": "Show that real division by zero doesn't cause runtime error in PascalABC.NET",
    "output": "var r: real := 0;\n\nbegin\n  Write(1/r);\nend."
  },
  {
    "instruction": "Show that working with real numbers cannot cause runtime errors in PascalABC.NET",
    "output": "// When working with real numbers it's impossible to get runtime error \nbegin\n  Println(Sqrt(-1)); // Output: NaN (Not a Number)\nend."
  },
  {
    "instruction": "Implement selection sort algorithm for real numbers in PascalABC.NET",
    "output": "procedure SelectionSort(a: array of real);\nbegin\n  for var i:=0 to a.Length-2 do\n  begin\n    var (min,ind) := (a[i],i); \n    for var j:=i+1 to a.Length-1 do\n      if a[j]<min then\n        (min,ind) := (a[j],j); \n    a[ind] := a[i];\n    a[i] := min;\n  end;\nend;\n\nbegin\n  var a := SeqRandomReal(20).Select(r->r.Round(2)).ToArray;\n  Println('Array contents: ');\n  a.Println;\n  SelectionSort(a);\n  Println('After selection sort: ');\n  a.Println;\nend."
  },
  {
    "instruction": "Create a sequence and print it in PascalABC.NET",
    "output": "begin\n  Seq(1,5,3,2,4).Print;\nend."
  },
  {
    "instruction": "Serialize and deserialize objects in PascalABC.NET",
    "output": "type \n  [Serializable]\n  Node = auto class\n    x: integer;\n    next: Node;\n  end;\n\nconst fname = 'a.dat';\n\nbegin\n  var m := new Node(5,new Node(3,new Node(4,nil)));\n  Serialize(fname,m);\n  var m1 := Deserialize(fname) as Node;\n  Print(m1);\nend."
  },
  {
    "instruction": "Serialize multiple objects to binary file in PascalABC.NET",
    "output": "type \n  [Serializable]\n  My = auto class\n    x,y: integer;\n  end;\n  IntArray = array of integer;\n\nconst fname = 'a.dat';\n\nbegin\n  var f := CreateBinary(fname);\n  f.Serialize(new My(444,555));\n  f.Serialize(|1,2,3|);\n  f.Serialize(Lst(1..9));\n  f.Close;\n  \n  f := OpenBinary(fname);\n  var m: My := f.Deserialize as My;\n  var a: array of integer := f.Deserialize as IntArray;\n  var l: List<integer> := f.Deserialize as List<integer>;\n  f.Close;\n  \n  Print(m,a,l);\nend."
  },
  {
    "instruction": "Show records with constructors and overridden ToString method in PascalABC.NET",
    "output": "// Illustration of constructors and methods in records\n// If ToString method is overridden, it's called when outputting object of this type by writeln procedure\ntype\n  SexType = (Male, Female);\n  Person = record\n    Name: string;\n    Age, Weight: integer;\n    Sex: SexType;\n    constructor (Name: string; Age, Weight: integer; Sex: SexType);\n    begin\n      Self.Name := Name;\n      Self.Age := Age;\n      Self.Sex := Sex;\n      Self.Weight := Weight;\n    end;\n    function ToString: string; override;\n    begin\n      Result := $'Name: {Name}   Sex: {Sex}   Age: {Age}   Weight: {Weight}';\n    end;\n  end;\n  \nbegin\n  var p: Person := new Person('Ivanov',20,70,SexType.Male);\n\n  Println(p);\nend."
  },
  {
    "instruction": "Create a simple shooter game with player, monsters and bullets using WPFObjects in PascalABC.NET",
    "output": "uses WPFObjects,Timers;\n\ntype \n  BulletWPF = class(CircleWPF) end;\n  MonsterWPF = class(SquareWPF) end;\n  PlayerWPF = class(EllipseWPF) end;\n\nbegin\n  var Player := new PlayerWPF(GraphWindow.Center, 30, 50, RandomColor);\n  Player.Velocity := 100;\n  Player.Number := 0;\n  \n  loop 5 do\n  begin\n    var m := new MonsterWPF(750,Random(10,550),30,RandomColor);\n    m.Velocity := 50;\n  end;  \n  \n  OnMouseMove := (x,y,mb) -> Player.RotateToPoint(x,y);\n  \n  OnMouseDown := (x,y,mb) -> begin\n    var cc := new BulletWPF(Player.CenterTop,5,Colors.Red);\n    cc.Direction := (x-Player.Center.X,y-Player.Center.Y);\n    cc.Velocity := 300;\n  end;\n  \n  var kl,kr,ku,kd: boolean;\n\n  OnDrawFrame := dt -> begin\n    Window.Title := 'Object count: '+Objects.Count;\n    if kr then \n      Player.Dx := 1\n    else if kl then \n      Player.Dx := -1\n    else Player.Dx := 0;  \n    if ku then \n      Player.Dy := -1\n    else if kd then \n      Player.Dy := 1\n    else Player.Dy := 0; \n    \n    for var i:=Objects.Count-1 downto 0 do\n    begin\n      var o := Objects[i];\n      if o is MonsterWPF then \n        o.Direction := (Player.Center.X - o.Center.X,Player.Center.Y-o.Center.Y);\n      o.MoveTime(dt);\n    end;\n    \n    if Player.IntersectionList.Any(o -> o is MonsterWPF) then\n    begin\n      // Game over\n    end;\n  end;\n  \n  CreateTimerAndStart(100,procedure ->\n  begin\n    for var i:=Objects.Count-1 downto 0 do\n    begin\n      var o := Objects[i];\n      if o.OutOfGraphWindow and not (o is PlayerWPF) then \n        o.Destroy;   \n      if o is BulletWPF then\n        foreach var x in o.IntersectionList do\n          if x is MonsterWPF then\n          begin\n            x.Destroy;\n            o.Destroy;\n            Player.Number += 1;\n            break;\n          end;\n    end;\n  end);\n  \n  CreateTimerAndStart(1000,procedure ->\n  begin\n    var x := if Random(2)=0 then 750 else 50;\n    var m := new MonsterWPF(x,Random(10,550),30,RandomColor);\n    m.Velocity := 50;\n  end);\n  \n  OnKeyDown := k ->\n  begin\n    case k of\n      Key.w,Key.Up: begin ku := true; kd := false; end; \n      Key.s,Key.Down: begin kd := true; ku := false; end;\n      Key.a,Key.Left: begin kl := true; kr := false; end;\n      Key.d,Key.Right: begin kr := true; kl := false end;\n    end;  \n  end;\n\n  OnKeyUp := k ->\n  begin\n    case k of\n      Key.w,Key.Up: ku := false;\n      Key.s,Key.Down: kd := false;\n      Key.a,Key.Left: kl := false;\n      Key.d,Key.Right: kr := false;\n    end;  \n  end;\nend."
  },
  {
    "instruction": "Create an enhanced shooter game with interface, game states and controls in PascalABC.NET",
    "output": "uses WPFObjects, Timers, Controls;\n\ntype\n  BulletWPF = class(CircleWPF) end;\n  MonsterWPF = class(SquareWPF) end;\n  PlayerWPF = class(EllipseWPF) end;\n  TGameState = (Paused, Started, EndOfGame);\n\nvar\n  GameState: TGameState := Paused;\n  sb: StatusBarWPF;\n  bstart, bstop, bnewgame: ButtonWPF;\n  Player: PlayerWPF;\n  kl, kr, ku, kd: boolean;\n\nprocedure InitGame;\nbegin\n  Player := new PlayerWPF(GraphWindow.Center, 30, 50, RandomColor);\n  Player.Velocity := 100;\n  Player.Number := 0;\n  \n  loop 10 do\n  begin\n    var m := new MonsterWPF(750, Random(10, 550), 30, RandomColor);\n    m.Velocity := 50;\n  end;\nend;\n\nprocedure NewGame;\nbegin\n  sb.Text := '';\n  Objects.Clear;\n  InitGame;\nend;\n\nprocedure GameOver;\nbegin\n  sb.Text := 'Player died';\n  GameState := EndOfGame;\n  bstart.Enabled := False;\n  bstop.Enabled := False;\n  bnewgame.Enabled := True;\n  Player.Color := Colors.Black;\nend;\n\nprocedure GameOverWin;\nbegin\n  sb.Text := 'Victory!';\n  GameState := EndOfGame;\n  bstart.Enabled := False;\n  bstop.Enabled := False;\n  bnewgame.Enabled := True;\n  Player.Color := Colors.Yellow;\nend;"
  },
  {
    "instruction": "Implement interface initialization and game procedures for shooter game in PascalABC.NET",
    "output": "procedure InitInterface;\nbegin\n  Window.SetSize(1000, 600);\n  LeftPanel(200, Colors.Orange);\n  bstart := Button('Start');\n  bstop := Button('Stop');\n  bnewgame := Button('New game');\n  bstop.Enabled := False;\n  bstart.Enabled := False;\n  bstart.Click := procedure \u2192 begin\n    GameState := Started;\n    bstart.Enabled := False;\n    bstop.Enabled := True;\n  end;\n  bstop.Click := procedure \u2192 begin\n    GameState := Paused;\n    bstart.Enabled := True;\n    bstop.Enabled := False;\n  end;\n  bNewGame.Click := procedure \u2192 begin\n    GameState := Started;\n    bnewgame.Enabled := False;\n    bstart.Enabled := False;\n    bstop.Enabled := True;\n    NewGame;\n  end;\n  sb := StatusBar;\nend;\n\nprocedure KillMonstersHandler;\nbegin\n  if GameState <> Started then \n    exit;\n  Objects.DestroyAll(o \u2192 o.OutOfGraphWindow and not (o is PlayerWPF));\n  foreach var o in Objects do\n  begin\n    if o is BulletWPF then\n      foreach var x in o.IntersectionList do\n        if x is MonsterWPF then\n        begin\n          x.Destroy;\n          o.Destroy;\n          Player.Number += 1;\n          break;\n        end;\n  end;\nend;\n\nprocedure DrawFrame(dt: real);\nbegin\n  if GameState <> Started then exit;\n  Window.Title := 'Object count: ' + Objects.Count;\n  \n  if kr then \n    Player.Dx := 1\n  else if kl then \n    Player.Dx := -1\n  else Player.Dx := 0;  \n  if ku then \n    Player.Dy := -1\n  else if kd then \n    Player.Dy := 1\n  else Player.Dy := 0; \n  \n  foreach var o in Objects do\n  begin\n    if o is MonsterWPF then \n      o.Direction := (Player.Center.X - o.Center.X, Player.Center.Y - o.Center.Y);\n    o.MoveTime(dt);\n  end;\n  \n  if Player.IntersectionList.Any(o \u2192 o is MonsterWPF) then\n    GameOver;\n\n  if Player.Number >= 10 then\n    GameOverWin;\nend;"
  },
  {
    "instruction": "Demonstrate usage of generic types with short type names in template parameters in PascalABC.NET",
    "output": "begin\n  var q := new Queue<(integer,integer)>;\n  q.Enqueue((1,2));\n  q.Enqueue((2,5));\n  q.Println;\n  Println(q);\n  \n  var l := new List<integer->integer>;\n  l.Add(x->x);\n  l.Add(x->x*x);\n  l.ForEach(f->Print(f(5)));\n  Println;\n  \n  var l1 := new List<(integer,integer)->integer>;\n  l1.Add((x,y)->x+y);\n  l1.Add((x,y)->x-y);\n  l1.Add((x,y)->x*y);\n  l1.ForEach(f->Print(f(2,3)));\nend."
  },
  {
    "instruction": "Demonstrate simple new language features in PascalABC.NET including variable initialization and type inference",
    "output": "// Simple new features of PascalABC.NET language\n\n// Variable initialization at declaration \nvar i: integer := 1; \n\n// Automatic variable type inference at initialization\nvar r := 2.5;\n\nbegin\n  // In-block variable declarations\n  var s: real := 1.0;\n  \n  // Variable declaration in loop header (variable lifetime - until end of loop body)\n  for var j: integer := 1 to 10 do\n    s += j; // += operation for numbers\n\n  var p := 1;\n  \n  // Variable declaration in loop header with automatic type inference\n  for var j := 1 to 10 do\n    p *= j; // *= operation\n    \n  var str := '';\n  for var c: char := 'a' to 'z' do\n    str += c; // += operation for strings\n  \nend."
  },
  {
    "instruction": "Create a simple text editor using CRT in PascalABC.NET",
    "output": "uses CRT;\n\nbegin\n  SetWindowTitle('Text editor (Enter - new line, Esc - exit)');\n  clrScr;\n  repeat\n    var c := ReadKey;\n    case c of\n  #13: writeln;\n  #27: break;\n  #32..#255: write(c);\n  #0: c := ReadKey;\n    end;\n  until false;\nend."
  },
  {
    "instruction": "Solve system of linear equations using NumLibABC in PascalABC.NET",
    "output": "uses NumLibABC;\n\nbegin\n  var A:=new Matrix(3,3,2,3,-1,1,-2,1,1,0,2);\n  var B:=new Vector(9,3,2);\n  var cond:real;\n  var x:=A.SLAU(B,cond);\n  x.Println;\n  Writeln('Condition number = ',cond)\nend."
  },
  {
    "instruction": "Implement selection sort algorithm with helper procedures in PascalABC.NET",
    "output": "procedure SortByChoice(a: array of real);\nbegin\n  for var i:=0 to a.Length-2 do\n  begin\n    var min := a[i]; \n    var ind := i;\n    for var j:=i+1 to a.Length-1 do\n      if a[j]<min then\n      begin\n        min := a[j];\n        ind := j;\n      end;\n    a[ind] :=a [i];\n    a[i] := min;\n  end;\nend;\n\nprocedure WriteArr(a: array of real); \nbegin\n  foreach x: real in a do\n    write(x,' ');\n  writeln;\nend;\n\nfunction CreateRandomArr(n: integer): array of real; \nbegin\n  Result := new real[n];\n  for var i:=0 to Result.Length-1 do\n    Result[i] := Random(100);\nend;\n\nvar a: array of real;\n\nbegin\n  a := CreateRandomArr(20);\n  writeln('Array contents: ');\n  WriteArr(a);\n  SortByChoice(a);\n  writeln('After selection sort: ');\n  WriteArr(a);\nend."
  },
  {
    "instruction": "Sort array of tuples using key projection in PascalABC.NET",
    "output": "begin\n  var pp := |('Sidorov',21),('Petrov',23), ('Popov',20),('Ivanov',22)|;\n  Sort(pp, p->p[0]);\n  Println('By last name');\n  pp.Println;\n  Sort(pp, p->p[1]);\n  Println('By age');\n  pp.Println;\nend."
  },
  {
    "instruction": "Create 3D spheres animation using Graph3D in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin\n  Window.Title := 'Creation of objects... wait!';\n  HideObjects;\n  View3D.ShowGridLines := False;\n  View3D.ShowViewCube := False;\n  View3D.ShowCoordinateSystem := False;\n  \n  var l := new List<SphereT>;\n  \n  var w := 1;\n  for var x := -5 to 5 do\n  for var y := -5 to 5 do\n  for var z := -5 to 5 do\n     l.Add(Sphere(x*w,y*w,z*w,w*0.5,RandomColor));\n  ShowObjects;\n\n  Window.Title := 'Spheres animation';\n  \n  foreach var x in l do\n    x.AnimMoveBy(Random,Random,Random).AutoReverse.Forever.Begin;\nend."
  },
  {
    "instruction": "Perform cubic spline interpolation using NumLibABC in PascalABC.NET",
    "output": "uses NumLibABC;\n\nbegin\n  var f:real->real:=x->(3*x-8)/(8*x-4.1);\n  var pt:=PartitionPoints(1.0,10.0,18).Select(x->new Point(x,f(x))).ToArray;\n  var oL:=new Spline(pt);\n  var r:=oL.Value(4.8);\n  Writeln('Value of approximated function for x=4.8: ',r);\n  var (d1,d2):=oL.Diff(4.8);\n  Writeln('Values of 1st and 2nd derivatives at this point: ',d1,' ',d2)\nend."
  },
  {
    "instruction": "Calculate square root using iterative method in PascalABC.NET",
    "output": "var x := 2.0;\nSeqGen(6,x,a \u2192 (a + x/a) / 2).Last.Println;\nx.Sqrt.Print;"
  },
  {
    "instruction": "Demonstrate array and set operations with square brackets in PascalABC.NET",
    "output": "begin\n  var a := [1,2,3];\n  Println(a,TypeName(a));\n  var s := [2..4];\n  Println(s,TypeName(s));\n  var s1: set of byte := [3,4,5];\n  Println(s1,TypeName(s1));\n  Println(s + [1,2,3], s * [1,2,3], [1,2,3] - s, s - [1,2,3]); \n  Println(a + [7,8,9], a * 3);\n  Println(5 in [3,5,7], 5 in [3..5,7]);\nend."
  },
  {
    "instruction": "Use pattern matching to calculate areas of different shapes in PascalABC.NET",
    "output": "type\n  Line = class\n  end;\n  Rectangle = auto class\n    X,Y,Width,Height: real;\n  end;\n  Circle = auto class\n    X,Y,Radius: real;\n  end;\n  \nbegin\n  var l := new List<Object>;\n  l.Add(new Line);\n  l.Add(new Circle(10,10,5));\n  l.Add(new Rectangle(10,10,20,10));\n  foreach var x in l do\n    match x with\n  Line(var ll): Println('Line S =',0);\n  Circle(var c): Println('Circle S =',c.Radius*c.Radius*Pi);\n  Rectangle(var r): Println('Rectangle S =',r.Width*r.Height);\n    end;\nend."
  },
  {
    "instruction": "Implement a generic stack class using arrays in PascalABC.NET",
    "output": "type\n  Stack<T> = class\n  private\n    a: array of T;\n    last: integer;\n  public  \n    constructor Create(sz: integer);\n    begin\n      SetLength(a,sz);\n      last := 0;\n    end;\n    constructor Create;\n    begin\n      Create(100);\n    end;\n    procedure push(i: T);\n    begin\n      a[last] := i;\n      Inc(last);\n    end;\n    function pop: T;\n    begin\n      Dec(last);\n      pop := a[last];\n    end;\n    function top: T;\n    begin\n      top := a[last-1];\n    end;\n    function empty: boolean;\n    begin\n      Result := (last=0);\n    end;\n    function ToString: string; override;\n    begin\n      Result := '';\n      for var i:=0 to last-1 do\n        Result += a[i]+' ';\n    end;\n  end;\n  \nvar s: Stack<integer>;\n\nbegin\n  s := new Stack<integer>;\n  s.push(7);\n  s.push(2);\n  s.push(5);\n  s.push(4);\n  writeln(s);\n  while not s.empty do\n    write(s.pop,' ');\nend."
  },
  {
    "instruction": "Serialize and deserialize a single object in PascalABC.NET",
    "output": "type \n  [Serializable]\n  My = auto class\n    x,y: integer;\n  end;\n\nconst fname = 'a.dat';\n\nbegin\n  var m := new My(2,3);\n  Serialize(fname,m);\n  var m1 := Deserialize(fname) as My;\n  Print(m1);\nend."
  },
  {
    "instruction": "Draw pixels using SetPixel function in GraphABC in PascalABC.NET",
    "output": "uses GraphABC;\n\nbegin\n  for var x:=0 to Window.Width-1 do\n  for var y:=0 to Window.Height-1 do\n    SetPixel(x,y,RGB(2*x-y,x-3*y,x+y));\nend."
  },
  {
    "instruction": "Draw pixels using SetPixel function in GraphWPF in PascalABC.NET",
    "output": "uses GraphWPF;\n\nbegin\n  Window.SetSize(640, 480);\n  for var x := 0 to Window.Width.Round do\n  for var y := 0 to Window.Height.Round do\n    SetPixel(x, y, RGB(2 * x - y, x - 3 * y, x + y));\n  Milliseconds.Println;  \nend."
  },
  {
    "instruction": "Draw pixels using SetPixels function for better performance in GraphWPF in PascalABC.NET",
    "output": "uses GraphWPF;\n\nbegin\n  Window.SetSize(640, 480);\n  SetPixels(0,0,640,480,(x, y)->RGB(2 * x - y, x - 3 * y, x + y));\n  Milliseconds.Println;  \nend."
  },
  {
    "instruction": "Show how to work with sets of strings in PascalABC.NET including union, intersection, and difference operations",
    "output": "// Working with sets\n// Base type for set can be arbitrary\n\nbegin\n  var s1: set of string := ['Ivanov','Popov','Sidorova','Petrov'];\n  var s2: set of string := ['Kozlov','Petrov','Ivanov'];\n  Println('Set s1:',s1);\n  Println('Set s2:',s2);\n  Println('Union of sets s1 and s2:',s1+s2);\n  Println('Intersection of sets s1 and s2:',s1*s2);\n  Println('Difference of sets s1 and s2:',s1-s2);\n  Include(s1,'Umnov');\n  Exclude(s1,'Ivanov');\n  Println('Set s1:',s1);\nend."
  },
  {
    "instruction": "Demonstrate shl (shift left) operation to calculate powers of 2 in PascalABC.NET",
    "output": "begin\n  Writeln('Powers of two');\n  Writeln(' n         2^n');\n  for var i:=0 to 30 do\n    Writeln(i:2,(1 shl i):12);\nend."
  },
  {
    "instruction": "Create a text stamp class with move functionality in PascalABC.NET",
    "output": "uses GraphABC;\n\ntype \n  TextStamp = auto class\n    x,y,pt: integer;\n    Text: string;\n    procedure Stamp;\n    begin\n      Font.Size := pt;\n      TextOut(x,y,text);\n    end;\n    procedure MoveOn(dx,dy: integer);\n    begin\n      x += dx; y += dy;\n    end;\n  end;\n  \nbegin\n  var txt := new TextStamp(200,200,14,'\u041f\u0440\u0438\u0432\u0435\u0442!');\n  txt.Stamp;\n  txt.MoveOn(0,40);\n  txt.Text := '\u0414\u043e \u0441\u0432\u0438\u0434\u0430\u043d\u0438\u044f!';\n  txt.Stamp;\nend."
  },
  {
    "instruction": "Create a cross stamp class with cloning and relative movement in PascalABC.NET",
    "output": "uses GraphABC;\n\ntype \n  CrossStamp = class\n    x,y,w: integer;\n    constructor (xx,yy,ww: integer);\n    begin\n      x := xx; y := yy;\n      w := ww; \n    end;\n    procedure Stamp;\n    begin\n      MoveTo(x,y);\n      LineTo(x+w,y);\n      LineTo(x+w,y+w);\n      LineTo(x+2*w,y+w);\n      LineTo(x+2*w,y);\n      LineTo(x+3*w,y);\n      LineTo(x+3*w,y-w);\n      LineTo(x+2*w,y-w);\n      LineTo(x+2*w,y-2*w);\n      LineTo(x+w,y-2*w);\n      LineTo(x+w,y-w);\n      LineTo(x,y-w);\n      LineTo(x,y);\n    end;\n    procedure MoveOn(dx,dy: integer);\n    begin\n      x += dx; y += dy;\n    end;\n    procedure MoveOnRel(a,b: integer);\n    begin\n      MoveOn(a*w,b*w);\n    end;\n    function Clone := new CrossStamp(x,y,w);\n  end;\n  \nbegin\n  var r := new CrossStamp(100,150,20);\n  for var k:=1 to 2 do\n  begin\n    var r1 := r.Clone;\n    for var i:=1 to 8 do\n    begin\n      r1.Stamp;\n      r1.MoveOnRel(2,1);\n    end;\n    r.MoveOnRel(-1,2);\n  end;\nend."
  },
  {
    "instruction": "Create a compound stamp class combining rectangle and text in PascalABC.NET",
    "output": "uses GraphABC;\n\ntype \n  TextStamp = class\n    x,y,pt: integer;\n    Text: string;\n    constructor (xx,yy,ppt: integer; t: string);\n    begin\n      x := xx; y := yy;\n      pt := ppt; \n      text := t;\n    end;\n    procedure Stamp;\n    begin\n      Font.Size := pt;\n      Brush.Color := clWhite;\n      TextOut(x,y,text);\n    end;\n    procedure MoveOn(dx,dy: integer);\n    begin\n      x += dx; y += dy;\n    end;\n  end;\n  \n  RectangleStamp = class\n    x,y,w,h: integer;\n    constructor (xx,yy,ww,hh: integer);\n    begin\n      x := xx; y := yy;\n      w := ww; h := hh;\n    end;\n    procedure Stamp;\n    begin\n      Brush.Color := clRandom;\n      Rectangle(x,y,x+w,y+h);\n    end;\n    procedure MoveOn(dx,dy: integer);\n    begin\n      x += dx; y += dy;\n    end;\n  end;\n  \n  RectWithTextStamp = class\n    x,y,w,h: integer;\n    Text: string;\n    constructor (xx,yy,ww,hh: integer; t: string);\n    begin\n      x := xx; y := yy;\n      w := ww; h := hh;\n      text := t;\n    end;\n    procedure Draw;\n    begin\n      var r := new RectangleStamp(x,y,w,-h);\n      var t := new TextStamp(x,y+3,10,Text);\n      r.Stamp;\n      t.Stamp;\n    end;\n    procedure MoveOn(dx,dy: integer);\n    begin\n      x += dx; y += dy;\n    end;\n  end;"
  },
  {
    "instruction": "Create a function stamp class for plotting mathematical functions in PascalABC.NET",
    "output": "uses GraphABC;\n\ntype \n  FuncType = function (r: real): real;\n  FuncStamp = class\n    xs0,ys0,ws,hs: integer;\n    xf0,yf0,wf,hf: real;\n    f: FuncType;\n    constructor (xs0p,ys0p,xs1p,ys1p: integer; xf0p,yf0p,xf1p,yf1p: real; ff: FuncType);\n    begin\n      SetScreenWindow(xs0p,ys0p,xs1p,ys1p);\n      SetFuncWindow(xf0p,yf0p,xf1p,yf1p);\n      f := ff;\n    end;\n    function WorldToScreenX(xf: real): integer;\n    begin\n      var a := ws/wf;\n      var b := xs0-a*xf0;\n      Result := Round(a * xf + b);\n    end;\n    function WorldToScreenY(yf: real): integer;\n    begin\n      var c := hs/hf;\n      var d := ys0-c*yf0;\n      Result := hs + 2*ys0 - Round(c * yf + d);\n    end;\n    procedure Stamp;\n    const n = 100;\n    begin\n      Pen.Color := Color.Gray;\n      Rectangle(xs0,ys0,xs0+ws,ys0+hs);\n      Pen.Color := Color.Black;\n      var x := xf0;\n      var y := f(x);\n      var h := wf/n;\n      var xs := WorldToScreenX(x);\n      var ys := WorldToScreenY(y);\n      MoveTo(xs,ys);\n      for var i:=1 to n do\n      begin\n        x += h;\n        y := f(x);\n        xs := WorldToScreenX(x);\n        ys := WorldToScreenY(y);\n        LineTo(xs,ys);\n      end;  \n    end;\n    procedure SetScreenWindow(xs0p,ys0p,xs1p,ys1p: integer);\n    begin\n      xs0 := xs0p; ys0 := ys0p;\n      ws := xs1p-xs0p; hs := ys1p-ys0p;\n    end;\n    procedure SetFuncWindow(xf0p,yf0p,xf1p,yf1p: real);\n    begin\n      xf0 := xf0p; yf0 := yf0p;\n      wf := xf1p-xf0p; hf := yf1p-yf0p;\n    end;\n    procedure MoveOn(dx,dy: integer);\n    begin\n      xs0 += dx; ys0 += dy;\n    end;\n  end;"
  },
  {
    "instruction": "Create a regular polygon stamp class with cloning in PascalABC.NET",
    "output": "uses GraphABC;\n\ntype \n  RegularPolygonStamp = class\n    x,y,r: real;\n    n: integer;\n    constructor (xx,yy,rr: real; nn: integer);\n    begin\n      x := xx; y := yy;\n      r := rr; n := nn;\n    end;\n    procedure Stamp;\n    begin\n      var t := 0.0;\n      var xr := r*cos(t);\n      var yr := r*sin(t);\n      MoveTo(Round(x + xr),Round(y + yr));\n      for var i:=1 to n do\n      begin\n        t += 2*Pi/n;\n        xr := Round(r*cos(t));\n        yr := Round(r*sin(t));\n        LineTo(Round(x + xr),Round(y + yr));\n      end;  \n    end;\n    procedure MoveOn(dx,dy: real);\n    begin\n      x += dx; y += dy;\n    end;\n    function Clone: RegularPolygonStamp;\n    begin\n      Result := new RegularPolygonStamp(x,y,r,n);\n    end;\n  end;\n  \nbegin\n  var r := new RegularPolygonStamp(Window.Center.X,Window.Center.Y,50,6);\n  r.Stamp;\n  var t := 2*Pi/12;\n  var rr := r.r*sqrt(3)+10;\n  for var i:=1 to 6 do\n  begin\n    var r1 := r.Clone;\n    r1.MoveOn(rr*cos(t),rr*sin(t));\n    r1.Stamp;\n    t += 2*Pi/6;\n  end;\nend."
  },
  {
    "instruction": "Display sizes of standard data types in PascalABC.NET",
    "output": "var \n  i: integer;\n  j: shortint;\n  k: smallint;\n  l: longint;\n  i64: int64;\n  b: byte;\n  w: word;\n  lw: longword;\n  car: cardinal;\n  ui64: uint64;\n  r: real;\n  d: double;\n  sn: single;\n  c: char;\n  \nbegin\n  writeln('sizeof(integer) = ':20, sizeof(integer));\n  writeln('sizeof(shortint) = ':20,sizeof(shortint));\n  writeln('sizeof(smallint) = ':20,sizeof(smallint));\n  writeln('sizeof(longint) = ':20, sizeof(longint));\n  writeln('sizeof(int64) = ':20,   sizeof(int64));\n  writeln('sizeof(byte) = ':20,    sizeof(byte));\n  writeln('sizeof(word) = ':20,    sizeof(word));\n  writeln('sizeof(longword) = ':20,sizeof(longword));\n  writeln('sizeof(cardinal) = ':20,sizeof(cardinal));\n  writeln('sizeof(uint64) = ':20,  sizeof(uint64));\n  writeln('sizeof(real) = ':20,    sizeof(real));\n  writeln('sizeof(double) = ':20,  sizeof(double));\n  writeln('sizeof(single) = ':20,  sizeof(single));\n  writeln('sizeof(char) = ':20,    sizeof(char));\nend."
  },
  {
    "instruction": "Show standard mathematical functions and string concatenation in PascalABC.NET",
    "output": "// Standard functions\n\nbegin\n  var x := ReadReal('Enter x:');\n  Println('Square of', x, 'equals', Sqr(x));\n  Println(x, 'to power 5 equals', Power(x, 5));\n  Println('Square root of', x, 'equals', Sqrt(x));\n  Println('Absolute value of', x, 'equals', Abs(x));\n  Println('Natural logarithm of', x, 'equals', Ln(x));\n  Println('Sine of', x, 'equals', Sin(x));\n  Println('Cosine of', x, 'equals', Cos(x));\nend.\n\n// String concatenation\n\nbegin\n  var s1 := 'Pascal';\n  var s2 := 'NET';\n  Writeln(s2, '-', s1);\n  Writeln(s1, '.', s2);\nend."
  },
  {
    "instruction": "Draw a star using polar coordinates in PascalABC.NET",
    "output": "uses GraphABC;\n\nconst \n  n = 17;\n  n1 = 7;\n\nbegin\n  var a := -Pi/2;\n  var Center := Window.Center;\n  var Radius := Window.Height/2.2;\n  MoveTo(Round(Center.X+Radius*cos(a)),Round(Center.Y+Radius*sin(a)));\n  for var i:=1 to n do\n  begin\n    a += n1*2*Pi/n;\n    LineTo(Round(Center.X+Radius*cos(a)),Round(Center.Y+Radius*sin(a)));\n  end;\nend."
  },
  {
    "instruction": "Create object movement and rotation controls using WPFObjects in PascalABC.NET",
    "output": "uses Controls,WPFObjects;\n\nbegin\n  Window.Title := 'Controls module - StatusBar';\n  var l := LeftPanel(180,Colors.Orange);\n  \n  var c := new RectangleWPF(50,200,80,50,Colors.Green);\n  c.Direction := (1,0);\n  c.Velocity := 0;\n  c.Tag := 0;\n  \n  OnDrawFrame := dt -> begin\n    c.MoveTime(dt);  \n    c.RotateAngle += integer(c.Tag) * dt;\n  end;\n\n  Button('Start movement').Click := procedure -> begin\n    c.Velocity := 30;\n  end;\n  Button('Stop movement').Click := procedure -> begin\n    c.Velocity := 0;\n  end;\n  Button('Start rotation').Click := procedure -> begin\n    c.Tag := 30;\n  end;\n  Button('Stop rotation').Click := procedure -> begin\n    c.Tag := 0;\n  end;\nend."
  },
  {
    "instruction": "Use high-precision Stopwatch for timing measurements in PascalABC.NET",
    "output": "begin\n  var stopWatch := new System.Diagnostics.Stopwatch;\n  stopWatch.Start;\n \n  Sleep(123);\n \n  stopWatch.Stop;\n  var ts := stopWatch.Elapsed;\n  writelnFormat('Elapsed time: {0:00}:{1:00}:{2:00}.{3:000}',ts.Hours, ts.Minutes, ts.Seconds, ts.Milliseconds);\nend."
  },
  {
    "instruction": "Create a basic rectangle stamp class in PascalABC.NET",
    "output": "uses GraphABC;\n\ntype \n  RectangleStamp = auto class\n    x,y,w,h: integer;\n    procedure Stamp;\n    begin\n      Rectangle(x,y,x+w,y+h);\n    end;\n  end;\n\nbegin\n  var r := new RectangleStamp(30,30,50,50);\n  r.Stamp;\n  for var i:=1 to 10 do\n  begin\n    r.x := r.x + r.w +5;\n    r.Stamp;\n  end;\nend."
  },
  {
    "instruction": "Create a row of rectangles stamp class in PascalABC.NET",
    "output": "uses GraphABC;\n\ntype \n  RectangleStamp = auto class\n    x,y,w,h: integer;\n    procedure Stamp;\n    begin\n      Rectangle(x,y,x+w,y+h);\n    end;\n  end;\n  \n  RowRectanglesStamp = auto class\n    x,y,w,h,n: integer;\n    procedure Stamp;\n    begin\n      var r := new RectangleStamp(x,y,w,h);\n      r.Stamp;\n      for var i:=1 to n-1 do\n      begin\n        r.x += r.w + 5;\n        r.Stamp;\n      end;\n    end;\n  end;  \n\nconst n=8;\n\nbegin\n  var r := new RowRectanglesStamp(30,30,50,50,n);\n  r.Stamp;\n  for var i:=1 to n-1 do\n  begin\n    r.y += r.h + 5;\n    r.Stamp;\n  end;\nend."
  },
  {
    "instruction": "Create a rectangle stamp with increase/decrease methods in PascalABC.NET",
    "output": "uses GraphABC;\n\ntype \n  RectangleStamp = auto class\n    x,y,w,h: integer;\n    procedure Stamp := Rectangle(x,y,x+w,y+h);\n    procedure Increase(dw,dh: integer);\n    begin\n      w += dw; h += dh;    \n    end;\n    procedure Decrease(dw,dh: integer) := Increase(-dw,-dh);      \n    procedure MoveOn(dx,dy: integer);\n    begin\n      x += dx; y += dy;\n    end;\n  end;\n  \nbegin\n  var r := new RectangleStamp(100,100,300,300);\n  r.Stamp;\n  while r.w>2 do\n  begin\n    r.Decrease(8,8);\n    r.MoveOn(4,4);\n    r.Stamp;\n  end;\nend."
  },
  {
    "instruction": "Create a rectangle stamp with center-based resizing in PascalABC.NET",
    "output": "uses GraphABC;\n\ntype \n  RectangleStamp = class\n    x,y,w,h: integer;\n    constructor (xx,yy,ww,hh: integer);\n    begin\n      x := xx; y := yy;\n      w := ww; h := hh;\n    end;\n    procedure Stamp;\n    begin\n      Rectangle(x,y,x+w,y+h);\n    end;\n    procedure IncreaseFromCenter(dw: integer);\n    begin\n      w += dw*2; h += dw*2;\n      x -= dw; y -= dw;\n    end;\n    procedure DecreaseFromCenter(dw: integer);\n    begin\n      IncreaseFromCenter(-dw);      \n    end;\n    procedure MoveOn(dx,dy: integer);\n    begin\n      x += dx; y += dy;\n    end;\n  end;\n  \nbegin\n  var r := new RectangleStamp(100,100,300,300);\n  r.Stamp;\n  while r.w>2 do\n  begin\n    r.DecreaseFromCenter(4);\n    r.Stamp;\n  end;\nend."
  },
  {
    "instruction": "Create a triangle stamp with orientation in PascalABC.NET",
    "output": "uses GraphABC;\n\ntype \n  TriangleStamp = auto class\n    x,y,w,orient: integer;\n    procedure Stamp;\n    begin\n      MoveTo(x,y);\n      var dx := w;\n      var dy := w;\n      case orient of\n     2: dx := -dx;\n     3: dy := -dy;\n     4: begin dx := -dx; dy := -dy; end;\n      end;\n      LineTo(x+dx,y);\n      LineTo(x,y+dy);\n      LineTo(x,y);      \n    end;\n    procedure MoveOn(dx,dy: integer);\n    begin\n      x += dx; y += dy;\n    end;\n  end;\n  \nbegin\n  var r := new TriangleStamp(200,200,100,1);\n  r.Stamp;\n  r.orient := 2;\n  r.Stamp;\n  r.orient := 3;\n  r.Stamp;\n  r.orient := 4;\n  r.Stamp;\nend."
  },
  {
    "instruction": "Work with static arrays - basic usage in PascalABC.NET",
    "output": "const n=10;\n\nvar a: array [1..n] of real;\n\nbegin\n  for var i:=1 to n do\n    a[i] := Random*10;\n  writeln('Contents of random real array: ');  \n  foreach x: real in a do\n    write(x:4:2,'  ');\nend."
  },
  {
    "instruction": "Work with static arrays as procedure parameters in PascalABC.NET",
    "output": "const n=10;\n\ntype RealArr = array [1..n] of real;\n\nprocedure FillArrByRandom(var a: RealArr; n: integer);\nbegin\n  for var i:=1 to n do\n    a[i] := Random*10;\nend;\n\nprocedure PrintArr(const a: RealArr; n: integer);\nbegin\n  foreach x: real in a do\n    write(x:4:2,'  ');\nend;\n\nvar a: RealArr;\n\nbegin\n  FillArrByRandom(a,n);\n  writeln('Contents of random real array: ');  \n  PrintArr(a,n);\nend."
  },
  {
    "instruction": "Use exit procedure to exit from subroutines in PascalABC.NET",
    "output": "const n=10;\n\ntype IntArr = array [1..n] of integer;\n\nprocedure FillArrByRandom(var a: IntArr; n: integer);\nbegin\n  for var i:=1 to n do\n    a[i] := Random(10);\nend;\n\nprocedure PrintArr(const a: IntArr; n: integer);\nbegin\n  foreach x: integer in a do\n    write(x,' ');\n  writeln;  \nend;\n\nfunction IndexOf(const a: IntArr; n: integer; k: integer): integer;\nbegin\n  Result := 0;\n  for var i := 1 to n do\n    if a[i]=k then\n    begin\n      Result := i;\n      exit;\n    end;  \nend;\n\nvar a: IntArr;\n\nbegin\n  FillArrByRandom(a,n);\n  writeln('Random integer array: ');\n  PrintArr(a,n);\n  \n  var ind := IndexOf(a,n,7);\n  if ind>0 then\n    writeln('Index of first element 7 equals ', ind)\n  else writeln('Element 7 not found');\nend."
  },
  {
    "instruction": "Show how to create a simple generic Stack class based on arrays in PascalABC.NET",
    "output": "// Demonstration of creating simple stack class based on array\ntype\n  Stack<T> = class\n  private\n    a: array of T;\n    last: integer;\n  public  \n    constructor Create(sz: integer);\n    begin\n      SetLength(a,sz);\n      last := 0;\n    end;\n    constructor Create;\n    begin\n      Create(100);\n    end;\n    procedure Push(i: T);\n    begin\n      a[last] := i;\n      Inc(last);\n    end;\n    function Pop: T;\n    begin\n      Dec(last);\n      Result := a[last];\n    end;\n    function Top: T;\n    begin\n      Result := a[last-1];\n    end;\n    function Empty: boolean;\n    begin\n      Result := last=0;\n    end;\n    function ToString: string; override;\n    begin\n      Result := '';\n      for var i:=0 to last-1 do\n        Result += a[i]+' ';\n    end;\n  end;\n  \nbegin\n  var s := new Stack<integer>;\n  s.Push(7);\n  s.Push(2);\n  s.Push(5);\n  s.Push(4);\n  Println(s);\n  while not s.Empty do\n    Print(s.Pop);\nend."
  },
  {
    "instruction": "Demonstrate string concatenation and character access in PascalABC.NET",
    "output": "var s: string := 'Pascal';\n\nbegin\n  writeln(s);\n  s := s + '.';\n  writeln(s);\n  s += 'NET';\n  writeln(s);\n  writeln(s[1],' ',s[2],' ',s[3],' ',s[4],' ',s[5],' ',s[6]);\nend."
  },
  {
    "instruction": "Demonstrate string length manipulation using SetLength and Length in PascalABC.NET",
    "output": "var s: string;\n\nbegin\n  writeln('Length(s) = ',Length(s));\n  SetLength(s,3);\n  s[1] := 'N';\n  s[2] := 'E';\n  s[3] := 'T';\n  writeln(s,'     Length(s) = ',Length(s));\n  for var i:= 1 to s.Length do\n    write(s[i],' ');\nend."
  },
  {
    "instruction": "Demonstrate dynamic string length capabilities in PascalABC.NET",
    "output": "var s: string;\n    \nbegin\n  s := 'abcdefghijklmnopqrstuvwxyz';\n  s := s + Uppercase(s);\n  s += s; \n  s += s; \n  s += s;\n  writeln('String length = ',s.Length);\n  writeln('String: ',s);\nend."
  },
  {
    "instruction": "Demonstrate fixed-length strings and shortstring in PascalABC.NET",
    "output": "var \n  s: string[9];\n  s1: shortstring;\n  slong: string;\n    \nbegin\n  slong := 'PascalABC.NET';\n  writeln('Variable length string: ',slong);\n  s := slong;\n  writeln('Fixed length string gets truncated: ',s);\nend."
  },
  {
    "instruction": "Use standard string procedures for string manipulation in PascalABC.NET",
    "output": "var \n  s: string := '  Pascal__NET  ';\n  s1: string := 'NET';\n    \nbegin\n  writeln('Original string: ''',s,'''');\n  s := Trim(s);\n  writeln('After Trim function: ''',s,'''');\n  var p := Pos(s1,s);\n  writelnFormat('Position of substring ''{0}'' in string ''{1}'' equals {2}',s1,s,p);\n  Delete(s,7,2);\n  writeln('After deleting __ characters: ',s);\n  Insert('ABC.',s,7);\n  writeln('After inserting substring ''ABC.'': ',s);\n  writeln('First part of string: ',Copy(s,1,9));\n  writeln('Last part of string: ',Copy(s,11,3));\nend."
  },
  {
    "instruction": "Show various string methods available in PascalABC.NET including trimming, searching, and manipulation",
    "output": "// Strings. Methods of string class\nvar \n  s: string := '  Pascal__NET  ';\n  s1: string := 'NET';\n    \nbegin\n  Println($'Original string: ''{s}''');\n  s := s.Trim;\n  Println($'After calling s.Trim: ''{s}''');\n  var p := s.IndexOf(s1); // Indexing - from zero\n  Println($'Position of substring ''{s1}'' in string ''{s}'' equals {p}');\n  s := s.Remove(6,2);\n  Println('After removing characters __:',s);\n  s := s.Insert(6,'ABC.');\n  Println('After inserting substring ''ABC.'':',s);\n  Println('First part of string:',s.Substring(0,9));\n  Println('Last part of string:',s.Substring(10,3));\nend."
  },
  {
    "instruction": "Convert between strings and numbers using TryParse in PascalABC.NET",
    "output": "begin\n  var s := '123,3443';\n  var r: real;\n  if not real.TryParse(s, r) then\n    Writeln('String s is not a valid real number representation')\n  else Writeln(r);\n     \n  var i: integer;\n  if not integer.TryParse(s, i) then\n    Writeln('String s is not a valid integer representation');\n     \n  i := 10;\n  s := i.ToString;\n  Writeln(s);\n  \n  s := '';\n  for i:=1 to 9 do\n    s += i.ToString;\n  Writeln(s);\nend."
  },
  {
    "instruction": "Demonstrate string-integer conversion using modern style methods in PascalABC.NET",
    "output": "// Integer <-> string conversion in new style \n\nbegin\n  // Integer to string conversion\n  var i: integer := 234;\n  var s: string := i.ToString;\n  Println($'Integer: {i}. After conversion to string: ''{s}''');\n  \n  // String to integer conversion\n  s := '567';\n  if integer.TryParse(s,i) then\n    Println($'String: ''{s}''. After conversion to integer: {i}');\nend."
  },
  {
    "instruction": "Convert between integers and strings using IntToStr and StrToInt in PascalABC.NET",
    "output": "var \n  s: string;\n  i: integer;\n\nbegin\n  i := 234;\n  s := IntToStr(i);\n  writelnFormat('Integer: {0}. After conversion to string: ''{1}''',i,s);\n  \n  s := '567';\n  i := StrToInt(s);\n  writelnFormat('String: ''{0}''. After conversion to integer: {1}',s,i);\nend."
  },
  {
    "instruction": "Convert between integers and strings using Val and Str procedures in PascalABC.NET",
    "output": "var \n  s: string;\n  i: integer;\n\nbegin\n  i := 234;\n  Str(i,s);\n  writelnFormat('Integer: {0}. After conversion to string: ''{1}''',i,s);\n  \n  s := '567';\n  var err: integer;\n  Val(s,i,err);\n  if err=0 then\n    writelnFormat('String: ''{0}''. After conversion to integer: {1}',s,i);\nend."
  },
  {
    "instruction": "Convert between real numbers and strings in PascalABC.NET",
    "output": "var \n  s: string;\n  r: real;\n\nbegin\n  r := 3.1415;\n  s := FloatToStr(r);\n  writelnFormat('Real: {0}. After conversion to string: ''{1}''',r,s);\n  \n  s := '3.1415';\n  r := StrToFloat(s);\n  writelnFormat('String: ''{0}''. After conversion to real: {1}',s,r);\nend."
  },
  {
    "instruction": "Demonstrate various string methods including length and comparison in PascalABC.NET",
    "output": "begin\n  var s1 := 'ABCDEFGH';\n  Writeln(s1.Length);\n\n  s1 := 'AAA';\n  var s2 := 'aaa';\n  if String.Compare(s1, s2, true) = 0 then\n    Writeln('Strings match ignoring case');\n  \n  s1 := 'Long string';\n  s2 := 'string';\n  if s1.EndsWith(s2) then\n    Writeln('String s1 ends with substring s2');\n    \n  Writeln(s1.IndexOf(s2));\n    \n  s1 := 'ABCDEFGH';\n  s2 := s1.Substring(3);\n  Writeln(s2);\n  \n  s2 := s1.Substring(3, 2);\n  Writeln(s2);\nend."
  },
  {
    "instruction": "Demonstrate string manipulation methods including insert, replace and remove in PascalABC.NET",
    "output": "begin\n  var s1 := 'ABCDEFGH';\n  var s2 := s1.Substring(3);\n  Writeln(s2);\n  \n  s2 := s1.Substring(3, 2);\n  Writeln(s2);\n  \n  s1 := 'ABCDEFGH';\n  s2 := s1.Insert(2, 'xxx');\n  Writeln(s2);\n  \n  s2 := s2.Replace('x', '!');\n  Writeln(s2);\n  \n  s2 := s2.Remove(2, 3);\n  Writeln(s2);\n  \n  s1 := '\u0441\u043b\u043e\u0432\u043e \u0441\u043b\u043e\u0432\u043e \u0441\u043b\u043e\u0432\u043e';\n  s2 := s1.Replace('\u0441\u043b\u043e\u0432', '\u043c\u043e\u043b\u043e\u043a');\n  Writeln(s2);\n  \n  s1 := '    xxx  xxx    ';\n  Writeln('|', s1, '|');\n  s1 := s1.Trim;\n  Writeln('|', s1, '|');\n  \n  s1 := '\u0430\u0431\u0432\u0433\u0434';\n  s1 := s1.ToUpper;\n  Writeln(s1);\nend."
  },
  {
    "instruction": "Demonstrate string concatenation with plus operator in PascalABC.NET",
    "output": "var s1: string := 'Pascal';\nvar s2: string := 'NET';\n\nbegin \n  Writeln(s2+'-'+s1);\n  Writeln(s1+'.'+s2);\nend."
  },
  {
    "instruction": "Split string into array and process numeric values in PascalABC.NET",
    "output": "begin\n  var s: string := '12 765 765 76';\n  var str_arr: array of string := s.Split;\n  \n  s := str_arr.JoinToString(' + ');\n  Write(s, ' = ');\n  \n  var int_arr := new integer[str_arr.Length];\n  for var i:=0 to int_arr.Length-1 do\n    integer.TryParse(str_arr[i], int_arr[i]);\n  \n  var sum := 0;\n  foreach var v: integer in int_arr do\n    sum += v;\n  Writeln(sum);\nend."
  },
  {
    "instruction": "Explain different string types in PascalABC.NET: string, string[n], and shortstring with memory characteristics",
    "output": "// Strings string, string[n], shortstring\nvar \n  s: string; // memory occupied by s depends on its length\n  s10: string[10]; // memory for ss is fixed\n  ss: shortstring := s;\n  f: file of string[10];\n  // f: file of string; - error\n\nbegin\n  s := '12345678901234567890';\n  s10 := s; // truncation\n  Println(s10);\n  s += s; s += s;\n  s += s; s += s;\n  Println(s);\n  Println('String length =',s.Length);\nend."
  },
  {
    "instruction": "Demonstrate structural type equivalence in PascalABC.NET",
    "output": "var \n  a: array of integer;\n  a1: array of integer;\n  s: set of real;\n  s1: set of real;\n  p: procedure (i: integer);\n  p1: procedure (i: integer);\n  r: ^integer;\n  r1: ^integer;\n\nprocedure proc(aa: array of integer; ss: set of real; pp: procedure (i: integer); rr: ^integer);\nbegin\n  \nend;\n\nbegin\n  a := a1;\n  s := s1;\n  p := p1;\n  r := r1;\n  proc(a,s,p,r);\nend."
  },
  {
    "instruction": "Compare string parameter passing by value vs by reference performance in PascalABC.NET",
    "output": "var ss:int64 := 0;\n\nprocedure p(s: string);\nbegin\n  s[1] := '1';\nend;\n\nprocedure q(var s: string);\nbegin\n  s[1] := '1';\nend;\n\nbegin\n  var n := 100000000;\n  var s := 'a'*n;\n  MillisecondsDelta;\n  loop 10 do\n    p(s);\n  Println(s[:3]);\n  MillisecondsDelta.Println;\n  loop 10 do\n    q(s);\n  Println(s[:3]);\n  MillisecondsDelta.Println;\nend."
  },
  {
    "instruction": "Demonstrate generic functions with type inference from parameter types in PascalABC.NET using Swap<T> as example",
    "output": "// Generic functions\n// Type T inference from parameter types\n\nprocedure Swap<T>(var a,b: T);\nbegin\n  var v := a;\n  a := b;\n  b := v;\nend;\n\nbegin\n  var a := 2;\n  var b := 3;\n  Println($'Before Swap a={a}, b={b}');\n  Swap(a,b);\n  Println($'After Swap a={a}, b={b}');\n  var c := 2.5;\n  var d := 3.3;\n  Println;\n  Println($'Before Swap c={c}, d={d}');\n  Swap(c,d);\n  Println($'After Swap c={c}, d={d}');\nend."
  },
  {
    "instruction": "Use System.Timers.Timer with event handlers in PascalABC.NET",
    "output": "uses System;\n\nvar\n  Timer: System.Timers.Timer;\n  x: integer;\n  exit: boolean;\n\nprocedure OnTimer2(sender: object; e: System.Timers.ElapsedEventArgs);\nbegin\n  Writeln(x);\n  x := x + 1;\n  exit := x >= 10;\nend;\n\nprocedure OnTimer1(sender: object; e: System.Timers.ElapsedEventArgs);\nbegin\n  Writeln(e.SignalTime);\n  x := x + 1;\n  if x >= 5 then begin\n    Timer.Elapsed -= OnTimer1;\n    Timer.Elapsed += OnTimer2;\n  end;\nend;\n\nbegin\n  Exit := false;\n  Timer := System.Timers.Timer.Create(1000);\n  Timer.Elapsed += OnTimer1;\n  Timer.Start;\n  while not exit do \n    Sleep(Round(Timer.Interval));\nend."
  },
  {
    "instruction": "Explain name resolution order in PascalABC.NET when using System unit and how it affects access to PABCSystem functions",
    "output": "// Illustration of name search first from right to left in uses section, then in system module PABCSystem \nuses System;\n\nbegin\n  // Name Random, defined in System namespace, overrides name Random \n  // in PABCSystem module, which is implicitly connected first\n  var r: Random := new Random();\n  Println(r.Next(10));\n  // That's why before this Random it's necessary to explicitly specify module name where it's located\n  var i: integer := PABCSystem.Random(10);\n  Println(i);\nend."
  },
  {
    "instruction": "Create a tentacles animation using trigonometric functions in PascalABC.NET",
    "output": "uses GraphABC;\n\nconst\n  S = 14;\n  N = 18;\n  W = 2;\n\nvar\n  i, j: Integer;\n  x, y: Real;\n  tx, ty: Real;\n  k, d: Real;\n  a: array [1..N] of Real;\n  len: Real;\n\nbegin\n  Pen.Width := W;\n  SetWindowSize(320, 320);\n  SetWindowTitle('Tentacles');\n  \n  if Window.Width > Window.Height then\n    len := Window.Height / 1.8 / N\n  else\n    len := Window.Width / 1.8 / N;\n  k := random(360) * pi / 180;\n  d := pi * 2 / S;\n  \n  var k1 := 1;\n  \n  repeat\n    if Window.Width > Window.Height then\n      len := Window.Height / 1.8 / N\n    else\n      len := Window.Width / 1.8 / N;\n    \n    LockDrawing();\n    ClearWindow(ClBlack);\n    \n    if random(50) = 0 then\n      k := random(360) * pi / 180;\n    \n    a[1] := a[1] + sin(k) / 15;\n\n    for i := 2 to N do \n      a[i] := a[i] + (a[i - 1] - a[i]) * 0.1;\n    for j := 0 to S - 1 do\n    begin\n      x := 0.5 * Window.Width;\n      y := 0.5 * Window.Height;\n      for i := 2 to N do \n      begin\n        SetPenColor(Color.FromArgb(255, trunc(255 - 255 * i / N), 255));\n        tx := x + cos(j * d + a[i]) * len;\n        ty := y + sin(j * d + a[i]) * len;\n        Line(trunc(x), trunc(y), trunc(tx), trunc(ty));\n        x  := tx;\n        y  := ty;\n      end;\n    end;\n    Redraw();\n\n    k1 += 1;\n    SetWindowTitle('Tentacles( Avg. FPS ' + Format('{0,5:f2}',k1/Milliseconds*1000)+')');\n    \n    sleep(5);\n  until false;\n  \nend."
  },
  {
    "instruction": "Read and display text from the program's own source file in PascalABC.NET",
    "output": "var \n  f: Text;\n\nbegin\n  assign(f,'Text1.pas');\n  reset(f);\n  while not eof(f) do\n  begin\n    var s: string;\n    readln(f,s);\n    writeln(s);\n  end;\n  close(f);\nend."
  },
  {
    "instruction": "Write text array to file in PascalABC.NET",
    "output": "var \n  f: Text;\n  a: array of string := ('\u041a\u0430\u0436\u0434\u044b\u0439','\u043e\u0445\u043e\u0442\u043d\u0438\u043a','\u0436\u0435\u043b\u0430\u0435\u0442','\u0437\u043d\u0430\u0442\u044c','\u0433\u0434\u0435','\u0441\u0438\u0434\u0438\u0442','\u0444\u0430\u0437\u0430\u043d');\n\nbegin\n  assign(f,'a.txt');\n  rewrite(f);\n  for var i:=0 to a.Length-1 do \n    writeln(f,a[i]);\n  close(f);\n  writeln('Text written to file a.txt');\nend."
  },
  {
    "instruction": "Write multiplication table to text file in PascalABC.NET",
    "output": "const \n  n = 30;\n  filename = 'pifagor.txt';\n\nvar f: Text;\n\nbegin\n  assign(f,filename);\n  rewrite(f);\n  for var i:=1 to n do \n  begin\n    for var j:=1 to n do \n      write(f,i*j:4);\n    writeln(f);  \n  end;    \n  close(f);\n  writeln('Multiplication table written to file '+filename);\nend."
  },
  {
    "instruction": "Create a simple text editor with file operations in PascalABC.NET",
    "output": "{$apptype windows}\n{$reference 'System.Windows.Forms.dll'}\n{$reference 'System.Drawing.dll'}\n{$resource 'Open.png'}\n{$resource 'Save.png'}\n\nuses System.Windows.Forms;\n\nconst \n  TextFileExt = 'txt';\n  TextFileFilter = 'Text files (*.'+TextFileExt+')|*.'+TextFileExt;\n\nvar\n  myForm: Form;\n  TextBox1: TextBox;\n\nprocedure SaveFile(FileName: string);\nbegin\n  var f := new System.IO.StreamWriter(FileName, false, System.Text.Encoding.Default);\n  f.Write(TextBox1.Text);\n  f.Close;\nend;\n\nprocedure OpenFile(FileName: string);\nbegin\n  var f := new System.IO.StreamReader(FileName, System.Text.Encoding.Default);\n  TextBox1.Text := f.ReadToEnd;\n  f.Close;\nend;\n\nprocedure FormClose(sender: object; args: System.EventArgs);\nbegin\n  myForm.Close;  \nend;\n\nprocedure MenuSaveClick(sender:object; args:System.EventArgs);\nbegin\n  var sd := new SaveFileDialog;\n  sd.DefaultExt := TextFileExt;\n  sd.Filter := TextFileFilter;\n  if sd.ShowDialog=DialogResult.OK then \n    SaveFile(sd.FileName);\nend;\n\nprocedure MenuOpenClick(sender:object; args:System.EventArgs);\nbegin\n  var sd := new OpenFileDialog;\n  sd.DefaultExt := TextFileExt;\n  sd.Filter := TextFileFilter;\n  if sd.ShowDialog = DialogResult.OK then \n    OpenFile(sd.FileName);\nend;\n\nbegin\n  myForm := new Form;\n  myForm.Text := 'Simple text editor';\n\n  TextBox1 := new TextBox;\n  TextBox1.Multiline := True;\n  TextBox1.Height := 100;\n  TextBox1.Dock := DockStyle.Fill;\n  TextBox1.ScrollBars := ScrollBars.Both;\n  TextBox1.Font := new System.Drawing.Font('Courier New',10);\n\n  myForm.Controls.Add(TextBox1);\n  \n  var toolStrip1 := new ToolStrip;\n  toolStrip1.GripStyle := System.Windows.Forms.ToolStripGripStyle.Hidden;\n  var miFile := new ToolStripMenuItem('File');  \n  miFile.DropDownItems.Add(new ToolStripMenuItem('Open', new System.Drawing.Bitmap(GetResourceStream('Open.png')),MenuOpenClick));\n  miFile.DropDownItems.Add(new ToolStripMenuItem('Save as...',new System.Drawing.Bitmap(GetResourceStream('Save.png')),MenuSaveClick));\n  miFile.DropDownItems.Add(new ToolStripMenuItem('Exit',nil,FormClose));\n  toolStrip1.Items.Add(miFile);\n  myForm.Controls.Add(toolStrip1);\n  \n  if CommandLineArgs.Length = 1 then \n    OpenFile(CommandLineArgs[0]);\n      \n  Application.Run(myForm);\nend."
  },
  {
    "instruction": "Count word frequency in a text file using Dictionary in PascalABC.NET",
    "output": "begin\n  var d := new Dictionary<string,integer>;\n  foreach var s in ReadLines('TextFileCount.pas') do\n    foreach var word in s.ToWords(AllDelimiters) do\n      d[word] := d.Get(word) + 1;\n  d.PrintLines;    \nend."
  },
  {
    "instruction": "Count word frequency using Dict initialization in PascalABC.NET",
    "output": "begin\n  var d := Dict('begin' to 0);\n  var words := ReadAllText('TextFileCount1.pas').ToWords(AllDelimiters); \n  foreach var word in words do\n    d[word] := d.Get(word) + 1;\n  d.Print(NewLine);    \nend."
  },
  {
    "instruction": "Display text at mathematical coordinates in GraphWPF in PascalABC.NET",
    "output": "uses GraphWPF;\n\nbegin\n  SetMathematicCoords;\n  var (p1,p2,p3) := (Pnt(0,0),Pnt(2,3),Pnt(4,-1));\n  Circle(p1,0.1);\n  Circle(p2,0.1);\n  Circle(p3,0.1);\n  TextOut(p1,p1);\n  TextOut(p2,p2);\n  TextOut(p3,p3);\nend."
  },
  {
    "instruction": "Use FontOptions for text formatting in GraphWPF in PascalABC.NET",
    "output": "uses GraphWPF;\n\nbegin\n  Window.Title := 'Using FontOptions';\n  TextOut(10,10,'Normal');\n  TextOut(10,40,'Bold',Font.WithStyle(FontStyle.Bold));\n  TextOut(10,70,'20 points',Font.WithSize(20));\n  TextOut(10,110,'Italic blue',Font.WithColor(Colors.Blue).WithStyle((FontStyle.Italic)));\nend."
  },
  {
    "instruction": "Apply texture material to 3D object in Graph3D in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin\n  var m := ImageMaterial('Cells1.png',0.2,0.2);\n  var c := Cube(0,0,2,4,m);\n  c.Rotate(OrtZ,35)\nend."
  },
  {
    "instruction": "Chain animations using WhenCompleted in Graph3D in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin\n  var s := Sphere(Origin,1,Colors.Green);\n  s.AnimMoveByX(5).WhenCompleted(procedure->s.AnimMoveByY(5).Begin).Begin;\n  var s1 := s.Clone;\n  s1.Color := Colors.Blue;\n  s1.AnimMoveByX(-5).WhenCompleted(procedure->s1.AnimMoveByY(-5).Begin).Begin;\nend."
  },
  {
    "instruction": "Overload comparison operators for Student class in PascalABC.NET",
    "output": "type \n  Student = auto class\n    Name: string;\n    Height: integer;\n  public\n    class function operator<(left,right: Student): boolean := left.Height < right.Height;\n    class function operator>(left,right: Student): boolean := left.Height > right.Height;\n    function ToString: string; override := string.Format('{0} ({1})', Name, Height);\n  end;\n\nbegin\n  var s1 := new Student('Stepa Morkovkin',188);\n  var s2 := new Student('Petya Pomidorov',180);\n  Writeln('s1: ',s1);\n  Writeln('s2: ',s2);\n  Writeln;\n  Writeln('s1<s2: ',s1<s2);\n  Writeln('Student.operator>(s1,s2): ',Student.operator>(s1,s2));\nend."
  },
  {
    "instruction": "Compare performance of Substring vs slice operations in PascalABC.NET",
    "output": "begin\n  var s := Range(#32,#1000).JoinIntoString;\n  var s1: string;\n  Milliseconds;\n  var n := 100000000;\n  loop n do\n    s1 := s.Substring(10,10);\n  MillisecondsDelta.Println;\n  loop n do\n    s1 := s[1:11];\n  MillisecondsDelta.Println;\nend."
  },
  {
    "instruction": "Compare performance of LINQ vs traditional loop for sum calculation in PascalABC.NET",
    "output": "begin\n  var n := 100000000;\n  var q := Range(1,n).Select(x->1/x).Sum();\n  Println(q,MillisecondsDelta);\n    \n  var s := 0.0;\n  for var i:=1 to n do\n    s += 1.0/i;\n\n  Println(s,MillisecondsDelta);\nend."
  },
  {
    "instruction": "Swap halves of an array using LINQ operations in PascalABC.NET",
    "output": "var a := Arr(1,3,5,7);\n\nbegin\n  a.Skip(2).Concat(a.Take(2)).Print;\nend."
  },
  {
    "instruction": "Work with arrays using System.Array methods in PascalABC.NET",
    "output": "const Size = 10;\n\nbegin\n  var a := ArrRandomInteger(Size);\n  a.Println;\n  Sort(a);\n  a.Println;\n  Reverse(a);\n  a.Println;\n  var i := a.IndexOf(99);\n  Println(i);\nend."
  },
  {
    "instruction": "Split string into words using custom delimiters in PascalABC.NET",
    "output": "begin\n  var s := '123.4, 6.6; 67';\n  s.ToWords(' ,;').PrintLines  \nend."
  },
  {
    "instruction": "Draw a recursive tree using Turtle graphics in PascalABC.NET",
    "output": "uses Turtle;\n\nprocedure DrawTree(length: real; depth: integer);\nbegin\n  if depth > 0 then\n  begin\n    forw(length);\n    turn(-35);\n    DrawTree(length*0.65, depth-1);\n    turn(70);\n    DrawTree(length*0.65, depth-1);\n    turn(-35);\n    forw(-length);\n  end;\nend;\n\nbegin\n  toPoint(0, -8);\n  down;\n  \n  DrawTree(6, 11);\nend."
  },
  {
    "instruction": "Draw a binary tree recursively using GraphWPF in PascalABC.NET",
    "output": "uses GraphWPF;\n\nconst \n  LevelHeight = 50;\n  Levels = 8;\n  delay = 10;\n\nprocedure DrawTree(x,y,dx: real; level: integer);\nbegin\n  if level>0 then \n  begin\n    DrawTree(x-dx,y+LevelHeight,dx / 2,level-1);\n    Line(x,y,x-dx,y+LevelHeight);\n    Line(x,y,x+dx,y+LevelHeight);\n    Sleep(delay);\n    DrawTree(x+dx,y+LevelHeight,dx / 2,level-1);\n  end;\nend;\n\nbegin\n  Window.Title := 'Recursive binary tree drawing';\n  Window.SetSize(800,30+Levels*LevelHeight);\n  DrawTree(Window.Width / 2,10,Window.Width / 5,Levels);\nend."
  },
  {
    "instruction": "Implement basic exception handling for input errors in PascalABC.NET",
    "output": "var a: integer;\n\nbegin\n  try \n    writeln('Enter number: ');\n    readln(a);\n    writeln('Number entered correctly');\n  except\n    writeln('Input error');\n  end;\n  writeln('Program execution continues');\nend."
  },
  {
    "instruction": "Handle multiple specific exceptions in PascalABC.NET",
    "output": "var x: integer;\n\nbegin\n  try \n    writeln('Enter number (1 - division by zero error): ');\n    readln(x);\n    x := 10 div (x-1);\n  except\n    on System.FormatException do\n      writeln('Input error');\n    on System.DivideByZeroException do\n      writeln('Division by zero');  \n  end;\nend."
  },
  {
    "instruction": "Demonstrate finally block in exception handling in PascalABC.NET",
    "output": "var x: integer := 0;\n\nbegin\n  try \n    if Random(2)=0 then\n      x := 10 div x;\n    writeln('Execution continues');   \n  finally\n    writeln('Finally block executed'); \n  end;\n  writeln('After finally block'); \nend."
  },
  {
    "instruction": "Create a starfield animation through space in PascalABC.NET",
    "output": "uses GraphABC;\n \n type\n   TStar = record\n     X, Y, Z : real;\n   end;\n\n const\n   MAX_STARS = 1000;\n   SPEED = 200;\n\n var\n   i     : Integer;\n   Stars : array [1..MAX_STARS] of TStar;\n   scr_W : Integer;\n   scr_H : Integer;\n   time, dt : Integer;\n\n   procedure SetPix(c: Integer);\n   var\n     sx, sy : Integer;\n   begin\n   try\n     sx := trunc(scr_W / 2 + Stars[i].X * 200 / (Stars[i].Z + 200));\n     sy := trunc(scr_H / 2 - Stars[i].Y * 200 / (Stars[i].Z + 200));\n     except\n     end;\n     \n     try\n      SetPixel(sx, sy, Color.FromArgb(c, c, c));\n     except\n     end;\n   end;\n\n begin\n   MaximizeWindow();\n   scr_W := Window.Width;  \n   scr_H := Window.Height;\n\n   randomize;\n   for i := 1 to MAX_STARS do\n   begin\n     Stars[i].X := random(scr_W * 4) - scr_W * 2;\n     Stars[i].Y := random(scr_H * 4) - scr_H * 2;\n     Stars[i].Z := random(1900);\n   end;\n   \n   ClearWindow(Color.Black); \n   \n   time := Milliseconds;\n   repeat\n     scr_W := Window.Width;  \n     scr_H := Window.Height;\n     dt   := Milliseconds - time;\n     time := Milliseconds;\n     for i := 1 to MAX_STARS do\n       begin\n       SetPix(0);\n       Stars[i].Z := Stars[i].Z - SPEED * dt/1000;\n       if Stars[i].Z <= -200 then\n       begin\n         Stars[i].X := random(scr_W * 4) - scr_W * 2;\n         Stars[i].Y := random(scr_H * 4) - scr_H * 2;\n         Stars[i].Z := 1900;\n       end;\n       SetPix(trunc(255 - 255 * (Stars[i].Z + 200) / 2100));\n     end;\n     sleep(10);\n   until false;\n end."
  },
  {
    "instruction": "Measure execution time of nested loops in PascalABC.NET",
    "output": "begin\n  var n := 60000;\n  var t1 := Milliseconds;\n  var sm := 0.0;\n  var i := 1.0;\n  while i < n do\n  begin\n    var j := 1.0;\n    while j < n do\n    begin\n      sm += 1.0 / i / j;\n      j += 1;\n    end;\n    i += 1;\n  end;\n  var t2 := Milliseconds;\n  print(t2 - t1);\nend."
  },
  {
    "instruction": "Create a program that uses two timers: one prints '!' every 200ms and another prints '?' every 300ms. Run them for 10 seconds.",
    "output": "uses Timers;\n\nprocedure OnTimer1 := Write('!');\n\nprocedure OnTimer2 := Write('?');\n\nbegin\n  var t1 := new Timer(200, OnTimer1);\n  var t2 := new Timer(300, OnTimer2);\n  t1.Start;\n  t2.Start;\n  Sleep(10000);\nend."
  },
  {
    "instruction": "Create a program that implements a 'puppy' animation where a black circle follows the mouse cursor with smooth movement using a timer.",
    "output": "uses GraphWPF, Timers;\n\nvar\n  xx,yy,px,py: real;\n\nprocedure Draw;\nbegin\n  FillCircle(xx,yy,11);\nend;\n\nprocedure TimerProc;\nbegin\n  if (xx<>px) or (yy<>py) then\n  begin\n    var t := 1/10;\n    var newx := round((1-t)*xx+t*px);\n    var newy := round((1-t)*yy+t*py);\n    (xx,yy) := (newx,newy);\n  end;\nend;\n\nbegin\n  Window.Title := '\"Puppy\"';\n  Brush.Color := Colors.Black;\n\n  xx := 100; yy := 100;\n\n  OnMouseMove := procedure(x,y,mb) -> (px,py) := (x,y);\n\n  OnDrawFrame := dt -> begin\n    FillCircle(xx,yy,11);\n  end;\n\n  var t := new Timer(20,TimerProc);\n  t.Start;\nend."
  },
  {
    "instruction": "Create a turtle graphics program that draws different fractal patterns using L-system rules. Include implementations for Dragon curve, Koch curve, Quadratic Koch Island, and Gosper hexagonal curve.",
    "output": "uses Turtle,GraphWPF;\n\nvar \n  Atom,FStr,XStr,YStr: string;\n  angle,len,x0,y0: real;\n  n: integer;\n\nprocedure Init1; // Dragon\nbegin\n  (Atom,FStr,XStr,YStr) := ('fx','f','x+yf+','-fx-y');\n  (angle,len,n,x0,y0) := (90,3,15,300,450);\nend;\n\nprocedure Init2; // Koch curve\nbegin\n  (Atom,FStr,XStr,YStr) := ('F', 'F-F++F-F', '', '');\n  (angle,len,n,x0,y0) := (60,5,7,10,550);\nend;\n\nprocedure Init3; // Quadratic Koch Island\nbegin\n  (Atom,FStr,XStr,YStr) := ('F+F+F+F', 'F+F-FF+F+F-F', '', '');\n  (angle,len,n,x0,y0) := (90,0.15,4,8,-1);\nend;\n\nprocedure Init4; // Gosper hexagonal curve\nbegin\n  (Atom,FStr,XStr,YStr) := ('XF', 'F', 'X+YF++YF-FX--FXFX-YF+','-FX+YFYF++YF+FX--FX-Y');\n  (angle,len,n,x0,y0) := (60,4,5,580,56);\nend;\n\nprocedure RunStr(s: string; n: integer);\nbegin\n  foreach var c in s do\n    case c of\n      '+': Turn(angle);\n      '-': Turn(-angle);\n      'f','F': if n>0 then RunStr(FStr,n-1) else Forw(len);\n      'x','X': if n>0 then RunStr(XStr,n-1);\n      'y','Y': if n>0 then RunStr(YStr,n-1);\n      else Print('error')\n    end;\nend;\n\nbegin\n  Init3;\n  ToPoint(x0,y0);\n  SetWidth(0.5);\n  Down;\n  RunStr(Atom,n);\n  Up;\nend."
  },
  {
    "instruction": "Create a turtle graphics program that draws a colorful spiral pattern with changing colors.",
    "output": "uses Turtle,GraphWPF;\n\nbegin\n  SetWidth(5);\n  ToPoint(-10,0);\n  loop 70 do\n  begin\n    SetColor(RandomColor);\n    Down;\n    Forw(5);\n    Up;\n    Back(5);\n    TurnRight(90);\n    Forw(0.3);\n    TurnLeft(90);\n  end;\nend."
  },
  {
    "instruction": "Create a turtle graphics program that draws a Hilbert curve using recursion.",
    "output": "uses Turtle;\n\nprocedure Hilbert(level: integer; angle,step: real);\nbegin\n  if level = 0 then\n    exit;\n  TurnRight(angle);\n  Hilbert(level-1, -angle, step);\n\n  Forw(step);\n  TurnLeft(angle);\n  Hilbert(level-1, angle, step);\n\n  Forw(step);\n  Hilbert(level-1, angle, step);\n\n  TurnLeft(angle);\n  Forw(step);\n  Hilbert(level-1, -angle, step);\n  TurnRight(angle);\nend;\n\nbegin\n  SetWidth(2);\n  ToPoint(-9,-9);\n  Down;\n  Hilbert(6,90,0.3);\nend."
  },
  {
    "instruction": "Create a turtle graphics program that draws a colorful spiral with gradually changing colors.",
    "output": "uses TurtleWPF;\n\nbegin\n  Down;\n  SetSpeed(11);\n  SetColor(Colors.Red);\n  for var i:=1 to 450 do\n  begin\n    SetColor(RGB(128+i,0,i));\n    Forw(i);\n    Turn(96);\n  end;\nend."
  },
  {
    "instruction": "Create a program that demonstrates the use of external units by calculating Fibonacci sequence and factorials for numbers 1 to 10.",
    "output": "Uses unit_example;\n\nconst N: integer = 10;\n\nbegin\n    println('Fibonacci sequence:');\n    for var i := 1 to N do\n        println('F(' + i + ')=', fibonacci(i));\n    println();\n\n    println('Factorial sequence:');\n    for var i := 1 to N do\n        println(i + '!=', factorial(i));\n    println();\nend."
  },
  {
    "instruction": "Create a turtle graphics program that draws different fractal patterns using L-system rules. Include implementations for Dragon curve, Koch curve, Quadratic Koch Island, and Gosper hexagonal curve with configurable parameters.",
    "output": "uses Turtle;\n\nvar \n  Atom,FStr,XStr,YStr: string;\n  angle,len,x0,y0: real;\n  n: integer;\n\nprocedure Init1; // Dragon\nbegin\n  (Atom,FStr,XStr,YStr) := ('fx','f','x+yf+','-fx-y');\n  (angle,len,n,x0,y0) := (90,0.1,15,7,0);\nend;\n\nprocedure Init2; // Koch curve\nbegin\n  (Atom,FStr,XStr,YStr) := ('F', 'F-F++F-F', '', '');\n  (angle,len,n,x0,y0) := (60,5,7,10,550);\nend;\n\nprocedure Init3; // Quadratic Koch Island\nbegin\n  (Atom,FStr,XStr,YStr) := ('F+F+F+F', 'F+F-FF+F+F-F', '', '');\n  (angle,len,n,x0,y0) := (90,4,4,250,450);\nend;\n\nprocedure Init4; // Gosper hexagonal curve\nbegin\n  (Atom,FStr,XStr,YStr) := ('XF', 'F', 'X+YF++YF-FX--FXFX-YF+','-FX+YFYF++YF+FX--FX-Y');\n  (angle,len,n,x0,y0) := (60,4,5,580,56);\nend;\n\nprocedure RunStr(s: string; n: integer);\nbegin\n  foreach var c in s do\n    case c of\n      '+': Turn(angle);\n      '-': Turn(-angle);\n      'f','F': if n>0 then RunStr(FStr,n-1) else Forw(len);\n      'x','X': if n>0 then RunStr(XStr,n-1);\n      'y','Y': if n>0 then RunStr(YStr,n-1);\n      else Print('error')\n    end;\nend;\n\nbegin\n  Sleep(100);\n  Init1;\n  ToPoint(x0,y0);\n  SetWidth(0.5);\n  Down;\n  RunStr(Atom,n);\n  Up;\nend."
  },
  {
    "instruction": "Create a turtle graphics program that draws a Koch curve using L-system rules with specific starting position and rotation.",
    "output": "uses Turtle;\n\nvar \n  Atom,FStr,XStr,YStr: string;\n  angle,len,x0,y0: real;\n  n: integer;\n\nprocedure Init1; // Dragon\nbegin\n  (Atom,FStr,XStr,YStr) := ('fx','f','x+yf+','-fx-y');\n  (angle,len,n,x0,y0) := (90,0.1,15,7,0);\nend;\n\nprocedure Init2; // Koch curve\nbegin\n  (Atom,FStr,XStr,YStr) := ('F', 'F-F++F-F', '', '');\n  (angle,len,n,x0,y0) := (60,0.012,7,-13,0);\nend;\n\nprocedure Init3; // Quadratic Koch Island\nbegin\n  (Atom,FStr,XStr,YStr) := ('F+F+F+F', 'F+F-FF+F+F-F', '', '');\n  (angle,len,n,x0,y0) := (90,4,4,250,450);\nend;\n\nprocedure Init4; // Gosper hexagonal curve\nbegin\n  (Atom,FStr,XStr,YStr) := ('XF', 'F', 'X+YF++YF-FX--FXFX-YF+','-FX+YFYF++YF+FX--FX-Y');\n  (angle,len,n,x0,y0) := (60,4,5,580,56);\nend;\n\nprocedure RunStr(s: string; n: integer);\nbegin\n  foreach var c in s do\n    case c of\n      '+': Turn(angle);\n      '-': Turn(-angle);\n      'f','F': if n>0 then RunStr(FStr,n-1) else Forw(len);\n      'x','X': if n>0 then RunStr(XStr,n-1);\n      'y','Y': if n>0 then RunStr(YStr,n-1);\n      else Print('error')\n    end;\nend;\n\nbegin\n  Init2;\n  ToPoint(x0,y0);\n  SetWidth(0.5);\n  Down;\n  Turn(90);\n  RunStr(Atom,n);\n  Up;\nend."
  },
  {
    "instruction": "Create a program that demonstrates exception handling by raising an exception when a function receives zero as input parameter.",
    "output": "function f(x: integer): integer;\nbegin\n  if x=0 then\n    raise new System.Exception('Function f argument cannot be zero');\n  Result := 10 mod x;\nend;\n\nbegin\n  writeln(f(0));    \nend."
  },
  {
    "instruction": "Create a program that demonstrates tuple creation and access to tuple elements using both index notation and named properties.",
    "output": "begin\n  var a := ('Ivanov',24);\n  Println(a[0],a[1]);\n\n  var b := ('Petrov',17,1,11);\n  Println(b.Item1,b.Item2,b.Item3,b.Item4);\nend."
  },
  {
    "instruction": "Create a program that demonstrates working with untyped files by writing and reading data of different types (real, char, integer) to/from a file.",
    "output": "const filename = 'u.dat';\n\nvar \n  f: file;\n  r: real;\n  s: string[10];\n  k: integer;\n  c: char;\n\nbegin\n  if not FileExists(filename) then\n  begin\n    assign(f,filename);\n    rewrite(f);\n    writeln('Writing to file ',filename);\n    \n    r := random*10; \n    for var i:=0 to 10 do\n      s := s + Chr(Ord('A')+Random(26));\n    c := Chr(Ord('A')+Random(26));\n    k := Random(100);\n    \n    writeln(r);\n    writeln(c);\n    writeln(k);\n    write(f,r);\n    write(f,c);\n    write(f,k);\n    close(f);  \n  end\n  else \n  begin\n    assign(f,filename);\n    reset(f);\n    writeln('Reading from file ',filename);\n    read(f,r,c,k);\n    writeln(r);\n    writeln(c);\n    writeln(k);\n    close(f);  \n    erase(f);\n  end;  \nend."
  },
  {
    "instruction": "Show how to use untyped files for writing and reading different data types in PascalABC.NET",
    "output": "// Untyped files\n\nbegin\n  var f: file := CreateBinary('a.dat');\n  // Write data of any types to file\n  f.Write(1,2.5,'Hello');  \n  f.Close;\n  f.Reset;\n  // Read this data from file\n  var i: integer;\n  var r: real;\n  var s: string;\n  Read(f,i,r,s);\n  Print(i,r,s);\n  f.Close;\nend."
  },
  {
    "instruction": "Create a program that demonstrates the use of UpperCase and LowerCase functions for both English and Russian characters.",
    "output": "var c: char;\n\nbegin\n  for c:='a' to 'z' do\n    write(UpperCase(c));\n  writeln;\n  for c:='A' to 'Z' do\n    write(LowerCase(c));\n  writeln;\n  for c:='\u0410' to '\u042f' do\n    write(UpperCase(c));\n  writeln;\n  for c:='\u0430' to '\u044f' do\n    write(LowerCase(c));\n  writeln;\n  var s := '\u041f\u0430\u043f\u0430 \u0443 \u0412\u0430\u0441\u0438 \u0441\u0438\u043b\u0451\u043d \u0432 \u043c\u0430\u0442\u0435\u043c\u0430\u0442\u0438\u043a\u0435';\n  s := UpperCase(s);\n  writeln(s);\n  s := LowerCase(s);\n  writeln(s);\nend."
  },
  {
    "instruction": "Create a class with a custom deconstructor and demonstrate its usage with pattern matching.",
    "output": "type\n  Person = class\n    name: string;\n    age: integer;\n    \n    constructor(name: string; age: integer);\n    begin\n      self.name := name;\n      self.age := age;\n    end;\n    \n    procedure Deconstruct(var name: string; var age: integer);\n    begin\n      name := self.name;\n      age := self.age;\n    end;\n  end;\n\nbegin\n  var p := new Person('\u041f\u0435\u0442\u0440', 25);\n  if p is Person(var name, var age) then\n    Println(name, age);\n    \n  match p with\n    Person(name,age): Println(name,age);\n  end;\nend."
  },
  {
    "instruction": "Create an extension method deconstructor for integer type that splits a number into tens and units.",
    "output": "procedure Deconstruct(Self: integer; var a: integer; var b: integer); extensionmethod;\nbegin\n  a := Self div 10;\n  b := Self mod 10;\nend;\n\nbegin\n  var i := 25;\n  if i is integer(var a, var b) then\n    Println(a,b); \n    \n  i := 9;\n  match i with\n    integer(a,b) when i>=10: Println(a,b);\n    integer(a): Println(a);\n  end;\nend."
  },
  {
    "instruction": "Create a short program that uses modules in compact syntax to create a 3D sphere.",
    "output": "uses Graph3D;\nSphere(Origin,1);"
  },
  {
    "instruction": "Create a program that demonstrates vector algebra operations using NumLibABC module.",
    "output": "uses NumLibABC;\n\nbegin\n  var a:=new Vector(3,-4,1);\n  var b:=new Vector(-1,0,5);\n  Writeln((2*a-b).ModV);\n  \n  var p:=Arr(3.0,0.0,-4.0);\n  a:=new Vector(p);\n  a.Ort.Println;\n\n  a:=new Vector(2,-1,1);\n  b:=new Vector(2,3,6);\n  Writeln(a*b/(a.ModV*b.ModV))\nend."
  },
  {
    "instruction": "Create a program that uses WebClient to download web page content and files from the internet.",
    "output": "uses System.Net;\n\nbegin\n  var w := new WebClient();\n  w.Encoding := System.Text.Encoding.UTF8;\n  var s := w.DownloadString('http://pascalabc.net');\n  writeln(s);\n  w.DownloadFile('http://pascalabc.net/images/logo/LogoPABCNET2010_Rus.png','LogoPABCNET2010_Rus.png');\nend."
  },
  {
    "instruction": "Show how to use the 'where' clause for generic type constraints in PascalABC.NET",
    "output": "// Where clause - constraint on type parameters\nuses System;\n\ntype\n   MyClass<T,T1> = class \n   where T: System.Array,ICloneable;\n   where T1: constructor;\n     procedure p(obj1: T; var obj2: T1);\n     begin\n       obj1.Clone();\n       obj2 := new T1;\n     end;\n   end;\n   IntArr = array of integer;\n   \nvar \n  m: MyClass<IntArr,integer>;\n  //m1: MyClass<integer>; // error\n\nbegin\nend."
  },
  {
    "instruction": "Show while loop examples for generating sequences and calculating digit sums in PascalABC.NET",
    "output": "// While loop. Output numbers with step 3\nconst n = 60;\n\nbegin\n  Println($'Numbers from 1 to {n}, multiples of 3');\n  var x := 3;\n  while x <= n do\n  begin\n    Print(x);\n    x += 3;\n  end;\n  Println;\nend.\n\n// While loop. Powers of 2\nbegin\n  Println('Powers of 2');\n  var i := 1;\n  var p := 1;\n  while i < 32 do\n  begin\n    Println($'{i,2}{p,12}');\n    i += 1;\n    p *= 2;\n  end;\nend.\n\n// While loop. Sum of digits of positive number\n\nbegin\n  var m := ReadlnInteger('Enter positive number:');\n\n  Print('Digits of number in reverse order:');\n  var s := 0;\n  while m>0 do\n  begin\n    var digit := m mod 10;\n    Print(digit);\n    s += digit;\n    m := m div 10;\n  end;\n  \n  Println;\n  Println('Sum of digits =',s);\nend."
  },
  {
    "instruction": "Show how to create a Windows Forms application with a button in PascalABC.NET",
    "output": "// Creating window application\n{$apptype windows}\n{$reference System.Windows.Forms.dll}\n\nuses \n  System,\n  System.Windows.Forms;\n\nvar myForm: Form;\n  \nprocedure MyButtonClick(sender: Object; e: EventArgs);\nbegin\n  myForm.Close;\nend;\n\nbegin\n  myForm := new Form;\n  myForm.Text := 'Window application';\n  var myButton := new Button;\n  myButton.Text := '  Close window  ';\n  myButton.AutoSize := True;\n  myButton.Left := 90;\n  myButton.Top := 110;\n  myForm.Controls.Add(myButton);\n  myButton.Click += MyButtonClick;\n  Application.Run(myForm);\nend."
  },
  {
    "instruction": "Create a 3D wireframe prism with labeled points using Graph3D module.",
    "output": "uses Graph3D;\n\nbegin\n  HideObjects;\n  var p := PrismWireFrame(Origin,13,3,5);\n  var pp := p.Points;\n  foreach var x in pp do\n    p.AddChild(Sphere(x,0.1,Colors.Gray));\n  var m := 'A';  \n  foreach var x in pp do\n  begin\n    var b := Text3D(x.Move(0.3,0.3,0.4),m,0.5);\n    p.AddChild(b);\n    Inc(m);\n  end;\n  var p1 := p.Clone;\n  p1.MoveByX(-5);\n  ShowObjects;\n  p1.AnimRotate(OrtZ,360,10).Forever.Begin;\nend."
  },
  {
    "instruction": "Create a WPF calculator application with basic arithmetic operations using procedural approach.",
    "output": "uses WPF;\n\nbegin\n  MainWindow.Title := 'Calculator';\n  var mainpanel := Panels.StackPanel.AsMainContent;\n  var panel1 := Panels.StackPanel(Margin := 10, Horizontal := True)\n    .With(Background := Brushes.LightBlue)\n    .AddTo(mainpanel);\n  \n  var tb := CreateTextBox('0', Width := 120);\n  var lb := CreateLabel('+',Width := 35);\n  var tb1 := CreateTextBox('0', Width := 120);\n  var lb1 := CreateLabel('=',Width := 55);\n  panel1.AddElements(tb,lb,tb1,lb1);\n  \n  var panel2 := Panels.StackPanel(Margin := |10,0,10,10|, Horizontal := True)\n    .With(Background := Brushes.LightBlue)\n    .AddTo(mainpanel);\n  panel2.HorizontalAlignment := HA.Right;\n\n  var Handler: EventHandler := (o,e) -> begin\n    var b := o as Button;\n    var Left := tb.Text.ToReal;\n    var Right := tb1.Text.ToReal;\n    case b.Text of\n      $'+': lb1.Content := '= ' + (Left + Right);\n      $'-': lb1.Content := '= ' + (Left - Right);\n      $'*': lb1.Content := '= ' + (Left * Right);\n      $'/': lb1.Content := '= ' + (Left / Right);\n    end;\n  end;\n  \n  var bb := CreateButtons(|$'+',$'-',$'*',$'/'|); \n  panel2.AddElements(bb, Width := 35, Margin := |10,0|, Padding := 5);\n\n  for var i:=0 to bb.Length-1 do\n    bb[i].Click += Handler;\n  \n  MainWindow.SizeToContent := SizeToContent.WidthAndHeight;\nend."
  },
  {
    "instruction": "Create a WPF calculator application using class-based approach with proper encapsulation.",
    "output": "uses WPF;\n\ntype Main = class\n  mainpanel,panel1,panel2: StackPanel;\n  tb,tb1: TextBox;\n  lb,lb1: TLabel;\n  bb: array of Button;\n  \n  procedure ButtonClick(o: Object; e: RoutedEventArgs);\n  begin\n    var b := o as Button;\n    var Left := tb.Text.ToReal;\n    var Right := tb1.Text.ToReal;\n    case b.Text of\n      $'+': lb1.Content := '= ' + (Left + Right);\n      $'-': lb1.Content := '= ' + (Left - Right);\n      $'*': lb1.Content := '= ' + (Left * Right);\n      $'/': lb1.Content := '= ' + (Left / Right);\n    end;\n  end;\n  \n  procedure InitControls;\n  begin\n    MainWindow.Title := 'Calculator';\n    mainpanel := Panels.StackPanel.AsMainContent;\n    panel1 := Panels.StackPanel(Margin := 10, Horizontal := True)\n      .With(Background := Brushes.LightBlue)\n      .AddTo(mainpanel);\n    \n    tb := CreateTextBox('0', Width := 120);\n    lb := CreateLabel('+',Width := 35);\n    tb1 := CreateTextBox('0', Width := 120);\n    lb1 := CreateLabel('=',Width := 55);\n    panel1.AddElements(tb,lb,tb1,lb1);\n    \n    panel2 := Panels.StackPanel(Margin := |10,0,10,10|, Horizontal := True)\n      .With(Background := Brushes.LightBlue)\n      .AddTo(mainpanel);\n    panel2.HorizontalAlignment := HA.Right;\n    \n    bb := CreateButtons(|$'+',$'-',$'*',$'/'|); \n    panel2.AddElements(bb, Width := 35, Margin := |10,0|, Padding := 5);\n\n    for var i:=0 to bb.Length-1 do\n      bb[i].Click += ButtonClick;\n    \n    MainWindow.SizeToContent := SizeToContent.WidthAndHeight;\n  end;\nend;\n\nbegin\n  Main.Create.InitControls; \nend."
  },
  {
    "instruction": "Create programs that demonstrate tuple unpacking for different scenarios: range tuples, dictionary key-value pairs, and ValueTuple types.",
    "output": "begin\n  var t := 2 to 3.5;\n  var (a,b) := t;\n  Println(a,b);\n  foreach var (a1,b1) in Dict(1 to 7, 22 to 555) do\n    Println(a1,b1);\nend.\n\nbegin\n  var s := Seq(('\u0423\u043c\u043d\u043e\u0432\u0430',16),('\u0418\u0432\u0430\u043d\u043e\u0432',23),\n               ('\u041f\u043e\u043f\u043e\u0432\u0430',17),('\u041a\u043e\u0437\u043b\u043e\u0432',24));\n  Println('Adults:');\n  s.Where(\\(name,age) -> age >= 18).Println;\n  Println('Sort by last name:');\n  s.OrderBy(\\(name,age) -> name).Println;\nend.\n\nbegin\n  var (n,s) := System.ValueTuple.Create(2,'ab');\n  Print(n,s);\nend."
  },
  {
    "instruction": "Create a generic Node class for a circular linked list and demonstrate creating two nodes that reference each other.",
    "output": "type \n  Node<T> = class\n  public\n    data: T;\n    next: Node<T>;\n    constructor (d: T; n: Node<T>);\n    begin\n      data := d;\n      next := n;\n    end;\n  end;\n\nbegin\n  var n1 := new Node<integer>(5,nil);\n  var n2 := new Node<integer>(6,n1);\n  writeln(n2);\n  n1.next := n2;\n  writeln(n2);\nend."
  },
  {
    "instruction": "Create programs that demonstrate various formatting options using WritelnFormat function, including reverse order output, escaping curly braces, field width specification, and decimal precision.",
    "output": "begin\n  WritelnFormat('{2},{1},{0}',1,2,3);\n  WritelnFormat('{{}}{0}','Output curly braces in format string');\n  WritelnFormat('{0,10:f}',3.1415);\n  WritelnFormat('{0:f3}',3.1415);\nend.\n\nbegin\n  WritelnFormat('{2},{1},{0}',1,2,3);\n  WritelnFormat('{{}}{0}','Output curly braces in format string');\n  WritelnFormat('{0:f3}',3.1415);\n  WritelnFormat('{0,10:f}',3.1415);\nend."
  },
  {
    "instruction": "Create a program that demonstrates zero-based string indexing directive and its effect on string slices and indexing.",
    "output": "{$zerobasedstrings}\nbegin\n  var s := '0123456789';\n  Println(s[0:5],s[5:8],s[8:]);\n  Print(s[^1]);\nend."
  },
  {
    "instruction": "Create a program that finds real zeros of a function on isolation intervals using NumLibABC module.",
    "output": "uses NumLibABC;\n\nbegin\n   var f:real->real := t->sin(t)/(1+Sqr(Exp(t)))-0.1;\n   var oL:=new Zeroin(f,1e-12);\n   Println(oL.Value(-10,-9.5), oL.Value(-6.5,-6), oL.Value(-3.5,-3),\n        oL.Value(0,0.5),oL.Value(1,1.5))\nend."
  },
  {
    "instruction": "Create programs that demonstrate Zip function usage for element-wise operations on sequences and Cartesian product operations.",
    "output": "begin\n  var a := Seq(1,5,3,2,4);\n  var b := Seq(2,3,4,1,6);\n  a.Zip(b,(x,y)->x*y).Print;\nend.\n\nbegin\n  var a := Seq(1,5,3,2,4);\n  a.Zip(a.Skip(1),(x,y)->y-x).Print;\nend.\n\nbegin\n  Zip(1..5,2..6).Println;\n  Zip(1..5,2..6,(x,y) -> x+y).Println;\n  Zip(1..5,2..6,3..7).Println;\n  Zip(1..5,2..6,3..7,(x,y,z) -> x+y+z).Println;\n\n  Cartesian(1..4,3..5).Println;\n  Cartesian(1..4,3..5,(x,y) -> x*y).Println;\n  Cartesian(1..2,4..5,6..7).Println;\n  Cartesian(1..2,4..5,6..7,(x,y,z) -> x*y*z).Println;\n\n  foreach var (a,b) in Cartesian(1..2,3..5) do\n    Print($'{a}+{b}')\nend."
  },
  {
    "instruction": "Create a procedure that draws lines connecting all points of a regular polygon using Cartesian product.",
    "output": "uses GraphWPF;\n\nprocedure \u0412\u0441\u0435\u0422\u043e\u0447\u043a\u0438\u041c\u043d\u043e\u0433\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430(x0,y0,r: real; n: integer);\nbegin\n  var q := PartitionPoints(0,2*Pi,n).Select(a->Pnt(x0 + r * Cos(a), y0 - r * Sin(a)));\n  q.Cartesian(q).ForEach(p->Line(p[0].x,p[0].y,p[1].x,p[1].y,RandomColor));\nend;\n\nbegin\n  Pen.Width := 0.5;\n  \u0412\u0441\u0435\u0422\u043e\u0447\u043a\u0438\u041c\u043d\u043e\u0433\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430(400,300,290,30)\nend."
  },
  {
    "instruction": "Create programs that demonstrate different text alignment options in GraphWPF for both rectangle areas and point coordinates.",
    "output": "uses GraphWPF;\n\nbegin\n  Window.Title := 'Font alignment';\n  Font.Size := 20;\n  var (x,y) := (200,200);\n  var (w,h) := (400,200);\n  DrawRectangle(x,y,w,h);\n  DrawText(x,y,w,h,'LeftTop',Alignment.LeftTop);\n  DrawText(x,y,w,h,'LeftCenter',Alignment.LeftCenter);\n  DrawText(x,y,w,h,'LeftBottom',Alignment.LeftBottom);\n  DrawText(x,y,w,h,'CenterTop',Alignment.CenterTop);\n  DrawText(x,y,w,h,'Center');\n  DrawText(x,y,w,h,'CenterBottom',Alignment.CenterBottom);\n  DrawText(x,y,w,h,'RightTop',Alignment.RightTop);\n  DrawText(x,y,w,h,'RightCenter',Alignment.RightCenter);\n  DrawText(x,y,w,h,'RightBottom',Alignment.RightBottom);\n  TextOut(150,100,'PointRightBottom',Alignment.RightBottom);\n  TextOut(150,100,'PointRightTop',Alignment.RightTop);\n  TextOut(150,100,'PointLeftTop',Alignment.LeftTop);\n  TextOut(150,100,'PointLeftBottom',Alignment.LeftBottom);\n  FillCircle(150,100,5,Colors.Red);\n  TextOut(600,100,'PointCenterTop',Alignment.CenterTop);\n  TextOut(600,100,'PointCenterBottom',Alignment.CenterBottom);\n  FillCircle(600,100,5,Colors.Red);\n  TextOut(400,500,'PointLeftCenter',Alignment.LeftCenter);\n  TextOut(400,500,'PointRightCenter',Alignment.RightCenter);\n  FillCircle(400,500,5,Colors.Red);\nend.\n\nuses GraphWPF;\n\nbegin\n  Window.Title := 'Font alignment';\n  Font.Size := 20;\n  \n  var sc := 40;\n  SetMathematicCoords;\n  \n  var (x,y) := (-5,-2);\n  var (w,h) := (10,4);\n  DrawRectangle(x,y,w,h);\n  DrawText(x,y,w,h,'LeftTop',Alignment.LeftTop);\n  DrawText(x,y,w,h,'LeftCenter',Alignment.LeftCenter);\n  DrawText(x,y,w,h,'LeftBottom',Alignment.LeftBottom);\n  DrawText(x,y,w,h,'CenterTop',Alignment.CenterTop);\n  DrawText(x,y,w,h,'Center');\n  DrawText(x,y,w,h,'CenterBottom',Alignment.CenterBottom);\n  DrawText(x,y,w,h,'RightTop',Alignment.RightTop);\n  DrawText(x,y,w,h,'RightCenter',Alignment.RightCenter);\n  DrawText(x,y,w,h,'RightBottom',Alignment.RightBottom);\n  TextOut(-5,5,'PointRightBottom',Alignment.RightBottom);\n  TextOut(-5,5,'PointRightTop',Alignment.RightTop);\n  TextOut(-5,5,'PointLeftTop',Alignment.LeftTop);\n  TextOut(-5,5,'PointLeftBottom',Alignment.LeftBottom);\n  FillCircle(-5,5,0.1,Colors.Red);\n  TextOut(5,5,'PointCenterTop',Alignment.CenterTop);\n  TextOut(5,5,'PointCenterBottom',Alignment.CenterBottom);\n  FillCircle(5,5,0.1,Colors.Red);\n  TextOut(5,-5,'PointLeftCenter',Alignment.LeftCenter);\n  TextOut(5,-5,'PointRightCenter',Alignment.RightCenter);\n  FillCircle(5,-5,0.1,Colors.Red);\nend."
  },
  {
    "instruction": "Create a WPF application with checkboxes that mix RGB colors to change the background color dynamically.",
    "output": "uses WPF;\n\nfunction MixColor(r,g,b: boolean): Color;\nbegin\n  var ri := integer(r);\n  var gi := integer(g);\n  var bi := integer(b);\n  Result := RGB(ri*255,gi*255,bi*255);\nend;\n\ntype Main = class\n  MainPanel: StackPanel;\n  cbr,cbg,cbb: CheckBox;\n  constructor;\n  begin\n    MainPanel := Panels.StackPanel(Margin := 10, Horizontal := True)\n      .With(Background := Brushes.LightBlue).AsMainContent;\n    cbr := CreateCheckBox('Red', Margin := 5);\n    cbg := CreateCheckBox('Green', Margin := 5, IsChecked := True);\n    cbb := CreateCheckBox('Blue', Margin := 5);\n    mainpanel.AddElements(cbr,cbg,cbb);\n    cbr.Click += Handler;\n    cbg.Click += Handler;\n    cbb.Click += Handler;\n    Handler(nil,nil);\n  end;\n  procedure Handler(o: object; e: RoutedEventArgs);\n  begin\n    var (r,g,b) := (cbr.IsChecked,cbg.IsChecked,cbb.IsChecked);\n    mainpanel.Background := GBrush(MixColor(r.Value,g.Value,b.Value));\n  end;\nend;\n\nbegin\n  Main.Create;\nend."
  },
  {
    "instruction": "Create a WPF application with a combobox that displays standard colors and changes a rectangle's fill color when selected.",
    "output": "uses WPF;\n\nbegin\n  var colorNames := typeof(Colors).GetProperties\n    .ToDictionary(pi -> pi.Name, pi -> GBrush(Color(pi.GetValue(nil,nil))));\n  MainWindow.Title := 'Standard Colors';\n  MainWindow.WindowStartupLocation := WindowStartupLocation.CenterScreen;\n  var mainpanel := CreateStackPanel(Margin := 10, Horizontal := True).AsMainContent;\n  var panel1 := CreateStackPanel(Width := 250).AddTo(mainpanel);\n  var cb := CreateComboBox.AddTo(panel1);\n  cb.ItemsSource := colorNames.Keys;\n  var rect := CreateRectangle(Height := 200, Margin := |0,10|).AddTo(panel1);\n  rect.Fill := Brushes.Blue;\n  \n  cb.SelectionChanged += procedure(o,e) -> (rect.Fill := colorNames[cb.SelectedValue as string]);\n  \n  MainWindow.SizeToContent := SizeToContent.WidthAndHeight;\nend."
  },
  {
    "instruction": "Create WPF applications that demonstrate DockPanel layout with buttons docked to different sides.",
    "output": "uses WPF;\n\nbegin\n  var dpanel := Panels.DockPanel.AsMainContent;\n  var b := Controls.Button('One');\n  var b1 := Controls.Button('Two');\n  var b2 := Controls.Button('Three');\n  var b3 := Controls.Button('Four');\n  var b4 := Controls.Button('Five');\n  dpanel.Children.Add(b);\n  dpanel.Children.Add(b1);\n  dpanel.Children.Add(b2);\n  dpanel.Children.Add(b3);\n  dpanel.Children.Add(b4);\n  DockPanel.SetDock(b,Dock.Left);\n  DockPanel.SetDock(b1,Dock.Right);\n  DockPanel.SetDock(b2,Dock.Top);\n  DockPanel.SetDock(b3,Dock.Bottom);\nend.\n\nuses WPF;\n\nbegin\n  var dpanel := Panels.DockPanel.AsMainContent;\n  var b := Controls.Button('One',Width := 100).AddTo(dpanel,Dock.Left);\n  var b1 := Controls.Button('Two',Width := 100).AddTo(dpanel,Dock.Right);\n  var b2 := Controls.Button('Three',Height := 50).AddTo(dpanel,Dock.Top);\n  var b3 := Controls.Button('Four',Height := 50).AddTo(dpanel,Dock.Bottom);\n  var b4 := Controls.Button('Five').AddTo(dpanel);\n  b.Click += (o,e) -> begin\n    MainWindow.Close\n  end;\nend."
  },
  {
    "instruction": "Create a WPF application that demonstrates dynamic font property changes including font size, font family, italic, and bold styles using sliders and checkboxes.",
    "output": "uses WPF;\n\nbegin\n  MainWindow.FontSize := 16;\n  MainWindow.Title := 'Font properties';\n  var dpanel := CreateDockPanel(Margin := 10).AsMainContent;\n  var toppanel := Panels.StackPanel(Horizontal := True, Margin := 0);\n  var TextLabel := CreateLabel('PascalABC.NET').With(HA := HA.Center, VA := VA.Center);\n  TextLabel.FontSize := 100;\n  dpanel.Add(toppanel,Dock.Top);\n  dpanel.Add(TextLabel);\n  \n  CreateLabel('Font size', Margin := 0).AddTo(toppanel);\n  var fontsizeslider := CreateSlider(20,100,10,10,Width := 100, Value := 100).AddTo(toppanel);\n  fontsizeslider.ValueChanged += procedure(o,e) -> TextLabel.FontSize := fontsizeslider.Value;\n  \n  CreateLabel('Font name',Margin := |20,0|).AddTo(toppanel);\n  var cb := CreateComboBox(|'Segoe UI','Arial','Times New Roman','Courier New'|).AddTo(toppanel);\n  cb.SelectionChanged += procedure(o,e) -> TextLabel.FontFamily := cb.SelectedValue.ToString;\n\n  var chb := CreateCheckBox('Italic',Margin := |20,5,0,0|).AddTo(toppanel);\n  chb.Click += procedure(o,e) -> (TextLabel.FontStyle := \n    chb.IsChecked.Value ? FontStyles.Italic : FontStyles.Normal);\n  var chb2 := CreateCheckBox('Bold',Margin := |20,5,0,0|).AddTo(toppanel);\n  chb2.Click += procedure(o,e) -> (TextLabel.FontWeight := \n    chb2.IsChecked.Value ? FontWeights.Bold : FontWeights.Normal);\nend."
  },
  {
    "instruction": "Create a WPF application that demonstrates dynamic rectangle property changes including width, height, and corner radius using sliders with data binding.",
    "output": "uses WPF;\n\nbegin\n  MainWindow.Title := 'Rectangle properties';\n  MainWindow.FontSize := 14;\n  MainWindow.WindowStartupLocation := WindowStartupLocation.CenterScreen;\n  var mainpanel := CreateDockPanel(Margin := 5).AsMainContent;\n  var leftpanel := CreateStackPanel(Margin := 0, Width := 150)\n    .With(Background := Brushes.Bisque).AddTo(mainpanel,Dock.Left);\n  var rect := CreateRectangle(Width := 300, Height := 200).With(HA := HA.Center, VA := VA.Center).AddTo(mainpanel);\n  rect.Fill := Brushes.Blue;\n  var widthslider := CreateSlider(50,500,10,50);\n  var tbwidth := CreateTextBlock();\n  var heightslider := CreateSlider(50,500,10,50);\n  var tbHeight := CreateTextBlock();\n  var radiusslider := CreateSlider(0,50,10,50);\n  var tbRadius := CreateTextBlock();\n  \n  leftpanel.AddElements(widthslider, tbwidth, heightslider, tbHeight, radiusslider, tbRadius);\n\n  widthslider.ValueChanged += procedure(o,e) -> tbwidth.Text := 'Width: ' + widthslider.Value.ToString(0);\n  heightslider.ValueChanged += procedure(o,e) -> tbheight.Text := 'Height: ' + heightslider.Value.ToString(0);\n  radiusslider.ValueChanged += procedure(o,e) -> begin\n    tbRadius.Text := 'Corner radius: ' + radiusslider.Value.ToString(0);\n    rect.RadiusX := radiusslider.Value;\n    rect.RadiusY := radiusslider.Value;\n  end; \n  radiusslider.Value := 10;\n\n  widthslider.SetBinding(Slider.ValueProperty, rect, 'Width');\n  heightslider.SetBinding(Slider.ValueProperty, rect, 'Height');\nend."
  },
  {
    "instruction": "Show how to output various data types using the write procedure in PascalABC.NET",
    "output": "/// Output of various types using write procedure\nbegin\n  // Output of integer, string, real\n  Writeln(1,'  ',2.5);\n  // Output of set\n  Writeln([1..10]);\n  // Output of boolean\n  Writeln(True);\n  var a: array [1..10] of integer;\n  // Output of static array\n  Writeln(a);\n  // Output of dynamic array\n  Writeln([2,3,5]);\n  // Output of tuple\n  Writeln(('Ivanov',16));\n  // Output of dictionary\n  Writeln(Dict('Ivanov' to 4.7, 'Petrova' to 4.9, 'Kozlov' to 3.8));\nend."
  },
  {
    "instruction": "Create a traffic light drawing procedure using GraphWPF that draws a gray rectangle with three colored circles (red, yellow, green) in vertical arrangement.",
    "output": "uses GraphWPF;\n\nprocedure \u0421\u0432\u0435\u0442\u043e\u0444\u043e\u0440(x,y,r: real);\nbegin\n  Rectangle(x,y,4*r,10*r,Colors.LightGray);\n  x += 2*r;\n  y += 2*r;\n  var dy := 3*r;\n\n  Circle(x,y,r,Colors.Red);\n  Circle(x,y + dy,r,Colors.Yellow);\n  Circle(x,y + 2*dy,r,Colors.Green);\nend;\n\nbegin\n  Pen.Width := 2;\n  Window.Title := 'Traffic Light';\n  \u0421\u0432\u0435\u0442\u043e\u0444\u043e\u0440(150,40,50);\nend."
  },
  {
    "instruction": "Create a mathematical coordinate system using GraphWPF with grid lines and a polygon with labeled vertices.",
    "output": "uses GraphWPF;\n\nbegin\n  Window.Title := 'Coordinate System';\n  Font.Size := 20;\n\n  SetMathematicCoords(-10,10,-9.2);\n  DrawGrid;\n \n  Print('Visible coordinates:',XMin,XMax,YMin,YMax);\n  \n  Polygon(Arr((-3,2),(2,1),(-2,-4)),ARGB(100,255,228,196));\n  TextOut(-3,2,'A(-3,2)',Alignment.RightBottom);\n  TextOut(2,1,'B(2,1)',Alignment.LeftBottom);\n  TextOut(-2,-4,'C(-2,-4)',Alignment.CenterTop);\nend."
  },
  {
    "instruction": "Create a 3D scene with interactive color changing where clicking on objects changes their color to a random color.",
    "output": "uses Graph3D;\n\nbegin \n  var s := Sphere(3,0,1,1);\n  var b := Box(0,2,0.5,3,2,1);\n  var t := Text3D(-5,0,1,'Graph3D',2);\n  OnMouseDown += procedure (x,y,mb) -> begin\n    if mb<>1 then exit;\n    var v := FindNearestObject(x,y);\n    if v<>nil then\n      v.Color := RandomColor;\n  end;\nend."
  },
  {
    "instruction": "Create a multiplication table display using GraphWPF that shows a 9x9 grid with multiplication results.",
    "output": "uses GraphWPF;\n\nbegin\n  Window.Title := 'Multiplication Table';\n  Font.Size := 16;\n  var n := 9;\n  var w := 40;\n  var (x0,y0) := (50,50);\n  for var i:=0 to n-1 do\n  for var j:=0 to n-1 do\n  begin\n    var (xx,yy) := (x0+i*w,y0+j*w);\n    Rectangle(xx,yy,w,w);\n    DrawText(xx,yy,w,w,(i+1)*(j+1));\n  end;  \nend."
  },
  {
    "instruction": "Create an animated 3D clock with rotating second and minute hands using Graph3D.",
    "output": "uses Graph3D;\n\nbegin\n  View3D.ShowGridLines := False;\n  var \u0426\u0438\u0444\u0435\u0440\u0431\u043b\u0430\u0442 := Cylinder(0,0,-0.4,0.2,6,Colors.DeepPink);\n  var \u0421\u0435\u043a := Arrow(0,0,0,0,-5.5,0,0.2,Colors.Yellow);\n  var \u041c\u0438\u043d := Arrow(0,0,0,0,-6.0,0,0.3,Colors.Red);\n  \n  var a := 0;\n  var r := 5.8;\n  loop 60 do\n  begin\n    Sphere(r*cos(a*Pi/180),r*sin(a*Pi/180),-0.2,0.1,Colors.White);\n    a += 6;\n  end;\n  \n  while True do\n  begin\n    Sleep(10);\n    \u0421\u0435\u043a.Rotate(v3D(0,0,1),-6);\n    \u041c\u0438\u043d.Rotate(v3D(0,0,1),-6/60);\n  end;\nend."
  },
  {
    "instruction": "Create a 3D castle structure using cloning and grouping of 3D objects with random colors and save it to a file.",
    "output": "uses Graph3D;\n\nfunction MultipleClones(c: Object3D; N: integer): Group3D;\nbegin\n  var g := Group(c);\n  loop N-1 do\n  begin\n    c := c.Clone;\n    c.MoveByX(-1.5);\n    if c is ObjectWithMaterial3D then \n      (c as ObjectWithMaterial3D).Color := RandomColor;\n    g.AddChild(c);\n  end;\n  Result := g;\nend;\n\nbegin\n  HideObjects;\n  var b := Box(0,0,2,14.5,1,4,Colors.Orange);\n  var c := Cube(6.75,0,4.5,1,RandomColor);\n  var c1 := Cone(6.75,0,5,1.5,0.4,RandomColor);\n  var g := MultipleClones(c,10);\n  var gp := MultipleClones(c1,10);\n  var gg := Group(g,b,gp);\n  var g1 := gg.Clone.MoveByY(6);\n  var g2 := gg.Clone.MoveByY(-6);\n  gg.Rotate(OrtZ,90);\n  var g3 := gg.Clone.MoveByX(-6);\n  gg.MoveByX(6);\n  var ggg := Group(gg,g1,g2,g3);\n  ShowObjects;\n\n  ggg.Save('\u0417\u0430\u043c\u043e\u043a.xaml');\nend."
  },
  {
    "instruction": "Create procedures to draw regular polygons with different numbers of sides using GraphWPF.",
    "output": "uses GraphWPF;\n\nprocedure \u041c\u043d\u043e\u0433\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a(x0,y0,r: real; n: integer);\nbegin\n  var a := Pi / 2;\n  MoveTo(x0 + r * Cos(a), y0 - r * Sin(a));\n  loop n do \n  begin\n    a += 2 * Pi / n;\n    LineTo(x0 + r * Cos(a), y0 - r * Sin(a));\n  end;\nend;\n\nbegin\n  var (x0,y0) := (400.0,300.0);\n  var r := 30.0;\n  for var n := 3 to 11 do\n    \u041c\u043d\u043e\u0433\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a(x0,y0,r+(n-3)*30,n)\nend.\n\nuses GraphWPF;\n\nbegin\n  var (n,r) := (9,250);\n  var a := ArrGen(n, i -> Window.Center + r * Vect(Cos(i*2*Pi/n),Sin(i*2*Pi/n)));\n  foreach var p in a.Combinations(2) do\n    Line(p[0], p[1]);\nend."
  },
  {
    "instruction": "Demonstrate arithmetic calculations with user input using ReadlnInteger2 in PascalABC.NET",
    "output": "begin\n  var (a,b) := ReadlnInteger2('Enter a and b:');\n  Writeln;\n  Writeln(a,' + ',b,' = ',a+b);\n  Writeln(a,' - ',b,' = ',a-b);\n  Writeln(a,' * ',b,' = ',a*b);\n  Writeln(a,' / ',b,' = ',a/b);\nend."
  },
  {
    "instruction": "Call static method from C# class library in PascalABC.NET",
    "output": "{$reference ClassLibrary1.dll}\nuses ClassLibrary1;\n\nbegin\n  writeln(Class1.add(2,3));  \nend."
  },
  {
    "instruction": "Call native DLL function from PascalABC.NET with platform target specification",
    "output": "{$platformtarget x86}\nfunction add(a,b: integer): integer; external 'NativeDll.dll' name 'add';\n\nbegin\n  writeln(add(2,3));\nend."
  },
  {
    "instruction": "Demonstrate string permutations, combinations and Cartesian operations in PascalABC.NET",
    "output": "begin\n  'abc'.Permutations.Println;\n  'abc'.Permutations(2).Println;\n  'abc'.Combinations(2).Println;\n  'abc'.CartesianPower(2).Println;\n  'abc'.Cartesian('def').Println;\nend."
  },
  {
    "instruction": "Implement case statement for grade evaluation in PascalABC.NET",
    "output": "var x: integer;\n\nbegin\n  writeln('Enter grade (1..5): ');\n  readln(x);\n  case x of\n    1: writeln('One');\n    2: writeln('Two');\n    3: writeln('Three');\n    4: writeln('Four');\n    5: writeln('Five');  \n  else writeln('No such grade');\n  end;\nend."
  },
  {
    "instruction": "Use case statement with ranges for weekday classification in PascalABC.NET",
    "output": "var day: integer;\n\nbegin\n  writeln('Enter day of week number (1..7): ');\n  readln(day);\n  case day of\n    1..5: writeln('Weekday');\n    6,7: writeln('Weekend');\n  else writeln('Invalid day of week');\n  end;\nend."
  },
  {
    "instruction": "Implement character classification using case statement in PascalABC.NET",
    "output": "var c: char;\n\nbegin\n  writeln('Enter character: ');\n  readln(c);\n  case c of\n    '0'..'9': writeln('This is digit');\n    'a'..'z','A'..'Z': writeln('This is English letter');\n    '\u0430'..'\u044f','\u0410'..'\u042f': writeln('This is Russian letter');\n  end;\nend."
  },
  {
    "instruction": "Generate random geometric shapes using case statement with GraphABC in PascalABC.NET",
    "output": "uses GraphABC;\n\nbegin\n  SetWindowSize(400,300);\n  var t := Random(1,5);\n  case t of\n    1: Circle(200,150,100);\n    2: Rectangle(100,100,300,200);\n    3: Ellipse(100,100,300,200);\n    4: RoundRect(100,100,300,200,20,20);\n    5: Line(100,100,300,200);\n  end;\nend."
  },
  {
    "instruction": "Demonstrate efficient real to integer casting in PascalABC.NET",
    "output": "begin\n  var i: integer := integer(2.7);\n  Print(i);\nend."
  },
  {
    "instruction": "Create comprehensive UI with all Controls module elements in GraphWPF using PascalABC.NET",
    "output": "uses GraphWPF,Controls;\n\nbegin\n  Window.Title := 'Controls module - all UI elements';\n  LeftPanel(160,Colors.Orange);\n \n  Button('Button');\n  CheckBox('Checkbox');\n  RadioButton('Radio button 1');\n  RadioButton('Radio button 2');\n  TextBox('Text input field');\n  var ib := IntegerBox('Integer input',0,10);\n  ib.Tooltip := 'Use mouse wheel to change value';\n  var l := ListBox('Country list');\n  l.Height := 110;\n  l.Add('Russia');\n  l.Add('USA');\n  l.Add('China');\n  l.Add('Germany');\n  l.Add('France');\n  var cb := ComboBox('Dropdown list');\n  cb.AddRange('Russia','USA','China','Germany','France');\n  \n  Slider('Slider:',0,10);\n  TextBlock('Text block');\n  IntegerBlock('Integer block:',64);\n  RealBlock('Real block:',3.5);\n\n  var s := StatusBar;\n  s.Text := 'Status bar';\nend."
  },
  {
    "instruction": "Implement 3D sphere dragging with mouse interaction using Graph3D in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin \n  View3D.Title := 'Drag sphere with mouse';\n  var s := Sphere(0,0,0,1);\n  var obj: Object3D;\n  OnMouseDown += procedure (x,y,mb) -> begin\n    obj := FindNearestObject(x,y);\n    if obj=s then View3D.Title := '';\n  end;\n\n  OnMouseUp += procedure (x,y,mb) -> begin\n    obj := nil\n  end;\n  \n  OnMouseMove += procedure (x,y,mb) -> begin\n    if obj = nil then exit;\n    var pp := PlaneXY.PointOnPlane(x,y);\n    if pp<>BadPoint then\n    begin\n      if pp.X<-5 then pp.X := -5;\n      if pp.X>5 then pp.X := 5;\n      if pp.Y<-5 then pp.Y := -5;\n      if pp.Y>5 then pp.Y := 5;\n      obj.Position := pp;\n      View3D.SubTitle := $'X={pp.x.ToString(2)} Y={pp.y.ToString(2)}';\n    end;\n  end;\nend."
  },
  {
    "instruction": "Create UI with constructor-based control creation and right panel in PascalABC.NET",
    "output": "uses GraphWPF,Controls;\n\nbegin\n  Window.Title := 'Controls module - constructor creation + right panel';\n  new RightPanelWPF(160,Colors.Orange);\n \n  new ButtonWPF('Button');\n  new CheckBoxWPF('Checkbox');\n  new RadioButtonWPF('Radio button 1');\n  new RadioButtonWPF('Radio button 2');\n  new TextBoxWPF('Text input field');\n  var ib := new IntegerBoxWPF('Integer input',0,10);\n  ib.Tooltip := 'Use mouse wheel to change value';\n  var l := new ListBoxWPF('Country list');\n  l.Height := 110;\n  l.Add('Russia');\n  l.Add('USA');\n  l.Add('China');\n  l.Add('Germany');\n  l.Add('France');\n  var cb := new ComboBoxWPF('Dropdown list');\n  cb.AddRange('Russia','USA','China','Germany','France');\n  \n  new SliderWPF('Slider:',0,10);\n  new TextBlockWPF('Text block');\n  new IntegerBlockWPF('Integer block:',64);\n  new RealBlockWPF('Real block:',3.5);\n\n  var s := new StatusBarWPF;\n  s.Text := 'Status bar';\nend."
  },
  {
    "instruction": "Implement button click handlers with different actions in Controls module using PascalABC.NET",
    "output": "uses GraphWPF,Controls;\n\nbegin\n  Window.Title := 'Controls module - buttons and their handlers';\n  var p := LeftPanel;\n  p.Color := Colors.Orange;\n \n  Button('Random color').Click := () -> begin\n    Window.Clear(RandomColor);\n  end;\n  \n  var b2 := Button('Plus');\n  b2.Click := procedure -> \n    if b2.Text = 'Plus' then b2.Text = 'Minus' else b2.Text = 'Plus';\n\n  var b1 := Button('Close window');\n  b1.Click := procedure -> Window.Close;\nend."
  },
  {
    "instruction": "Implement checkbox controls with programmatic toggling in PascalABC.NET",
    "output": "uses GraphWPF,Controls;\n\nbegin\n  Window.Title := 'Controls module - checkboxes';\n  \n  var p := LeftPanel(170,Colors.Orange);\n \n  var b1 := Button('Toggle checkbox 1');\n  var b2 := Button('Toggle checkbox 2');\n  var b3 := Button('Toggle checkbox 3');\n\n  var cb1 := new CheckBoxWPF('Checkbox 1');\n  var cb2 := new CheckBoxWPF('Checkbox 2');\n  var cb3 := new CheckBoxWPF('Checkbox 3');\n  \n  b1.Click := procedure -> cb1.Checked := not cb1.Checked;\n  b2.Click := procedure -> cb2.Checked := not cb2.Checked;\n  b3.Click := procedure -> cb3.Checked := not cb3.Checked;\nend."
  },
  {
    "instruction": "Create circle customization interface with checkboxes using WPFObjects in PascalABC.NET",
    "output": "uses WPFObjects,Controls;\n\nbegin\n  Window.Title := 'Controls module - checkboxes';\n  \n  LeftPanel(170);\n \n  var tb := TextBlock('Circle parameters:'); \n  tb.Margin := 12;\n  \n  var cb1 := new CheckBoxWPF('Fill');\n  var cb2 := new CheckBoxWPF('Bold border');\n  var cb3 := new CheckBoxWPF('With text');\n  \n  var c := new CircleWPF(GraphWindow.Center,60,Colors.White,1);\n  \n  cb1.Click := procedure -> begin\n    if cb1.Checked then \n      c.Color := Colors.Green\n    else c.Color := Colors.White\n  end;\n  cb2.Click := procedure -> begin\n    if cb2.Checked then \n      c.BorderWidth := 4\n    else c.BorderWidth := 1\n  end;\n  cb3.Click := procedure -> begin\n    if cb3.Checked then \n      c.Text := 'Text'\n    else c.Text := ''\n  end;\nend."
  },
  {
    "instruction": "Implement color selection using radio buttons with WPFObjects in PascalABC.NET",
    "output": "uses WPFObjects,Controls;\n\nbegin\n  Window.Title := 'Controls module - radio buttons';\n  LeftPanel(150,Colors.Beige);\n \n  var tb := TextBlock('Circle color:'); \n  \n  var rb1 := new RadioButtonWPF('Red');\n  var rb2 := new RadioButtonWPF('Green');\n  var rb3 := new RadioButtonWPF('Blue');\n  \n  var c := new CircleWPF(GraphWindow.Center,60,Colors.White,1);\n  \n  rb1.Click := procedure -> begin\n    c.Color := Colors.Red;\n  end;\n  rb2.Click := procedure -> begin\n    c.Color := Colors.Green;\n  end;\n  rb3.Click := procedure -> begin\n    c.Color := Colors.Blue;\n  end;\nend."
  },
  {
    "instruction": "Implement 3D object movement along lines with mouse interaction using Graph3D in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin \n  var d := new Dictionary<Object3D,Line3D>;\n  \n  var pp := Arr(p3D(2,3,0),p3D(-3,0,0),p3D(2,-2,0));\n  var p := p3D(0,0,5);\n  foreach var x in pp do\n  begin\n    var lin := Line(x,p);\n    Segment3D(x,p);\n    var s := Sphere(x,0.2);\n    d[s] := lin;\n  end;\n  \n  var tr := Polygon3D(Arr(pp));\n  \n  var obj: Object3D;\n  OnMouseDown += procedure (x,y,mb) -> begin\n    obj := FindNearestObject(x,y);\n    if obj=nil then exit;\n    if not d.ContainsKey(obj) then\n      obj := nil;\n  end;\n\n  OnMouseUp += procedure (x,y,mb) -> begin\n    obj := nil\n  end;\n\n  OnMouseMove += procedure (x,y,mb) -> begin\n    if mb<>1 then exit;\n    if obj=nil then exit;\n    \n    obj.Position := d[obj].NearestPointOnLine(x,y);\n    \n    var pp := d.Keys.Select(o->o.Position).ToArray;\n    tr.Points := Arr(pp[0],pp[1],pp[1],pp[2],pp[2],pp[0]);\n  end;\nend."
  },
  {
    "instruction": "Create UI with controls positioned manually on main panel in PascalABC.NET",
    "output": "uses GraphWPF,Controls;\n\nbegin\n  Window.Title := 'Controls module - manually positioned controls';\n\n  var x := 10;\n  var w := 140;\n  Button(x,10,'Button',w);\n  CheckBox(x,43,'Checkbox');\n  RadioButton(x,70,'Radio button 1');\n  RadioButton(x,97,'Radio button 2');\n  TextBox(x,120,'Text input field',w);\n  var ib0 := IntegerBox(x,172,'Integer input',0,10,w);\n  ib0.Tooltip := 'Use mouse wheel to change value';\n  var l0 := ListBox(x,221,'Country list',w);\n  l0.Height := 110;\n  l0.Add('Russia');\n  l0.Add('USA');\n  l0.Add('China');\n  l0.Add('Germany');\n  l0.Add('France');\n  var cb0 := ComboBox(x,362,'Dropdown list',w);\n  cb0.AddRange('Russia','USA','China','Germany','France');\n  \n  Slider(x,414,'Slider:',0,10,w);\n  TextBlock(x,469,'Text block',w);\n  IntegerBlock(x,497,'Integer block:',w,64);\n  RealBlock(x,526,'Real block:',w,3.5);\n\n  LeftPanel(160,Colors.Orange);\n \n  Button('Button');\n  CheckBox('Checkbox');\n  RadioButton('Radio button 1');\n  RadioButton('Radio button 2');\n  TextBox('Text input field');\n  var ib := IntegerBox('Integer input',0,10);\n  ib.Tooltip := 'Use mouse wheel to change value';\n  var l := ListBox('Country list');\n  l.Height := 110;\n  l.Add('Russia');\n  l.Add('USA');\n  l.Add('China');\n  l.Add('Germany');\n  l.Add('France');\n  var cb := ComboBox('Dropdown list');\n  cb.AddRange('Russia','USA','China','Germany','France');\n  \n  Slider('Slider:',0,10);\n  TextBlock('Text block');\n  IntegerBlock('Integer block:',64);\n  RealBlock('Real block:',3.5);\n\n  var s := StatusBar;\n  s.Text := 'Status bar';\nend."
  },
  {
    "instruction": "Implement 3D line-constrained sphere movement with Graph3D in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin \n  View3D.Title := 'Drag sphere with mouse';\n  \n  var p1 := p3D(2,3,0);\n  var p := p3D(0,0,5);\n  var lin := Line(p,p1);\n  Segment3D(p,p1);\n  var s := Sphere(p1,0.2);\n\n  var obj: Object3D;\n  OnMouseDown += procedure (x,y,mb) -> begin\n    obj := FindNearestObject(x,y);\n    if obj=s then View3D.Title := '';\n  end;\n\n  OnMouseUp += procedure (x,y,mb) -> begin\n    obj := nil;\n  end;\n\n  OnMouseMove += procedure (x,y,mb) -> begin\n    if mb<>1 then exit;\n    if obj=nil then exit;\n    \n    obj.Position := lin.NearestPointOnLine(x,y);\n  end;\nend."
  },
  {
    "instruction": "Create a menu system with file operations using Controls module in PascalABC.NET",
    "output": "uses Controls,GraphWPF;\n\nbegin\n  LeftPanel(150, Colors.Orange);\n  var m := new MenuWPF;\n  var mi1 := m.Add('File');\n  mi1.Add('New');\n  mi1.Add('Open');\n  mi1.Add('Save');\n  mi1.AddSeparator;\n  mi1.Add('Exit').Click := procedure->Window.Close;\n  m.Add('Edit');\n  m.Add('Options');\n  var mi := m.Add('Help');\nend."
  },
  {
    "instruction": "Create a compact menu using AddRange method in Controls module with PascalABC.NET",
    "output": "uses Controls,GraphWPF;\n\nbegin\n  LeftPanel(150, Colors.Orange);\n  var m := new MenuWPF;\n  m.AddRange('File','Edit','Options','Help');\n  m[0].AddRange('New','Open','Save','-','Exit');\n  m[0][3].Click := procedure->Window.Close;\nend."
  },
  {
    "instruction": "Implement file dialogs for opening and saving text files with menu integration in PascalABC.NET",
    "output": "uses Controls,GraphWPF;\n\nbegin\n  Window.Title := 'Controls module - OpenFileDialog and SaveFileDialog';\n  LeftPanel(150, Colors.Orange);\n  var tb := SetMainControl.AsTextBox;\n  tb.FontSize := 16;\n  tb.ReadOnly := False;\n  tb.FontName := 'Courier new Cyr';\n  \n  var dopen := new OpenFileDialogWPF('c:\\PABCWork.NET','Programs|*.pas');\n  var dSave := new SaveFileDialogWPF('c:\\PABCWork.NET','Programs|*.pas');\n  \n  var OpenHandler: procedure := procedure -> begin\n    var res := dopen.ShowDialog;\n    if res then\n      tb.Text := ReadAllText(dopen.FileName);\n  end;\n  var SaveHandler: procedure := procedure -> begin\n    var res := dSave.ShowDialog;\n    if res then\n      WriteAllText(dSave.FileName,tb.Text);\n  end;\n  \n  var bOpen := Button('Open');\n  bOpen.Click := OpenHandler;\n  \n  var bSave := Button('Save');\n  bSave.Click := SaveHandler;\n  \n  var m := Menu;\n  var m1 := m.Add('File');\n  var mm1 := m1.Add('Open');\n  mm1.Click := OpenHandler;\n  m1.Add('Save',SaveHandler);\n  m1.AddSeparator;\n  m1.Add('Exit',procedure->Window.Close);\nend."
  },
  {
    "instruction": "Demonstrate different MessageBox types with button handlers in PascalABC.NET",
    "output": "uses GraphWPF,Controls;\n\nbegin\n  Window.Title := 'Controls module - MessageBox';\n  LeftPanel(150, Colors.Orange);\n  Button('MsgBoxOK').Click := () -> MessageBox.Show('Message','Title');\n  Button('MsgBoxYesNo').Click := () -> begin\n    if MessageBox.Show('Message','Title',MessageBoxButton.YesNo) = MessageBoxResult.Yes then\n      Print('Yes')\n    else Print('No');\n  end;  \n  Button('MsgBoxWithQuestion').Click := () -> begin\n    if MessageBox.Show('Are you sure?','Title',MessageBoxButton.YesNo,MessageBoxImage.Question) \n      = MessageBoxResult.Yes then\n        Print('Sure')\n    else Print('No');\n  end;  \nend."
  },
  {
    "instruction": "Create 3D sphere generator with button control using Graph3D in PascalABC.NET",
    "output": "uses Graph3D,Controls;\n\nfunction R := Random(-7,7);\n\nbegin\n  Window.Title := 'Random spheres';\n  LeftPanel(150,Colors.Orange);\n  var b := new ButtonWPF('Create sphere');\n  b.Click := () \u2192 begin\n    Sphere(P3D(R,R,R),1);\n  end; \nend."
  },
  {
    "instruction": "Implement RGB color mixer with sliders and real-time updates in PascalABC.NET",
    "output": "uses GraphWPF,Controls;\n\nbegin\n  Window.Title := 'Colors';\n  Font.Size := 40;\n  LeftPanel(150);\n\n  var r := Slider('Red: ',0,255,255,16);\n  var g := Slider('Green: ',0,255,255,16);\n  var b := Slider('Blue: ',0,255,255,16);\n  \n  Button('Exit').Click := procedure \u2192 Window.Close;\n\n  var p: procedure := () \u2192 begin\n    var c := RGB(r.Value,g.Value,b.Value);\n    Window.Clear(c);\n    DrawText(GraphWindow.ClientRect,$'R={c.R}, G={c.G}, B={c.B}');\n  end;\n  r.ValueChanged := p;\n  g.ValueChanged := p;\n  b.ValueChanged := p;\n  p;\nend."
  },
  {
    "instruction": "Create object movement controls with keyboard and button handlers in PascalABC.NET",
    "output": "uses WPFObjects,Controls;\n\nbegin\n  Window.Title := 'Controls module - movement buttons + keyboard';\n\n  LeftPanel;\n\n  var c := new CircleWPF(GraphWindow.Center,30,Colors.Blue);\n  \n  OnKeyDown := k -> begin\n    case k of\n      Key.Left: c.MoveBy(-2,0);\n      Key.Right: c.MoveBy(2,0);\n      Key.Up: c.MoveBy(0,-2);\n      Key.Down: c.MoveBy(0,2);\n    end;\n  end;\n  \n  var l := Button('Left');\n  var r := Button('Right');\n  var u := Button('Up');\n  var d := Button('Down');\n  l.Click := ()->c.MoveBy(-2,0);\n  r.Click := ()->c.MoveBy(2,0);\n  u.Click := ()->c.MoveBy(0,-2);\n  d.Click := ()->c.MoveBy(0,2);\nend."
  },
  {
    "instruction": "Implement object positioning with IntegerBox and IntegerBlock synchronization in PascalABC.NET",
    "output": "uses WPFObjects,Controls;\n\nbegin\n  Window.Title := 'Controls module - IntegerBlock, IntegerBox and object movement';\n\n  LeftPanel;\n\n  var c := new CircleWPF(300,300,30,Colors.Blue);\n  \n  var X := IntegerBox('X:',0,600);\n  X.Value := 300;\n  var Y := IntegerBox('Y:',0,600);\n  Y.Value := 300;\n\n  var XX := IntegerBlock('X:',300);\n  var YY := IntegerBlock('Y:',300);\n  \n  X.ValueChanged := procedure \u2192 begin\n    c.Center := Pnt(X.Value,Y.Value);\n    XX.Value := X.Value;\n  end;\n  Y.ValueChanged := procedure \u2192 begin\n    c.Center := Pnt(X.Value,Y.Value);\n    YY.Value := Y.Value;\n  end;\nend."
  },
  {
    "instruction": "Create country-capital dictionary application with ListBox selection in PascalABC.NET",
    "output": "uses Controls,GraphWPF;\n\nbegin\n  Window.Title := 'Country capitals';\n  LeftPanel(150,Colors.Orange);\n  var l := ListBox('Country list');\n  l.Height := 110;\n  l.Add('Russia');\n  l.Add('USA');\n  l.Add('China');\n  l.Add('Germany');\n  l.Add('France');\n  \n  var d := Dict(('Russia','Moscow'),\n    ('USA','Washington'),\n    ('China','Beijing'),\n    ('Germany','Berlin'),\n    ('France','Paris')\n  );\n  \n  Font.Size := 70;\n  l.SelectionChanged := procedure -> begin\n    Window.Clear;\n    DrawText(GraphWindow.ClientRect,'Capital:'+#10+d[l.SelectedText]);\n  end;\nend."
  },
  {
    "instruction": "Implement country-capital selector using ComboBox with dictionary in PascalABC.NET",
    "output": "uses Controls,GraphWPF;\n\nbegin\n  Window.Title := 'Country capitals';\n  LeftPanel(150,Colors.Orange);\n  var l := ComboBox('Country list');\n  l.Tooltip := 'Select country - capital will be displayed';\n  l.Add('Russia');\n  l.Add('USA');\n  l.Add('China');\n  l.Add('Germany');\n  l.Add('France');\n  \n  var d := Dict(('Russia','Moscow'),\n    ('USA','Washington'),\n    ('China','Beijing'),\n    ('Germany','Berlin'),\n    ('France','Paris')\n  );\n  \n  Font.Size := 70;\n  l.SelectionChanged := procedure -> begin\n    Window.Clear;\n    DrawText(GraphWindow.ClientRect,d[l.SelectedText]);\n  end;\nend."
  },
  {
    "instruction": "Create function graph selector using ComboBox with dynamic redrawing in PascalABC.NET",
    "output": "uses GraphWPF,Controls;\n\nbegin\n  Window.Title := 'Controls module - ComboBox and function graphs';\n  LeftPanel(150, Colors.Orange);\n  var cb := ComboBox('Function graphs');\n  cb.AddRange('x*sin(x)','exp(x)','x*x','sin(x)-cos(2.5*x)');\n  \n  var Redraw: procedure := () -> begin\n    case cb.SelectedIndex of\n      0: DrawGraph(x->x*sin(x));\n      1: DrawGraph(x->exp(x));\n      2: DrawGraph(x->x*x);\n      3: DrawGraph(x->sin(x)-cos(2.5*x));\n    end;\n  end;\n  \n  cb.SelectionChanged := Redraw;\n  OnResize := Redraw;\n  Redraw;\nend."
  },
  {
    "instruction": "Demonstrate text wrapping functionality in TextBlock controls using PascalABC.NET",
    "output": "uses GraphWPF,Controls;\n\nbegin\n  Window.Title := 'Controls module - TextBlock wrapping mode';\n  LeftPanel(150,Colors.Orange);\n  var b := Button('No Wrap');\n  b.Tooltip := 'Click to change word wrap mode';\n  \n  var tb1 := TextBlock('This text does not fit on one line and in Wrapping mode automatically wraps');\n  b.Click := procedure \u2192 begin\n    tb1.Wrapping := not tb1.Wrapping;\n    b.Text := if tb1.Wrapping then 'Wrap' else 'No Wrap';\n  end;\n  var tb := TextBlock('This text is truncated,'#10'but you can explicitly'#10'split into lines');\nend."
  },
  {
    "instruction": "Implement toggle for control titles visibility in PascalABC.NET UI",
    "output": "uses Controls, GraphWPF;\n\nbegin\n  Window.Title := 'Controls module - controls with titles';\n  LeftPanel(170, Colors.Orange);\n  \n  var b := Button('Titles enabled');\n  \n  var tb := new TextBoxWPF('TextBox');\n  tb.Height := 40;\n  tb.Text := 'Multiple lines of text';\n  tb.Wrapping := True;\n  \n  var ib := new IntegerBoxWPF('IntegerBox', 0, 10);\n  var lb := new ListBoxWPF('ListBox',100);\n  lb.AddRange('1 2 3 4 5'.ToWords);\n  var cb := new ComboBoxWPF('ComboBox');\n  cb.AddRange('1 2 3 4 5'.ToWords);\n  var sl := new SliderWPF('Slider:');\n  \n  b.Click := procedure -> begin\n    if b.Text = 'Titles enabled' then\n      b.Text = 'Titles disabled'\n    else b.Text = 'Titles enabled';\n    tb.TitleVisible := not tb.TitleVisible;\n    ib.TitleVisible := not ib.TitleVisible;\n    lb.TitleVisible := not lb.TitleVisible;\n    cb.TitleVisible := not cb.TitleVisible;\n    sl.TitleVisible := not sl.TitleVisible;\n  end;\nend."
  },
  {
    "instruction": "Demonstrate Canvas control usage for custom element positioning in PascalABC.NET",
    "output": "uses Controls,GraphWPF;\n\nbegin\n  Window.Title := 'Controls module - replacing graphic panel with Canvas control';\n  var left := LeftPanel(150,Colors.Orange);\n  var can := SetMainControl.AsCanvas;\n  can.Color := Colors.AntiqueWhite;\n\n  Button(100,100,'On Canvas you can place elements');\n  Button(50,300,'in any location,');\n  TextBlock(150,500,'specifying their coordinates');\n  \n  SetActivePanel(left);\n  Button('Close').Click := procedure \u2192 Window.Close;\nend."
  },
  {
    "instruction": "Implement ListView control with custom class data binding in PascalABC.NET",
    "output": "uses Controls,GraphWPF;\n\ntype My = class\npublic\n  auto property Field1: integer;\n  auto property Field2: integer;\n  constructor (f1,f2: integer) := (Field1,Field2) := (f1,f2);\nend;\n\nbegin\n  Window.Title := 'Controls module - replacing graphic window with ListView element';\n  LeftPanel(150,Colors.Orange);\n  \n  var l := SetMainControl.AsListView;\n  \n  l.Fill(Arr(new My(2,5),new My(4,6)));\n  \n  Button('Clear list').Click := procedure -> l.Clear;\n  Button('Fill with data').Click := procedure -> l.Fill(|('Ivanov',20),('Petrov',19)|);\n  Button('Fill headers').Click := procedure -> l.SetHeaders('Last Name','Age');\nend."
  },
  {
    "instruction": "Create database query visualization with country data using ListView in PascalABC.NET",
    "output": "uses GraphWPF,Controls,ABCDatabases;\n\nbegin\n  Window.Title := 'Controls module - database query visualization';\n  LeftPanel(150,Colors.Orange);\n  var l := SetMainControl.AsListView;\n\n  var countries := FillCountriesArray;\n  l.Fill(countries);\n\n  Button('All').Click := procedure -> l.Fill(countries);\n  \n  Button('Asia').Click := procedure -> \n    l.Fill(countries.Where(country -> country.Continent='Asia'));\n    \n  Button('Sort by population').Click := procedure -> \n    l.Fill(countries.OrderByDescending(s -> s.Population));\nend."
  },
  {
    "instruction": "Implement country-capital selector with database integration in PascalABC.NET",
    "output": "uses GraphWPF, Controls, ABCDatabases;\n\nbegin\n  Window.Title := 'Country capitals';\n  LeftPanel(220, Colors.LightGoldenrodYellow);\n  var countries := FillCountriesArray;\n\n  var a := ListBox('Countries',550);\n  a.AddRange(countries.ConvertAll(country -> country.Name));\n  \n  var d := DictStr;\n  foreach var country in countries do\n    d[country.Name] := country.Capital;\n   \n  Font.Size := 70;\n  a.SelectionChanged := procedure -> begin\n    Window.Clear;\n    DrawText(GraphWindow.ClientRect,d[a.SelectedText])\n  end;\nend."
  },
  {
    "instruction": "Create simple calculator interface with IntegerBox controls in PascalABC.NET",
    "output": "uses Controls,GraphWPF;\n\nbegin\n  Window.Title := 'Calculator Light';\n  LeftPanel(150, Colors.Orange);\n  var tb := SetMainControl.AsTextBox;\n  tb.FontSize := 30;\n  var x := IntegerBox('X:',1,9);\n  var y := IntegerBox('Y:',1,9);\n  Button('Sum').Click := procedure -> begin\n    tb.Println($'{x.Value} + {y.Value} = {x.Value + y.Value}');\n  end;\nend."
  },
  {
    "instruction": "Implement full calculator with operation selection and status tracking in PascalABC.NET",
    "output": "uses Controls,GraphWPF;\n\nbegin\n  Window.Title := 'Calculator with TextBox output';\n  LeftPanel(150, Colors.Orange);\n  var tb := SetMainControl.AsTextBox;\n  tb.FontSize := 30;\n  var x := IntegerBox('X:');\n  var y := IntegerBox('Y:');\n  x.Value := Random(0,10);\n  y.Value := Random(0,10);\n  \n  var cb := new ComboBoxWPF('Operation');\n  cb.AddRange('+','-','*','/');\n  \n  var count := 0;\n  var sb := StatusBar;\n  sb.Text := 'Calculation count: ' + count;\n  \n  var b := Button('+');\n  b.Click := procedure -> begin\n    case cb.SelectedText of\n      '+': tb.Println($'{x.Value} + {y.Value} = {x.Value + y.Value}');\n      '-': tb.Println($'{x.Value} - {y.Value} = {x.Value - y.Value}');\n      '*': tb.Println($'{x.Value} * {y.Value} = {x.Value * y.Value}');\n      '/': tb.Println($'{x.Value} / {y.Value} = {x.Value / y.Value}');\n    end;\n    x.Value := Random(0,10);\n    y.Value := Random(0,10);\n    count += 1;\n    sb.Text := 'Calculation count: ' + count;\n  end;\n  \n  Button('Clear').Click := () -> begin\n    count := 0;\n    sb.Text := 'Calculation count: ' + count;\n    tb.Clear;\n  end;\n  \n  cb.SelectionChanged := procedure -> begin\n    b.Text := cb.SelectedText\n  end;\nend."
  },
  {
    "instruction": "Create status bar with window dimension tracking in PascalABC.NET",
    "output": "uses Controls,GraphWPF;\n\nbegin\n  Window.Title := 'Controls module - StatusBar';\n  var l := LeftPanel(150,Colors.Orange);\n  l.Tooltip := 'Change window size';\n  var sb := StatusBar(24,55);\n  sb.AddText('',55);\n  Button('Clear W field').Click := procedure -> sb.ItemText[0] := '';\n  Button('Clear H field').Click := procedure -> sb.ItemText[1] := '';\n  OnResize := () -> begin\n    sb.ItemText[0] := 'W=' + Window.Width.Round;\n    sb.ItemText[1] := 'H=' + Window.Height.Round;\n  end;\n  OnResize();\nend."
  },
  {
    "instruction": "Show how to use the CountOf method for counting substring occurrences in strings with and without overlap in PascalABC.NET",
    "output": "begin\n  var s := 'arara';\n  s.CountOf('ara').Println;\n  s.CountOf('ara',allowOverlap := True).Println;\nend."
  },
  {
    "instruction": "Write a procedure in PascalABC.NET that fills an integer array with random numbers in the range from minValue to maxValue",
    "output": "procedure FillByRandom(a: array of integer; minValue, maxValue: integer);\nbegin\n  for var i := 0 to a.Length - 1 do\n    a[i] := PABCSystem.Random(minValue, maxValue);\nend;"
  },
  {
    "instruction": "Write a procedure in PascalABC.NET that fills an array with a specified value",
    "output": "procedure FillByValue<T>(a: array of T; x: T);\nbegin\n  for var i := 0 to a.Length - 1 do\n    a[i] := x;\nend;"
  },
  {
    "instruction": "Write a function in PascalABC.NET that creates and returns an integer array of size n filled with random numbers in the range from minValue to maxValue",
    "output": "function CreateRandomIntegerArray(n: integer; minValue, maxValue: integer): array of integer;\nbegin\n  SetLength(Result, n);\n  FillByRandom(Result, minValue, maxValue);\nend;"
  },
  {
    "instruction": "Write a function in PascalABC.NET that creates and returns a real array of size n filled with random numbers in the range from minValue to maxValue",
    "output": "function CreateRandomRealArray(n: integer; minValue, maxValue: real): array of real;\nbegin\n  SetLength(Result, n);\n  FillByRandom(Result, minValue, maxValue);\nend;"
  },
  {
    "instruction": "Write a procedure in PascalABC.NET that reads an integer array from input",
    "output": "procedure ReadArray(a: array of integer);\nbegin\n  for var i := 0 to a.Length - 1 do\n    read(a[i]);\n  readln;  \nend;"
  },
  {
    "instruction": "Write a procedure in PascalABC.NET that writes an array using delimiter as a separator for values",
    "output": "procedure WriteArray<T>(a: array of T; delimiter: string := ' ');\nbegin\n  if (a=nil) or (a.Length=0) then\n    exit;\n  for var i := 0 to a.Length - 2 do\n    write(a[i], delimiter);\n  write(a[a.Length - 1]);  \nend;"
  },
  {
    "instruction": "Write a procedure in PascalABC.NET that writes an array using delimiter as a separator for values and moves to a new line",
    "output": "procedure WritelnArray<T>(a: array of T; delimiter: string := ' ');\nbegin\n  WriteArray(a, delimiter);\n  writeln;\nend;"
  },
  {
    "instruction": "Write a procedure in PascalABC.NET that sorts an array in ascending order",
    "output": "procedure Sort<T>(a: array of T);\nbegin\n  System.Array.Sort(a);\nend;"
  },
  {
    "instruction": "Write a procedure in PascalABC.NET that sorts an array in descending order",
    "output": "procedure SortDescending<T>(a: array of T);\nbegin\n  System.Array.Sort(a);\n  System.Array.Reverse(a);\nend;"
  },
  {
    "instruction": "Write a procedure in PascalABC.NET that fills a two-dimensional integer array with random numbers in the range from minValue to maxValue",
    "output": "procedure FillByRandom(a: array [,] of integer; minValue, maxValue: integer);\nbegin\n  for var i := 0 to a.GetLength(0) - 1 do\n    for var j := 0 to a.GetLength(1) - 1 do\n      a[i, j] := PABCSystem.Random(minValue, maxValue);\nend;"
  },
  {
    "instruction": "Write a procedure in PascalABC.NET that fills a two-dimensional array with a specified value",
    "output": "procedure FillByValue<T>(a: array [,] of T; x: T);\nbegin\n  for var i := 0 to a.GetLength(0) - 1 do\n    for var j := 0 to a.GetLength(1) - 1 do\n      a[i, j] := x\nend;"
  },
  {
    "instruction": "Write a function in PascalABC.NET that creates and returns a two-dimensional integer array of size m x n filled with random numbers in the range from minValue to maxValue",
    "output": "function CreateRandomIntegerMatrix(m, n: integer; minValue, maxValue: integer): array [,] of integer;\nbegin\n  SetLength(Result, m, n);  \n  FillByRandom(Result, minValue, maxValue);\nend;"
  },
  {
    "instruction": "Write a function in PascalABC.NET that creates and returns a two-dimensional real array of size m x n filled with random numbers in the range from minValue to maxValue",
    "output": "function CreateRandomRealMatrix(m, n: integer; minValue, maxValue: real): array [,] of real;\nbegin\n  SetLength(Result, m, n);  \n  FillByRandom(Result, minValue, maxValue);\nend;"
  },
  {
    "instruction": "Write a procedure in PascalABC.NET that writes a two-dimensional array with specified width formatting",
    "output": "procedure WriteMatrix<T>(a: array [,] of T; width: integer := 0);\nbegin\n  for var i := 0 to a.GetLength(0) - 1 do\n  begin\n    for var j := 0 to a.GetLength(1) - 1 do\n      write(a[i, j]:width, ' ');\n    writeln;  \n  end;\nend;"
  },
  {
    "instruction": "Write a procedure in PascalABC.NET that writes a two-dimensional real array with specified width and decimal places formatting",
    "output": "procedure WriteMatrix(a: array [,] of real; width: integer := 0; digitsafterpoint: integer := 2);\nbegin\n  for var i := 0 to a.GetLength(0) - 1 do\n  begin\n    for var j := 0 to a.GetLength(1) - 1 do\n      write(a[i, j]:width:digitsafterpoint, ' ');\n    writeln;  \n  end;\nend;"
  },
  {
    "instruction": "Write an extension method in PascalABC.NET that writes an array using delimiter as separator",
    "output": "procedure &Array.Write(delimiter: string);\nbegin\n  if Self.Rank = 1 then\n    for var i := 0 to Self.Length - 1 do\n    begin\n      PABCSystem.write(Self.GetValue(i));\n      if i < Self.Length - 1 then\n        PABCSystem.write(delimiter);\n    end\n  else if Self.Rank = 2 then \n    for var i := 0 to Self.GetLength(0) - 1 do\n    begin\n      for var j := 0 to Self.GetLength(1) - 1 do\n        PABCSystem.write(Self.GetValue(i, j), delimiter);\n      PABCSystem.writeln;\n    end;\nend;"
  },
  {
    "instruction": "Write an extension method in PascalABC.NET that writes an array using delimiter as separator and moves to a new line",
    "output": "procedure &Array.Writeln(delimiter: string);\nbegin\n  Self.Write(delimiter);\n  PABCSystem.writeln;\nend;"
  },
  {
    "instruction": "Write a SingleNode class in PascalABC.NET that represents a node with one link field",
    "output": "type\n  SingleNode<T> = class\n  private \n    fData: T;\n    fNext: SingleNode<T>;\n  public \n    constructor Create(pData: T; pNext: SingleNode<T>);\n    begin\n      fData := pData;\n      fNext := pNext;\n    end;\n    \n    property Data: T read fData write fData;\n    property Next: SingleNode<T> read fNext write fNext;\n  end;"
  },
  {
    "instruction": "Write a complete Stack class template in PascalABC.NET with all methods implemented",
    "output": "type\n  Stack<T> = class\n  private \n    fTop: SingleNode<T> := nil; \n  public \n    constructor Create;\n    begin\n      fTop := nil;\n    end;\n    \n    procedure Push(x: T);\n    begin\n      fTop := new SingleNode<T>(x, fTop);\n    end;\n    \n    function Pop: T;\n    begin\n      if IsEmpty then \n        raise new Exception('Attempt to pop element from empty stack');\n      \n      Result := fTop.data;\n      fTop := fTop.next;  \n    end;\n    \n    function Top: T;\n    begin\n      if IsEmpty then \n        raise new Exception('Attempt to get element from empty stack');\n      \n      Result := fTop.data;\n    end;\n    \n    function IsEmpty: boolean;\n    begin\n      Result := (fTop = nil);\n    end;\n    \n    function ToString: string; override;\n    begin\n      Result := '';\n      var curElem := fTop;\n      while curElem <> nil do\n      begin\n        Result += curElem.data.ToString + ' ';\n        curElem := curElem.next;\n      end;\n    end;\n    \n    procedure Print;\n    begin\n      write(ToString);\n    end;\n    \n    procedure Println;\n    begin\n      writeln(ToString);\n    end;\n  end;"
  },
  {
    "instruction": "Write a complete Queue class template in PascalABC.NET with all methods implemented",
    "output": "type\n  Queue<T> = class\n  private \n    head: SingleNode<T>;\n    tail: SingleNode<T>;\n  public \n    constructor Create;\n    begin\n      head := nil;\n      tail := nil;\n    end;\n    \n    procedure Enqueue(x: T);\n    begin\n      if IsEmpty then\n      begin\n        head := new SingleNode<T>(x, nil);\n        tail := head;\n      end\n      else\n      begin\n        tail.next := new SingleNode<T>(x, nil);\n        tail := tail.next;\n      end;\n    end;\n    \n    function Dequeue: T;\n    begin\n      if IsEmpty then \n        raise new Exception('Attempt to remove element from empty queue');\n      \n      Result := head.data;\n      head := head.next;\n      if head = nil then\n        tail := nil;\n    end;\n    \n    function Top: T;\n    begin\n      if IsEmpty then \n        raise new Exception('Attempt to get element from empty queue');\n      Result := head.data;\n    end;\n    \n    function IsEmpty: boolean;\n    begin\n      Result := (head = nil);\n      if Result then\n        Assert(tail = nil);\n    end;\n    \n    function ToString: string; override;\n    begin\n      Result := '';\n      var curElem := head;\n      while curElem <> nil do\n      begin\n        Result += curElem.data + ' ';\n        curElem := curElem.next;\n      end;\n    end;\n    \n    procedure Print;\n    begin\n      write(ToString);\n    end;\n    \n    procedure Println;\n    begin\n      writeln(ToString);\n    end;\n  end;"
  },
  {
    "instruction": "Write a complete DynArray class template in PascalABC.NET for dynamic array with all methods implemented",
    "output": "type\n  DynArray<T> = class\n  private \n    fData: array of T;\n    fSize: integer;\n    fCap: integer;\n    \n    procedure SetElem(index: integer; x: T);\n    begin\n      if (index < 0) or (index > fSize - 1) then \n        raise new Exception('Attempt to set value to element outside array bounds with index ' + index.ToString);\n      \n      fData[index] := x;\n    end;\n    \n    function GetElem(index: integer): T;\n    begin\n      if (index < 0) or (index > fSize - 1) then \n        raise new Exception('Attempt to get value from element outside array bounds with index ' + index.ToString);\n      \n      Result := fData[index];\n    end;\n    \n  public \n    constructor Create;\n    begin\n      Create(0);\n    end;\n    \n    constructor Create(pSize: integer);\n    begin\n      if pSize < 0 then\n        raise new Exception('Attempt to set negative value to array size ' + pSize.ToString);\n      \n      fSize := pSize;\n      fCap := 2 * pSize + 4;\n      SetLength(fData, fCap);\n    end;\n    \n    procedure Reserve(newCap: integer);\n    begin\n      if newCap > fCap then \n      begin\n        SetLength(fData, newCap);\n        fCap := newCap;\n      end;\n    end;\n    \n    procedure Resize(newSize: integer);\n    begin\n      if newSize < 0 then\n        raise new Exception('Attempt to set negative value to array size ' + newSize.ToString);\n      \n      if newSize > fCap then\n      begin\n        Reserve(2 * newSize);\n        for var i := fSize to newSize - 1 do\n          fData[i] := default(T);\n      end;\n      fSize := newSize;\n    end;\n    \n    procedure Add(x: T);\n    begin\n      Resize(fSize + 1);\n      fData[fSize - 1] := x;\n    end;\n    \n    procedure Insert(pos: integer; x: T);\n    begin\n      if (pos < 0) or (pos > fSize - 1) then \n        raise new Exception('Attempt to insert outside array bounds at position ' + pos.ToString);\n      \n      Resize(fSize + 1);\n      for var i := fSize - 2 downto pos do\n        fData[i + 1] := fData[i];\n      fData[pos] := x;\n    end;\n    \n    procedure Remove(pos: integer);\n    begin\n      if (pos < 0) or (pos > fSize - 1) then \n        raise new Exception('Attempt to remove outside array bounds from position ' + pos.ToString);\n      \n      for var i := pos to fSize - 2 do\n        fData[i] := fData[i + 1];\n      Resize(fSize - 1);\n    end;\n    \n    function Find(x: T): integer;\n    begin\n      Result := -1;\n      for var i := 0 to fSize - 1 do\n        if fData[i] = x then\n        begin\n          Result := i;\n          exit;\n        end;\n    end;\n    \n    property Count: integer read fSize write Resize;\n    property Capacity: integer read fCap write Reserve;\n    property Elem[index: integer]: T read GetElem write SetElem; default;\n    \n    function ToString: string; override;\n    begin\n      Result := '';\n      for var i := 0 to fSize - 1 do\n        Result += fData[i].ToString + ' '; \n    end;\n    \n    procedure Print;\n    begin\n      write(ToString);\n    end;\n    \n    procedure Println;\n    begin\n      writeln(ToString);\n    end;\n  end;"
  },
  {
    "instruction": "Write a complete SimpleSet class template in PascalABC.NET based on dynamic array with all methods implemented",
    "output": "type\n  SimpleSet<T> = class \n  private \n    data: DynArray<T>;\n  public \n    constructor Create;\n    begin\n      data := new DynArray<T>;\n    end;\n    \n    procedure Add(x: T);\n    begin\n      if data.Find(x) = -1 then \n        data.Add(x);\n    end;\n    \n    procedure Remove(x: T);\n    begin\n      var xPos := data.Find(x);\n      if xPos <> -1 then\n        data.Remove(xPos);\n    end;\n    \n    function Contains(x: T): boolean;\n    begin\n      Result := (data.Find(x) <> -1);\n    end;\n    \n    function ToString: string; override;\n    begin\n      Result := data.ToString;\n    end;\n    \n    procedure Print;\n    begin\n      write(ToString);\n    end;\n    \n    procedure Println;\n    begin\n      writeln(ToString);\n    end;\n  end;"
  },
  {
    "instruction": "Write a complete AssocArray class template in PascalABC.NET for associative array with all methods implemented",
    "output": "type\n  AssocArray<KeyType, ValueType> = class\n  private \n    keys: DynArray<KeyType>;\n    values: DynArray<ValueType>;\n    \n    procedure SetElem(key: KeyType; value: ValueType);\n    begin\n      var ind := Keys.Find(key);\n      if ind <> -1 then\n        Values[ind] := value\n      else\n      begin\n        Keys.Add(key);\n        Values.Add(value);\n      end;\n    end;\n    \n    function GetElem(key: KeyType): ValueType;\n    begin\n      var ind := Keys.Find(key);\n      if ind <> -1 then\n        Result := Values[ind]\n      else Result := default(ValueType);\n    end;\n    \n  public \n    constructor Create;\n    begin\n      keys := new DynArray<KeyType>;\n      values := new DynArray<ValueType>;\n    end;\n    \n    property Elem[key: KeyType]: ValueType read GetElem write SetElem; default;\n    \n    function ToString: string; override;\n    const\n      NewLine = #13#10;\n    begin\n      Result := '';\n      for var i := 0 to keys.Count - 1 do\n        Result += keys[i].ToString + ' ' + values[i].ToString + NewLine;\n    end;\n    \n    procedure Print;\n    begin\n      write(ToString);\n    end;\n    \n    procedure Println;\n    begin\n      write(ToString);\n    end;\n  end;"
  },
  {
    "instruction": "Write a complete LinkedListNode class in PascalABC.NET that represents a node with two link fields",
    "output": "type\n  LinkedListNode<T> = class\n  private \n    fData: T;\n    fPrev: LinkedListNode<T>;\n    fNext: LinkedListNode<T>;\n  public \n    constructor Create(data: T; prev, next: LinkedListNode<T>);\n    begin\n      fData := data;\n      fNext := next;\n      fPrev := prev;\n    end;\n    property Value: T read fData write fData;\n    property Prev: LinkedListNode<T> read fPrev;\n    property Next: LinkedListNode<T> read fNext;\n  end;"
  },
  {
    "instruction": "Write a complete LinkedList class template in PascalABC.NET for doubly linked linear list with all methods implemented",
    "output": "type\n  LinkedList<T> = class\n  private \n    fFirst: LinkedListNode<T>;\n    fLast: LinkedListNode<T>;\n  public \n    constructor Create;\n    begin\n    end;\n    \n    property First: LinkedListNode<T> read fFirst;\n    property Last: LinkedListNode<T> read fLast;\n    \n    procedure AddFirst(x: T);\n    begin\n      var val := new LinkedListNode<T>(x, nil, fFirst);\n      if fFirst <> nil then\n        fFirst.fPrev := val;\n      \n      fFirst := val;\n      if fLast = nil then\n        fLast := fFirst;\n    end;\n    \n    procedure AddLast(x: T);\n    begin\n      var val := new LinkedListNode<T>(x, fLast, nil);\n      if fLast <> nil then\n        fLast.fNext := val;\n      \n      fLast := val;\n      if fFirst = nil then\n        fFirst := fLast;\n    end;\n    \n    procedure RemoveFirst();\n    begin\n      if fFirst = nil then\n        raise new Exception('Attempt to remove from empty list');\n      \n      fFirst := fFirst.fNext;\n      if fFirst = nil then\n        fLast := nil\n      else\n        fFirst.fPrev := nil;\n    end;\n    \n    procedure RemoveLast();\n    begin\n      if fLast = nil then\n        raise new Exception('Attempt to remove from empty list');\n      \n      fLast := fLast.fPrev;\n      if fLast = nil then\n        fFirst := nil\n      else\n        fLast.fNext := nil;\n    end;\n    \n    procedure AddBefore(node: LinkedListNode<T>; x: T);\n    begin\n      if node = nil then\n        raise new Exception('Parameter node is null reference');\n      \n      if node = fFirst then\n        AddFirst(x)\n      else\n      begin\n        var val := new LinkedListNode<T>(x, node.fPrev, node);\n        node.fPrev.fNext := val;\n        node.fPrev := val;\n      end;\n    end;\n    \n    procedure AddAfter(node: LinkedListNode<T>; x: T);\n    begin\n      if node = nil then\n        raise new Exception('Parameter node is null reference');\n      \n      if node = fLast then\n        AddLast(x)\n      else\n      begin\n        var val := new LinkedListNode<T>(x, node, node.fNext);\n        node.fNext.fPrev := val;\n        node.fNext := val;\n      end;\n    end;\n    \n    procedure Remove(node: LinkedListNode<T>);\n    begin\n      if node = nil then\n        raise new Exception('Parameter node is null reference');\n      \n      if node = fFirst then\n        RemoveFirst\n      else if node = fLast then\n        RemoveLast\n      else\n      begin\n        node.fPrev.fNext := node.fNext;\n        node.fNext.fPrev := node.fPrev;\n      end;\n    end;\n    \n    function ToString: string; override;\n    begin\n      Result := '';\n      var cur := fFirst;\n      while cur <> nil do\n      begin\n        Result := cur.Value.ToString + ' ';\n        cur := cur.Next;\n      end;\n    end;\n    \n    procedure Print;\n    begin\n      write(ToString);\n    end;\n    \n    procedure Println;\n    begin\n      writeln(ToString);\n    end;\n  end;"
  },
  {
    "instruction": "Write a PascalABC.NET class for Chebyshev polynomial approximation of tabular function using least squares method",
    "output": "type\n  ApproxCheb=class\n  private\n  nt:integer;\n  a:array[,] of real;\n  \n  procedure MatrCreate;\n  begin\n    a:=new real[r+1,r+2];\n    var p,s:real;\n    for var i:=0 to r do begin\n      (p,s):=(1.0,x[i]); a[i,r+1]:=f[i];\n      for var j:=0 to r do begin a[i,j]:=p; p*=s end\n      end\n  end;\n  \n  procedure Gauss;\n  begin\n    var n1:=r+1;\n    c:=new real[n1];\n    var p,s:real;   \n    for var k:=0 to r do begin\n      var k1:=k+1; s:=a[k,k]; var jj:=k; \n      for var i:=k1 to r do begin\n        p:=a[i,k]; \n        if Abs(r)>Abs(s) then (s,jj):=(p,i)\n        end; \n      if jj<>k then\n        for var i:=k to n1 do Swap(a[k,i],a[jj,i]);\n      for var j:=k1 to n1 do a[k,j]/=s; \n      for var i:=k1 to r do begin\n        p:=a[i,k];\n        for var j:=k1 to n1 do a[i,j]-=a[k,j]*p\n        end\n      end; \n    for var i:=r downto 0 do begin\n      s:=a[i,n1];\n      for var j:=i+1 to r do s-=a[i,j]*c[j];\n      c[i]:=s\n      end\n  end;\n  \n  public\n  x:array of real;\n  y:array of real;\n  tol:real;\n  r:integer;\n  f:array of real;\n  c:array of real;\n  \n  constructor (x,y:array of real; eps:real);\n  begin\n    nt:=x.Length;\n    Assert(nt=y.Length,'Approx: point count mismatch in argument and function');\n    Self.x:=x;\n    Self.y:=y;\n    f:=ArrFill(nt,0.0);\n    Cheb(eps)\n  end;\n  \n  procedure Cheb(e:real);\n  begin\n    r:=0;\n    var n:=nt-1;\n    var f1:=ArrFill(nt,0.0);\n    var f2:=ArrFill(nt,1.0);\n    var eps:=ArrFill(nt,0.0);\n    while true do begin\n      var sum1:=y.Zip(f2,(p,q)->p*q).Sum;\n      var sum2:=f2.Select(p->p*p).Sum;\n      var al:=sum1/sum2;\n      f:=f.Zip(f2,(p,q)->p+al*q).ToArray;\n      for var i:=0 to n do eps[i]:=Abs(y[i]-f[i]);\n      tol:=Sqrt((eps.Select(t->t*t).Sum)/n);\n      if (tol<e) or (r>=n+1) then break;\n      sum1:=x.Zip(f2,(p,q)->p*q*q).Sum;\n      sum2:=f2.Select(p->p*p).Sum;\n      var be:=-(sum1/sum2);\n      var g:real;\n      if r<>0 then begin\n        (sum1,sum2):=(0.0,0.0);\n        for var i:=0 to n do begin sum1+=x[i]*f1[i]*f2[i]; sum2+=Sqr(f1[i]) end;\n        g:=-(sum1/sum2);\n        end;\n      r+=1;\n      for var i:=0 to n do begin\n        var a:=f1[i]; f1[i]:=f2[i]; f2[i]:=(x[i]+be)*f1[i]+g*a\n        end\n      end\n  end;\n  \n  procedure MakeCoef;\n  begin\n    MatrCreate;\n    Gauss\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for LU decomposition of real matrix for solving linear equation systems",
    "output": "type\n  Decomp=class\n  private\n  n:integer;\n  \n  procedure Decomp;\n  begin\n    Assert(a.RowCount=a.ColCount,'DECOMP: matrix is not square');\n    ipvt[n]:=1;\n    if n=0 then begin\n      if a[0,0]<>0 then cond:=1\n      else cond:=MaxReal;\n      Exit\n      end;\n    var anorm:=a.Cols.Select(r->r.Select(x->Abs(x)).Sum).Max;\n    for var k:=0 to n-1 do begin\n      var m:=k;\n      for var i:=k+1 to n do\n        if Abs(a[i,k])>Abs(a[m,k]) then m:=i;\n      ipvt[k]:=m;\n      if m<>k then ipvt[n]:=-ipvt[n];\n      Swap(a[m,k],a[k,k]);\n      if a[k,k]<>0 then begin\n        for var i:=k+1 to n do a[i,k]:=-a[i,k]/a[k,k];\n        for var j:=k+1 to n do begin\n          Swap(a[m,j],a[k,j]);\n          if a[k,j]<>0 then\n            for var i:=k+1 to n do a[i,j]+=a[i,k]*a[k,j]\n          end\n        end\n      end;\n    var work:=new real[n+1];\n    for var k:=0 to n do begin\n      var t:=0.0;\n      if k<>0 then\n        for var i:=0 to k-1 do t+=a[i,k]*work[i];\n      var ek:=1.0;\n      if t<0.0 then ek:=-1.0;\n      if a[k,k]=0.0 then begin cond:=MaxReal; Exit end;\n      work[k]:=-(ek+t)/a[k,k];\n      end;\n    for var kb:=0 to n-1 do begin\n      var k:=n-kb-1;\n      var t:=0.0;\n      for var i:=k+1 to n do t+=a[i,k]*work[k];\n      work[k]:=t;\n      var m:=ipvt[k];\n      if m<>k then Swap(work[m],work[k])\n      end;\n    var ynorm:=work.Select(x->Abs(x)).Sum;\n    Self.Solve(work);\n    var znorm:=work.Select(x->Abs(x)).Sum;\n    cond:=Max(anorm*znorm/ynorm,1.0);\n    det:=real(ipvt.Last);\n    for var i:=0 to a.RowCount-1 do det*=a[i,i];\n  end;\n  \n  public\n  a:array[,] of real;\n  cond:real;\n  ipvt:array of integer;\n  det:real;\n  \n  constructor(a:array[,] of real);\n  begin\n    n:=a.RowCount-1;\n    Assert((n=a.ColCount-1) and (n>=0),'DECOMP: source matrix is not square');\n    Self.a:=new real[n+1,n+1];\n    for var i:=0 to n do\n      for var j:=0 to n do\n        Self.a[i,j]:=a[i,j];\n    Self.ipvt:=new integer[n+1];\n    Decomp\n  end;\n  \n  procedure Solve(b:array of real);\n  begin\n    Assert(b.Length-1=n,'DECOMP/SOLVE: wrong length of right-hand side vector');\n    for var k:=0 to n-1 do begin\n      var m:=ipvt[k];\n      Swap(b[m],b[k]);\n      for var i:=k+1 to n do b[i]+=a[i,k]*b[k]\n      end;\n    for var k:=n downto 1 do begin\n      b[k]/=a[k,k];\n      var t:=-b[k];\n      for var i:=0 to k-1 do begin\n        b[i]+=a[i,k]*t;\n        end\n      end;\n    b[0]/=a[0,0]\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for factoring polynomial with integer coefficients into rational linear factors",
    "output": "type\n  Factors=class\n  private\n  a:array of integer;\n  n:integer;\n  \n  public\n  \n  constructor(params a:array of integer);\n  begin\n    Self.a:=a;\n    Self.n:=a.Length-1;\n  end;\n\n  function Factorize:array[,] of integer;\n  begin\n    var f,g,q:integer;\n    var (r,c):=(0,1);\n    Result:=new integer[n+1,2];\n    var b:=a.Reverse.ToArray;\n    while b[n]=1 do begin\n      n-=1; r+=1;\n      (Result[r,0],Result[r,1]):=(1,0);\n      end;\n    var Fin:=false;\n    for var p:=1 to Abs(b[0]) do\n      if b[0] mod p=0 then\n        for var q1:=1 to Abs(b[n]) do begin\n          q:=q1;\n          if q<>1 then begin\n            var flag:=true;\n            for var j:=0 to n do\n              if b[j] mod q<>0 then begin flag:=false; break end;\n            if flag then\n              for var j:=0 to n do b[j]:=b[j] div q\n            end;\n          repeat\n            (f,g):=(b[0],1);\n            for var i:=1 to n do begin g*=p; f:=f*q+g*b[i] end;\n            if f=0 then begin\n              r+=1;\n              (Result[r,0],Result[r,1]):=(p,q);\n              for var i:=0 to n do begin f:=(b[i]+f) div p; b[i]:=f; f*=q end;\n              n-=1;\n              if n<>0 then continue;\n              Fin:=true\n              end;\n            if not Fin then q:=-q;\n          until (q>0) or Fin;\n          if Fin then break;\n          end;\n      if n=0 then c*=b[0];\n      (Result[0,0],Result[0,1]):=(r,c);\n      SetLength(Result,r+1,2)\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for finding function minimum on given interval using Brent's method",
    "output": "type\n  FMin=class\n  private\n  a,b,t:real;\n  f:real->real;\n  \n  procedure FMin;\n  begin\n    var d,fu,u,tol1:real;\n    var c:=0.5*(3-Sqrt(5.0));\n    var(sa,sb):=(a,b);\n    x:=sa+c*(b-a);\n    var w:=x;\n    var (v,e,fx):=(w,0.0,f(x));\n    var fw:=fx;\n    var fv:=fw;\n    var eps:=1.0;\n    repeat\n      eps:=0.5*eps;\n      tol1:=1.0+eps\n    until tol1<=1.0;\n    eps:=Sqrt(eps);\n    repeat\n      var m:=0.5*(sa+sb);\n      var tol:=eps*Abs(x)+t;\n      var t2:=2*tol;\n      if Abs(x-m) <= t2-0.5*(sb-sa) then break;\n      var r:=0.0;\n      var q:=r;\n      var p:=q;\n      if tol<Abs(e) then begin\n        r:=(x-w)*(fx-fv); q:=(x-v)*(fx-fw);\n        p:=(x-v)*q-(x-w)*r; q:=2.0*(q-r);\n        if q>0.0 then p:=-p;\n        q:=Abs(q); r:=e; e:=d\n        end;\n      if (Abs(p)<Abs(0.5*q*r)) and (q*(sa-x)<p) and (p<q*(sb-x)) then begin\n        d:=p/q; u:=x+d;\n        if ((u-sa)<t2) or ((sb-u)<t2) then d:=x<m?tol:-tol;\n        end\n      else begin\n        e:=x<m?sb-x:sa-x; d:=c*e\n        end;\n      if tol<=Abs(d) then u:=x+d\n      else if d>0.0 then u:=x+tol\n      else u:=x-tol;\n      fu:=f(u);\n      if fu<=fx then begin\n        if u<x then sb:=x else sa:=x;\n        (v,fv):=(w,fw);\n        (w,fw):=(x,fx);\n        (x,fx):=(u,fu)\n        end\n      else begin\n        if u<x then sa:=u else sb:=u;\n        if (fu<=fw) or (w=x) then begin\n          (v,fv):=(w,fw);\n          (w,fw):=(u,fu)\n          end\n        else\n          if (fu<=fv) or (v=x) or (v=w) then (v,fv):=(u,fu)\n        end\n    until false;\n    Value:=fx\n  end;\n  \n  public\n  x:real;\n  Value:real;\n  \n  constructor(f:real->real; a,b:real; t:real:=1.05e-8);\n  begin\n    Self.a:=a;\n    Self.b:=b;\n    Self.t:=t;\n    Self.f:=f;\n    FMin\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for minimization of multivariable function using Hooke-Jeeves direct search method",
    "output": "type\n  FMinN=class\n  private\n  delta:array of real;\n  fbefore:real;\n  newx:array of real;\n  fun:function(x:array of real):real;\n  \n  function BestNearby:real;\n  begin\n    Result:=fbefore;\n    var z:=Copy(newx);\n    for var i:=0 to n-1 do begin\n    z[i]:=newx[i]+delta[i];\n    var ftmp:=fun(z);\n    if ftmp<Result then Result:=ftmp\n    else begin\n      delta[i]:=-delta[i];\n      z[i]:=newx[i]+delta[i];\n      ftmp:=fun(z);\n      if ftmp<Result then Result:=ftmp\n      else z[i]:=newx[i]\n      end\n    end;\n    newx:=Copy(z);\n  end;\n  \n  public\n  n:integer;\n  iter:integer;\n  x:array of real;\n  \n  constructor (px:array of real; f:function(x:array of real):real);\n  begin\n    n:=px.Length;\n    x:=Copy(px);\n    fun:=f;\n    iter:=0;\n    Randomize;\n  end;\n  \n  function HJ(eps:real:=1e-6; rho:real:=0.5; itermax:integer:=5000):array of real;\n  begin\n  newx:=Copy(x);\n  var xbefore:=Copy(x);\n  delta:=x.Select(t->t=0?rho:rho*Abs(t)).ToArray;\n  var steplength:=rho;\n  iter:=0;\n  fbefore:=fun(newx);\n  var newf:=fbefore;\n  while (iter<itermax) and (eps<steplength) do begin\n    iter+=1;\n    newx:=Copy(xbefore);\n    newf:=BestNearby;\n    var keep:=1;\n    while (newf<fbefore) and (keep=1) do begin\n      for var i:=0 to n-1 do begin\n        if newx[i]<=xbefore[i] then delta[i]:=-Abs(delta[i])\n        else delta[i]:=Abs(delta[i]);\n        var tmp:=xbefore[i];\n        xbefore[i]:=newx[i];\n        newx[i]+=newx[i]-tmp\n        end;\n      fbefore:=newf;\n      newf:=BestNearby;\n      if fbefore<=newf then break;\n      keep:=0;\n      for var i:=0 to n-1 do\n        if 0.5*Abs(delta[i])<Abs(newx[i]-xbefore[i]) then begin\n          keep:=1; break\n          end;\n      end;\n    if (eps<=steplength) and (fbefore<=newf) then begin\n      steplength*=rho;\n      delta.Transform(x->x*rho);\n      end\n    end;\n  Result:=Copy(xbefore);\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for arbitrary precision fractions with arithmetic operations",
    "output": "type\n  Fraction=class\n  private\n  class function GCD(a, b: BigInteger): BigInteger;\n  begin\n    if a < 0 then\n      a := -a;\n    while b <> 0 do\n      (a, b) := (b, a mod b);\n    Result := a\n  end;\n\n  public\n  numerator:BigInteger;\n  denominator:BigInteger;\n  \n  constructor (num:BigInteger:=0; denom:BigInteger:=1);\n  begin\n    Assert(denom>0,'Fraction: denominator must be positive');\n    var n:=GCD(num,denom);\n    numerator:=num div n;\n    denominator:=denom div n\n  end;\n  \n  class function operator +(a,b:fraction):fraction;\n  begin\n    var n:=GCD(a.denominator,b.denominator);\n    Result:=new fraction(a.numerator*(b.denominator div n)+\n        b.numerator*(a.denominator div n),a.denominator div n*b.denominator);\n  end;\n  \n  class function operator -(a,b:fraction):fraction;\n  begin\n    var n:=GCD(a.denominator,b.denominator);\n    Result:=new fraction(a.numerator*(b.denominator div n)-\n        b.numerator*(a.denominator div n),a.denominator div n*b.denominator);\n  end;\n  \n  class function operator *(a,b:fraction):fraction;\n  begin\n    Result:=new fraction(a.numerator*b.numerator,a.denominator*b.denominator);\n    var n:=GCD(Result.numerator,Result.denominator);\n    if n<>1 then begin\n      Result.numerator:=Result.numerator div n;\n      Result.denominator:=Result.denominator div n\n      end\n  end;\n  \n  class function operator /(a,b:fraction):fraction;\n  begin\n    Result:=new fraction(a.numerator*b.denominator,a.denominator*b.numerator);\n    var n:=GCD(Result.numerator,Result.denominator);\n    if n<>1 then begin\n      Result.numerator:=Result.numerator div n;\n      Result.denominator:=Result.denominator div n\n      end\n  end;\n  \n  function Inv:fraction;\n  begin\n    Result:=new fraction;\n    Result.numerator:=denominator;\n    Result.denominator:=numerator\n  end;\n  \n  function Abs:fraction;\n  begin\n    Result:=new fraction;\n    Result.numerator:=PABCSystem.Abs(numerator);\n    Result.denominator:=denominator\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for vector operations including cross product and mixed product",
    "output": "type\n  Vector=class\n  public\n    Value:array of real;\n    Length:integer;\n  \n  constructor (params px:array of real);\n  begin\n    Value:=PABCSystem.Copy(px);\n    Length:=Value.Length;\n    Assert(Value.Length<>0,'Vector: zero length prohibited')\n  end;\n  \n  class function operator + (va,vb:Vector):Vector;\n  begin\n    Assert(va.Length=vb.Length,'Vector: lengths incompatible');\n    Result:=new Vector(va.Value.Zip(vb.Value,(p,q)->p+q).ToArray);\n  end;\n  \n  class function operator - (va,vb:Vector):Vector;\n  begin\n    Assert(va.Length=vb.Length,'Vector: lengths incompatible');\n    Result:=new Vector(va.Value.Zip(vb.Value,(p,q)->p-q).ToArray);\n  end;\n  \n  class function operator * (va,vb:Vector):real;\n  begin\n    Assert(va.Length=vb.Length,'Vector: lengths incompatible');\n    Result:=va.Value.Zip(vb.Value,(p,q)->p*q).Sum;\n  end;\n  \n  function VP(vb:Vector):Vector;\n  begin\n    Result:=new Vector(3);\n    Assert(Length=vb.Length,'Vector.VP: vector lengths incompatible');\n    if (Length=2) or (Length=3) then begin\n      var r:=new real[3,3] ((1,1,1),(0,0,0),(0,0,0));\n      for var j:=0 to Length-1 do begin\n        r[1,j]:=Value[j];\n        r[2,j]:=vb.Value[j]\n        end;\n      Result.Value[0]:=r[1,1]*r[2,2]-r[1,2]*r[2,1];\n      Result.Value[1]:=-r[1,0]*r[2,2]+r[1,2]*r[2,0];\n      Result.Value[2]:=r[1,0]*r[2,1]-r[1,1]*r[2,0]\n      end       \n    else begin\n      Assert(false,'Vector.VP: Vectors must be 2D or 3D');\n      Result.Value:=ArrFill(3,MaxReal)\n      end\n  end;\n  \n  function MP(vb,vc:Vector):real;\n  begin\n    Assert((Length=vb.Length) or (Length=vc.Length),\n        'Vector.MP: vector lengths incompatible');\n    if (Length=2) or (Length=3) then begin\n      var r:=new real[3,3];\n      for var j:=0 to Length-1 do begin\n        r[0,j]:=Value[j];\n        r[1,j]:=vb.Value[j];\n        r[2,j]:=vc.Value[j]\n        end;\n      Result:=r[0,0]*(r[1,1]*r[2,2]-r[1,2]*r[2,1])-\n          r[0,1]*(r[1,0]*r[2,2]-r[1,2]*r[2,0])+\n          r[0,2]*(r[1,0]*r[2,1]-r[1,1]*r[2,0])\n      end       \n    else begin\n      Assert(false,'Vector.VP: Vectors must be 2D or 3D');\n      Result:=MaxReal\n      end\n  end;\n  \n  function ModV:real; \n  begin\n    Result:=Sqrt(Value.Select(t->t*t).Sum);\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for matrix operations including determinant, inverse and linear system solution",
    "output": "type\n  Matrix=class\n  public\n    Value: array[,] of real;\n    RowCount:  integer;\n    ColCount:  integer;\n  \n  constructor (pa:array[,] of real);\n  begin\n    (RowCount,ColCount):=(pa.RowCount,pa.ColCount);\n    Value:=new real[RowCount,ColCount];\n    for var i:=0 to RowCount-1 do\n      for var j:=0 to ColCount-1 do\n        Value[i,j]:=pa[i,j]\n  end;\n  \n  class function operator + (pa,pb:Matrix):Matrix;\n  begin\n    Assert((pa.RowCount=pb.RowCount) and (pa.ColCount=pb.ColCount),\n        'Matrix addition: size mismatch');\n    Result:=new Matrix(pa.RowCount,pa.ColCount);\n    for var i:=0 to pa.RowCount-1 do\n      for var j:=0 to pa.ColCount-1 do\n        Result.Value[i,j]:=pa.Value[i,j]+pb.Value[i,j]\n  end;\n  \n  class function operator * (pa,pb:Matrix):Matrix;\n  begin\n    Assert(pa.ColCount=pb.RowCount,\n        'Matrix: matrix multiplication. Size mismatch');\n    Result:=new Matrix(pa.RowCount,pb.ColCount);\n    for var i:=0 to pa.RowCount-1 do\n      for var j:=0 to pb.ColCount-1 do begin\n        var s:=0.0;\n        for var k:=0 to pa.ColCount-1 do\n          s+=pa.Value[i,k]*pb.Value[k,j];\n        Result.Value[i,j]:=s\n        end\n  end;\n  \n  function Det:real;\n  begin\n    var r:=new Decomp(Value);\n    Result:=r.det\n  end;\n  \n  function Inv:Matrix;\n  begin\n    Assert(RowCount=ColCount,'Matrix.Inv: matrix is not square');\n    Result:=new Matrix(RowCount,ColCount);\n    var r:=new Decomp(Value);\n    if r.cond<MaxReal then begin\n      for var j:=0 to ColCount-1 do begin\n        var v:=ArrGen(RowCount,i->i=j?1.0:0.0);\n        r.Solve(v);\n        for var i:=0 to RowCount-1 do Result.Value[i,j]:=v[i]\n        end\n      end\n    else Result.Value:=MatrFill(RowCount,ColCount,MaxReal);  \n  end;\n  \n  function SLAU(vb:Vector; var cond:real):Vector;\n  begin\n    Assert(vb.Length=ColCount,\n        'Matrix.SLAU: vector vb length incompatible with matrix size');\n    var r:=new Decomp(Value);\n    cond:=r.cond;\n    Result:=new Vector(vb.Length);\n    Result.Value:=PABCSystem.Copy(vb.Value);\n    r.Solve(Result.Value);\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for polynomial arithmetic including differentiation and integration",
    "output": "type\n  Polynom=class\n  public\n    a:array of real;\n    n:integer;\n    eps:real;\n  \n  constructor(params p:array of real);\n  begin\n    a:=PABCSystem.Copy(p);\n    n:=a.Length\n  end;\n\n  function Value(x:real):real;\n  begin\n    Result:=a[0];\n    var k:=1.0;\n    for var i:=1 to n-1 do begin\n      k*=x;\n      Result+=a[i]*k\n      end;\n  end;\n  \n  function PDif:Polynom;\n  begin\n    Result:=new Polynom(n-1);\n    for var i:=0 to n-2 do Result.a[i]:=a[i+1]*(i+1)\n  end;\n  \n  function PInt:Polynom;\n  begin\n    Result:=new Polynom(Arr(0.0)+a);\n    for var i:=1 to Result.n-1 do Result.a[i]/=i\n  end;\n  \n  class function operator + (p,q:Polynom):Polynom;\n  begin\n    var m:=Max(p.n,q.n);\n    Result:=new Polynom(m);\n    if p.n>q.n then begin\n      for var i:=0 to q.n-1 do Result.a[i]:=p.a[i]+q.a[i];\n      for var i:=q.n to m-1 do Result.a[i]:=p.a[i]\n      end\n    else begin\n      for var i:=0 to p.n-1 do Result.a[i]:=p.a[i]+q.a[i];\n      for var i:=p.n to m-1 do Result.a[i]:=q.a[i]\n      end\n  end;\n  \n  class function operator * (p,q:Polynom):Polynom;\n  begin\n    var m:=p.n+q.n-1;\n    Result:=new Polynom(m);\n    for var i:=0 to p.n-1 do\n      for var j:=0 to q.n-1 do\n        Result.a[i+j]+=p.a[i]*q.a[j]\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for finding all roots of polynomial with real coefficients using Newton-Raphson method",
    "output": "type\n  PolRt=class\n  private\n    p:Polynom;\n  \n  public\n    ier:integer;\n  \n  constructor(p:Polynom);\n  begin\n    Self.p:=p;\n  end;\n\n  function Value:array of complex;\n  begin\n    var m:=p.n-2;\n    if m>35 then begin ier:=2; Exit end;\n    if p.a[m+1]=0 then begin ier:=4; Exit end;\n    if m<=0 then begin ier:=1; Exit end;\n    var SSq:complex->real:=x->Sqr(x.Real)+Sqr(x.Imaginary);\n    ier:=0;\n    Result:=new complex[m+1];\n    var sumsq,temp,alpha:real;\n    var x:complex;\n    var L50, L60, L100, L135: boolean;\n    var (ifit,n2,n,nx,nxx):=(0,0,m,m,m+1);\n    var kj1:=nxx;\n    var cof:=p.a.Reverse.ToArray;\n    while n>=0 do begin\n      var xo:=cplx(0.00500101,0.01000101);\n      var ini:=0;\n      (L50,L60,L135):=(false,false,false);\n      while true do begin\n        if not l60 then begin\n          xo:=cplx(-10*xo.Imaginary,-10*xo.Real); x:=xo; ini+=1\n          end;\n        L100:=false;\n        var xpr:=cplx(0.0,0.0);\n        for var ict:=1 to 500 do begin\n          var u:=cplx(cof[n+1],0.0);\n          var xt:=cplx(1.0,0.0);\n          var ux:=cplx(0.0,0.0);\n          if u.Real=0 then begin\n            (x,L50,L135):=(0.0,true,true); nx-=1; nxx-=1;\n            break\n            end;\n          for var i:=1 to n+1 do begin\n            temp:=cof[n-i+1];\n            var xt2:=x*xt;\n            u+=temp*xt2; ux+=Conjugate(i*temp*xt);\n            xt:=xt2\n            end;\n          sumsq:=SSq(ux);\n          if sumsq=0.0 then\n            if ifit=0 then begin L60:=false; continue end\n            else begin x:=xpr; L50:=true; break end;\n          var dx:=-u*ux/sumsq; x+=dx;\n          if Abs(dx.Imaginary)+Abs(dx.Real)<1e-12 then begin\n            L100:=true; break\n            end\n          end;\n        if not L50 then begin  \n          L100:=L100 or (ifit<>0);\n          if not L100 then\n            if ini>=5 then begin ier:=3; Exit end\n            else begin L60:=false; continue end;\n          for var l:=0 to nxx do Swap(p.a[kj1-l],cof[l]);\n          Swap(n,nx);\n          if ifit=0 then begin\n            (ifit,xpr,L60):=(1,x,true);\n            continue\n            end\n          else break\n          end\n        end;\n      L50:=false;\n      if L135 then begin\n        x:=cplx(x.Real,0.0); (sumsq,alpha,L135):=(0.0,x.Real,false); n-=1;\n        end\n      else begin\n        ifit:=0;\n        if Abs(x.Imaginary)-1e-10*Abs(x.Real)>=0 then begin\n          alpha:=2*x.Real; sumsq:=SSq(x); n-=2\n          end\n        else begin\n          x:=cplx(x.Real,0.0); (sumsq,alpha):=(0.0,x.Real); n-=1\n          end\n        end;\n      cof[1]:=cof[1]+alpha*cof[0];\n      for var l:=1 to n do cof[l+1]+=alpha*cof[l]-sumsq*cof[l-1];\n      Result[n2]:=x; n2+=1;\n      if sumsq<>0.0 then begin\n        Result[n2]:=Conjugate(x); n2+=1\n        end\n      end\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for adaptive quadrature numerical integration using QUANC8 algorithm",
    "output": "type\n  Quanc8=class\n  private\n  fun:real->real;\n  a,b,abserr,relerr:real;\n  \n  public\n  \n  constructor(f:real->real; a,b,abserr,relerr:real);\n  begin\n    fun:=f;\n    Self.a:=a;\n    Self.b:=b;\n    Self.abserr:=abserr;\n    Self.relerr:=relerr;\n  end;\n\n  function Value:(real,real,real,integer);\n  begin\n    var (res,errest,flag):=(0.0,0.0,0.0);\n    var nofun:=0;\n    var (levmin,levmax,levout,nomax):=(1,30,6,5000);\n    var nofin:=nomax-8*(levmax-levout+128);\n    var k:=14175.0;\n    var (w0,w1,w2,w3,w4):=(3956.0/k,23552.0/k,-3712.0/k,41984.0/k,-18160.0/k);\n    var (area,cor11):=(0.0,0.0);\n    if(a=b) then begin Result:=(0.0,0.0,0.0,0); Exit end;\n    var (lev,nim):=(0,1);\n    var x:=new real[17];\n    (x[0],x[16]):=(a,b);\n    var qprev:=0.0;\n    var f:=new real[17];\n    f[0]:=fun(x[0]);\n    var stone:=(b-a)/16;\n    x[8]:=(x[0]+x[16])/2;\n    x[4]:=(x[0]+x[8])/2;\n    x[12]:=(x[8]+x[16])/2;\n    x[2]:=(x[0]+x[4])/2;\n    x[6]:=(x[4]+x[8])/2;\n    x[10]:=(x[8]+x[12])/2;\n    x[14]:=(x[12]+x[16])/2;\n    var j:=2;\n    while j<=16 do begin f[j]:=fun(x[j]); j+=2 end;\n    nofun:=9;\n    var qright:=new real[32];\n    var fsave:=new real[9,31];\n    var xsave:=new real[9,31];\n    while True do begin\n      x[1]:=(x[0]+x[2])/2; f[1]:=fun(x[1]);\n      j:=3;\n      while j<=15 do begin\n        x[j]:=(x[j-1]+x[j+1])/2; f[j]:=fun(x[j]); j:=j+2\n        end;\n      nofun+=8;\n      var step:=(x[16]-x[0])/16;\n      var qleft:=(w0*(f[0]+f[8])+w1*(f[1]+f[7])+w2*(f[2]+f[6])+w3*(f[3]+f[5])+\n          w4*f[4])*step;\n      qright[lev+1]:=(w0*(f[8]+f[16])+w1*(f[9]+f[15])+w2*(f[10]+f[14])+\n          w3*(f[11]+f[13])+w4*f[12])*step;\n      var qnow:=qleft+qright[lev+1];\n      var qdiff:=qnow-qprev; area+=qdiff;\n      var esterr:=Abs(qdiff)/1023;\n      var tolerr:=Max(abserr,relerr*Abs(area))*(step/stone);\n      var L70:=false;\n      if lev>=levmin then begin;\n        if lev>=levmax then begin\n          flag+=1; L70:=true\n          end\n        else if nofun>nofin then begin\n          nofin*=2; levmax:=levout; flag+=(b-x[0])/(b-a); L70:=true\n          end\n        else if esterr<=tolerr then L70:=true;\n        end;\n      if not L70 then begin\n        nim*=2; lev+=1;\n        for var i:=1 to 8 do begin\n          fsave[i,lev]:=f[i+8];\n          xsave[i,lev]:=x[i+8]\n          end;\n        qprev:=qleft;\n        for var i:=8 downto 1 do begin\n          f[2*i]:=f[i];\n          x[2*i]:=x[i]\n          end;\n        continue\n        end;\n      res+=qnow; errest+=esterr; cor11+=qdiff/1023;\n      while nim.IsOdd do begin\n        nim:=nim div 2;\n        lev-=1\n      end;\n      nim+=1;\n      if lev<=0 then break;\n      qprev:=qright[lev]; x[0]:=x[16]; f[0]:=f[16];\n      for var i:=1 to 8 do begin\n        f[2*i]:=fsave[i,lev];\n        x[2*i]:=xsave[i,lev]\n        end;\n      end;\n    res+=cor11;\n    if errest=0 then begin\n      Result:=(res,errest,flag,nofun); Exit\n      end;\n    repeat\n      var temp:=Abs(res)+errest;\n      if temp<>Abs(res) then begin\n        Result:=(res,errest,flag,nofun); Exit\n        end;\n      errest*=2;\n    until false;\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for Runge-Kutta-Fehlberg 4th-5th order method for solving ordinary differential equations",
    "output": "type\n  RKF45=class\n  private\n  neqn:integer;\n  abserr_save:real;\n  relerr_save:real;\n  h:real;\n  epsilon:=1.2e-15;\n  flag_save:integer;\n  init:integer;\n  kflag:integer;\n  kop:integer;\n  nfe:integer;\n  f1:array of real;\n  f2:array of real;\n  f3:array of real;\n  f4:array of real;\n  f5:array of real;\n  p:procedure(x:real; y,yp:array of real);\n  \n  procedure Fehl(s:array of real; t,h:real);\n  begin\n    var ch:=h/4.0;\n    for var i:=0 to neqn-1 do f5[i]:=y[i]+ch*yp[i];\n    p(t+ch,f5,f1); ch:=3.0*h/32.0;\n    for var i:=0 to neqn-1 do f5[i]:=y[i]+ch*(yp[i]+3.0*f1[i]);\n    p(t+3.0*h/8.0,f5,f2); ch:=h/2197.0;\n    for var i:=0 to neqn-1 do \n      f5[i]:=y[i]+ch*(1932.0*yp[i]+7296.0*f2[i]-7200.0*f1[i]);\n    p(t+12.0*h/13.0,f5,f3); ch:=h/4104.0;\n    for var i:=0 to neqn-1 do\n      f5[i]:=y[i]+ch*(8341.0*yp[i]-845.0*f3[i]+29440.0*f2[i]-32832.0*f1[i]);\n    p(t+h,f5,f4); ch:=h/20520.0;\n    for var i:=0 to neqn-1 do\n      f1[i]:=y[i]+ch*(-6080.0*yp[i]+9295.0*f3[i]-5643.0*f4[i]+41040.0*f1[i]-\n          28352.0*f2[i]);\n    p(t+h/2.0,f1,f5); ch:=h/7618050.0;\n    for var i:=0 to neqn-1 do\n      s[i]:=y[i]+ch*(902880.0*yp[i]+3855735.0*f3[i]-1371249.0*f4[i]+\n          3953664.0*f2[i]+277020.0*f5[i])\n  end;\n  \n  public\n  flag:integer;\n  relerr:real;\n  abserr:real;\n  y:array of real;\n  yp:array of real;\n  MsgOn:boolean;\n  \n  constructor (f:procedure(x:real; y,yp:array of real);\n      y:array of real; abserr,relerr:real; MsgOn:boolean:=true);\n  begin\n    neqn:=y.Length;\n    Self.y:=Copy(y);\n    yp:=new real[neqn];\n    f1:=new real[neqn];\n    f2:=new real[neqn];\n    f3:=new real[neqn];\n    f4:=new real[neqn];\n    f5:=new real[neqn];\n    Self.epsilon:=epsilon;\n    flag:=1;\n    Self.abserr:=abserr;\n    Self.relerr:=relerr;\n    Self.MsgOn:=MsgOn;\n    (abserr_save,relerr_save,h):=(-1.0,-1.0,-1.0);\n    (flag_save,init,kflag,kop,nfe):=(-1000,-1000,-1000,-1,-1);\n    p:=f;\n  end;\n  \n  procedure Solve(var t:real; tout:real);\n  begin\n    var maxnfe:=3000;\n    var remin:=1.0E-12;\n    var eps:=Self.epsilon;\n    if (neqn<1) then begin\n      flag:=8; Exit\n      end;\n    if (relerr<0.0) or (abserr<0.0) then begin\n      flag:=8; Exit\n      end;\n    if (flag=0) or (flag<-2) or (flag>8) then begin\n      flag:=8; Exit\n        end;\n    var mflag:=Abs(flag);\n    if mflag<>1 then begin\n      if (t=tout) and (kflag<>3) then begin\n        flag:=8; Exit\n        end;\n      if mflag=2 then begin\n        if kflag=3 then begin\n          flag:=flag_save; mflag:=Abs(flag)\n          end\n        else if init=0 then flag:=flag_save\n        else if kflag=4 then nfe:=0\n        else if (kflag=5) and (abserr=0.0) then begin\n          flag:=-5; Exit\n          end\n        else if (kflag=6) and (relerr<=relerr_save) and\n            (abserr<=abserr_save) then begin\n              flag:=-4; Exit\n              end\n        end\n      else\n        if flag=3 then begin\n          flag:=flag_save;\n          if kflag=3 then mflag:=Abs(flag);\n          end\n        else if flag=4 then begin\n          nfe:=0; flag:=flag_save;\n          if kflag=3 then mflag:=Abs(flag)\n          end\n        else if (flag=5) and (abserr>0.0) then begin\n          flag:=flag_save;\n          if kflag=3 then mflag:=Abs(flag)\n          end\n        else begin\n          flag:=-3; Exit\n          end\n        end;\n    flag_save:=flag; kflag:=0;\n    relerr_save:=relerr; abserr_save:=abserr;\n    relerr_min:=2.0*epsilon+remin;\n    if relerr<relerr_min then begin\n      relerr:=relerr_min; flag:=3; kflag:=3;\n      Exit\n      end;\n    dt:=tout-t;\n    if mflag=1 then begin\n      init:=0; kop:=0;\n      p(t,y,yp);\n      nfe:=1;\n      if t=tout then begin\n        flag:=2; Exit\n        end\n      end;\n    if init=0 then begin\n      init:=1; h:=Abs(dt); toln:=0.0;\n      for var k:=0 to neqn-1 do begin\n        tol:=relerr*Abs(y[k])+abserr;\n        if tol>0.0 then begin\n          toln:=tol; ypk:=Abs(yp[k]);\n          if tol<ypk*Power(h,5) then h:=Power(tol/ypk,0.2)\n          end\n        end;\n      if toln<=0.0 then h:=0.0;\n      h:=Max(h,26.0*eps*Max(Abs(t),Abs(dt)));\n      flag_save:=flag<0?-2:2\n      end;\n    if dt<0 then h:=-h;\n    if 2.0*Abs(dt)<=Abs(h) then kop+=1;\n    if kop=10000 then begin kop:=0; flag:=7; Exit end;\n    if Abs(dt)<=26.0*eps*Abs(t) then begin\n      t:=tout;\n      for var i:=0 to neqn-1 do y[i]+=dt*yp[i];\n      p(t,y,yp);\n      nfe+=1; flag:=2;\n      Exit\n    end;\n    output:=false; scale:=2.0/relerr; ae:=scale*abserr;\n    repeat\n      hfaild:=false; hmin:=26.0*eps*Abs(t); dt:=tout-t;\n      if 2.0*Abs(h)>Abs(dt) then begin\n        if Abs(dt)<=Abs(h) then begin output:=true; h:=dt end\n        else h:=0.5*dt\n        end;\n      while true do begin\n        if maxnfe<nfe then begin (flag,kflag):=(4,4); Exit end;\n        Fehl(f1,t,h);\n        nfe+=5; eeoet:=0.0;\n        for var k:=0 to neqn-1 do begin\n          et:=Abs(y[k])+Abs(f1[k])+ae;\n          if et<=0.0 then begin flag:=5; Exit end;\n          ee:=Abs((-2090.0*yp[k]+(21970.0*f3[k]-15048.0*f4[k]))+\n              (22528.0*f2[k]-27360.0*f5[k]));\n          eeoet:=Max(eeoet,ee/et)\n          end;\n        esttol:=Abs(h)*eeoet*scale/752400.0;\n        if esttol<=1.0 then Break;\n        hfaild:=true; output:=false;\n        if esttol<59049.0 then s:=0.9/Power(esttol,0.2)\n        else s:=0.1;\n        h*=s;\n        if Abs(h)<hmin then begin (flag,kflag):=(6,6); Exit end;\n        end;\n      t+=h; y:=Copy(f1);\n      p(t,y,yp);\n      nfe+=1;\n      if esttol>0.0001889568 then s:=0.9/Power(esttol,0.2)\n      else s:=5.0;\n      if hfaild then s:=Min(s,1.0);\n      h:=Sign(Max(s*Abs(h),hmin),h);\n      if output then begin t:=tout; flag:=2; Exit end;\n    until flag<=0;    \n    flag:=-2;\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for root isolation of equation y(x)=0 on given interval",
    "output": "type\n  RootsIsolation=class\n  private\n    f:real->real;\n    a,b,h:real;\n  \n  public\n  \n  constructor(f:real->real; a,b,h:real);\n  begin\n    Self.f:=f;\n    Self.a:=a;\n    Self.b:=b;\n    Self.h:=h\n  end;\n\n  function Value:array of (real,real);\n  begin\n    var r:=new List<(real,real)>;\n    var h2:=h/2;\n    var eps:=1e-7;\n    var (xa,ya,bk):=(a,f(a),b+h2);\n    if Abs(ya)<eps then begin\n      r.Add((xa-h2,xa+h2));\n      xa+=h2; ya:=f(xa)\n      end;\n    var xb:=xa+h;\n    while xb<=bk do begin\n      var yb:=f(xb);\n      if Abs(yb)<eps then begin\n        r.Add((xb-h2,xb+h2));\n        xa:=xb+h2; ya:=f(xa);\n        xb:=xa+h\n        end\n      else if ya*yb<0 then begin\n        r.Add((xa,xb));\n        (xa,ya):=(xb,yb);\n        xb:=xa+h\n        end\n      else begin\n        (xa,ya):=(xb,yb);\n        xb:=xa+h\n        end\n      end;\n    Result:=r.ToArray\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for cubic spline interpolation of tabular function",
    "output": "type\n  Spline=class\n  private\n  n:integer;\n  aK:array[,] of real;\n  P:array of Point;\n  \n  procedure Spline;\n  begin\n    if n<2 then Exit;\n    if n=2 then begin\n      aK[0,0]:=(P[1].y-P[0].y)/(P[1].x-P[0].x); aK[0,1]:=aK[0,0];\n      (aK[1,0],aK[1,1],aK[2,0],aK[2,1]):=(0,0,0,0);\n      Exit\n      end;\n    aK[2,0]:=P[1].x-P[0].x; aK[1,1]:=(P[1].y-P[0].y)/aK[2,0];\n    for var i:=1 to n-2 do begin\n      aK[2,i]:=P[i+1].x-P[i].x;\n      aK[0,i]:=2*(aK[2,i-1]+aK[2,i]);\n      aK[1,i+1]:=(P[i+1].y-P[i].y)/aK[2,i];\n      aK[1,i]:=aK[1,i+1]-aK[1,i]\n      end;\n    aK[0,0]:=-aK[2,0]; aK[0,n-1]:=-aK[2,n-2];\n    aK[1,0]:=0; aK[1,n-1]:=0;\n    if n<>3 then begin\n      aK[1,0]:=aK[1,2]/(P[3].x-P[1].x)-aK[1,1]/(P[2].x-P[0].x);\n      aK[1,n-1]:=aK[1,n-2]/(P[n-1].x-P[n-3].x)-aK[1,n-3]/(P[n-2].x-P[n-4].x);\n      aK[1,0]:=aK[1,0]*Sqr(aK[2,0])/(P[3].x-P[0].x);\n      aK[1,n-1]:=-aK[1,n-1]*Sqr(aK[2,n-2])/(P[n-1].x-P[n-4].x)\n      end;\n    for var i:=1 to n-1 do begin\n      var t:=aK[2,i-1]/aK[0,i-1];\n      aK[0,i]:=aK[0,i]-t*aK[2,i-1];\n      aK[1,i]:=aK[1,i]-t*aK[1,i-1]\n      end;\n    aK[1,n-1]:=aK[1,n-1]/aK[0,n-1];\n    for var i:=n-2 downto 0 do\n      aK[1,i]:=(aK[1,i]-aK[2,i]*aK[1,i+1])/aK[0,i];\n    aK[0,n-1]:=(P[n-1].y-P[n-2].y)/aK[2,n-2]+\n        aK[2,n-2]*(aK[1,n-2]+2*aK[1,n-1]);\n    for var i:=0 to n-2 do begin\n      aK[0,i]:=(P[i+1].y-P[i].y)/aK[2,i]-\n          aK[2,i]*(aK[1,i+1]+2*aK[1,i]);\n      aK[2,i]:=(aK[1,i+1]-aK[1,i])/aK[2,i];\n      aK[1,i]:=3*aK[1,i]\n      end;\n    aK[1,n-1]:=3*aK[1,n-1]; aK[2,n-1]:=aK[2,n-2]\n  end;\n  \n  public\n  \n  constructor (pts:array of Point);\n  begin\n    n:=pts.Length;\n    P:=pts;\n    SetLength(aK,3,n);\n    Spline;\n  end;\n  \n  function Value(u:real):real;\n  begin\n    var i,j:integer;\n    if u<P[0].x then i:=0\n    else if u>P[n-1].x then i:=n-2\n    else begin\n      j:=n-1;\n      repeat\n        var k:=(i+j) div 2;\n        if u<P[k].x then j:=k else i:=k\n      until j-i<=1\n      end;  \n    var dx:=u-P[i].x;\n    Result:=P[i].y+dx*(aK[0,i]+dx*(aK[1,i]+dx*aK[2,i]))\n  end;\n  \n  function Diff(u:real):(real,real);\n  begin\n    var i,j:integer;\n    if u<P[0].x then i:=0\n    else if u>P[n-1].x then i:=n-2\n    else begin\n      j:=n-1;\n      repeat\n        var k:=(i+j) div 2;\n        if u<P[k].x then j:=k else i:=k\n      until j-i<=1\n      end;  \n    var dx:=u-P[i].x;\n    Result:=(aK[0,i]+dx*(2*aK[1,i]+3*dx*aK[2,i]),2*ak[1,i]+6*dx*aK[2,i])\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for finding initial uncertainty interval for unimodal function minimization using Svenn's method",
    "output": "type\n  Svenn=class\n  private\n  f:real->real;\n  xn,t:real;\n  \n  public\n  \n  constructor(f:real->real; xn,t:real);\n  begin\n    Self.f:=f;\n    Self.xn:=xn;\n    Self.t:=t\n  end;\n  \n  function Value:(real,real,integer);\n  begin\n    var k:=0;\n    var (x1,x2,x3):=(xn-t,xn,xn+t);\n    var (y1,y2,y3):=(f(x1),f(x2),f(x3));\n    var d,a,b:real;\n    if (y1>=y2) and (y2<=y3) then begin\n      Result:=(x1,x3,0);\n      Exit\n      end\n    else if (y1<=y2) and (y2>=y3) then begin\n      Result:=(x1,x3,1);\n      Exit\n      end\n    else if (y1>=y2) and (y2>=y3) then (d,a,x2,k):=(t,x2,x2+t,1)\n    else (d,b,x2,k):=(-t,x2,x2-t,1);\n    repeat\n      x1:=x2+Power(2,k)*d;\n      (y1,y2):=(f(x1),f(x2));\n      if (y1<y2) then begin\n        if d=t then a:=x2 else b:=x2;\n        k+=1; x2:=x1\n        end\n    until y1>=y2;\n    if d=t then Result:=(a,x1,0)\n    else Result:=(x1,b,0)\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for finding real zero of function on isolation interval using Brent's method",
    "output": "type\n  Zeroin=class\n  private\n  tol:real;\n  f:real->real;\n  \n  public\n  \n  constructor(f:real->real; tol:real);\n  begin\n    Self.tol:=tol;\n    Self.f:=f;\n  end;  \n  \n  function Value(ax,bx:real):real;\n  begin\n    var Sign:real->real:=x->(x=0?0.0:x<0?-1.0:1.0);\n    var eps:=1.0;\n    var tol1:real;\n    repeat\n      eps:=eps/2; tol1:=1.0+eps\n    until tol1<=1.0;\n    var (fa,fb,a,b):=(f(ax),f(bx),ax,bx);\n    repeat\n      var (c,d,fc):=(a,b-a,fa);\n      var e:=d;\n      repeat\n        if Abs(fc)<Abs(fb) then\n          begin (a,b):=(b,c); c:=a; (fa,fb):=(fb,fc); fc:=fa end;\n        tol1:=2*eps*Abs(b)+0.5*tol;\n        var xm:=0.5*(c-b);\n        if (Abs(xm)<tol1) or (fb=0) then begin Result:=b; Exit end;\n        if (Abs(e)<tol1) or (Abs(fa)<=Abs(fb)) then (d,e):=(xm,d)\n        else begin\n          var p,q,s:real;\n          if a=c then begin s:=fb/fa; p:=2*xm*s; q:=1-s end\n          else begin\n            var r:=fb/fc; q:=fa/fc; s:=fb/fa; p:=s*(2*xm*q*(q-r)-(b-a)*(r-1));\n            q:=(q-1)*(r-1)*(s-1)\n            end;\n          if p>0 then q:=-q;\n          p:=Abs(p);\n          if (2*p >= 3*xm*q-Abs(tol1*q)) or (p>=Abs(0.5*e*q)) then (d,e):=(xm,d)\n          else (e,d):=(d,p/q)\n          end;\n        (a,fa):=(b,fb);\n        if abs(d)>tol1 then  b:=b+d\n        else b+=Abs(tol1)*Sign(xm);\n        fb:=f(b);\n      until fb*Sign(fc)>0;\n    until false\n  end;\nend;"
  },
  {
    "instruction": "Convert a decimal number to binary system",
    "output": "function Bin(number: int64): string;\nbegin\n  if number < 0 then number := -number;\n  Result := '';\n  while number >= 2 do\n  begin\n    Result += number mod 2;\n    number := number div 2\n  end;  \n  Result += number;\n  Result := Result.Inverse\nend;"
  },
  {
    "instruction": "Convert a decimal number to octal system",
    "output": "function Oct(number: int64): string;\nbegin\n  if number < 0 then number := -number;\n  Result := '';\n  while number >= 8 do\n  begin\n    Result += number mod 8;\n    number := number div 8\n  end;  \n  Result += number;\n  Result := Result.Inverse;\nend;"
  },
  {
    "instruction": "Convert a decimal number to hexadecimal system",
    "output": "function Hex(number: int64): string;\nbegin\n  if number < 0 then number := -number;\n  var hex_nums := '0123456789ABCDEF';\n  Result := '';\n  while number >= 16 do\n  begin\n    Result += hex_nums[number mod 16 + 1];\n    number := number div 16\n  end;  \n  Result += hex_nums[number + 1];\n  Result := Result.Inverse;\nend;"
  },
  {
    "instruction": "Convert from base system (2..36) to decimal",
    "output": "function Dec(str: string; base: integer): int64;\nbegin\n  if not (base in 2..36) then\n    raise new School_InvalidBase\n    ($'Dec: Invalid base {base}');\n  str := str.ToUpper;\n  var invalid_chars := \n    str.Except(valid_chars[:base + 1]).JoinToString;\n  if invalid_chars.Length > 0 then\n    raise new School_BadCharInString\n    ($'Dec: Invalid characters \"{invalid_chars}\"');\n  var rank_weight := 1bi;\n  var res := 0bi;\n  foreach var char in str.Reverse do\n  begin\n    var rank_value := Pos(char, valid_chars) - 1;\n    res += rank_weight * rank_value;\n    rank_weight *= base\n  end;\n  Result := int64(res)\nend;"
  },
  {
    "instruction": "Convert decimal number to any base system (2..36)",
    "output": "function ToBase(number: int64; base: integer): string;\nbegin\n  if not (base in 2..36) then\n    raise new School_InvalidBase\n    ($'ToBase: Invalid base {base}');\n  var sb := new System.Text.StringBuilder('');\n  while number > 0 do \n  begin\n    sb.Insert(0, valid_chars[number mod base + 1]);\n    number := number div base\n  end;\n  Result := if sb.Length = 0 then '0'\n    else sb.ToString\nend;"
  },
  {
    "instruction": "Calculate GCD of two numbers",
    "output": "function \u041d\u041e\u0414(a, b: int64): int64;\nbegin\n  while b <> 0 do\n    (a, b) := (b, a mod b);\n  Result := Abs(a)\nend;"
  },
  {
    "instruction": "Calculate LCM of two numbers",
    "output": "function \u041d\u041e\u041a(a, b: int64): int64;\nbegin\n  var (a1, b1) := (a, b);\n  while b <> 0 do\n    (a, b) := (b, a mod b);\n  Result := Abs(a1 div a * b1)\nend;"
  },
  {
    "instruction": "Check if a number is prime",
    "output": "function IsPrime(n: integer): boolean;\nbegin\n  if n < 2 then\n    Result := False\n  else\n  begin\n    Result := True;\n    foreach var prime in LPrimes do\n      if Sqr(prime) > n then\n        break\n      else if n mod prime = 0 then\n      begin\n        Result := False;\n        break\n      end\n  end\nend;"
  },
  {
    "instruction": "Get prime numbers in range [2;n]",
    "output": "function Primes(n: integer): List<integer>;\nbegin\n  Result := [];\n  if n < 2 then\n    exit;\n  var Sieve := new boolean[n];\n  var p := 2;\n  while Sqr(p) <= n do\n  begin\n    if not Sieve[p - 1] then\n    begin\n      var notPrime := p * p;\n      while notPrime <= n do\n      begin\n        Sieve[notPrime - 1] := True;\n        notPrime += p\n      end\n    end;\n    p += 1\n  end;\n  for var i := 2 to n do\n    if not Sieve[i - 1] then\n      Result.Add(i)\nend;"
  },
  {
    "instruction": "Get prime factors of a number",
    "output": "function PrimeFactors(n: integer): List<integer>;\nbegin\n  Result := [];\n  if n < 2 then exit;\n  var (i, prime, m) := (0, LPrimes[0], n);\n  while Sqr(prime) <= n do\n  begin\n    while n mod prime = 0 do\n    begin\n      Result.Add(prime);\n      n := n div prime\n    end;\n    Inc(i);\n    prime := LPrimes[i];\n  end;\n  if Result.Count = 0 then Result.Add(m)\n  else if n > 1 then Result.Add(n)\nend;"
  },
  {
    "instruction": "Get digits of a number in given base",
    "output": "function Digits(n: int64; base: integer): List<integer>;\nbegin\n  Result := [];\n  if (n < 0) or (base < 2) or (base > integer.MaxValue) then exit;\n  if n = 0 then Result := Lst(0)\n  else\n    while n > 0 do\n    begin\n      var rem: integer := n mod base;\n      Result.Add(rem);\n      n := n div base\n    end;\n    Result.Reverse\nend;"
  },
  {
    "instruction": "Get all divisors of a natural number",
    "output": "function Divisors(n: integer): List<integer>;\nbegin\n  Result := [];\n  Result.Add(1);\n  foreach var prime in LPrimes do\n  begin\n    if Sqr(prime) > n then break;\n    var ndivs := Result.Count;\n    while n mod prime = 0 do\n    begin\n      for var i := Result.Count - ndivs to Result.Count - 1 do\n        Result.Add(Result[i] * prime);\n      n := n div prime\n    end\n  end;\n  if n > 1 then\n    for var i := 0 to Result.Count - 1 do\n      Result.Add(Result[i] * n);\n  Result.Sort;\nend;"
  },
  {
    "instruction": "Calculate sine of angle in degrees",
    "output": "function SinDegrees(x: real): real := Sin(DegToRad(x));"
  },
  {
    "instruction": "Generate array of random real numbers",
    "output": "function ArrRandomReal(n: integer; a, b: real; t: integer): array of real;\nbegin\n  Result := new real[n];\n  for var i := 0 to Result.Length - 1 do\n    Result[i] := Round(Random * (b - a) + a, t);\nend;"
  },
  {
    "instruction": "Generate truth table for boolean function with 2 variables",
    "output": "function TrueTable(f: function(a, b: boolean): boolean):\n    array[,] of boolean;\nbegin\n  Result := new boolean[4, 3];\n  var i := 0;\n  for var a := False to True do\n    for var b := False to True do\n    begin\n      Result[i, 0] := a;\n      Result[i, 1] := b;\n      Result[i, 2] := f(a, b);\n      i += 1\n    end;\nend;"
  },
  {
    "instruction": "Replace last occurrence of substring in string",
    "output": "procedure ReplaceLast(var s: string; source, target: string);\nbegin\n  var position := LastPos(source, s);\n  if position > 0 then\n  begin\n    Delete(s, position, source.Length);\n    Insert(target, s, position)\n  end\nend;"
  },
  {
    "instruction": "Multiple character replacement in string",
    "output": "function ReplaceMany(s, source, target: string): string;\nbegin\n  var SB := new StringBuilder(s);\n  var m := target.Length;\n  for var i := 1 to source.Length do\n    if i <= m then SB.Replace(source[i], target[i])\n    else SB.Replace(source[i],'');\n  Result := SB.ToString\nend;"
  },
  {
    "instruction": "Bitwise AND operation for Addr32 objects",
    "output": "static function Addr32.operator and (a, b: Addr32): Addr32;\nbegin\n  Result := new Addr32;\n  Result.addr10 := a.addr10 and b.addr10;\n  SetAddress(Result) \nend;"
  },
  {
    "instruction": "Convert decimal BigInteger to binary system",
    "output": "function Bin(number: BigInteger): string;\nbegin\n  if number < 0 then number := -number;\n  Result := '';\n  while number >= 2 do\n  begin\n    Result += byte(number mod 2);\n    number := number div 2\n  end;  \n  Result += byte(number);\n  Result := Result.Inverse\nend;"
  },
  {
    "instruction": "Convert decimal number to binary with formatting",
    "output": "function BinFormat(number: BigInteger; bytes: integer; split: string): string;\nbegin\n  if number < 0 then number := -number;\n  var a := number = 0 ? [byte(0)] : number.ToByteArray;\n  var len := a.Length;\n  if (number > 0) and (a[^1] = 0) then Dec(len);\n  SetLength(a, Max(bytes, len));\n  Result := a.Reverse.Select(t -> (Convert.ToString(t, 2)).PadLeft(8, '0')).JoinToString(split)\nend;"
  },
  {
    "instruction": "Convert decimal BigInteger to octal system",
    "output": "function Oct(number: BigInteger): string;\nbegin\n  if number < 0 then number := -number;\n  Result := '';\n  while number >= 8 do\n  begin\n    Result += byte(number mod 8);\n    number := number div 8\n  end;  \n  Result += byte(number);\n  Result := Result.Inverse;\nend;"
  },
  {
    "instruction": "Convert decimal BigInteger to hexadecimal system",
    "output": "function Hex(number: BigInteger): string;\nbegin\n  if number < 0 then number := -number;\n  var hex_nums := '0123456789ABCDEF';\n  Result := '';\n  while number >= 16 do\n  begin\n    Result += hex_nums[byte(number mod 16 + 1)];\n    number := number div 16\n  end;  \n  Result += hex_nums[byte(number + 1)];\n  Result := Result.Inverse;\nend;"
  },
  {
    "instruction": "Convert from base system to BigInteger decimal",
    "output": "function DecBig(str: string; base: integer): BigInteger;\nbegin\n  if not (base in 2..36) then\n    raise new School_InvalidBase\n    ($'DecBig: Invalid base {base}');\n  str := str.ToUpper;\n  var invalid_chars := \n    str.Except(valid_chars[:base + 1]).JoinToString;\n  if invalid_chars.Length > 0 then\n    raise new School_BadCharInString\n    ($'DecBig: Invalid characters \"{invalid_chars}\"');\n  var rank_weight := 1bi;\n  Result := 0bi;\n  foreach var char in str.Reverse do\n  begin\n    var rank_value := Pos(char, valid_chars) - 1;\n    Result += rank_weight * rank_value;\n    rank_weight *= base\n  end\nend;"
  },
  {
    "instruction": "Convert decimal BigInteger to any base system",
    "output": "function ToBase(number: BigInteger; base: integer): string;\nbegin\n  if not (base in 2..36) then\n    raise new School_InvalidBase\n    ($'ToBase: Invalid base {base}');\n  var sb := new System.Text.StringBuilder('');\n  while number > 0 do \n  begin\n    sb.Insert(0, valid_chars[integer(number mod base) + 1]);\n    number := number div base\n  end;\n  Result := if sb.Length = 0 then '0'\n    else sb.ToString\nend;"
  },
  {
    "instruction": "Calculate GCD and LCM of two numbers",
    "output": "function \u041d\u041e\u0414\u041d\u041e\u041a(a, b: int64): (int64, int64);\nbegin\n  var (a1, b1) := (a, b);\n  while b <> 0 do\n    (a, b) := (b, a mod b);\n  Result := (a, Abs(a1 div a * b1))\nend;"
  },
  {
    "instruction": "Get prime numbers in range [m;n]",
    "output": "function Primes(m, n: integer): List<integer>;\nbegin\n  var ls := ubPrimeDivs;\n  if m > n then Swap(m, n);\n  Result := [];\n  if m <= LPrimes[^1] then\n  begin\n    foreach var prime in LPrimes do\n    begin\n      if prime > n then break;\n      if prime >= m then Result.Add(prime)\n    end;\n    if Result.Count = 0 then exit;\n    m := Result[^1] + 1;\n    if m >= n then exit\n  end;  \n  var ls64: int64 := ls;\n  var ln := Ceil(m / ls);\n  var rn := Ceil(n / ls);\n  for var sn := ln to rn do\n  begin\n    var a := Max((sn - 1) * ls64 + 1, 2);\n    var b := sn * ls64;\n    var Sieve := new boolean[ls];\n    for var i := 0 to LPrimes.Count - 1 do\n    begin\n      var prime := LPrimes[i];\n      if Sqr(prime) > b then break;\n      var k := a;\n      var d := k mod prime;\n      if d <> 0 then k += prime - d;\n      while k <= b do\n      begin\n        Sieve[integer(k - a)] := True;\n        k += prime\n      end\n    end;\n    for var i := 0 to Sieve.High do\n      if not Sieve[i] then\n        if (a + i >= m) and (a + i <= n) then\n          Result.Add(a + i)\n  end\nend;"
  },
  {
    "instruction": "Get first k prime numbers",
    "output": "function FirstPrimes(k: integer): List<integer>;\nbegin\n  if k <= nPrimeDivs then Result := LPrimes[:k]\n  else\n  begin\n    Result := LPrimes;\n    var kprimes := nPrimeDivs;\n    var n := maxPrimeDiv + 2;\n    repeat\n      if n.IsPrime then\n      begin\n        Result.Add(n);\n        Inc(kprimes)\n      end;  \n      n += 2\n    until kprimes = k\n  end\nend;"
  },
  {
    "instruction": "Get unique prime divisors of a number",
    "output": "function PrimeDivisors(n: integer): List<integer>;\nbegin\n  Result := [];\n  if n < 2 then exit;\n  var (i, prime, m) := (0, LPrimes[0], n);\n  while Sqr(prime) <= n do\n  begin\n    if n mod prime = 0 then\n    begin\n      Result.Add(prime);\n      repeat\n        n := n div prime\n      until n mod prime <> 0\n    end;\n    Inc(i);\n    prime := LPrimes[i];\n  end;\n  if Result.Count = 0 then Result.Add(m)\n  else if n > 1 then Result.Add(n)\nend;"
  },
  {
    "instruction": "Count unique prime divisors of a number",
    "output": "function PrimeDivisorsCount(n: integer): integer;\nbegin\n  Result := 0;\n  if n < 2 then Exit;\n  var (i, prime, DivIsPrime) := (0, LPrimes[0], True);\n  while Sqr(prime) <= n do\n  begin\n    if n mod prime = 0 then\n    begin\n      Inc(Result);\n      DivIsPrime := False;\n      repeat\n        n := n div prime\n      until n mod prime <> 0\n    end;\n    Inc(i);\n    prime := LPrimes[i];\n  end;\n  if DivIsPrime then Result := 1\n  else if n > 1 then Result += 1\nend;"
  },
  {
    "instruction": "Count prime factors of a number",
    "output": "function PrimeFactorsCount(n: integer): integer;\nbegin\n  Result := 0;\n  if n < 2 then exit;\n  var (i, prime, DivIsPrime) := (0, LPrimes[0], True);\n  while Sqr(prime) <= n do\n  begin\n    while n mod prime = 0 do\n    begin\n      Inc(Result);\n      DivIsPrime := False;\n      n := n div prime\n    end;\n    Inc(i);\n    prime := LPrimes[i];\n  end;\n  if DivIsPrime then Result := 1\n  else if n > 1 then Result += 1\nend;"
  },
  {
    "instruction": "Convert digits list to BigInteger",
    "output": "function DigitsToBigInteger(ext: List<integer>; base: integer): BigInteger;\nbegin\n  Result := BigInteger.Zero;\n  var p := BigInteger.One;\n  for var i := ext.Count -1 downto 0 do\n  begin  \n    Result += ext[i] * p;\n    p *= base\n  end\nend;"
  },
  {
    "instruction": "Count divisors of a number",
    "output": "function DivisorsCount(n: integer): integer;\nbegin\n  Result := 1;\n  foreach var prime in LPrimes do\n  begin\n    if Sqr(prime) > n then break;\n    var ndivs := Result;\n    while n mod prime = 0 do\n    begin\n      for var i := Result - ndivs to Result - 1 do\n        Result += 1;\n      n := n div prime;\n    end\n  end;  \n  if n > 1 then\n    for var i := 0 to Result - 1 do\n      Result += 1;\nend;"
  },
  {
    "instruction": "Calculate cosine of angle in degrees",
    "output": "function CosDegrees(x: real): real := Cos(DegToRad(x));"
  },
  {
    "instruction": "Calculate tangent of angle in degrees",
    "output": "function TanDegrees(x: real): real := Tan(DegToRad(x));"
  },
  {
    "instruction": "Generate sequence of random real numbers",
    "output": "function SeqRandomReal(n: integer; a, b: real; t: integer): sequence of real;\nbegin\n  loop n do\n    yield Round(Random * (b - a) + a, t)\nend;"
  },
  {
    "instruction": "Generate matrix of random real numbers",
    "output": "function MatrRandomReal(m: integer; n: integer; a, b: real; t: integer): array [,] of real;\nbegin\n  Result := new real[m, n];\n  for var i := 0 to Result.RowCount - 1 do\n    for var j := 0 to Result.ColCount - 1 do\n      Result[i, j] := Round(Random * (b - a) + a, t);\nend;"
  },
  {
    "instruction": "Generate truth table for boolean function with 3 variables",
    "output": "function TrueTable(f: function(a, b, c: boolean): boolean):\n    array[,] of boolean;\nbegin\n  Result := new boolean[8, 4];\n  var i := 0;\n  for var a := False to True do\n    for var b := False to True do\n      for var c := False to True do\n      begin\n        Result[i, 0] := a;\n        Result[i, 1] := b;\n        Result[i, 2] := c;\n        Result[i, 3] := f(a, b, c);\n        i += 1\n      end;\nend;"
  },
  {
    "instruction": "Generate truth table for boolean function with n variables",
    "output": "function TrueTable(n: integer; f: (array of boolean) -> boolean):\n    array[,] of boolean;\nbegin\n  Result := new boolean[1 shl n, n + 1];\n  foreach var values in [False, True].CartesianPower(n) index i do\n  begin\n    foreach var val in values index j do \n    begin\n      Result[i, j] := val\n    end;\n    Result[i, ^1] := f(values)\n  end\nend;"
  },
  {
    "instruction": "Multiple substring replacement in string",
    "output": "function ReplaceMany(s: string; source, target: IList<string>): string;\nbegin\n  var SB := new StringBuilder(s);\n  var tl := target.Count - 1;\n  for var i := 0 to source.Count - 1 do\n    if i <= tl then SB.Replace(source[i], target[i])\n    else SB.Replace(source[i], '');\n  Result := SB.ToString\nend;"
  },
  {
    "instruction": "Swap substrings in string",
    "output": "procedure SwapSubstr(var s: string; ss1, ss2: string);\nbegin\n  if not ((ss1 in s) and (ss2 in s)) then exit;\n  var D := Dict((ss1, ss2), (ss2, ss1));\n  s := Regex.Replace(s, $'({ss1}|{ss2})', m -> D[m.Value])\nend;"
  },
  {
    "instruction": "Translate characters in string",
    "output": "function Translate(s, source, target: string): string;\nbegin\n  var sb := new StringBuilder(s.Length);\n  foreach var x in s do \n  begin\n    var ind := source.IndexOf(x); \n    if ind >= 0 then\n    begin\n      if ind <= target.Length - 1 then\n        sb.Append(target[ind + 1])\n    end\n    else sb.Append(x)\n  end;\n  Result := sb.ToString\nend;"
  },
  {
    "instruction": "Bitwise OR operation for Addr32 objects",
    "output": "static function Addr32.operator or (a, b: Addr32): Addr32;\nbegin\n  Result := new Addr32;\n  Result.addr10 := a.addr10 or b.addr10;\n  SetAddress(Result)\nend;"
  },
  {
    "instruction": "Bitwise NOT operation for Addr32 object",
    "output": "static function Addr32.operator not (a: Addr32): Addr32;\nbegin\n  Result := new Addr32;\n  Result.addr10 := not a.addr10;\n  SetAddress(Result)\nend;"
  },
  {
    "instruction": "Addition operation for Addr32 object",
    "output": "static function Addr32.operator + (a: Addr32; b: longword): Addr32;\nbegin\n  Result := new Addr32;\n  Result.addr10 := a.addr10 + b;\n  SetAddress(Result)\nend;"
  },
  {
    "instruction": "Validate IP address format with octets",
    "output": "function Addr32.AddressValid(address: string): boolean := \n    (address = address.MatchValue('(\\d{1,3}\\.){3}\\d{1,3}')) and\n    address.Split('.').All(t -> t.ToInteger <= 255);"
  },
  {
    "instruction": "Validate 32-bit binary address format",
    "output": "function Addr32.AddressBinValid(address: string): boolean :=\n    address.MatchValue('[0|1]*').Length = 32;"
  },
  {
    "instruction": "Convert IP address/mask from decimal with octets to 32-bit binary",
    "output": "function Addr32.AddressToBin(address: string): string :=\n    address.Split('.')\n    .Select(t -> Convert.ToString(Convert.ToByte(t), 2).PadLeft(8, '0'))\n    .JoinToString('');"
  },
  {
    "instruction": "Convert 32-bit binary string to decimal value",
    "output": "function Addr32.BinToDec(bits: string): longword := Convert.ToUInt32(bits, 2);"
  },
  {
    "instruction": "Convert binary address representation to decimal with octets",
    "output": "static function Addr32.BinToAddress(pic: string): string;\nbegin\n  var s := if '.' in pic then pic.Split('.') else pic.Batch(8).Select(t -> t.JoinToString(''));\n  Result := s.Select(t -> Convert.ToByte(t, 2)).JoinToString('.')\nend;"
  },
  {
    "instruction": "Format 32-bit binary address with octets",
    "output": "function Addr32.AddrFormat(addr: string): string;\nbegin\n  Result := addr.Substring(0, 8);\n  for var i := 1 to 3 do\n    Result += '.' + addr.Substring(8 * i, 8);\nend;"
  },
  {
    "instruction": "Set address for Addr32 object",
    "output": "procedure Addr32.SetAddress(value: string);\nbegin\n  if AddressValid(value) then\n  begin\n    addr := value;\n    addr2 := AddressToBin(value);\n    addr10 := BinToDec(addr2)\n  end\n  else\n  begin\n    Println('Incorrect address record:', value);\n    Halt\n  end\nend;"
  },
  {
    "instruction": "Set binary address for Addr32 object",
    "output": "procedure Addr32.SetAddressBin(value: string);\nbegin\n  if AddressBinValid(value) then\n  begin\n    addr := Addr32.BinToAddress(value);\n    addr2 := value;\n    addr10 := BinToDec(addr2)\n  end\n  else\n  begin\n    Println('Incorrect address record:', value);\n    Halt\n  end\nend;"
  },
  {
    "instruction": "Binary representation of decimal number for CalcIP",
    "output": "function CalcIP.Bin(n:int64): string := Convert.ToString(n, 2);"
  },
  {
    "instruction": "32-bit binary representation of decimal number for CalcIP",
    "output": "function CalcIP.Bin32(n:int64): string := Convert.ToString(n, 2).PadLeft(32, '0');"
  },
  {
    "instruction": "Convert binary string to decimal for CalcIP",
    "output": "function CalcIP.BinToDec(bits: string): integer := integer(Convert.ToInt64(bits, 2));"
  },
  {
    "instruction": "Format address with network and host separation",
    "output": "function CalcIP.AddrFine(addr: Addr32): string;\nbegin\n  Result := AddrFormat(addr.value2);\n  var d := bit_mask + bit_mask div 8 + 1;\n  if bit_mask > 0 then Result := Result[:d] + '  ' + Result[d:]\nend;"
  },
  {
    "instruction": "Validate IP address format for CalcIP",
    "output": "function CalcIP.AddressValid(addr: string): boolean :=\n    (addr = addr.MatchValue('(\\d{1,3}\\.){3}\\d{1,3}')) and\n    addr.Split('.').All(t -> t.ToInteger <= 255);"
  },
  {
    "instruction": "Convert IP address to binary for CalcIP",
    "output": "function CalcIP.AddressToBin(addr: string): string :=\n    addr.Split('.')\n    .Select(t -> Convert.ToString(Convert.ToByte(t), 2).PadLeft(8, '0'))\n    .JoinToString('');"
  },
  {
    "instruction": "Convert binary address to decimal with octets for CalcIP",
    "output": "function CalcIP.BinToAddress(pic: string): string;\nbegin\n  var s := if '.' in pic then pic.Split('.') else pic.Batch(8).Select(t -> t.JoinToString(''));\n  Result := s.Select(t -> Convert.ToByte(t, 2)).JoinToString('.')\nend;"
  },
  {
    "instruction": "Validate subnet mask",
    "output": "function CalcIP.MaskValid(mask: Addr32): boolean :=\n    mask.value2.MatchValue('1+0+').Length = 32;"
  },
  {
    "instruction": "Calculate IP network parameters",
    "output": "procedure CalcIP.Calc;\nbegin\n  bit_mask := Pos('0', mask32.value2) - 1;\n  n_hosts := integer(2 ** (32 - bit_mask)) - 2;\n  var addr := mask32.value.Split('.').Select(t -> (255 - Convert.ToByte(t)).ToString).JoinToString('.');\n  wildcard32 := new Addr32(addr);\n  network32 := ip32 and mask32;\n  broadcast32 := network32 or wildcard32;\n  hostmin32 := network32 + 1;\n  hostmax32 := network32 + n_hosts\nend;"
  },
  {
    "instruction": "Format address with bitmask separation",
    "output": "function CalcIP.AddressFormat(pic: string): string := pic[:bit_mask + 1] + '  ' + pic[bit_mask + 1:];"
  },
  {
    "instruction": "Get string representation of Addr32 object",
    "output": "function Addr32.ToString: string := $'{addr + '','', -15}{AddrFormat(addr2)}';"
  },
  {
    "instruction": "Get string representation of CalcIP object",
    "output": "function CalcIP.ToString: string;\nbegin\n  var s := \n       $'IP address (Address)                  | {ip32.value, -15} | {AddrFine(ip32)}{NewLine}';\n  s += $'Subnet mask prefix (Bitmask)          | /{bit_mask}{NewLine}';\n  s += $'Subnet mask (Netmask)                 | {mask32.value, -15} | {AddrFine(mask32)}{NewLine}';\n  s += $'Host mask (Wildcard)                  | {Wildcard32.value, -15} | {AddrFine(wildcard32)}{NewLine}';\n  s += $'Network IP address (Network)          | {network32.value, -15} | {AddrFine(network32)}{NewLine}';\n  s += $'Broadcast address (Broadcast)         | {broadcast32.value, -15} | {AddrFine(broadcast32)}{NewLine}';\n  s += $'Available host addresses (Hosts)      | {n_hosts}{NewLine}';\n  s += $'First host address (Hostmin)          | {hostmin32.value, -15} | {AddrFine(hostmin32)}{NewLine}';\n  s += $'Last host address (Hostmax)           | {hostmax32.value, -15} | {AddrFine(hostmax32)}{NewLine}';\n  Result := s\nend;"
  },
  {
    "instruction": "Initialize prime numbers list using Sieve of Eratosthenes",
    "output": "procedure PrimesInternal;\nbegin\n  LPrimes := new List<integer>;\n  var Sieve := new boolean[ubPrimeDivs + 1];\n  for var i := 2 to ubPrimeDivs do\n    if not Sieve[i] then\n    begin\n      LPrimes.Add(i);\n      var k := i;\n      while k <= ubPrimeDivs - i do\n      begin\n        k += i;\n        Sieve[k] := True\n      end\n    end\nend;"
  },
  {
    "instruction": "Print truth table with filtering options",
    "output": "procedure TrueTablePrint(a: array[,] of boolean; f: integer; s: string);\nbegin\n  var n := a.ColCount;\n  s := s?[:n];\n  s := s.PadRight(n - 1, ' ');\n  Write(' ');\n  for var i := 1 to s.Length do\n    Print(s[i]);\n  Writeln('F');\n  Writeln(' ' + (2 * n - 1) * '-');\n  for var i := 0 to a.RowCount - 1 do\n    if not (((f = 0) and a[i, n - 1]) or ((f = 1) and not a[i, n - 1])) then\n    begin\n      for var j := 0 to n - 1 do\n        Write(if a[i, j] then ' 1' else ' 0');\n      Writeln\n    end\nend;"
  },
  {
    "instruction": "Logical implication extension method",
    "output": "function Imp(Self, b: boolean): boolean; extensionmethod := not Self or b;"
  },
  {
    "instruction": "GCD extension method for integer tuple",
    "output": "function \u041d\u041e\u0414(Self: (integer, integer)): integer; extensionmethod;\nbegin\n  var (a, b) := Self;\n  while b <> 0 do\n    (a, b) := (b, a mod b);\n  Result := Abs(a)\nend;"
  },
  {
    "instruction": "Set internal address for Addr32 object",
    "output": "static procedure Addr32.SetAddress(a: Addr32);\nbegin\n  a.addr2 := Bin32(a.addr10);\n  a.addr := BinToAddress(a.addr2)\nend;"
  },
  {
    "instruction": "Generate truth table for boolean function with 4 variables",
    "output": "function TrueTable(f: function(a, b, c, d: boolean): boolean):\n    array[,] of boolean;\nbegin\n  Result := new boolean[16, 5];\n  var i := 0;\n  for var a := False to True do\n    for var b := False to True do\n      for var c := False to True do\n        for var d := False to True do\n        begin\n          Result[i, 0] := a;\n          Result[i, 1] := b;\n          Result[i, 2] := c;\n          Result[i, 3] := d;\n          Result[i, 4] := f(a, b, c, d);\n          i += 1\n        end;\nend;"
  },
  {
    "instruction": "Generate truth table for boolean function with 5 variables",
    "output": "function TrueTable(f: function(a, b, c, d, e: boolean): boolean):\n    array[,] of boolean;\nbegin\n  Result := new boolean[32, 6];\n  var i := 0;\n  for var a := False to True do\n    for var b := False to True do\n      for var c := False to True do\n        for var d := False to True do\n          for var e := False to True do\n          begin\n            Result[i, 0] := a;\n            Result[i, 1] := b;\n            Result[i, 2] := c;\n            Result[i, 3] := d;\n            Result[i, 4] := e;\n            Result[i, 5] := f(a, b, c, d, e);\n            i += 1\n          end;\nend;"
  },
  {
    "instruction": "GCD extension method for int64 tuple",
    "output": "function \u041d\u041e\u0414(Self: (int64, int64)): integer; extensionmethod;\nbegin\n  var (a, b) := Self;\n  while b <> 0 do\n    (a, b) := (b, a mod b);\n  Result := Abs(a)\nend;"
  },
  {
    "instruction": "BinFormat for int64 with default parameters",
    "output": "function BinFormat(number: int64; bytes: integer; split: string): string :=\n    BinFormat(BigInteger(number), bytes, split);"
  },
  {
    "instruction": "32-bit binary representation static method for Addr32",
    "output": "static function Addr32.Bin32(n:integer): string := (Convert.ToString(n, 2)).PadLeft(32, '0');"
  },
  {
    "instruction": "Format address with octets for CalcIP",
    "output": "function CalcIP.AddrFormat(addr: string): string;\nbegin\n  Result := addr.Substring(0, 8);\n  for var i := 1 to 3 do\n    Result += '.' + addr.Substring(8 * i, 8);\nend;"
  },
  {
    "instruction": "Find minimum and maximum of integer sequence",
    "output": "function MinMax(seq: sequence of integer): (integer, integer);\nbegin\n  var min := integer.MaxValue;\n  var max := integer.MinValue;\n  foreach var elem in seq do\n  begin\n    if elem < min then\n      min := elem;\n    if elem > max then\n      max := elem\n  end;\n  Result := (min, max)\nend;"
  },
  {
    "instruction": "Write a function to find the number of times a given number appears in its binary representation.",
    "output": "function BinaryCount(n: integer): integer;\nbegin\n  var value := n;\n  var count := 0;\n  while value > 0 do\n  begin\n    count += value and 1;\n    value := value shr 1;\n  end;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function that takes a string of parentheses, brackets, and braces and returns whether the order of the parentheses is valid. Valid means that each opening symbol has a corresponding closing symbol and the pairs of parentheses are properly nested.",
    "output": "uses System.Collections.Generic;\n\nfunction ParenthesesValidator(const s: string): boolean;\nbegin\n  var stack := new Stack<char>;\n  var pairs := new Dictionary<char, char>;\n  pairs.Add(')', '(');\n  pairs.Add(']', '[');\n  pairs.Add('}', '{');\n  foreach var ch in s do\n    if pairs.ContainsKey(ch) then\n    begin\n      if stack.Count = 0 then\n        exit(False);\n      var top := stack.Pop;\n      if top <> pairs[ch] then\n        exit(False);\n    end\n    else\n      stack.Push(ch);\n  Result := stack.Count = 0;\nend;"
  },
  {
    "instruction": "Write a function to find the number of sublists in a given list that are palindromes.\n\nA palindrome is a sequence that reads the same backward as forward.",
    "output": "function PalindromeSublists(const lst: array of integer): integer;\nbegin\n  Result := 0;\n  if lst.Length = 0 then\n    exit(0);\n  for var i := 0 to High(lst) do\n    for var j := i to High(lst) do\n    begin\n      var left := i;\n      var right := j;\n      var isPalindrome := True;\n      while left < right do\n      begin\n        if lst[left] <> lst[right] then\n        begin\n          isPalindrome := False;\n          break;\n        end;\n        left += 1;\n        right -= 1;\n      end;\n      if isPalindrome then\n        Result += 1;\n    end;\nend;"
  },
  {
    "instruction": "Write a function to find the number of times a specific sublist appears in a given list.",
    "output": "function FindSublistCount(const lst, sublst: array of integer): integer;\nbegin\n  if (sublst = nil) or (sublst.Length = 0) or (lst.Length < sublst.Length) then\n    exit(0);\n  var count := 0;\n  for var i := 0 to lst.Length - sublst.Length do\n  begin\n    var matches := True;\n    for var j := 0 to sublst.Length - 1 do\n      if lst[i + j] <> sublst[j] then\n      begin\n        matches := False;\n        break;\n      end;\n    if matches then\n      count += 1;\n  end;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function that takes a string and returns the minimum number of characters that need to be inserted to make the string a palindrome.\n\nA palindrome is a string that reads the same forwards and backwards. The function should find the minimum number of insertions necessary to transform the given string into a palindrome.",
    "output": "function MinInsertionsToPalindrome(const s: string): integer;\nbegin\n  var n := s.Length;\n  if n = 0 then\n    exit(0);\n  var chars := s.ToCharArray;\n  var dp := new integer[n, n];\n  for var i := n - 1 downto 0 do\n  begin\n    dp[i, i] := 1;\n    for var j := i + 1 to n - 1 do\n      if chars[i] = chars[j] then\n        if j = i + 1 then\n          dp[i, j] := 2\n        else\n          dp[i, j] := dp[i + 1, j - 1] + 2\n      else\n        dp[i, j] := Max(dp[i + 1, j], dp[i, j - 1]);\n  end;\n  Result := n - dp[0, n - 1];\nend;"
  },
  {
    "instruction": "Write a function to find the kth smallest prime fraction in a given array. The array is sorted in ascending order.",
    "output": "uses System.Collections.Generic;\n\ntype\n  TFraction = record\n    NumIndex, DenIndex: integer;\n    Value: real;\n  end;\n\nfunction KthSmallestPrimeFraction(const arr: array of integer; k: integer): (integer, integer);\nbegin\n  var fractions := new List<TFraction>;\n  for var j := 1 to arr.Length - 1 do\n    for var i := 0 to j - 1 do\n    begin\n      var item: TFraction;\n      item.NumIndex := i;\n      item.DenIndex := j;\n      item.Value := arr[i] / arr[j];\n      fractions.Add(item);\n    end;\n  fractions.Sort((a, b) -> a.Value.CompareTo(b.Value));\n  var frac := fractions[k - 1];\n  Result := (arr[frac.NumIndex], arr[frac.DenIndex]);\nend;"
  },
  {
    "instruction": "Write a function to calculate the total price of a product after applying a discount. The function should take the original price of the product and the discount percentage as arguments. The discount can be either a fixed percentage (e.g., 10%) or a percentage range (e.g., 10% - 20%). If the discount is a range, the function should return the minimum and maximum possible prices after applying the discount.",
    "output": "function CalcDiscount(price, discountPercent: real): real;\nbegin\n  Result := price * (1 - discountPercent / 100);\nend;\n\nfunction CalcDiscount(price: real; discountRange: (real, real)): (real, real);\nbegin\n  var minDiscount := discountRange.Item1;\n  var maxDiscount := discountRange.Item2;\n  var minPrice := price * (1 - maxDiscount / 100);\n  var maxPrice := price * (1 - minDiscount / 100);\n  Result := (minPrice, maxPrice);\nend;"
  },
  {
    "instruction": "Write a function that takes two lists as parameters and returns a new list where each element is the product of the elements at the same index in the original lists. If the lists have different lengths, the function should only multiply up to the length of the shorter list.",
    "output": "function ProductOfLists(const list1, list2: array of integer): array of integer;\nbegin\n  var minLen := Min(list1.Length, list2.Length);\n  Result := new integer[minLen];\n  for var i := 0 to minLen - 1 do\n    Result[i] := list1[i] * list2[i];\nend;"
  },
  {
    "instruction": "Write a function to determine if a given string is a rotation of an anagram of another string. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. A rotation is the operation of moving the last character of the string to the front.\n\nExample 1:\nInput: s = \"listen\", t = \"silent\"\nOutput: true\nExplanation: \"listen\" is an anagram of \"silent\". A rotation of \"silent\" would also be an anagram of \"listen\".\n\nExample 2:\nInput: s = \"hello\", t = \"lohel\"\nOutput: true\nExplanation: \"lohel\" is a rotation of \"hello\".\n\nExample 3:\nInput: s = \"code\", t = \"decode\"\nOutput: false\nExplanation: \"decode\" is not a rotation or an anagram of \"code\".\n\nNote:\nYou may assume the strings contain only lowercase alphabets.\n\nFollow up:\nWhat if the inputs contain unicode characters? How would you adapt your solution to such a case?",
    "output": "uses System.Collections.Generic;\n\nfunction IsRotationAnagram(const s, t: string): boolean;\nbegin\n  if s.Length <> t.Length then\n    exit(False);\n  var counts := new Dictionary<char, integer>;\n  foreach var ch in s do\n    if counts.ContainsKey(ch) then\n      counts[ch] += 1\n    else\n      counts[ch] := 1;\n  foreach var ch in t do\n    if counts.ContainsKey(ch) then\n    begin\n      counts[ch] -= 1;\n      if counts[ch] = 0 then\n        counts.Remove(ch);\n    end\n    else\n      exit(False);\n  if counts.Count <> 0 then\n    exit(False);\n  var doubled := t + t;\n  Result := doubled.Contains(s);\nend;"
  },
  {
    "instruction": "Write a function that takes a list of numbers and returns a new list with the numbers squared.",
    "output": "function SquaredList(const numbers: array of integer): array of integer;\nbegin\n  Result := new integer[numbers.Length];\n  for var i := 0 to numbers.Length - 1 do\n    Result[i] := numbers[i] * numbers[i];\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest consecutive sequence of a specific character in a given string.",
    "output": "function LongestConsecutiveChar(const s: string): integer;\nbegin\n  if s = '' then\n    exit(0);\n  var chars := s.ToCharArray;\n  var maxLen := 1;\n  var current := 1;\n  for var i := 1 to chars.Length - 1 do\n    if chars[i] = chars[i - 1] then\n    begin\n      current += 1;\n      if current > maxLen then\n        maxLen := current;\n    end\n    else\n      current := 1;\n  Result := maxLen;\nend;"
  },
  {
    "instruction": "Write a function to find the closest pair of points in a list of 2D points. The function should return the Euclidean distance between the closest pair of points.",
    "output": "type\n  Point2D = record\n    X, Y: real;\n  end;\n\nfunction ClosestPairDistance(const points: array of Point2D): real;\nbegin\n  if points.Length < 2 then\n    exit(0);\n  var minDist := double.MaxValue;\n  for var i := 0 to points.Length - 2 do\n    for var j := i + 1 to points.Length - 1 do\n    begin\n      var dx := points[i].X - points[j].X;\n      var dy := points[i].Y - points[j].Y;\n      var dist := Sqrt(dx * dx + dy * dy);\n      if dist < minDist then\n        minDist := dist;\n    end;\n  Result := minDist;\nend;"
  },
  {
    "instruction": "Write a function to convert a given string to uppercase and append a period at the end.",
    "output": "function UppercaseAndPeriod(const sentence: string): string;\nbegin\n  if sentence = '' then\n    exit('.');\n  Result := sentence.ToUpper + '.';\nend;"
  },
  {
    "instruction": "Write a function to find the symmetric difference between two given lists. The symmetric difference of two sets is the set of elements which are in either of the sets but not in their intersection.",
    "output": "uses System.Collections.Generic;\n\nfunction FindSymmetricDifference(const nums1, nums2: array of integer): array of integer;\nbegin\n  var set1 := new HashSet<integer>(nums1);\n  var set2 := new HashSet<integer>(nums2);\n  var resultList := new List<integer>;\n  foreach var value in set1 do\n    if not set2.Contains(value) then\n      resultList.Add(value);\n  foreach var value in set2 do\n    if not set1.Contains(value) then\n      resultList.Add(value);\n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum sum of two non-overlapping subarrays of a given array such that the first subarray has a length of m and the second subarray has a length of n.",
    "output": "function MaxSumTwoNonOverlapping(const nums: array of integer; m, n: integer): integer;\nbegin\n  if nums.Length < m + n then\n    exit(0);\n  var prefix := new integer[nums.Length + 1];\n  for var i := 0 to nums.Length - 1 do\n    prefix[i + 1] := prefix[i] + nums[i];\n\n  var best := 0;\n  var maxLeft := 0;\n  for var i := m to nums.Length - n do\n  begin\n    var leftSum := prefix[i] - prefix[i - m];\n    if leftSum > maxLeft then\n      maxLeft := leftSum;\n    var rightSum := prefix[i + n] - prefix[i];\n    if maxLeft + rightSum > best then\n      best := maxLeft + rightSum;\n  end;\n\n  maxLeft := 0;\n  for var i := n to nums.Length - m do\n  begin\n    var leftSum := prefix[i] - prefix[i - n];\n    if leftSum > maxLeft then\n      maxLeft := leftSum;\n    var rightSum := prefix[i + m] - prefix[i];\n    if maxLeft + rightSum > best then\n      best := maxLeft + rightSum;\n  end;\n\n  Result := best;\nend;"
  },
  {
    "instruction": "Write a function to find the average of the values in a given dictionary.",
    "output": "uses System.Collections.Generic;\n\nfunction AverageDictValues(d: Dictionary<string, real>): real;\nbegin\n  if (d = nil) or (d.Count = 0) then\n    exit(0);\n  var total := 0.0;\n  foreach var value in d.Values do\n    total += value;\n  Result := total / d.Count;\nend;"
  },
  {
    "instruction": "Write a function that takes an array of strings and returns the strings that have the maximum length in the array.",
    "output": "uses System.Collections.Generic;\n\nfunction FindLongestStrings(const words: array of string): array of string;\nbegin\n  if words.Length = 0 then\n    exit(new string[0]);\n  var maxLen := 0;\n  foreach var word in words do\n    if word.Length > maxLen then\n      maxLen := word.Length;\n  var resultList := new List<string>;\n  foreach var word in words do\n    if word.Length = maxLen then\n      resultList.Add(word);\n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function that sorts a list of dictionaries based on multiple keys in ascending order. The function should take a list of dictionaries and a list of keys as parameters. If a key does not exist in a dictionary, it should be treated as nil.\n\nFor example, given the list of dictionaries:\n```\n[\n    {'name': 'Alice', 'age': 25, 'city': 'New York'},\n    {'name': 'Bob', 'age': 30, 'city': 'Los Angeles'},\n    {'name': 'Charlie', 'age': 20, 'city': 'Chicago', 'job': 'Engineer'},\n    {'name': 'Diana', 'age': 35, 'city': 'San Francisco'}\n]\n```\nAnd the list of keys: `['age', 'city']`, the function should return:\n```\n[\n    {'name': 'Charlie', 'age': 20, 'city': 'Chicago', 'job': 'Engineer'},\n    {'name': 'Alice', 'age': 25, 'city': 'New York'},\n    {'name': 'Bob', 'age': 30, 'city': 'Los Angeles'},\n    {'name': 'Diana', 'age': 35, 'city': 'San Francisco'}\n]\n```",
    "output": "uses System, System.Collections.Generic;\n\nfunction MultiKeySort(data: List<Dictionary<string, string>>; const keys: array of string): List<Dictionary<string, string>>;\nbegin\n  data.Sort((a, b) ->\n  begin\n    foreach var key in keys do\n    begin\n      var av := '';\n      var bv := '';\n      if a.ContainsKey(key) then av := a[key];\n      if b.ContainsKey(key) then bv := b[key];\n      var avInt, bvInt: integer;\n      var cmp := 0;\n      if TryStrToInt(av, avInt) and TryStrToInt(bv, bvInt) then\n        cmp := avInt.CompareTo(bvInt)\n      else\n        cmp := string.Compare(av, bv);\n      if cmp <> 0 then\n      begin\n        Result := cmp;\n        exit;\n      end;\n    end;\n    Result := 0;\n  end);\n  Result := data;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the smallest substring in a given string that contains all the characters of another string.",
    "output": "uses System.Collections.Generic;\n\nfunction SmallestSubstringLength(const s, t: string): integer;\nbegin\n  if (s = '') or (t = '') then\n    exit(-1);\n  var target := new Dictionary<char, integer>;\n  foreach var ch in t do\n    if target.ContainsKey(ch) then\n      target[ch] += 1\n    else\n      target[ch] := 1;\n  var formed := 0;\n  var required := target.Count;\n  var window := new Dictionary<char, integer>;\n  var chars := s.ToCharArray;\n  var left := 0;\n  var best := integer.MaxValue;\n  for var right := 0 to chars.Length - 1 do\n  begin\n    var ch := chars[right];\n    if window.ContainsKey(ch) then\n      window[ch] += 1\n    else\n      window[ch] := 1;\n    if target.ContainsKey(ch) and (window[ch] = target[ch]) then\n      formed += 1;\n    while (left <= right) and (formed = required) do\n    begin\n      if right - left + 1 < best then\n        best := right - left + 1;\n      var leftChar := chars[left];\n      window[leftChar] -= 1;\n      if target.ContainsKey(leftChar) and (window[leftChar] < target[leftChar]) then\n        formed -= 1;\n      left += 1;\n    end;\n  end;\n  if best = integer.MaxValue then\n    Result := -1\n  else\n    Result := best;\nend;"
  },
  {
    "instruction": "Write a function to convert a binary string to a decimal number.",
    "output": "uses System;\n\nfunction BinToDec(const value: string): integer;\nbegin\n  Result := Convert.ToInt32(value, 2);\nend;"
  },
  {
    "instruction": "Write a function to find the number of unique values in a given list.",
    "output": "uses System.Collections.Generic;\n\nfunction UniqueValues(const lst: array of integer): integer;\nbegin\n  var setValues := new HashSet<integer>(lst);\n  Result := setValues.Count;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings and returns a list of unique strings, preserving the order of their first occurrence.",
    "output": "uses System.Collections.Generic;\n\nfunction UniqueStringsPreservingOrder(const strings: array of string): array of string;\nbegin\n  var seen := new HashSet<string>;\n  var resultList := new List<string>;\n  foreach var s in strings do\n    if seen.Add(s) then\n      resultList.Add(s);\n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to determine the minimum number of parentheses that must be added to a string of parentheses to make it valid. A string of parentheses is valid if every opening parenthesis \"(\" has a corresponding closing parenthesis \")\" and vice versa.",
    "output": "function MinAddToMakeValid(const s: string): integer;\nbegin\n  var balance := 0;\n  var additions := 0;\n  foreach var ch in s do\n    if ch = '(' then\n      balance += 1\n    else\n    begin\n      if balance = 0 then\n        additions += 1\n      else\n        balance -= 1;\n    end;\n  Result := additions + balance;\nend;"
  },
  {
    "instruction": "Write a function to find the number of islands in a given grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.",
    "output": "procedure DFS(var grid: array[,] of integer; r, c: integer);\nbegin\n  if (r < 0) or (c < 0) or (r >= grid.GetLength(0)) or (c >= grid.GetLength(1)) then\n    exit;\n  if grid[r, c] <> 1 then\n    exit;\n  grid[r, c] := -1;\n  DFS(grid, r + 1, c);\n  DFS(grid, r - 1, c);\n  DFS(grid, r, c + 1);\n  DFS(grid, r, c - 1);\nend;\n\nfunction FindIslands(var grid: array[,] of integer): integer;\nbegin\n  var rows := grid.GetLength(0);\n  var cols := grid.GetLength(1);\n  var count := 0;\n  for var r := 0 to rows - 1 do\n    for var c := 0 to cols - 1 do\n      if grid[r, c] = 1 then\n      begin\n        count += 1;\n        DFS(grid, r, c);\n      end;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function that will take a list of strings and return a dictionary where the keys are the strings from the list and the values are the lengths of those strings.",
    "output": "uses System.Collections.Generic;\n\nfunction LengthDict(const strings: array of string): Dictionary<string, integer>;\nbegin\n  var resultDict := new Dictionary<string, integer>;\n  foreach var s in strings do\n    resultDict[s] := s.Length;\n  Result := resultDict;\nend;"
  },
  {
    "instruction": "Write a function to determine if two strings are one edit away from being identical. An edit can be defined as inserting a character, deleting a character, or replacing a character.",
    "output": "function OneInsertAway(const longer, shorter: string): boolean;\nbegin\n  var i := 0;\n  var j := 0;\n  var edits := 0;\n  var a := longer.ToCharArray;\n  var b := shorter.ToCharArray;\n  while (i < a.Length) and (j < b.Length) do\n    if a[i] = b[j] then\n    begin\n      i += 1;\n      j += 1;\n    end\n    else\n    begin\n      edits += 1;\n      if edits > 1 then\n        exit(False);\n      i += 1;\n    end;\n  Result := True;\nend;\n\nfunction IsOneEditAway(const s1, s2: string): boolean;\nbegin\n  var diff := Abs(s1.Length - s2.Length);\n  if diff > 1 then\n    exit(False);\n  if diff = 0 then\n  begin\n    var edits := 0;\n    for var i := 1 to s1.Length do\n      if s1[i] <> s2[i] then\n      begin\n        edits += 1;\n        if edits > 1 then\n          exit(False);\n      end;\n    Result := edits = 1;\n  end\n  else if s1.Length > s2.Length then\n    Result := OneInsertAway(s1, s2)\n  else\n    Result := OneInsertAway(s2, s1);\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns a list of their square roots rounded to the nearest integer.",
    "output": "function RoundSquareRoots(const numbers: array of integer): array of integer;\nbegin\n  Result := new integer[numbers.Length];\n  for var i := 0 to numbers.Length - 1 do\n    Result[i] := Round(Sqrt(numbers[i]));\nend;"
  },
  {
    "instruction": "Write a function to find the number of times a given number can be divided by a prime number.",
    "output": "function CountDivisionsByPrime(number, prime: integer): integer;\nbegin\n  var value := number;\n  Result := 0;\n  while (prime <> 0) and (value > 0) and (value mod prime = 0) do\n  begin\n    Result += 1;\n    value := value div prime;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the binary representation of a given number without using built-in bin function.",
    "output": "uses System.Text;\n\nfunction BinRepresentation(num: integer): string;\nbegin\n  if num = 0 then\n    exit('0');\n  var builder := new StringBuilder;\n  var value := num;\n  while value > 0 do\n  begin\n    builder.Insert(0, char(ord('0') + (value mod 2)));\n    value := value div 2;\n  end;\n  Result := builder.ToString;\nend;"
  },
  {
    "instruction": "Write a function to check whether a string is a pangram or not. A pangram is a sentence that contains every letter of the alphabet at least once.",
    "output": "uses System.Collections.Generic;\n\nfunction PangramChecker(const sentence: string): boolean;\nbegin\n  var letters := new HashSet<char>;\n  foreach var ch in sentence.ToLower do\n    if (ch >= 'a') and (ch <= 'z') then\n      letters.Add(ch);\n  Result := letters.Count = 26;\nend;"
  },
  {
    "instruction": "Write a function to find out the minimum time needed for all messages to be received by all nodes. The messages start from a specific node and every node is connected to other nodes through a network. The function should take the network's edges, the total number of nodes, and the starting node as arguments. The edges are given as a list of tuples where each tuple contains the source node, destination node, and the time taken for the message to travel from the source to the destination.",
    "output": "uses System.Collections.Generic;\n\nfunction NetworkDelayTime(const edges: array of (integer, integer, integer); n, k: integer): integer;\nbegin\n  var graph := new Dictionary<integer, List<(integer, integer)>>;\n  foreach var edge in edges do\n  begin\n    if not graph.ContainsKey(edge.Item1) then\n      graph[edge.Item1] := new List<(integer, integer)>;\n    graph[edge.Item1].Add((edge.Item2, edge.Item3));\n  end;\n  var dist := new Dictionary<integer, integer>;\n  for var node := 1 to n do\n    dist[node] := integer.MaxValue;\n  dist[k] := 0;\n  var visited := new HashSet<integer>;\n  while visited.Count < n do\n  begin\n    var nextNode := -1;\n    var best := integer.MaxValue;\n    foreach var kvp in dist do\n      if (not visited.Contains(kvp.Key)) and (kvp.Value < best) then\n      begin\n        best := kvp.Value;\n        nextNode := kvp.Key;\n      end;\n    if nextNode = -1 then\n      break;\n    visited.Add(nextNode);\n    if not graph.ContainsKey(nextNode) then\n      continue;\n    foreach var edge in graph[nextNode] do\n    begin\n      var newDist := dist[nextNode] + edge.Item2;\n      if newDist < dist[edge.Item1] then\n        dist[edge.Item1] := newDist;\n    end;\n  end;\n  if visited.Count <> n then\n    exit(-1);\n  var maxTime := 0;\n  foreach var value in dist.Values do\n    if value > maxTime then\n      maxTime := value;\n  Result := maxTime;\nend;"
  },
  {
    "instruction": "Write a function that returns a list of all the uppercase letters in a given string.",
    "output": "uses System.Collections.Generic;\n\nfunction FindUppercaseLetters(const s: string): array of char;\nbegin\n  var resultList := new List<char>;\n  foreach var ch in s do\n    if ch.IsUpper then\n      resultList.Add(ch);\n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to generate all possible combinations of a given list of lists, where each combination contains one element from each list.",
    "output": "uses System.Collections.Generic;\n\nprocedure Build(const lists: array of array of integer; index: integer; current: List<integer>; resultList : List<array of integer>);\nbegin\n  if index = lists.Length then\n  begin\n    resultList.Add(current.ToArray);\n    exit;\n  end;\n  foreach var value in lists[index] do\n  begin\n    current.Add(value);\n    Build(lists, index + 1, current, resultList);\n    current.RemoveAt(current.Count - 1);\n  end;\nend;\n\nfunction GenerateCombinations(const lists: array of array of integer): array of array of integer;\nbegin\n  \n  var resultList := new List<array of integer>;\n  \n  if lists.Length = 0 then\n    exit(Arr&<array of integer>());\n  var current := new List<integer>;\n  Build(lists, 0, current, resultList);\n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest element in a list that is larger than a given value. If no such element exists, return -1.",
    "output": "uses System;\n\nfunction FindSmallestLarger(const arr: array of integer; val: integer): integer;\nbegin\n  var copy := arr.Clone as array of integer;\n  &Array.Sort(copy);\n  foreach var item in copy do\n    if item > val then\n      exit(item);\n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to reach the top of a staircase given that you can either take 1 step, 2 steps, or 3 steps at a time.",
    "output": "function Staircases(n: integer): integer;\nbegin\n  if (n = 0) or (n = 1) then\n    exit(1);\n  if n = 2 then\n    exit(2);\n  var dp := new integer[n + 1];\n  dp[0] := 1;\n  dp[1] := 1;\n  dp[2] := 2;\n  for var i := 3 to n do\n    dp[i] := dp[i - 1] + dp[i - 2] + dp[i - 3];\n  Result := dp[n];\nend;"
  },
  {
    "instruction": "Write a function that takes in a list of integers and returns the sum of the squares of the even numbers in the list.",
    "output": "function SumOfSquaresOfEven(const numbers: array of integer): integer;\nbegin\n  var total := 0;\n  foreach var num in numbers do\n    if num mod 2 = 0 then\n      total += num * num;\n  Result := total;\nend;"
  },
  {
    "instruction": "Write a function to find the first and last positions of a target value in a sorted array. If the target value is not found in the array, return [-1, -1].",
    "output": "function FindFirstPosition(const nums: array of integer; target: integer): integer;\nbegin\n  var left := 0;\n  var right := nums.Length - 1;\n  var ans := -1;\n  while left <= right do\n  begin\n    var mid := (left + right) div 2;\n    if nums[mid] >= target then\n    begin\n      if nums[mid] = target then\n        ans := mid;\n      right := mid - 1;\n    end\n    else\n      left := mid + 1;\n  end;\n  Result := ans;\nend;\n\nfunction FindLastPosition(const nums: array of integer; target: integer): integer;\nbegin\n  var left := 0;\n  var right := nums.Length - 1;\n  var ans := -1;\n  while left <= right do\n  begin\n    var mid := (left + right) div 2;\n    if nums[mid] <= target then\n    begin\n      if nums[mid] = target then\n        ans := mid;\n      left := mid + 1;\n    end\n    else\n      right := mid - 1;\n  end;\n  Result := ans;\nend;\n\nfunction FirstAndLastPositions(const nums: array of integer; target: integer): array of integer;\nbegin\n  var first := FindFirstPosition(nums, target);\n  var last := FindLastPosition(nums, target);\n  if (first = -1) or (last = -1) then\n    exit(|-1, -1|);\n  Result := |first, last|;\nend;"
  },
  {
    "instruction": "Write a function to perform matrix multiplication of two matrices. The function should return the resulting matrix.",
    "output": "function MatrixMult(const a, b: array [,] of integer): array [,] of integer;\nbegin\n  var rows := a.GetLength(0);\n  var cols := b.GetLength(1);\n  var shared := b.GetLength(0);\n  \n  if a.GetLength(1) <> shared then\n    raise new System.ArgumentException('Matrix dimensions are not compatible for multiplication');\n    \n  Result := new integer[rows, cols];\n  \n  for var i := 0 to rows - 1 do\n    for var j := 0 to cols - 1 do\n    begin\n      var sum := 0;\n      for var k := 0 to shared - 1 do\n        sum += a[i, k] * b[k, j];\n      Result[i, j] := sum;\n    end;\nend;"
  },
  {
    "instruction": "Write a function to return the maximum number of consecutive occurrences of a given value in a list.",
    "output": "function MaxConsecutiveOccurrences(const lst: array of integer; value: integer): integer;\nbegin\n  var best := 0;\n  var current := 0;\n  foreach var item in lst do\n    if item = value then\n    begin\n      current += 1;\n      if current > best then\n        best := current;\n    end\n    else\n      current := 0;\n  Result := best;\nend;"
  },
  {
    "instruction": "Write a function to sort a list of elements using cocktail sort.",
    "output": "function CocktailSort(var nums: array of integer): array of integer;\nbegin\n  var start := 0;\n  var last := nums.Length - 1;\n  var swapped := True;\n  while swapped do\n  begin\n    swapped := False;\n    for var i := start to last - 1 do\n      if nums[i] > nums[i + 1] then\n      begin\n        Swap(nums[i], nums[i + 1]);\n        swapped := True;\n      end;\n    if not swapped then\n      break;\n    swapped := False;\n    last -= 1;\n    for var i := last downto start + 1 do\n      if nums[i - 1] > nums[i] then\n      begin\n        Swap(nums[i - 1], nums[i]);\n        swapped := True;\n      end;\n    start += 1;\n  end;\n  Result := nums;\nend;"
  },
  {
    "instruction": "Write a function to find the next largest prime number after a given number.",
    "output": "function IsPrime(n: integer): boolean;\nbegin\n  if n < 2 then\n    exit(False);\n  for var i := 2 to Round(Sqrt(n)) do\n    if n mod i = 0 then\n      exit(False);\n  Result := True;\nend;\n\nfunction NextPrime(n: integer): integer;\nbegin\n  var candidate := n + 1;\n  while not IsPrime(candidate) do\n    candidate += 1;\n  Result := candidate;\nend;"
  },
  {
    "instruction": "Create a function that takes a list of strings and returns a list where each string is replaced by its length.",
    "output": "function StringToLen(const lst: array of string): array of integer;\nbegin\n  Result := new integer[lst.Length];\n  for var i := 0 to lst.Length - 1 do\n    Result[i] := lst[i].Length;\nend;"
  },
  {
    "instruction": "Write a function to find the missing element in a sequence of unique integers from 1 to n.",
    "output": "function GetMissingElement(const arr: array of integer; n: integer): integer;\nbegin\n  var expected := n * (n + 1) div 2;\n  var actual := 0;\n  foreach var value in arr do\n    actual += value;\n  Result := expected - actual;\nend;"
  },
  {
    "instruction": "Write a function that takes a string and returns a dictionary with the count of each unique character in the string. Consider case sensitivity, meaning 'A' and 'a' should be counted as different characters.",
    "output": "uses System.Collections.Generic;\n\nfunction CharacterCounter(const inputString: string): Dictionary<char, integer>;\nbegin\n  var resultDict := new Dictionary<char, integer>;\n  foreach var ch in inputString do\n    if resultDict.ContainsKey(ch) then\n      resultDict[ch] += 1\n    else\n      resultDict[ch] := 1;\n  Result := resultDict;\nend;"
  },
  {
    "instruction": "Write a function to find the first repeated character in a given string.",
    "output": "function RepeatedCharacter(const s: string): char;\nbegin\n  var counts := new Dictionary<char, integer>;\n  foreach var ch in s do\n  begin\n    if counts.ContainsKey(ch) then\n      counts[ch] += 1\n    else\n      counts[ch] := 1;\n    if counts[ch] = 2 then\n      exit(ch);\n  end;\n  Result := #0;\nend;"
  },
  {
    "instruction": "Write a function to find the number of divisors of a positive integer.",
    "output": "function CountDivisors(n: integer): integer;\nbegin\n  var count := 0;\n  for var i := 1 to n do\n    if n mod i = 0 then\n      count += 1;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of points that can be made by connecting segments between points on a 2D plane. The function will take a list of points and a list of segments as inputs. A segment is defined by two distinct points and can be traversed in both directions. The function should return the maximum number of points that can be connected by the segments.",
    "output": "uses System.Collections.Generic;\n\nfunction DFS(node: integer; var visited: HashSet<integer>; var graph: Dictionary<integer, List<integer>>): integer;\nbegin\n  visited.Add(node);\n  var size := 1;\n  foreach var neighbor in graph[node] do\n    if not visited.Contains(neighbor) then\n      size += DFS(neighbor, visited, graph);\n  Result := size;\nend;\n\nfunction MaxPointsConnection(pointCount: integer; const segments: array of (integer, integer)): integer;\nbegin\n  var graph := new Dictionary<integer, List<integer>>;\n  for var i := 0 to pointCount - 1 do\n    graph[i] := new List<integer>;\n  foreach var seg in segments do\n  begin\n    graph[seg.Item1].Add(seg.Item2);\n    graph[seg.Item2].Add(seg.Item1);\n  end;\n  var visited := new HashSet<integer>;\n  var best := 0;\n  \n  for var node := 0 to pointCount - 1 do\n    if not visited.Contains(node) then\n    begin\n      var size := DFS(node, visited, graph);\n      if size > best then\n        best := size;\n    end;\n  Result := best;\nend;"
  },
  {
    "instruction": "Write a function to find the k most frequent elements in an array of integers. If there are multiple elements with the same frequency, return them in the order they appear in the array.",
    "output": "uses System.Collections.Generic;\n\nfunction TopFrequent(const nums: array of integer; k: integer): array of integer;\nbegin\n  var counts := new Dictionary<integer, integer>;\n  var firstIndex := new Dictionary<integer, integer>;\n  for var i := 0 to nums.Length - 1 do\n  begin\n    var value := nums[i];\n    if counts.ContainsKey(value) then\n      counts[value] += 1\n    else\n    begin\n      counts[value] := 1;\n      firstIndex[value] := i;\n    end;\n  end;\n  var ordered := new List<integer>(counts.Keys);\n  ordered.Sort((a, b) ->\n  begin\n    var cmp := counts[b].CompareTo(counts[a]);\n    if cmp <> 0 then \n      Result := cmp\n    else\n      Result := firstIndex[a].CompareTo(firstIndex[b]);\n  end);\n  var resultList := new List<integer>;\n  for var i := 0 to Min(k, ordered.Count) - 1 do\n    resultList.Add(ordered[i]);\n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to generate all possible ways to divide a list into two non-empty parts. The function should return a list of tuples, where each tuple contains two lists representing a possible division.",
    "output": "function SplitList(const xs: array of integer): array of array of integer;\nbegin\n  var resultList := new List<array of integer>;\n  for var i := 1 to xs.Length - 1 do\n  begin\n    var left := new integer[i];\n    var right := new integer[xs.Length - i];\n    &Array.Copy(xs, 0, left, 0, i);\n    &Array.Copy(xs, i, right, 0, xs.Length - i);\n    resultList.Add(left);\n    resultList.Add(right);\n  end;\n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the nth missing positive number in a sorted array of distinct positive integers.",
    "output": "function NthMissingPositive(const arr: array of integer; n: integer): integer;\nbegin\n  var missing := 0;\n  var current := 1;\n  var index := 0;\n  while missing < n do\n  begin\n    if (index < arr.Length) and (arr[index] = current) then\n      index += 1\n    else\n    begin\n      missing += 1;\n      if missing = n then\n        exit(current);\n    end;\n    current += 1;\n  end;\n  Result := current;\nend;"
  },
  {
    "instruction": "Write a function that checks if a given list of integers can represent the postorder traversal of a binary search tree (BST). A BST is a binary tree where for every node, all nodes in its left subtree have values less than the node's value, and all nodes in its right subtree have values greater than the node's value. The function should return True if the list can represent a BST's postorder traversal, otherwise, it should return False.",
    "output": "function IsPostorderBST(const postorder: array of integer): boolean;\n\n  function Helper(left, right: integer): boolean;\n  begin\n    if left >= right then\n      exit(True);\n    var pivot := postorder[right];\n    var mid := left;\n    while (mid < right) and (postorder[mid] < pivot) do\n      mid += 1;\n    for var i := mid to right - 1 do\n      if postorder[i] < pivot then\n        exit(False);\n    Result := Helper(left, mid - 1) and Helper(mid, right - 1);\n  end;\n\nbegin\n  if postorder.Length = 0 then\n    exit(True);\n  Result := Helper(0, postorder.Length - 1);\nend;"
  },
  {
    "instruction": "Write a function to find the largest rectangular area in a histogram.",
    "output": "uses System.Collections.Generic;\n\nfunction FindHistogramArea(const heights: array of integer): integer;\nbegin\n  var stack := new Stack<integer>;\n  var index := 0;\n  var maxArea := 0;\n  while index < heights.Length do\n    if (stack.Count = 0) or (heights[stack.Peek] <= heights[index]) then\n    begin\n      stack.Push(index);\n      index += 1;\n    end\n    else\n    begin\n      var top := stack.Pop;\n      var width := index;\n      if stack.Count > 0 then\n        width -= stack.Peek + 1;\n      var area := heights[top] * width;\n      if area > maxArea then\n        maxArea := area;\n    end;\n  while stack.Count > 0 do\n  begin\n    var top := stack.Pop;\n    var width := index;\n    if stack.Count > 0 then\n      width -= stack.Peek + 1;\n    var area := heights[top] * width;\n    if area > maxArea then\n      maxArea := area;\n  end;\n  Result := maxArea;\nend;"
  },
  {
    "instruction": "Write a function to find the number of times a specific value appears in a sorted array using binary search.",
    "output": "function BinarySearchFirst(const arr: array of integer; target: integer): integer;\nbegin\n  var left := 0;\n  var right := arr.Length - 1;\n  var ans := -1;\n  while left <= right do\n  begin\n    var mid := (left + right) div 2;\n    if arr[mid] >= target then\n    begin\n      if arr[mid] = target then\n        ans := mid;\n      right := mid - 1;\n    end\n    else\n      left := mid + 1;\n  end;\n  Result := ans;\nend;\n\nfunction BinarySearchLast(const arr: array of integer; target: integer): integer;\nbegin\n  var left := 0;\n  var right := arr.Length - 1;\n  var ans := -1;\n  while left <= right do\n  begin\n    var mid := (left + right) div 2;\n    if arr[mid] <= target then\n    begin\n      if arr[mid] = target then\n        ans := mid;\n      left := mid + 1;\n    end\n    else\n      right := mid - 1;\n  end;\n  Result := ans;\nend;\n\nfunction CountValueOccurrence(const arr: array of integer; target: integer): integer;\nbegin\n  var first := BinarySearchFirst(arr, target);\n  if first = -1 then\n    exit(0);\n  var last := BinarySearchLast(arr, target);\n  Result := last - first + 1;\nend;"
  },
  {
    "instruction": "Write a function that takes a string as input and returns the string in reverse order. However, reverse only the alphabetic characters in the string while keeping the other characters (like spaces, punctuation, and numbers) in their original positions.",
    "output": "function ReverseOnlyLetters(const value: string): string;\nbegin\n  var chars := value.ToCharArray;\n  var left := 0;\n  var right := chars.Length - 1;\n  while left < right do\n  begin\n    while (left < right) and not chars[left].IsLetter do\n      left += 1;\n    while (left < right) and not chars[right].IsLetter do\n      right -= 1;\n    if left < right then\n    begin\n      var temp := chars[left];\n      chars[left] := chars[right];\n      chars[right] := temp;\n      left += 1;\n      right -= 1;\n    end;\n  end;\n  Result := new string(chars);\nend;"
  },
  {
    "instruction": "Write a function to encrypt a given string using a simple substitution cipher where each character in the plaintext is 'rotated' forward by a fixed number of places in the alphabet.",
    "output": "function RotateCipher(const text: string; shift: integer): string;\nbegin\n  var builder := new System.Text.StringBuilder;\n  foreach var ch in text do\n    if ch.IsLetter then\n    begin\n      var offset := ord('a');\n      if ch.IsUpper then\n        offset := ord('A');\n      var rotated := char(offset + (ord(ch) - offset + shift) mod 26);\n      builder.Append(rotated);\n    end\n    else\n      builder.Append(ch);\n  Result := builder.ToString;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of all the multiples of 3 or 5 below a given number.",
    "output": "function FindMultiplesSum(limit: integer): integer;\nbegin\n  var total := 0;\n  for var i := 1 to limit - 1 do\n    if (i mod 3 = 0) or (i mod 5 = 0) then\n      total += i;\n  Result := total;\nend;"
  },
  {
    "instruction": "Write a function to check if it's possible to divide a list of integers into consecutive subsequences of length k. A consecutive subsequence is a sequence of integers where each element is one more than the previous element.",
    "output": "uses System.Collections.Generic;\n\nfunction IsPossibleDivide(const nums: array of integer; k: integer): boolean;\nbegin\n  if k = 0 then\n    exit(False);\n  if nums.Length mod k <> 0 then\n    exit(False);\n  var counts := new SortedDictionary<integer, integer>;\n  foreach var num in nums do\n    if counts.ContainsKey(num) then\n      counts[num] += 1\n    else\n      counts[num] := 1;\n  while counts.Count > 0 do\n  begin\n    var start := counts.Keys.First;\n    for var offset := 0 to k - 1 do\n    begin\n      var value := start + offset;\n      if (not counts.ContainsKey(value)) then\n        exit(False);\n      counts[value] -= 1;\n      if counts[value] = 0 then\n        counts.Remove(value);\n    end;\n  end;\n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function that checks if two given circles intersect each other. The circles are defined by their centers and radii.",
    "output": "function DoCirclesIntersect(const center1, center2: (real, real); radius1, radius2: real): boolean;\nbegin\n  var dx := center1.Item1 - center2.Item1;\n  var dy := center1.Item2 - center2.Item2;\n  var distance := Sqrt(dx * dx + dy * dy);\n  Result := distance < (radius1 + radius2);\nend;"
  },
  {
    "instruction": "Write a function to evaluate the score of a given word by summing the points of each letter. The letter point values are based on the following table: A=1, B=3, C=3, D=2, E=1, F=4, G=2, H=4, I=1, J=8, K=5, L=1, M=3, N=1, O=1, P=3, Q=10, R=1, S=1, T=1, U=1, V=4, W=4, X=8, Y=4, Z=10",
    "output": "uses System.Collections.Generic;\n\nfunction ScoreWord(const word: string): integer;\nconst\n  scores: array['A'..'Z'] of integer = (\n    1, 3, 3, 2, 1, 4, 2, 4, 1, 8, 5, 1, 3,\n    1, 1, 3, 10, 1, 1, 1, 1, 4, 4, 8, 4, 10);\nbegin\n  var total := 0;\n  foreach var ch in word.ToUpper do\n    if (ch >= 'A') and (ch <= 'Z') then\n      total += scores[ch];\n  Result := total;\nend;"
  },
  {
    "instruction": "Write a function to remove all occurrences of a specific value from a list in-place and return the new length of the list.",
    "output": "function RemoveValue(var nums: array of integer; value: integer): integer;\nbegin\n  var index := 0;\n  for var i := 0 to nums.Length - 1 do\n    if nums[i] <> value then\n    begin\n      nums[index] := nums[i];\n      index += 1;\n    end;\n  Result := index;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number in the given list using a heap data structure.",
    "output": "uses System.Collections.Generic;\n\nfunction HeapMax(const values: array of integer): integer;\nbegin\n  var heap := new SortedSet<integer>;\n  foreach var value in values do\n    heap.Add(value);\n  Result := heap.Max;\nend;"
  },
  {
    "instruction": "Write a function to generate the next number in the \"look-and-say\" sequence given the current number as a string.\n\nThe \"look-and-say\" sequence is defined as follows:\n- Begin with a single digit (as a string).\n- Read off the digits of the current number, count the number of digits in groups of the same digit, and then write down the count followed by the digit.\n- For example, starting with \"1\":\n  - \"1\" is read off as \"one 1\" or \"11\".\n  - \"11\" is read off as \"two 1s\" or \"21\".\n  - \"21\" is read off as \"one 2, then one 1\" or \"1211\".\n  - \"1211\" is read off as \"one 1, one 2, then two 1s\" or \"111221\".",
    "output": "uses System.Text;\n\nfunction NextLookAndSay(const current: string): string;\nbegin\n  if current = '' then\n    exit('');\n  var builder := new StringBuilder;\n  var chars := current.ToCharArray;\n  var i := 0;\n  while i < chars.Length do\n  begin\n    var j := i;\n    while (j < chars.Length) and (chars[j] = chars[i]) do\n      j += 1;\n    builder.Append((j - i).ToString);\n    builder.Append(chars[i]);\n    i := j;\n  end;\n  Result := builder.ToString;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of coins that make up a given amount. You can assume that you have an infinite number of coins of each denomination. If it is not possible to make up the amount with the given coin denominations, return -1.",
    "output": "function CoinsRequired(amount: integer; const coins: array of integer): integer;\nbegin\n  var dp := new integer[amount + 1];\n  for var i := 1 to amount do\n    dp[i] := integer.MaxValue div 2;\n  dp[0] := 0;\n  foreach var coin in coins do\n    for var value := coin to amount do\n      dp[value] := Min(dp[value], dp[value - coin] + 1);\n  if dp[amount] >= integer.MaxValue div 2 then\n    Result := -1\n  else\n    Result := dp[amount];\nend;"
  },
  {
    "instruction": "Write a function that checks if a given string is a valid time in the format \"HH:MM\". If the time is valid, return True. If not, return False.\n\nA valid time must meet the following conditions:\n1. The string consists of exactly 5 characters, two digits, a colon, and two more digits.\n2. The first two digits must represent a valid hour, which means it must be between 00 and 23 (inclusive).\n3. The last two digits must represent a valid minute, which means it must be between 00 and 59 (inclusive).",
    "output": "function ValidTime(const timeValue: string): boolean;\nbegin\n  var parts := timeValue.Split(':');\n  if parts.Length <> 2 then\n    exit(False);\n  var hour, minute: integer;\n  if (not TryStrToInt(parts[0], hour)) or (not TryStrToInt(parts[1], minute)) then\n    exit(False);\n  Result := (hour >= 0) and (hour < 24) and (minute >= 0) and (minute < 60);\nend;"
  },
  {
    "instruction": "Write a function to check if a given list contains any duplicates and return the duplicate elements.",
    "output": "uses System.Collections.Generic;\n\nfunction FindDuplicates(const values: array of integer): array of integer;\nbegin\n  var seen := new HashSet<integer>;\n  var duplicates := new List<integer>;\n  foreach var value in values do\n    if seen.Contains(value) then\n      duplicates.Add(value)\n    else\n      seen.Add(value);\n  Result := duplicates.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to check if a given sequence of numbers is a valid subsequence of another sequence. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.",
    "output": "function IsValidSubsequence(const arrayValues, seq: array of integer): boolean;\nbegin\n  var seqIndex := 0;\n  for var i := 0 to arrayValues.Length - 1 do\n    if (seqIndex < seq.Length) and (arrayValues[i] = seq[seqIndex]) then\n      seqIndex += 1;\n  Result := seqIndex = seq.Length;\nend;"
  },
  {
    "instruction": "Write a function to find the first non-repeating character in a given string.",
    "output": "uses System.Collections.Generic;\n\nfunction FindNonRepeatingChar(const value: string): char;\nbegin\n  var counts := new Dictionary<char, integer>;\n  foreach var ch in value do\n    if counts.ContainsKey(ch) then\n      counts[ch] += 1\n    else\n      counts[ch] := 1;\n  foreach var ch in value do\n    if counts[ch] = 1 then\n      exit(ch);\n  Result := #0;\nend;"
  },
  {
    "instruction": "Write a function to count the number of zeros in a given list of integers.",
    "output": "function CountZeros(const numbers: array of integer): integer;\nbegin\n  var count := 0;\n  foreach var value in numbers do\n    if value = 0 then\n      count += 1;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to convert a decimal number to 9's complement. The 9's complement of a decimal number is calculated by subtracting each digit of the number from 9, and the result is the 9's complement digit. For example, the 9's complement of 123 is 876.",
    "output": "function NinesComplement(decimalNum: integer): string;\nbegin\n  var digits := decimalNum.ToString;\n  var builder := new System.Text.StringBuilder;\n  foreach var ch in digits do\n    builder.Append(char(ord('0') + (9 - (ord(ch) - ord('0')))));\n  Result := builder.ToString;\nend;"
  },
  {
    "instruction": "Write a function that takes two strings as input. The function should compare the frequency of each character in the two strings. If the frequencies of all characters are the same, the function returns True. Otherwise, it returns False.",
    "output": "uses System.Collections.Generic;\n\nfunction CompareCharFreq(const s1, s2: string): boolean;\nbegin\n  var freq1 := new Dictionary<char, integer>;\n  var freq2 := new Dictionary<char, integer>;\n  foreach var ch in s1 do\n    if freq1.ContainsKey(ch) then freq1[ch] += 1 else freq1[ch] := 1;\n  foreach var ch in s2 do\n    if freq2.ContainsKey(ch) then freq2[ch] += 1 else freq2[ch] := 1;\n  Result := freq1.Count = freq2.Count;\n  if not Result then\n    exit(False);\n  foreach var kvp in freq1 do\n    if (not freq2.ContainsKey(kvp.Key)) or (freq2[kvp.Key] <> kvp.Value) then\n      exit(False);\n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of character deletions required to make a string palindrome.\n\nA palindrome is a string that reads the same backward as forward, e.g., \"radar\" or \"level\".",
    "output": "{$zerobasedstrings}\nfunction MinDeletionsPalindrome(const s: string): integer;\nbegin\n  var chars := s.ToCharArray;\n  var n := chars.Length;\n  if n <= 1 then\n    exit(0);\n  var dp := new integer[n, n];\n  for var len := 2 to n do\n    for var i := 0 to n - len do\n    begin\n      var j := i + len - 1;\n      if chars[i] = chars[j] then\n        if len = 2 then\n          dp[i, j] := 0\n        else\n          dp[i, j] := dp[i + 1, j - 1]\n      else\n        dp[i, j] := Min(dp[i + 1, j], dp[i, j - 1]) + 1;\n    end;\n  Result := dp[0, n - 1];\nend;"
  },
  {
    "instruction": "Write a function to find the maximum element in a list using recursion.",
    "output": "uses System;\n\nfunction MaxElementRecursive(const nums: array of integer; index: integer): integer;\nbegin\n  if index = nums.Length - 1 then\n    exit(nums[index]);\n  var tailMax := MaxElementRecursive(nums, index + 1);\n  if nums[index] > tailMax then\n    Result := nums[index]\n  else\n    Result := tailMax;\nend;\n\nfunction MaxElement(const nums: array of integer): integer;\nbegin\n  if nums = nil then\n    raise new ArgumentNullException('nums');\n  if nums.Length = 0 then\n    raise new ArgumentException('Array cannot be empty');\n  Result := MaxElementRecursive(nums, 0);\nend;"
  },
  {
    "instruction": "Write a function to create a recommended user name based on a given string. The function should follow these rules:\n1. Convert the ID to lowercase.\n2. Remove all characters that are not a-z, A-Z, 0-9, -, _, or . from the ID.\n3. Replace sequences of . with a single ..\n4. Remove leading and trailing . characters from the ID.\n5. If the ID is empty, change it to a.\n6. If the length of the ID is greater than 15, cut it to 15 characters. Remove leading and trailing . characters again if any.\n7. If the length of the ID is less than 3, append the last character of the ID to make the length 3.",
    "output": "uses System, System.Text;\n\nfunction RecommendUsername(idValue: string): string;\nbegin\n  var lower := idValue.ToLower;\n  var filtered := new StringBuilder;\n  foreach var ch in lower do\n    if Char.IsLower(ch) or Char.IsDigit(ch) or (ch in ['-', '_', '.']) then\n      filtered.Append(ch);\n  var collapsed := new StringBuilder;\n  var prevDot := False;\n  foreach var ch in filtered.ToString do\n    if ch = '.' then\n    begin\n      if not prevDot then\n        collapsed.Append(ch);\n      prevDot := True;\n    end\n    else\n    begin\n      collapsed.Append(ch);\n      prevDot := False;\n    end;\n  var candidate := collapsed.ToString.Trim('.');\n  if candidate = '' then\n    candidate := 'a';\n  if candidate.Length > 15 then\n  begin\n    candidate := candidate.Substring(0, 15).Trim('.');\n    if candidate = '' then\n      candidate := 'a';\n  end;\n  while candidate.Length < 3 do\n    candidate += candidate[^1];\n  Result := candidate;\nend;"
  },
  {
    "instruction": "Write a function to check if a given word's abbreviation is unique in a given dictionary.",
    "output": "uses System.Collections.Generic;\n\nfunction WordAbbr(const word: string): string;\nbegin\n  if word.Length < 3 then\n    exit(word);\n  Result := word[1] + (word.Length - 2).ToString + word[word.Length];\nend;\n\nfunction IsUniqueWordAbbreviation(const dictionary: array of string; const word: string): boolean;\nbegin\n  var groups := new Dictionary<string, List<string>>;\n  foreach var entry in dictionary do\n  begin\n    var abbr := WordAbbr(entry);\n    if not groups.ContainsKey(abbr) then\n      groups[abbr] := new List<string>;\n    groups[abbr].Add(entry);\n  end;\n  var target := WordAbbr(word);\n  if not groups.ContainsKey(target) then\n    exit(True);\n  var matches := groups[target];\n  Result := (matches.Count = 1) and (matches[0] = word);\nend;"
  },
  {
    "instruction": "Write a function that checks if a given string contains a repeated substring pattern. The function should return True if the string can be constructed by repeating a substring multiple times, and False otherwise.",
    "output": "uses System.Text;\n{$zerobasedstrings}\nfunction RepeatedSubstringPattern(const s: string): boolean;\nbegin\n  if s.Length <= 1 then\n    exit(False);\n  for var len := 1 to s.Length div 2 do\n    if s.Length mod len = 0 then\n    begin\n      var chunk := s.Substring(0, len);\n      var builder := new StringBuilder;\n      var repeats := s.Length div len;\n      for var k := 1 to repeats do\n        builder.Append(chunk);\n      if builder.ToString = s then\n        exit(True);\n    end;\n  Result := False;\nend;"
  },
  {
    "instruction": "Write a function to find the kth smallest element in an unsorted array using QuickSelect algorithm.",
    "output": "uses System;\n\nprocedure Swap(var a, b: integer);\nbegin\n  var temp := a;\n  a := b;\n  b := temp;\nend;\n\nfunction Partition(var arr: array of integer; left, right: integer): integer;\nbegin\n  var pivot := arr[right];\n  var i := left - 1;\n  for var j := left to right - 1 do\n    if arr[j] <= pivot then\n    begin\n      i += 1;\n      Swap(arr[i], arr[j]);\n    end;\n  Swap(arr[i + 1], arr[right]);\n  Result := i + 1;\nend;\n\nfunction RandomPartition(var arr: array of integer; left, right: integer): integer;\nbegin\n  var randomGen := new Random;\n  var pivotIdx := randomGen.Next(left, right + 1);\n  Swap(arr[pivotIdx], arr[right]);\n  Result := Partition(arr, left, right);\nend;\n\nfunction QuickSelectInternal(var arr: array of integer; left, right, kIdx: integer): integer;\nbegin\n  var pos := RandomPartition(arr, left, right);\n  if pos = kIdx then\n    exit(arr[pos]);\n  if pos > kIdx then\n    exit(QuickSelectInternal(arr, left, pos - 1, kIdx))\n  else\n    exit(QuickSelectInternal(arr, pos + 1, right, kIdx));\nend;\n\nfunction QuickSelectKthSmallest(var arr: array of integer; k: integer): integer;\nbegin\n  if (k < 1) or (k > arr.Length) then\n    raise new ArgumentOutOfRangeException('k');\n  Result := QuickSelectInternal(arr, 0, arr.Length - 1, k - 1);\nend;"
  },
  {
    "instruction": "Write a function to create a dictionary where keys are numbers between 1 and n (inclusive) and values are square of keys.",
    "output": "uses System.Collections.Generic;\n\nfunction CreateSquareDict(n: integer): Dictionary<integer, integer>;\nbegin\n  var items := new Dictionary<integer, integer>;\n  for var i := 1 to n do\n    items[i] := i * i;\n  Result := items;\nend;"
  },
  {
    "instruction": "Write a function to convert a CamelCase string to snake_case.",
    "output": "uses System, System.Text;\n\nfunction ConvertCamelToSnake(const value: string): string;\nbegin\n  var builder := new StringBuilder;\n  foreach var ch in value do\n    if Char.IsUpper(ch) then\n    begin\n      if builder.Length > 0 then\n        builder.Append('_');\n      builder.Append(Char.ToLower(ch));\n    end\n    else\n      builder.Append(ch);\n  Result := builder.ToString;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest consecutive sequence of zeros in the binary representation of a given number, surrounded by ones at both ends.",
    "output": "uses System;\n\nfunction LongestZeroSequence(n: integer): integer;\nbegin\n  var bits := Convert.ToString(n, 2);\n  var maxLen := 0;\n  var current := 0;\n  var seenOne := False;\n  foreach var ch in bits do\n    if ch = '1' then\n    begin\n      if seenOne and (current > maxLen) then\n        maxLen := current;\n      current := 0;\n      seenOne := True;\n    end\n    else if seenOne then\n      current += 1;\n  Result := maxLen;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns a list of all possible sublists of consecutive elements from the original list.",
    "output": "uses System.Collections.Generic;\n\nfunction GenerateSublists(const values: array of integer): List<array of integer>;\nbegin\n  var resultList := new List<array of integer>;\n  for var i := 0 to values.Length - 1 do\n    for var j := i to values.Length - 1 do\n    begin\n      var sliceLen := j - i + 1;\n      var slice := new integer[sliceLen];\n      for var k := 0 to sliceLen - 1 do\n        slice[k] := values[i + k];\n      resultList.Add(slice);\n    end;\n  Result := resultList;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and an integer as input and returns the list with the integer inserted at the correct position to maintain the list sorted in ascending order.",
    "output": "uses System.Collections.Generic;\n\nfunction InsertSorted(const values: array of integer; num: integer): array of integer;\nbegin\n  var lst := new List<integer>(values);\n  var inserted := False;\n  for var i := 0 to lst.Count - 1 do\n    if lst[i] > num then\n    begin\n      lst.Insert(i, num);\n      inserted := True;\n      break;\n    end;\n  if not inserted then\n    lst.Add(num);\n  Result := lst.ToArray;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of three integers representing the number of cold, warm, and hot water cups. The function should return the minimum number of seconds needed to fill all the cups, given that in each second, we can fill two cups (one of any two types).",
    "output": "uses System.Collections.Generic;\n\nfunction FillCups(const amount: array of integer): integer;\nbegin\n  var counts := new List<integer>(amount);\n  counts.Sort;\n  var seconds := 0;\n  while (counts.Count >= 2) and (counts[counts.Count - 2] > 0) do\n  begin\n    counts[counts.Count - 1] -= 1;\n    counts[counts.Count - 2] -= 1;\n    seconds += 1;\n    counts.Sort;\n  end;\n  if counts.Count > 0 then\n    seconds += counts[counts.Count - 1];\n  Result := seconds;\nend;"
  },
  {
    "instruction": "Write a function to check whether the given string is a valid hexadecimal number or not.",
    "output": "uses System;\n\nfunction CheckHexadecimal(const s: string): boolean;\nconst\n  HexDigits = '0123456789abcdefABCDEF';\nbegin\n  foreach var ch in s do\n    if HexDigits.IndexOf(ch) = -1 then\n      exit(False);\n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function to calculate the number of possible paths from the top-left corner to the bottom-right corner of a 2D grid. You can only move either down or right at any point in time.",
    "output": "function NumPaths(rows, cols: integer): integer;\nbegin\n  if (rows <= 0) or (cols <= 0) then\n    exit(0);\n  var dp := new integer[rows, cols];\n  for var i := 0 to rows - 1 do\n    for var j := 0 to cols - 1 do\n      if (i = 0) or (j = 0) then\n        dp[i, j] := 1\n      else\n        dp[i, j] := dp[i - 1, j] + dp[i, j - 1];\n  Result := dp[rows - 1, cols - 1];\nend;"
  },
  {
    "instruction": "Write a function to convert a decimal number to its equivalent in binary, octal, and hexadecimal.",
    "output": "uses System;\n\nfunction NumberToBase(n: integer): (string, string, string);\nbegin\n  var binary := Convert.ToString(n, 2);\n  var octal := Convert.ToString(n, 8);\n  var hexadecimal := Convert.ToString(n, 16).ToUpper;\n  Result := (binary, octal, hexadecimal);\nend;"
  },
  {
    "instruction": "Write a function to find the mode(s) in a list of numbers.",
    "output": "uses System.Collections.Generic;\n\nfunction FindModes(const nums: array of integer): array of integer;\nbegin\n  if nums = nil then\n    exit(new integer[0]);\n  var freq := new Dictionary<integer, integer>;\n  foreach var num in nums do\n    if freq.ContainsKey(num) then\n      freq[num] += 1\n    else\n      freq[num] := 1;\n  var maxCount := 0;\n  foreach var value in freq.Values do\n    if value > maxCount then\n      maxCount := value;\n  var resultList := new List<integer>;\n  foreach var pair in freq do\n    if pair.Value = maxCount then\n      resultList.Add(pair.Key);\n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to check whether a list contains a sublist or not. The function should return True if the list contains the sublist, otherwise, return False. The sublist can appear in any order in the main list.",
    "output": "uses System.Collections.Generic;\n\nfunction CheckSublist(const mainList, subList: array of integer): boolean;\nbegin\n  var lookup := new HashSet<integer>(mainList);\n  foreach var item in subList do\n    if not lookup.Contains(item) then\n      exit(False);\n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function that takes a matrix as input, and returns the count of unique 2x2 squares found in the matrix.",
    "output": "uses System.Collections.Generic, System.Text;\n\nfunction UniqueSquares(const matrix: array of array of integer): integer;\nbegin\n  var rows := matrix.Length;\n  if rows < 2 then\n    exit(0);\n  var cols := matrix[0].Length;\n  if cols < 2 then\n    exit(0);\n  var seen := new HashSet<string>;\n  for var i := 0 to rows - 2 do\n    for var j := 0 to cols - 2 do\n    begin\n      var sb := new StringBuilder;\n      sb.Append(matrix[i][j]).Append(',').Append(matrix[i][j + 1]).Append(';');\n      sb.Append(matrix[i + 1][j]).Append(',').Append(matrix[i + 1][j + 1]);\n      seen.Add(sb.ToString);\n    end;\n  Result := seen.Count;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of lists, where each inner list represents a character's properties in a game. The first element in each list is the defense level and the second element is the attack level. The function should return the number of weak characters. A character is considered weak if there is another character with a higher defense level and higher attack level.",
    "output": "uses System.Collections.Generic;\n\ntype\n  TCharacter = record\n    Defense, Attack: integer;\n\n  end;\n\nfunction CountWeakCharacters(const properties: array of array of integer): integer;\nbegin\n  if properties = nil then\n    exit(0);\n  var charList := new List<TCharacter>;\n  foreach var entry in properties do\n    if entry.Length >= 2 then\n    begin\n      var t : TCharacter := (Defense : entry[0]; Attack : entry[1]);\n      charList.Add(t);\n    end;\n  charList.Sort((a, b) ->\n  begin\n    var cmp := b.Defense.CompareTo(a.Defense);\n    if cmp <> 0 then\n      Result := cmp\n    else\n      Result := a.Attack.CompareTo(b.Attack);\n  end);\n  var maxAttack := integer.MinValue;\n  var weak := 0;\n  foreach var ch in charList do\n  begin\n    if ch.Attack < maxAttack then\n      weak += 1\n    else if ch.Attack > maxAttack then\n      maxAttack := ch.Attack;\n  end;\n  Result := weak;\nend;"
  },
  {
    "instruction": "Write a function to calculate the mean of a list of numbers.",
    "output": "uses System;\n\nfunction CalculateMean(const numbers: array of real): real;\nbegin\n  if (numbers = nil) or (numbers.Length = 0) then\n    raise new ArgumentException('numbers');\n  var total := 0.0;\n  foreach var value in numbers do\n    total += value;\n  Result := total / numbers.Length;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest possible sum of k consecutive elements in a given array.",
    "output": "function MinConsecutiveSum(const nums: array of integer; target: integer): integer;\nbegin\n  var n := nums.Length;\n  var minLen := integer.MaxValue;\n  var currentSum := 0;\n  var left := 0;\n  for var right := 0 to n - 1 do\n  begin\n    currentSum += nums[right];\n    while currentSum >= target do\n    begin\n      minLen := Min(minLen, right - left + 1);\n      currentSum -= nums[left];\n      left += 1;\n    end;\n  end;\n  if minLen = integer.MaxValue then\n    Result := 0\n  else\n    Result := minLen;\nend;"
  },
  {
    "instruction": "Write a function to find the number of unique triplets in the list that sum up to zero.",
    "output": "uses System.Collections.Generic;\n\nfunction FindZeroTriplets(const arr: array of integer): List<List<integer>>;\nbegin\n  var resultList := new List<List<integer>>;\n  var sorted := arr.Sorted.ToArray();\n  for var i := 0 to sorted.Length - 3 do\n  begin\n    if (i > 0) and (sorted[i] = sorted[i - 1]) then\n      continue;\n    var left := i + 1;\n    var right := sorted.Length - 1;\n    while left < right do\n    begin\n      var sum := sorted[i] + sorted[left] + sorted[right];\n      if sum = 0 then\n      begin\n        resultList.Add(new List<integer>([sorted[i], sorted[left], sorted[right]]));\n        while (left < right) and (sorted[left] = sorted[left + 1]) do\n          left += 1;\n        while (left < right) and (sorted[right] = sorted[right - 1]) do\n          right -= 1;\n        left += 1;\n        right -= 1;\n      end\n      else if sum < 0 then\n        left += 1\n      else\n        right -= 1;\n    end;\n  end;\n  Result := resultList;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest consecutive elements sequence in an unsorted array of integers. Algorithm should run in O(n) time complexity.",
    "output": "uses System.Collections.Generic;\n\nfunction LongestConsecutive(const nums: array of integer): integer;\nbegin\n  if nums.Length = 0 then\n    exit(0);\n  var numSet := new HashSet<integer>(nums);\n  var longest := 0;\n  foreach var num in numSet do\n  begin\n    if not numSet.Contains(num - 1) then\n    begin\n      var currentNum := num;\n      var currentStreak := 1;\n      while numSet.Contains(currentNum + 1) do\n      begin\n        currentNum += 1;\n        currentStreak += 1;\n      end;\n      if currentStreak > longest then\n        longest := currentStreak;\n    end;\n  end;\n  Result := longest;\nend;"
  },
  {
    "instruction": "Write a function to check if a given string is a valid parenthesis sequence.",
    "output": "function IsValidParenthesis(const s: string): boolean;\nbegin\n  var stack := new List<char>;\n  foreach var ch in s do\n  begin\n    if ch in ['(', '{', '['] then\n      stack.Add(ch)\n    else\n    begin\n      if stack.Count = 0 then\n        exit(False);\n      var last := stack[stack.Count - 1];\n      if ((ch = ')') and (last = '(')) or \n         ((ch = '}') and (last = '{')) or \n         ((ch = ']') and (last = '[')) then\n        stack.RemoveAt(stack.Count - 1)\n      else\n        exit(False);\n    end;\n  end;\n  Result := stack.Count = 0;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings and returns a list of strings with the last character removed.",
    "output": "function RemoveLastChar(const s: string): string;\nbegin\n  if s.Length = 0 then\n    Result := ''\n  else\n    Result := s.Substring(0, s.Length - 1);\nend;"
  },
  {
    "instruction": "Write a function to sort a given list of dictionaries based on a specified key in the dictionaries.",
    "output": "uses System.Collections.Generic;\n\nfunction SortDictsByKey(const dicts: List<Dictionary<string, object>>; const key: string): List<Dictionary<string, object>>;\nbegin\n  Result := dicts.OrderBy(d -> Convert.ToInt32(d[key])).ToList;\nend;"
  },
  {
    "instruction": "Write a function to find the power of a given number using recursion.",
    "output": "function PowerRecursive(base, exp: integer): integer;\nbegin\n  if exp = 0 then\n    exit(1);\n  if exp = 1 then\n    exit(base);\n  Result := base * PowerRecursive(base, exp - 1);\nend;"
  },
  {
    "instruction": "Write a function to find the intersection of two sets.",
    "output": "uses System.Collections.Generic;\n\nfunction IntersectionSets(const set1, set2: HashSet<integer>): HashSet<integer>;\nbegin\n  var resultSet := new HashSet<integer>;\n  foreach var item in set1 do\n    if set2.Contains(item) then\n      resultSet.Add(item);\n  Result := resultSet;\nend;"
  },
  {
    "instruction": "Write a function that takes a string and returns the number of alphabetic characters in it.",
    "output": "function CountAlphabetic(const s: string): integer;\nbegin\n  var count := 0;\n  foreach var ch in s do\n    if Char.IsLetter(ch) then\n      count += 1;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns the integer that appears only once in the list. Every other integer appears exactly three times.",
    "output": "uses System.Collections.Generic;\n\nfunction FindUniqueElement(const arr: array of integer): integer;\nbegin\n  var counts := new Dictionary<integer, integer>;\n  foreach var num in arr do\n    if counts.ContainsKey(num) then\n      counts[num] += 1\n    else\n      counts[num] := 1;\n  foreach var kvp in counts do\n    if kvp.Value = 1 then\n      exit(kvp.Key);\n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to find the longest substring without repeating characters in a given string.",
    "output": "function LongestSubstringKDistinct(const s: string; k: integer): integer;\nbegin\n  if (k = 0) or (s.Length = 0) then\n    exit(0);\n  var charCount := new Dictionary<char, integer>;\n  var left := 0;\n  var maxLen := 0;\n  for var right := 0 to s.Length - 1 do\n  begin\n    var ch := s[right];\n    if charCount.ContainsKey(ch) then\n      charCount[ch] += 1\n    else\n      charCount[ch] := 1;\n    while charCount.Count > k do\n    begin\n      var leftCh := s[left];\n      charCount[leftCh] -= 1;\n      if charCount[leftCh] = 0 then\n        charCount.Remove(leftCh);\n      left += 1;\n    end;\n    maxLen := Max(maxLen, right - left + 1);\n  end;\n  Result := maxLen;\nend;"
  },
  {
    "instruction": "Write a function to find all unique permutations of a list with duplicates.",
    "output": "function MinDeletionsPalindrome(const s: string): integer;\nbegin\n  var n := s.Length;\n  var dp := new integer[n, n];\n  for var i := n - 1 downto 0 do\n    for var j := i + 1 to n - 1 do\n      if s[i] = s[j] then\n        dp[i, j] := dp[i + 1, j - 1]\n      else\n        dp[i, j] := 1 + Min(dp[i + 1, j], dp[i, j - 1]);\n  Result := dp[0, n - 1];\nend;"
  },
  {
    "instruction": "Write a function to find the sum of all elements in a list that are not divisible by a given number.",
    "output": "function MaxElementRecursive(const arr: array of integer; index: integer): integer;\nbegin\n  if index = arr.Length - 1 then\n    exit(arr[index]);\n  Result := Max(arr[index], MaxElementRecursive(arr, index + 1));\nend;"
  },
  {
    "instruction": "Write a function to find the total number of ways to reach the top of a staircase if you can either climb 1 or 2 steps at a time.",
    "output": "function RecommendUsername(const name: string): string;\nbegin\n  var username := name.ToLower.Replace(' ', '_');\n  var sb := new StringBuilder;\n  foreach var ch in username do\n    if Char.IsLetterOrDigit(ch) or (ch = '_') then\n      sb.Append(ch);\n  Result := sb.ToString;\nend;"
  },
  {
    "instruction": "Write a function to find the number of possible binary search trees with given number of nodes.",
    "output": "function CountBST(n: integer): integer;\nbegin\n  if n <= 1 then\n    exit(1);\n  var count := 0;\n  for var i := 1 to n do\n    count += CountBST(i - 1) * CountBST(n - i);\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the number of unique binary search trees (BSTs) that store values 1...n.",
    "output": "function HasRepeatedSubstringPattern(const s: string): boolean;\nbegin\n  var doubled := s + s;\n  var sub := doubled.Substring(1, doubled.Length - 2);\n  Result := sub.Contains(s);\nend;"
  },
  {
    "instruction": "Write a function to find the maximum sum of a path in a binary tree.",
    "output": "type\n  TreeNode = class\n    Value: integer;\n    Left, Right: TreeNode;\n    constructor(v: integer; l, r: TreeNode);\n    begin\n      Value := v;\n      Left := l;\n      Right := r;\n    end;\n  end;\n\nfunction DFS(node: TreeNode; var maxSum: integer): integer;\nbegin\n  if node = nil then\n    exit(0);\n  var leftMax := Max(0, DFS(node.Left, maxSum));\n  var rightMax := Max(0, DFS(node.Right, maxSum));\n  maxSum := Max(maxSum, leftMax + rightMax + node.Value);\n  Result := Max(leftMax, rightMax) + node.Value;\nend;\n\nfunction MaxPathSum(root: TreeNode): integer;\nbegin\n  var maxSum := integer.MinValue;\n  if root <> nil then\n    DFS(root, maxSum);\n  Result := maxSum;\nend;"
  },
  {
    "instruction": "Given an array of integers, write a function that finds the length of the longest subarray that contains only 1's after deleting one element. If there are no 1's in the array, return 0.",
    "output": "function LongestOnesAfterDelete(const arr: array of integer): integer;\nbegin\n  var left := 0;\n  var zeroCount := 0;\n  var maxLen := 0;\n  \n  for var right := 0 to arr.Length - 1 do\n  begin\n    if arr[right] = 0 then\n      zeroCount += 1;\n    \n    while zeroCount > 1 do\n    begin\n      if arr[left] = 0 then\n        zeroCount -= 1;\n      left += 1;\n    end;\n    \n    maxLen := Max(maxLen, right - left);\n  end;\n  \n  Result := maxLen;\nend;"
  },
  {
    "instruction": "Write a function to find the number of occurrences of an element in a sorted list using binary search.",
    "output": "uses System.Text;\n\nfunction CamelToSnake(const s: string): string;\nbegin\n  var sb := new StringBuilder;\n  foreach var ch in s do\n    if Char.IsUpper(ch) then\n    begin\n      if sb.Length > 0 then\n        sb.Append('_');\n      sb.Append(Char.ToLower(ch));\n    end\n    else\n      sb.Append(ch);\n  Result := sb.ToString;\nend;"
  },
  {
    "instruction": "Write a function to check if a given number is a perfect number. A perfect number is a number that is equal to the sum of its proper divisors, excluding itself.",
    "output": "function LongestZeroSequence(const arr: array of integer): integer;\nbegin\n  var maxLen := 0;\n  var currentLen := 0;\n  foreach var num in arr do\n    if num = 0 then\n    begin\n      currentLen += 1;\n      if currentLen > maxLen then\n        maxLen := currentLen;\n    end\n    else\n      currentLen := 0;\n  Result := maxLen;\nend;"
  },
  {
    "instruction": "Write a function to find the total number of occurrences of specified characters in a given string.",
    "output": "uses System.Collections.Generic;\n\nfunction CountCharacters(const s: string; const charsToCount: array of char): integer;\nbegin\n  var count := 0;\n  var charSet := new HashSet<char>(charsToCount);\n  foreach var ch in s do\n    if charSet.Contains(ch) then\n      count += 1;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to reach the last cell of a given grid from the first cell using moves that can either go one cell to the right or one cell down.",
    "output": "function UniquePaths(m, n: integer): integer;\nbegin\n  var dp := new integer[m, n];\n  for var i := 0 to m - 1 do\n    dp[i, 0] := 1;\n  for var j := 0 to n - 1 do\n    dp[0, j] := 1;\n  for var i := 1 to m - 1 do\n    for var j := 1 to n - 1 do\n      dp[i, j] := dp[i - 1, j] + dp[i, j - 1];\n  Result := dp[m - 1, n - 1];\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest increasing subsequence in a given list of numbers.",
    "output": "function LengthOfLIS(const nums: array of integer): integer;\nbegin\n  if nums.Length = 0 then\n    exit(0);\n  var dp := new integer[nums.Length];\n  for var i := 0 to nums.Length - 1 do\n  begin\n    dp[i] := 1;\n    for var j := 0 to i - 1 do\n      if nums[j] < nums[i] then\n        dp[i] := Max(dp[i], dp[j] + 1);\n  end;\n  Result := dp.Max;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of tuples, each containing a string and an integer. The function should return a list of tuples sorted by the integer in each tuple in ascending order. Use the `sorted()` function with a lambda function as the key parameter.",
    "output": "function SortListOfTuples(const data: array of (string, integer)): array of (string, integer);\nbegin\n  Result := data;\n  Sort(Result, (x, y) -> x[1].CompareTo(y[1]));\nend;"
  },
  {
    "instruction": "Write a function to check whether a given list of integers can be formed by concatenating two palindromic lists.",
    "output": "function NumPaths(m, n: integer): integer;\nbegin\n  var dp := new integer[m, n];\n  for var i := 0 to m - 1 do\n    dp[i, 0] := 1;\n  for var j := 0 to n - 1 do\n    dp[0, j] := 1;\n  for var i := 1 to m - 1 do\n    for var j := 1 to n - 1 do\n      dp[i, j] := dp[i - 1, j] + dp[i, j - 1];\n  Result := dp[m - 1, n - 1];\nend;"
  },
  {
    "instruction": "Create a function that searches for a specific key in a nested dictionary. The function should return the value of the key if it exists, and nil if it does not. The dictionary can have an arbitrary depth of nested dictionaries.",
    "output": "uses System.Collections.Generic;\n\nfunction FindInNestedDict(dictObj: Dictionary<string, object>; key: string): object;\nbegin\n  if dictObj.ContainsKey(key) then\n    exit(dictObj[key]);\n  foreach var value in dictObj.Values do\n    if value is Dictionary<string, object> then\n    begin\n      var res := FindInNestedDict(value as Dictionary<string, object>, key);\n      if res <> nil then\n        exit(res);\n    end;\n  Result := nil;\nend;"
  },
  {
    "instruction": "Write a function to count the number of matching elements at the same index in two lists.",
    "output": "uses System.Collections.Generic;\n\nfunction FindModes(const nums: array of integer): array of integer;\nbegin\n  var counts := new Dictionary<integer, integer>;\n  foreach var num in nums do\n    if counts.ContainsKey(num) then\n      counts[num] += 1\n    else\n      counts[num] := 1;\n  var maxCount := counts.Values.Max;\n  var modes := new List<integer>;\n  foreach var kvp in counts do\n    if kvp.Value = maxCount then\n      modes.Add(kvp.Key);\n  Result := modes.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to check if any number in the list can be incremented by x to reach or exceed the target value H. If such a number exists, return 'YES', otherwise return 'NO'.",
    "output": "function CanReachTarget(const nums: array of integer; x, H: integer): string;\nbegin\n  foreach var num in nums do\n    if num + x >= H then\n      exit('YES');\n  Result := 'NO';\nend;"
  },
  {
    "instruction": "Create a function that checks if a given set of four points in a 2D plane can form a valid square. A valid square is defined as a shape with four equal sides and four 90-degree angles.",
    "output": "uses System.Collections.Generic;\n\nfunction UniqueSquares(const numbers: array of integer): array of integer;\nbegin\n  var squares := new HashSet<integer>;\n  foreach var num in numbers do\n    squares.Add(num * num);\n  Result := squares.OrderBy(x -> x).ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the count of subarrays with a given xor value.",
    "output": "uses System.Collections.Generic;\n\nfunction CountWeakCharacters(const properties: array of (integer, integer)): integer;\nbegin\n  var sorted := properties.OrderByDescending(p -> p.Item1).ThenBy(p -> p.Item2).ToArray;\n  var maxDefense := 0;\n  var count := 0;\n  foreach var prop in sorted do\n  begin\n    if prop.Item2 < maxDefense then\n      count += 1;\n    if prop.Item2 > maxDefense then\n      maxDefense := prop.Item2;\n  end;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to check whether a number is a confusing number or not. A confusing number is a number that when rotated 180 degrees becomes a different number, and each digit remains valid after the rotation.",
    "output": "function IsConfusingNumber(n: integer): boolean;\nbegin\n  var s := n.ToString;\n  foreach var ch in s do\n    if not (ch in ['0', '1', '6', '8', '9']) then\n      exit(False);\n  var reversed := '';\n  for var i := s.Length - 1 downto 0 do\n  begin\n    var ch := s[i];\n    if ch = '6' then\n      reversed += '9'\n    else if ch = '9' then\n      reversed += '6'\n    else\n      reversed += ch;\n  end;\n  Result := reversed <> s;\nend;"
  },
  {
    "instruction": "Write a function to find the perimeter of the island in a given grid. The island is represented by 1's and the water is represented by 0's. Each cell is a square of side length 1. Grid cells are connected horizontally/vertically (not diagonally). The grid is rectangular, width and height don't exceed 100. The given grid is always a rectangular matrix of 1's and 0's and only contains one island (there is no water on the grid).",
    "output": "function FindIslandPerimeter(const grid: array of array of integer): integer;\nbegin\n  var rows := grid.Length;\n  if rows = 0 then\n    exit(0);\n  var cols := grid[0].Length;\n  var perimeter := 0;\n  \n  for var i := 0 to rows - 1 do\n    for var j := 0 to cols - 1 do\n      if grid[i][j] = 1 then\n      begin\n        if (i = 0) or (grid[i - 1][j] = 0) then\n          perimeter += 1;\n        if (i = rows - 1) or (grid[i + 1][j] = 0) then\n          perimeter += 1;\n        if (j = 0) or (grid[i][j - 1] = 0) then\n          perimeter += 1;\n        if (j = cols - 1) or (grid[i][j + 1] = 0) then\n          perimeter += 1;\n      end;\n  \n  Result := perimeter;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to reach the top of a staircase. You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "output": "function StairClimb(n: integer): integer;\nbegin\n  if n <= 2 then\n    exit(n);\n  var a := 1;\n  var b := 2;\n  for var i := 2 to n - 1 do\n  begin\n    var temp := a + b;\n    a := b;\n    b := temp;\n  end;\n  Result := b;\nend;"
  },
  {
    "instruction": "Write a function that takes two integers, `low` and `high`, and returns the count of odd numbers from `low` to `high` (inclusive). However, this function should not use any loops or modulus operator.",
    "output": "function CountOddsNoLoop(low, high: integer): integer;\nbegin\n  if (low < 0) or (high > 1000000000) or (low > high) then\n    exit(0);\n  if (low mod 2 <> 0) and (high mod 2 = 0) then\n    Result := (high - low + 1) div 2\n  else if (low mod 2 = 0) and (high mod 2 = 0) then\n    Result := (high - low) div 2\n  else if (low mod 2 = 0) and (high mod 2 <> 0) then\n    Result := (high - low + 1) div 2\n  else\n    Result := (high - low + 2) div 2;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum length of a substring where the difference of each character's ASCII value does not exceed a given limit.",
    "output": "function MaxLenSubstring(const s: string; limit: integer): integer;\nbegin\n  var diffs := new List<integer>;\n  diffs.Add(0);\n  for var i := 0 to s.Length - 2 do\n    diffs.Add(Abs(Ord(s[i]) - Ord(s[i + 1])));\n  diffs.Add(limit + 1);\n  var curCost := 0;\n  var maxLen := 0;\n  var startPos := 0;\n  var endPos := 0;\n  while (startPos < diffs.Count) and (endPos < diffs.Count - 1) do\n  begin\n    endPos := Max(startPos, endPos);\n    if curCost + diffs[endPos] > limit then\n    begin\n      curCost -= diffs[startPos];\n      startPos += 1;\n    end\n    else\n    begin\n      curCost += diffs[endPos];\n      endPos += 1;\n      maxLen := Max(maxLen, endPos - startPos);\n    end;\n  end;\n  Result := maxLen;\nend;"
  },
  {
    "instruction": "Write a function that checks if a list of numbers is sorted in ascending order and if all numbers in the list are unique. The function should return a boolean value.",
    "output": "function CheckSortedUnique(const numbers: array of integer): boolean;\nbegin\n  var seen := new HashSet<integer>;\n  foreach var num in numbers do\n    if seen.Contains(num) then\n      exit(False)\n    else\n      seen.Add(num);\n  for var i := 1 to numbers.Length - 1 do\n    if numbers[i] <= numbers[i - 1] then\n      exit(False);\n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to fill a 2D grid of size m x n with 1 x 1 tiles, considering there are obstacles in the grid. A tile can only be placed if there is no obstacle in that position. The grid is represented as a list of lists, where 0 represents an empty position and 1 represents an obstacle.",
    "output": "function UniquePathwaysWithObstacles(const grid: array of array of integer): integer;\nbegin\n  var m := grid.Length;\n  if m = 0 then\n    exit(0);\n  var n := grid[0].Length;\n  if grid[0][0] = 1 then\n    exit(0);\n  \n  var dp := new integer[m, n];\n  dp[0, 0] := 1;\n  \n  for var i := 1 to m - 1 do\n    if (grid[i][0] = 0) and (dp[i - 1, 0] = 1) then\n      dp[i, 0] := 1\n    else\n      dp[i, 0] := 0;\n      \n  for var j := 1 to n - 1 do\n    if (grid[0][j] = 0) and (dp[0, j - 1] = 1) then\n      dp[0, j] := 1\n    else\n      dp[0, j] := 0;\n      \n  for var i := 1 to m - 1 do\n    for var j := 1 to n - 1 do\n      if grid[i][j] = 0 then\n        dp[i, j] := dp[i - 1, j] + dp[i, j - 1]\n      else\n        dp[i, j] := 0;\n        \n  Result := dp[m - 1, n - 1];\nend;"
  },
  {
    "instruction": "Write a function to remove duplicates from a list while preserving the order of the elements.",
    "output": "uses System.Collections.Generic;\n\nfunction RemoveDuplicatesPreserveOrder(const lst: array of integer): array of integer;\nbegin\n  var seen := new HashSet<integer>;\n  var resultList := new List<integer>;\n  foreach var item in lst do\n    if not seen.Contains(item) then\n    begin\n      seen.Add(item);\n      resultList.Add(item);\n    end;\n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to convert an RGB color to its hexadecimal representation.",
    "output": "function RGBToHex(r, g, b: integer): string;\nbegin\n  Result := '#' + r.ToString('x2') + g.ToString('x2') + b.ToString('x2');\nend;"
  },
  {
    "instruction": "Write a function to find the missing numbers in a given array of integers where the integers are in the range from 1 to n inclusive and some numbers are missing.",
    "output": "uses System.Collections.Generic;\n\nfunction MissingNumbers(const arr: array of integer): array of integer;\nbegin\n  if arr.Length = 0 then\n    exit(new integer[0]);\n  var maxVal := arr[0];\n  foreach var val in arr do\n    if val > maxVal then\n      maxVal := val;\n  var present := new HashSet<integer>(arr);\n  var missing := new List<integer>;\n  for var i := 1 to maxVal do\n    if not present.Contains(i) then\n      missing.Add(i);\n  Result := missing.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of points that lie on the same line from a list of points in a 2D plane.",
    "output": "uses System.Collections.Generic;\n\nfunction GCD(a, b: integer): integer;\nbegin\n  while b <> 0 do\n  begin\n    var temp := b;\n    b := a mod b;\n    a := temp;\n  end;\n  Result := Abs(a);\nend;\n\nfunction MaxPointsOnSameLine(const points: array of (integer, integer)): integer;\nbegin\n  if points.Length <= 2 then\n    exit(points.Length);\n  var maxPoints := 0;\n  for var i := 0 to points.Length - 1 do\n  begin\n    var slopes := new Dictionary<string, integer>;\n    var samePoint := 1;\n    for var j := i + 1 to points.Length - 1 do\n    begin\n      if (points[i].Item1 = points[j].Item1) and (points[i].Item2 = points[j].Item2) then\n      begin\n        samePoint += 1;\n        continue;\n      end;\n      var slope: string;\n      if points[i].Item1 = points[j].Item1 then\n        slope := 'inf'\n      else\n      begin\n        var rise := points[j].Item2 - points[i].Item2;\n        var run := points[j].Item1 - points[i].Item1;\n        var g := GCD(rise, run);\n        slope := $'{rise div g}/{run div g}';\n      end;\n      if slopes.ContainsKey(slope) then\n        slopes[slope] += 1\n      else\n        slopes[slope] := 1;\n      maxPoints := Max(maxPoints, slopes[slope] + samePoint);\n    end;\n    maxPoints := Max(maxPoints, samePoint);\n  end;\n  Result := maxPoints;\nend;"
  },
  {
    "instruction": "Write a function to check if a given string is a valid hexadecimal color code.",
    "output": "function IsHexColor(const code: string): boolean;\nbegin\n  if (code.Length <> 7) or (code[1] <> '#') then\n    exit(False);\n  for var i := 2 to 7 do\n  begin\n    var ch := code[i];\n    if not (((ch >= '0') and (ch <= '9')) or \n            ((ch >= 'A') and (ch <= 'F')) or \n            ((ch >= 'a') and (ch <= 'f'))) then\n      exit(False);\n  end;\n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum average subarray of a given array of integers.",
    "output": "function FindMaxAverage(const nums: array of integer; k: integer): real;\nbegin\n  var currentSum := 0;\n  for var i := 0 to k - 1 do\n    currentSum += nums[i];\n  var maxAvg := currentSum / k;\n  for var i := k to nums.Length - 1 do\n  begin\n    currentSum += nums[i] - nums[i - k];\n    var avg := currentSum / k;\n    if avg > maxAvg then\n      maxAvg := avg;\n  end;\n  Result := maxAvg;\nend;"
  },
  {
    "instruction": "Write a function that takes a number and returns the position of the rightmost set bit in its binary representation.",
    "output": "function RightmostSetBit(num: integer): integer;\nbegin\n  if num = 0 then\n    exit(-1);\n  var pos := 0;\n  while (num and 1) = 0 do\n  begin\n    num := num shr 1;\n    pos += 1;\n  end;\n  Result := pos + 1;\nend;"
  },
  {
    "instruction": "Write a function that returns a list of all divisors of a given number, excluding the number itself.",
    "output": "uses System.Collections.Generic;\n\nfunction FindDivisors(number: integer): array of integer;\nbegin\n  var divisors := new List<integer>;\n  for var i := 1 to number - 1 do\n    if number mod i = 0 then\n      divisors.Add(i);\n  Result := divisors.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest window that contains all the characters of a given pattern in a string.",
    "output": "uses System.Collections.Generic;\n\nfunction FindSmallestWindow(const s, pat: string): string;\nbegin\n  var patCount := new Dictionary<char, integer>;\n  foreach var ch in pat do\n    if patCount.ContainsKey(ch) then\n      patCount[ch] += 1\n    else\n      patCount[ch] := 1;\n  var startPos := 0;\n  var startIndex := -1;\n  var minLen := integer.MaxValue;\n  var matchCount := 0;\n  var currCount := new Dictionary<char, integer>;\n  for var j := 0 to s.Length - 1 do\n  begin\n    var ch := s[j];\n    if currCount.ContainsKey(ch) then\n      currCount[ch] += 1\n    else\n      currCount[ch] := 1;\n    if patCount.ContainsKey(ch) and (currCount[ch] <= patCount[ch]) then\n      matchCount += 1;\n    if matchCount = pat.Length then\n    begin\n      var currentCharValue: integer;\n      while (currCount[s[startPos]] > (patCount.TryGetValue(s[startPos], currentCharValue) ? currentCharValue : 0)) do\n      begin\n        if currCount[s[startPos]] > 0 then\n          currCount[s[startPos]] -= 1;\n        startPos += 1;\n      end;\n      var windowLen := j - startPos + 1;\n      if windowLen < minLen then\n      begin\n        minLen := windowLen;\n        startIndex := startPos;\n      end;\n    end;\n  end;\n  if startIndex = -1 then\n    Result := ''\n  else\n    Result := s.Substring(startIndex, minLen);\nend;"
  },
  {
    "instruction": "Write a function to find the maximum sum of a subarray with the length of exactly k.",
    "output": "function MaxSumSubArrayK(const arr: array of integer; k: integer): integer;\nbegin\n  if (arr = nil) or (k <= 0) or (k > arr.Length) then\n    exit(0);\n  var currentSum := 0;\n  for var i := 0 to k - 1 do\n    currentSum += arr[i];\n  var maxSum := currentSum;\n  for var i := k to arr.Length - 1 do\n  begin\n    currentSum += arr[i] - arr[i - k];\n    if currentSum > maxSum then\n      maxSum := currentSum;\n  end;\n  Result := maxSum;\nend;"
  },
  {
    "instruction": "Write a function to calculate the total cost of a shopping cart given the price and quantity of each item.",
    "output": "uses System.Collections.Generic;\n\nfunction CalculateCartCost(const cart: List<Dictionary<string, object>>): real;\nbegin\n  var total := 0.0;\n  foreach var item in cart do\n  begin\n    var price := Convert.ToDouble(item['price']);\n    var quantity := Convert.ToInt32(item['quantity']);\n    total += price * quantity;\n  end;\n  Result := Round(total, 2);\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to represent a given number as a sum of 3 prime numbers.",
    "output": "uses System.Collections.Generic;\n\nfunction IsPrime(n: integer): boolean;\nbegin\n  if n <= 1 then\n    exit(False);\n  if n <= 3 then\n    exit(True);\n  if (n mod 2 = 0) or (n mod 3 = 0) then\n    exit(False);\n  var i := 5;\n  while i * i <= n do\n  begin\n    if (n mod i = 0) or (n mod (i + 2) = 0) then\n      exit(False);\n    i += 6;\n  end;\n  Result := True;\nend;\n\nfunction WaysToSumPrimes(n: integer): integer;\nbegin\n  var primes := new List<integer>;\n  for var i := 2 to n - 1 do\n    if IsPrime(i) then\n      primes.Add(i);\n  var ways := 0;\n  for var i := 0 to primes.Count - 1 do\n    for var j := i to primes.Count - 1 do\n    begin\n      var k := n - primes[i] - primes[j];\n      if (k >= primes[j]) and primes.Contains(k) then\n        ways += 1;\n    end;\n  Result := ways;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum difference between two elements in a given array, where the larger element appears after the smaller element.",
    "output": "function FindMaxDiff(const arr: array of integer): integer;\nbegin\n  if arr.Length < 2 then\n    exit(0);\n  var maxDiff := arr[1] - arr[0];\n  var minElement := arr[0];\n  for var i := 1 to arr.Length - 1 do\n  begin\n    if arr[i] - minElement > maxDiff then\n      maxDiff := arr[i] - minElement;\n    if arr[i] < minElement then\n      minElement := arr[i];\n  end;\n  Result := maxDiff;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns a string that groups consecutive integers into ranges. For example, given the input list [0, 1, 2, 4, 5, 7], the function should return the string \"0-2,4-5,7\". If an integer appears more than once in the list, it should appear only once in the output.",
    "output": "uses System, System.Linq, System.Text, System.Collections.Generic;\n\nfunction CompressRanges(const lst: array of integer): string;\nbegin\n  if lst.Length = 0 then\n    exit('');\n  var numbers := lst.Distinct.Order.ToArray;\n  var segments := new List<string>;\n  var start := numbers[0];\n  var finish := numbers[0];\n\n  for var i := 1 to High(numbers) do\n    if numbers[i] = finish + 1 then\n      finish := numbers[i]\n    else\n    begin\n      if start = finish then\n        segments.Add(start.ToString)\n      else\n        segments.Add($'{start}-{finish}');\n      start := numbers[i];\n      finish := numbers[i];\n    end;\n\n  if start = finish then\n    segments.Add(start.ToString)\n  else\n    segments.Add($'{start}-{finish}');\n\n  Result := string.Join(',', segments.ToArray);\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of friends required to repair all weak points in a wall. The wall is represented as a circular array of weak points, and a list of available friends' repair distances. Each friend can repair a single section of the wall up to their maximum repair distance. The goal is to minimize the number of friends needed to repair the entire wall.",
    "output": "uses System, System.Linq, System.Collections.Generic;\n\nfunction RepairWall(n: integer; weak, dist: array of integer): integer;\nbegin\n  var length := weak.Length;\n  if length = 0 then\n    exit(0);\n  if dist.Length = 0 then\n    exit(-1);\n\n  var extended := weak.ToList;\n  for var i := 0 to length - 1 do\n    extended.Add(weak[i] + n);\n\n  var answer := integer.MaxValue;\n\n  foreach var permutation in dist.Permutations do\n    for var i := 0 to length - 1 do\n    begin\n      var count := 0;\n      var maxPos := extended[i] + permutation[count];\n      var covered := true;\n      for var j := i to i + length - 1 do\n        if maxPos < extended[j] then\n        begin\n          Inc(count);\n          if count >= permutation.Length then\n          begin\n            covered := false;\n            break;\n          end;\n          maxPos := extended[j] + permutation[count];\n        end;\n      if covered and (count + 1 < answer) then\n        answer := count + 1;\n    end;\n\n  if answer = integer.MaxValue then\n    Result := -1\n  else\n    Result := answer;\nend;"
  },
  {
    "instruction": "Write a function to calculate the total number of vowels in a given string.",
    "output": "function NumVowels(const s: string): integer;\nconst vowels = 'aeiouAEIOU';\nbegin\n  Result := 0;\n  foreach var ch in s do\n    if ch in vowels then\n      Inc(Result);\nend;"
  },
  {
    "instruction": "Write a function to find the last digit of a given number.",
    "output": "function LastDigit(n: integer): integer := Abs(n mod 10);"
  },
  {
    "instruction": "Write a function to find the longest palindromic substring in a given string.",
    "output": "{$zerobasedstrings}\nuses System;\n\ntype PalInfo = record\n  Start, Length: integer;\nend;\n\nfunction ExpandAroundCenter(const s: string; left, right: integer): PalInfo;\nbegin\n  var l := left;\n  var r := right;\n  while (l >= 0) and (r < s.Length) do\n  begin\n    if s[l] <> s[r] then\n      break;\n    Dec(l);\n    Inc(r);\n  end;\n  Result.Start := l + 1;\n  Result.Length := r - l - 1;\nend;\n\nfunction LongestPalindromicSubstring(const s: string): string;\nbegin\n  if s.Length < 2 then\n    exit(s);\n  var best: PalInfo;\n  best.Start := 0;\n  best.Length := 1;\n\n  for var i := 0 to s.Length - 1 do\n  begin\n    var info := ExpandAroundCenter(s, i, i);\n    if info.Length > best.Length then\n      best := info;\n\n    info := ExpandAroundCenter(s, i, i + 1);\n    if info.Length > best.Length then\n      best := info;\n  end;\n\n  Result := s.Substring(best.Start, best.Length);\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of coins required to make a given amount using a given set of coin denominations.",
    "output": "uses System;\n\nfunction MinCoinsToMakeAmount(const coins: array of integer; amount: integer): integer;\nbegin\n  if amount = 0 then\n    exit(0);\n  var dp := new integer[amount + 1];\n  for var i := 0 to amount do\n    dp[i] := integer.MaxValue div 2;\n  dp[0] := 0;\n\n  foreach var coin in coins do\n    for var value := coin to amount do\n      if dp[value - coin] + 1 < dp[value] then\n        dp[value] := dp[value - coin] + 1;\n\n  if dp[amount] >= integer.MaxValue div 2 then\n    Result := -1\n  else\n    Result := dp[amount];\nend;"
  },
  {
    "instruction": "Write a function that finds the largest permutation of a given number that is less than or equal to a target number.",
    "output": "uses System, System.Linq;\n\nfunction LargestPermutation(num1, num2: integer): integer;\nbegin\n  var digits := num1.ToString.ToArray;\n  var limit := num2;\n  var resultValue := -1;\n\n  foreach var perm in digits.Permutations do\n  begin\n    if (perm.Length = 0) or (perm[0] = '0') then\n      continue;\n    var candidate := string.Concat(perm).ToInteger;\n    if (candidate <= limit) and (candidate > resultValue) then\n      resultValue := candidate;\n  end;\n\n  Result := resultValue;\nend;"
  },
  {
    "instruction": "Write a function to find the kth smallest element in an unsorted list using QuickSelect algorithm.",
    "output": "uses System, System.Linq;\n\nfunction QuickSelect(const arr: array of integer; k: integer): integer;\nbegin\n  Assert((k >= 1) and (k <= arr.Length));\n  if arr.Length = 1 then\n    exit(arr[0]);\n\n  var pivot := arr[arr.Length div 2];\n  var left := arr.Where(x -> x < pivot).ToArray;\n  var middle := arr.Where(x -> x = pivot).ToArray;\n  var right := arr.Where(x -> x > pivot).ToArray;\n\n  if k <= left.Length then\n    Result := QuickSelect(left, k)\n  else if k > left.Length + middle.Length then\n    Result := QuickSelect(right, k - left.Length - middle.Length)\n  else\n    Result := middle[0];\nend;"
  },
  {
    "instruction": "Write a function to find the index in a sorted list where a value would fit in order to keep the list sorted.",
    "output": "function FindInsertPosition(const sortedList: array of integer; value: integer): integer;\nbegin\n  var left := 0;\n  var right := sortedList.Length;\n  while left < right do\n  begin\n    var mid := (left + right) div 2;\n    if sortedList[mid] < value then\n      left := mid + 1\n    else\n      right := mid;\n  end;\n  Result := left;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum score in a list of tuples, where each tuple contains a player's name and their score.",
    "output": "uses System, System.Linq;\n\nfunction MinScore(const players: array of (string, integer)): integer;\nbegin\n  if players.Length = 0 then\n    exit(0);\n  Result := players.Select(p -> p.Item2).Min;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to achieve a given score in a game where you can add either 1, 2, or 3 points at a time. This problem uses dynamic programming to find the solution.",
    "output": "uses System;\n\nfunction GameScoreWays(score: integer): integer;\nbegin\n  if score = 0 then\n    exit(1);\n  if score < 0 then\n    exit(0);\n\n  var dp := new integer[score + 1];\n  dp[0] := 1;\n  for var i := 1 to score do\n  begin\n    if i - 1 >= 0 then\n      dp[i] += dp[i - 1];\n    if i - 2 >= 0 then\n      dp[i] += dp[i - 2];\n    if i - 3 >= 0 then\n      dp[i] += dp[i - 3];\n  end;\n  Result := dp[score];\nend;"
  },
  {
    "instruction": "Write a function to rearrange a given string such that no two adjacent characters are the same. If it is not possible to rearrange the string to meet the requirements, return an empty string.",
    "output": "uses System, System.Linq, System.Collections.Generic, System.Text;\n\nfunction RearrangeString(const s: string): string;\nbegin\n  if s = '' then\n    exit('');\n  var freq := new Dictionary<char, integer>;\n  foreach var ch in s do\n  begin\n    if not freq.ContainsKey(ch) then\n      freq[ch] := 0;\n    freq[ch] := freq[ch] + 1;\n  end;\n\n  var sb := new StringBuilder;\n  var lastChar := #0;\n\n  while sb.Length < s.Length do\n  begin\n    var nextChar := #0;\n    var bestCount := -1;\n\n    // Greedy pick highest-frequency char that differs from previous one\n    foreach var kvp in freq.ToArray do\n      if (kvp.Value > bestCount) and ((sb.Length = 0) or (kvp.Key <> lastChar)) and (kvp.Value > 0) then\n      begin\n        nextChar := kvp.Key;\n        bestCount := kvp.Value;\n      end;\n\n    if bestCount = -1 then\n      exit('');\n\n    sb.Append(nextChar);\n    lastChar := nextChar;\n    freq[nextChar] := bestCount - 1;\n    if freq[nextChar] = 0 then\n      freq.Remove(nextChar);\n  end;\n\n  Result := sb.ToString;\nend;"
  },
  {
    "instruction": "Write a function to find the number of days required for two friends to meet each other. Two friends are on a number line and they start walking towards each other. The first friend starts from position 'start' and walks 'speed1' units per day, while the second friend starts from position 'end' and walks 'speed2' units per day. Write a function that finds the number of days required for them to meet. If they start at the same position, return 0.",
    "output": "uses System;\n\nfunction MeetDays(startPos, endPos, speed1, speed2: integer): integer;\nbegin\n  if startPos = endPos then\n    exit(0);\n  var distance := Abs(endPos - startPos);\n  var step := speed1 + speed2;\n  Result := distance div step;\n  if distance mod step <> 0 then\n    Result += 1;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of the digits in a given number raised to a specified power.",
    "output": "function PowerDigitSum(number, power: integer): integer;\nbegin\n  var total := 0;\n  foreach var ch in number.ToString do\n  begin\n    var digit := Ord(ch) - Ord('0');\n    var value := 1;\n    for var i := 1 to power do\n      value *= digit;\n    total += value;\n  end;\n  Result := total;\nend;"
  },
  {
    "instruction": "Write a function to find the number of islands in a given 2D binary grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "output": "uses System;\n\nprocedure IslandDfs(const matrix: array[,] of integer; var visited: array[,] of boolean; rows, cols, r, c: integer);\nbegin\n  if (r < 0) or (c < 0) or (r >= rows) or (c >= cols) then\n    exit;\n  if (matrix[r, c] = 0) or visited[r, c] then\n    exit;\n  visited[r, c] := true;\n  IslandDfs(matrix, visited, rows, cols, r + 1, c);\n  IslandDfs(matrix, visited, rows, cols, r - 1, c);\n  IslandDfs(matrix, visited, rows, cols, r, c + 1);\n  IslandDfs(matrix, visited, rows, cols, r, c - 1);\nend;\n\nfunction IslandCounter(const matrix: array[,] of integer): integer;\nbegin\n  if matrix = nil then\n    exit(0);\n  var rows := matrix.GetLength(0);\n  var cols := matrix.GetLength(1);\n  if (rows = 0) or (cols = 0) then\n    exit(0);\n\n  var visited := new boolean[rows, cols];\n  var islands := 0;\n  for var r := 0 to rows - 1 do\n    for var c := 0 to cols - 1 do\n      if (matrix[r, c] = 1) and not visited[r, c] then\n      begin\n        Inc(islands);\n        IslandDfs(matrix, visited, rows, cols, r, c);\n      end;\n  Result := islands;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of all the even Fibonacci numbers up to a given limit.",
    "output": "function EvenFibSum(limit: integer): integer;\nbegin\n  var a := 1;\n  var b := 2;\n  var total := 0;\n  while b <= limit do\n  begin\n    if b mod 2 = 0 then\n      total += b;\n    var nextValue := a + b;\n    a := b;\n    b := nextValue;\n  end;\n  Result := total;\nend;"
  },
  {
    "instruction": "Write a function that calculates the maximum product of a partition of a given positive integer. The function should take a positive integer `n` as input and return the maximum product of its partition.",
    "output": "function MaxProductPartition(n: integer): integer;\nbegin\n  if n <= 2 then\n    exit(1);\n  if n = 3 then\n    exit(2);\n  case n mod 3 of\n    0: Result := Round(Power(3, n div 3));\n    1: Result := 4 * Round(Power(3, (n - 4) div 3));\n  else\n    Result := 2 * Round(Power(3, (n - 2) div 3));\n  end;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns a new list where all the elements are positive. If an element is negative, it should be converted to its positive equivalent.",
    "output": "uses System, System.Linq;\n\nfunction MakePositive(const lst: array of integer): array of integer :=\n  lst.Select(x -> Abs(x)).ToArray;"
  },
  {
    "instruction": "Write a function to generate a list by replicating the elements of another list n times.",
    "output": "uses System.Collections.Generic;\n\nfunction ReplicateElements(n: integer; const lst: array of integer): array of integer;\nbegin\n  if n <= 0 then\n    exit(new integer[0]);\n  var resultList := new List<integer>;\n  foreach var value in lst do\n    for var i := 1 to n do\n      resultList.Add(value);\n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to remove duplicates from a list and return a sorted list.",
    "output": "uses System.Linq;\n\nfunction RemoveDuplicatesAndSort(const lst: array of integer): array of integer :=\n  lst.Distinct.Order.ToArray;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns a list of unique sublists, where each sublist is a consecutive sequence of integers found in the input list. Each sublist should be sorted in ascending order, and the order of sublists in the output should be based on their starting element in the input list.",
    "output": "uses System, System.Linq, System.Collections.Generic;\n\nfunction FindConsecutiveSequences(const nums: array of integer): array of array of integer;\nbegin\n  if nums.Length = 0 then\n  begin\n    SetLength(Result, 0);\n    exit;\n  end;\n  var sorted := nums.Order.ToArray;\n  var current := new List<integer>;\n  current.Add(sorted[0]);\n  var groups := new List<array of integer>;\n  for var i := 1 to sorted.Length - 1 do\n    if sorted[i] = sorted[i - 1] + 1 then\n      current.Add(sorted[i])\n    else\n    begin\n      if current.Count > 1 then\n        groups.Add(current.ToArray);\n      current := new List<integer>;\n      current.Add(sorted[i]);\n    end;\n  if current.Count > 1 then\n    groups.Add(current.ToArray);\n  Result := groups.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the kth bit of the n-th number in the Thue-Morse sequence.\n\nThe Thue-Morse sequence is defined as follows:\n- T(0) = 0\n- T(2n) = T(n)\n- T(2n + 1) = 1 - T(n)\n\nFor example:\nT(0) = 0\nT(1) = 1\nT(2) = 1\nT(3) = 0\nT(4) = 1\nT(5) = 1\nT(6) = 0\nT(7) = 1",
    "output": "uses System;\n\nfunction FindKthBitRec(n, k: integer; signUnchanged: boolean): char;\nbegin\n  if n = 1 then\n  begin\n    if signUnchanged then\n      exit('0')\n    else\n      exit('1');\n  end;\n  var middle := n div 2 + 1;\n  if k = middle then\n  begin\n    if signUnchanged then\n      exit('1')\n    else\n      exit('0');\n  end;\n  if k < middle then\n    Result := FindKthBitRec(n div 2, k, signUnchanged)\n  else\n    Result := FindKthBitRec(n div 2, n - k + 1, not signUnchanged);\nend;\n\nfunction FindKthBit(n, k: integer): string;\nbegin\n  var totalLength := (1 shl n) - 1;\n  var ch := FindKthBitRec(totalLength, k, true);\n  Result := ch.ToString;\nend;"
  },
  {
    "instruction": "Write a function to create a dictionary where keys are the numbers from 1 to n and values are the squares of these numbers.",
    "output": "uses System.Collections.Generic;\n\nfunction CreateSquaresDict(n: integer): Dictionary<integer, integer>;\nbegin\n  var squares := new Dictionary<integer, integer>;\n  for var i := 1 to n do\n    squares[i] := i * i;\n  Result := squares;\nend;"
  },
  {
    "instruction": "Write a function `generate_powers` that takes in two parameters `base` and `power` and returns a list of all the powers of the base up to the given power. The function should return an empty list if the power is less than zero.",
    "output": "uses System;\n\nfunction GeneratePowers(baseValue, power: integer): array of integer;\nbegin\n  if power < 0 then\n  begin\n    SetLength(Result, 0);\n    exit;\n  end;\n  SetLength(Result, power + 1);\n  Result[0] := 1;\n  for var i := 1 to power do\n    Result[i] := Result[i - 1] * baseValue;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum XOR of two numbers in an array.",
    "output": "uses System;\n\ntype\n  TreeNode = class\n  public\n    Children: array of TreeNode;\n    constructor Create;\n  end;\n\n  Tree = class\n  private\n    fRoot: TreeNode;\n  public\n    constructor Create;\n    procedure Insert(num: integer);\n    function Query(num: integer): integer;\n  end;\n\nconstructor TreeNode.Create;\nbegin\n  Children[0] := nil;\n  Children[1] := nil;\nend;\n\nconstructor Tree.Create;\nbegin\n  fRoot := new TreeNode;\nend;\n\nprocedure Tree.Insert(num: integer);\nbegin\n  var node := fRoot;\n  for var i := 31 downto 0 do\n  begin\n    var bit := (num shr i) and 1;\n    if node.Children[bit] = nil then\n      node.Children[bit] := new TreeNode;\n    node := node.Children[bit];\n  end;\nend;\n\nfunction Tree.Query(num: integer): integer;\nbegin\n  var node := fRoot;\n  var xorValue := 0;\n  for var i := 31 downto 0 do\n  begin\n    var bit := (num shr i) and 1;\n    var toggled := 1 - bit;\n    if node.Children[toggled] <> nil then\n    begin\n      xorValue := xorValue or (1 shl i);\n      node := node.Children[toggled];\n    end\n    else if node.Children[bit] <> nil then\n      node := node.Children[bit]\n    else\n      break;\n  end;\n  Result := xorValue;\nend;\n\nfunction Find_Max_XOR(const nums: array of integer; n: integer): integer;\nbegin\n  if nums.Length = 0 then\n    exit(0);\n  var _tree := new Tree;\n  var maxXor := 0;\n  foreach var num in nums do\n  begin\n    _tree.Insert(num);\n    var candidate := _tree.Query(num);\n    if candidate > maxXor then\n      maxXor := candidate;\n  end;\n  Result := maxXor;\nend;"
  },
  {
    "instruction": "Write a function to check if a list contains only unique elements.",
    "output": "uses System, System.Linq;\n\nfunction CheckUniqueElements(const lst: array of integer): boolean;\nbegin\n  Result := lst.Length = lst.Distinct.Count;\nend;"
  },
  {
    "instruction": "Write a function that takes a sorted list of unique integers and a target integer. The function should return the index of the first number that is greater than or equal to the target. If the target is greater than all numbers in the list, the function should return the length of the list.",
    "output": "uses System;\n\nfunction FindTargetPosition(const nums: array of integer; target: integer): integer;\nbegin\n  for var idx := 0 to nums.Length - 1 do\n    if nums[idx] >= target then\n      exit(idx);\n  Result := nums.Length;\nend;"
  },
  {
    "instruction": "Write a function that simulates a traffic light system. The function should take a string representing the current state of the traffic light (\"green\", \"yellow\", \"red\") and return the next state. The sequence is \"green\" -> \"yellow\" -> \"red\" -> \"green\".",
    "output": "uses System;\n\nfunction NextTrafficLight(const current: string): string;\nbegin\n  if current = 'green' then\n    exit('yellow')\n  else if current = 'yellow' then\n    exit('red')\n  else if current = 'red' then\n    exit('green');\n  Result := current;\nend;"
  },
  {
    "instruction": "Write a function that converts a decimal number to its binary equivalent and returns the count of 1's in the binary representation.",
    "output": "uses System;\n\nfunction CountOnesInBinary(decimalNumber: integer): integer;\nbegin\n  var value := Abs(decimalNumber);\n  Result := 0;\n  while value > 0 do\n  begin\n    if (value and 1) = 1 then\n      Inc(Result);\n    value := value shr 1;\n  end;\nend;"
  },
  {
    "instruction": "Write a function that finds the two numbers in a given array such that they add up to a specific target. You should return the indices of the two numbers in the form of a list. Assume that each input would have exactly one solution, and you may not use the same element twice.",
    "output": "uses System.Collections.Generic;\n\nfunction TwoSum(const nums: array of integer; target: integer): array of integer;\nbegin\n  var indices := new Dictionary<integer, integer>;\n  for var i := 0 to nums.Length - 1 do\n  begin\n    var complement := target - nums[i];\n    if indices.ContainsKey(complement) then\n    begin\n      SetLength(Result, 2);\n      Result[0] := indices[complement];\n      Result[1] := i;\n      exit;\n    end;\n    indices[nums[i]] := i;\n  end;\n  SetLength(Result, 0);\nend;"
  },
  {
    "instruction": "Write a function to convert a given decimal number to its equivalent in base -2 (negative two). The function should return the result as a string.",
    "output": "uses System, System.Text;\n\nfunction Base_Neg2(N: integer): string;\nbegin\n  if N = 0 then\n    exit('0');\n  var value := N;\n  var sb := new StringBuilder;\n  while value <> 0 do\n  begin\n    var remainder := value mod -2;\n    value := value div -2;\n    if remainder < 0 then\n    begin\n      remainder += 2;\n      Inc(value);\n    end;\n    sb.Insert(0, remainder.ToString);\n  end;\n  Result := sb.ToString;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of the largest contiguous subarray within a given one-dimensional array of numbers.",
    "output": "uses System;\n\nfunction LargestContiguousSubarraySum(const nums: array of integer): integer;\nbegin\n  if nums.Length = 0 then\n    exit(0);\n  var maxCurrent := nums[0];\n  var maxGlobal := nums[0];\n  for var i := 1 to nums.Length - 1 do\n  begin\n    maxCurrent := Max(nums[i], maxCurrent + nums[i]);\n    maxGlobal := Max(maxGlobal, maxCurrent);\n  end;\n  Result := maxGlobal;\nend;"
  },
  {
    "instruction": "Write a function to find the number of times a given number appears in a rotated and potentially duplicated sorted array.",
    "output": "uses System;\n\nfunction FindNumInRotatedArray(const nums: array of integer; target: integer): integer;\nbegin\n  var count := 0;\n  foreach var value in nums do\n    if value = target then\n      Inc(count);\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to decode a message using a specific mapping. The mapping is 'A' -> 1, 'B' -> 2, ..., 'Z' -> 26. The message consists of digits from 1-9 and can be decoded as a sequence of letters using the mapping. The function should return the total number of ways to decode the message.",
    "output": "uses System;\n\nfunction DecodeMessage(const s: string): integer;\nbegin\n  if (s = '') or (s[1] = '0') then\n    exit(0);\n  var dp := new integer[s.Length + 1];\n  dp[0] := 1;\n  dp[1] := 1;\n  for var i := 2 to s.Length do\n  begin\n    if s[i] <> '0' then\n      dp[i] := dp[i] + dp[i - 1];\n    var twoDigit := (Ord(s[i - 1]) - Ord('0')) * 10 + (Ord(s[i]) - Ord('0'));\n    if (twoDigit >= 10) and (twoDigit <= 26) then\n      dp[i] := dp[i] + dp[i - 2];\n  end;\n  Result := dp[s.Length];\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of points you can earn by applying operations on a list of integers. You can perform the following operation any number of times:\nChoose two adjacent elements and replace them with their sum. The maximum number of points you can earn is the sum of the elements in the final list.",
    "output": "uses System.Collections.Generic;\n\nfunction MaxPoints(const nums: array of integer): integer;\nbegin\n  if nums.Length = 0 then\n    exit(0);\n  var values := new List<integer>;\n  values.AddRange(nums);\n  while values.Count > 1 do\n  begin\n    var maxSum := integer.MinValue;\n    var maxIndex := 0;\n    for var i := 0 to values.Count - 2 do\n    begin\n      var candidate := values[i] + values[i + 1];\n      if candidate > maxSum then\n      begin\n        maxSum := candidate;\n        maxIndex := i;\n      end;\n    end;\n    values[maxIndex] := maxSum;\n    values.RemoveAt(maxIndex + 1);\n  end;\n  Result := values[0];\nend;"
  },
  {
    "instruction": "Write a function to find the largest subarray sum in a list of integers, where the subarray contains at least one number.",
    "output": "uses System;\n\nfunction FindLargestSubarraySum(const nums: array of integer): integer;\nbegin\n  if nums.Length = 0 then\n    exit(0);\n  var currentSum := nums[0];\n  var maxSum := nums[0];\n  for var i := 1 to nums.Length - 1 do\n  begin\n    currentSum := Max(nums[i], currentSum + nums[i]);\n    maxSum := Max(maxSum, currentSum);\n  end;\n  Result := maxSum;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of operations that can be performed on a list of integers. An operation consists of selecting two elements from the list that add up to a given value k, then removing those elements from the list. The function should return the maximum number of such operations that can be performed.",
    "output": "uses System, System.Collections.Generic, System.Linq;\n\nfunction MaxOperations(const nums: array of integer; k: integer): integer;\nbegin\n  var freq := new Dictionary<integer, integer>;\n  foreach var num in nums do\n    if freq.ContainsKey(num) then\n      freq[num] := freq[num] + 1\n    else\n      freq[num] := 1;\n  var operations := 0;\n  foreach var key in freq.Keys.ToArray do\n  begin\n    if not freq.ContainsKey(key) then\n      continue;\n    var countX := freq[key];\n    if countX = 0 then\n      continue;\n    var y := k - key;\n    if y = key then\n    begin\n      operations += freq[key] div 2;\n      freq[key] := 0;\n    end\n    else if freq.ContainsKey(y) then\n    begin\n      var &match := Min(freq[key], freq[y]);\n      operations += &match;\n      freq[key] := 0;\n      freq[y] := Max(0, freq[y] - &match);\n    end\n    else\n      freq[key] := 0;\n  end;\n  Result := operations;\nend;"
  },
  {
    "instruction": "Write a function to check if two strings are anagrams of each other.",
    "output": "uses System, System.Linq;\n\nfunction IsAnagram(const str1, str2: string): boolean;\nbegin\n  if str1.Length <> str2.Length then\n    exit(false);\n  Result := str1.OrderBy(c -> c).SequenceEqual(str2.OrderBy(c -> c));\nend;"
  },
  {
    "instruction": "Write a function that will return the number of digits in a given integer. The function should work for both positive and negative integers.",
    "output": "uses System;\n\nfunction NumOfDigits(n: integer): integer;\nbegin\n  if n = 0 then\n    exit(1);\n  Result := Abs(n).ToString.Length;\nend;"
  },
  {
    "instruction": "Write a function to find the number of days between two given dates.",
    "output": "uses System, System.Globalization;\n\nfunction Diff_Dates(const date1, date2: string): integer;\nbegin\n  var format := 'yyyy-MM-dd';\n  var culture := CultureInfo.InvariantCulture;\n  var a := DateTime.ParseExact(date1, format, culture);\n  var b := DateTime.ParseExact(date2, format, culture);\n  Result := (b - a).Days;\nend;"
  },
  {
    "instruction": "Write a function to find the total number of meeting rooms required for a list of meetings.\nEach meeting is represented as a list of two integers [start, end] where start is the start time of the meeting and end is the end time of the meeting.",
    "output": "uses System;\n\nfunction MeetingRooms(const meetings: array of array of integer): integer;\nbegin\n  if meetings.Length = 0 then\n    exit(0);\n  var starts := new integer[meetings.Length];\n  var ends := new integer[meetings.Length];\n  for var i := 0 to meetings.Length - 1 do\n  begin\n    starts[i] := meetings[i][0];\n    ends[i] := meetings[i][1];\n  end;\n  &Array.Sort(starts);\n  &Array.Sort(ends);\n  var s := 0;\n  var e := 0;\n  var count := 0;\n  var maxCount := 0;\n  while s < meetings.Length do\n  begin\n    if starts[s] < ends[e] then\n    begin\n      count += 1;\n      if count > maxCount then\n        maxCount := count;\n      s += 1;\n    end\n    else\n    begin\n      count -= 1;\n      e += 1;\n    end;\n  end;\n  Result := maxCount;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest contiguous subarray with all unique elements.",
    "output": "uses System, System.Collections.Generic;\n\nfunction FindLongestUniqueSubarray(const arr: array of integer): integer;\nbegin\n  var start := 0;\n  var maxLen := 0;\n  var lastIndex := new Dictionary<integer, integer>;\n  for var i := 0 to arr.Length - 1 do\n  begin\n    var value := arr[i];\n    if lastIndex.ContainsKey(value) and (start <= lastIndex[value]) then\n      start := lastIndex[value] + 1;\n    maxLen := Math.Max(maxLen, i - start + 1);\n    lastIndex[value] := i;\n  end;\n  Result := maxLen;\nend;"
  },
  {
    "instruction": "Write a function to find the starting index of the first occurrence of a substring within a given string.",
    "output": "uses System;\n\nfunction FindSubstringIndex(const strValue, substring: string): integer;\nbegin\n  Result := strValue.IndexOf(substring);\nend;"
  },
  {
    "instruction": "Write a function to find the Fibonacci number at a given position using matrix exponentiation.",
    "output": "uses System;\n\ntype\n  Matrix2 = array[,] of int64;\n\nprocedure Multiply(var F: Matrix2; const M: Matrix2);\nbegin\n  var x := F[0,0] * M[0,0] + F[0,1] * M[1,0];\n  var y := F[0,0] * M[0,1] + F[0,1] * M[1,1];\n  var z := F[1,0] * M[0,0] + F[1,1] * M[1,0];\n  var w := F[1,0] * M[0,1] + F[1,1] * M[1,1];\n  F[0,0] := x;\n  F[0,1] := y;\n  F[1,0] := z;\n  F[1,1] := w;\nend;\n\nprocedure Power(var F: Matrix2; n: integer);\nbegin\n  if (n = 0) or (n = 1) then\n    exit;\n  Power(F, n div 2);\n  Multiply(F, F);\n  if n mod 2 <> 0 then\n  begin\n    var M := new int64[2, 2];\n    \n    M[0,0] := 1; M[0,1] := 1;\n    M[1,0] := 1; M[1,1] := 0;\n    Multiply(F, M);\n  end;\nend;\n\nfunction FibonacciMatrix(n: integer): int64;\nbegin\n  if n = 0 then\n    exit(0);\n  \n  var F := new int64[2, 2];\n  \n  F[0,0] := 1; F[0,1] := 1;\n  F[1,0] := 1; F[1,1] := 0;\n  Power(F, n - 1);\n  Result := F[0,0];\nend;"
  },
  {
    "instruction": "Write a function to find the n'th pentagonal number.",
    "output": "uses System;\n\nfunction FindPentagonalNum(n: integer): integer;\nbegin\n  Result := n * (3 * n - 1) div 2;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of intervals and a new interval, and inserts the new interval into the list of intervals while maintaining the order and non-overlapping property. If necessary, merge intervals.",
    "output": "uses System, System.Collections.Generic, System.Linq;\n\nfunction InsertNewInterval(const intervals: array of array of integer; const newInterval: array of integer): array of array of integer;\nbegin\n  var allIntervals := new List<array of integer>;\n  foreach var interval in intervals do\n    allIntervals.Add(Copy(interval));\n  allIntervals.Add(Copy(newInterval));\n  allIntervals.Sort((a, b) -> a[0].CompareTo(b[0]));\n  var merged := new List<array of integer>;\n  foreach var interval in allIntervals do\n    if (merged.Count = 0) or (merged[merged.Count - 1][1] < interval[0]) then\n      merged.Add(Copy(interval))\n    else\n    begin\n      var last := merged[merged.Count - 1];\n      if interval[1] > last[1] then\n      begin\n        last[1] := interval[1];\n        merged[merged.Count - 1] := last;\n      end;\n    end;\n  Result := merged.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to check if two rectangles overlap. The rectangles are represented as tuples of four integers (x1, y1, x2, y2), where (x1, y1) is the coordinate of the top-left corner, and (x2, y2) is the coordinate of the bottom-right corner.",
    "output": "uses System;\n\nfunction RectanglesOverlap(const rect1, rect2: array of integer): boolean;\nbegin\n  var x1 := rect1[0];\n  var y1 := rect1[1];\n  var x2 := rect1[2];\n  var y2 := rect1[3];\n  var x3 := rect2[0];\n  var y3 := rect2[1];\n  var x4 := rect2[2];\n  var y4 := rect2[3];\n  Result := not ((x1 >= x4) or (x2 <= x3) or (y1 >= y4) or (y2 <= y3));\nend;"
  },
  {
    "instruction": "Write a function to convert the given list of integers into a dictionary, where keys are the numbers and values are the squares of the numbers.",
    "output": "uses System.Collections.Generic;\n\nfunction IntToDict(const lst: array of integer): Dictionary<integer, integer>;\nbegin\n  var res := new Dictionary<integer, integer>;\n  foreach var value in lst do\n    res[value] := value * value;\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to calculate the sum of the binomial coefficients C(n, k) for all 0 <= k <= n, where C(n, k) = n! / (k! * (n-k)!).",
    "output": "uses System.Numerics;\n\nfunction BinomialSum(n: integer): BigInteger;\nbegin\n  var sum := BigInteger.Zero;\n  var combination := BigInteger.One;\n  for var k := 0 to n do\n  begin\n    if k = 0 then\n      combination := BigInteger.One\n    else\n      combination := combination * (n - k + 1) div k;\n    sum := sum + combination;\n  end;\n  Result := sum;\nend;"
  },
  {
    "instruction": "Write a function to return the largest string from a list of strings.",
    "output": "uses System, System.Linq;\n\nfunction Largest_String(const lst: array of string): string;\nbegin\n  if lst.Length = 0 then\n    exit('');\n  Result := lst.OrderByDescending(s -> s.Length).First;\nend;"
  },
  {
    "instruction": "Write a function to alter the given array such that the array is sorted in the form small, large, small, large, ....",
    "output": "uses System, System.Linq, System.Collections.Generic;\n\nfunction RearrangeArray(const arr: array of integer): array of integer;\nbegin\n  if arr.Length = 0 then\n    exit(new integer[0]);\n  var sorted := arr.Order.ToList;\n  var resultList := new List<integer>;\n  var left := 0;\n  var right := sorted.Count - 1;\n  while left <= right do\n  begin\n    resultList.Add(sorted[left]);\n    left += 1;\n    if left <= right then\n    begin\n      resultList.Add(sorted[right]);\n      right -= 1;\n    end;\n  end;\n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns the count of numbers with an even number of digits.",
    "output": "uses System;\n\nfunction CountEvenDigitNumbers(const nums: array of integer): integer;\nbegin\n  Result := 0;\n  foreach var num in nums do\n    if num.ToString.Length mod 2 = 0 then\n      Inc(Result);\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns a list of unique triplets that sum up to zero. Each triplet must contain distinct elements from the input list.",
    "output": "uses System, System.Linq, System.Collections.Generic;\n\nfunction ZeroSumTriplets(const nums: array of integer): array of array of integer;\nbegin\n  var resultList := new List<array of integer>;\n  if nums.Length < 3 then\n  begin\n    Result := resultList.ToArray;\n    exit;\n  end;\n\n  var sorted := nums.Order.ToArray;\n  for var i := 0 to sorted.Length - 3 do\n  begin\n    if (i > 0) and (sorted[i] = sorted[i - 1]) then\n      continue;\n    var left := i + 1;\n    var right := sorted.Length - 1;\n    while left < right do\n    begin\n      var sum := sorted[i] + sorted[left] + sorted[right];\n      if sum = 0 then\n      begin\n        resultList.Add(Arr(sorted[i], sorted[left], sorted[right]));\n        Inc(left);\n        Dec(right);\n        while (left < right) and (sorted[left] = sorted[left - 1]) do\n          Inc(left);\n        while (left < right) and (sorted[right] = sorted[right + 1]) do\n          Dec(right);\n      end\n      else if sum < 0 then\n        Inc(left)\n      else\n        Dec(right);\n    end;\n  end;\n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to check if a given array of integers has any duplicates within a given range of indices.",
    "output": "uses System.Collections.Generic;\n\nfunction HasNearbyDuplicate(const nums: array of integer; k: integer): boolean;\nbegin\n  var lastIndex := new Dictionary<integer, integer>;\n  for var index := 0 to nums.Length - 1 do\n  begin\n    var value := nums[index];\n    if lastIndex.ContainsKey(value) and (index - lastIndex[value] <= k) then\n      exit(true);\n    lastIndex[value] := index;\n  end;\n  Result := false;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of unique characters in a string.",
    "output": "{$zerobasedstrings}\nuses System, System.Collections.Generic;\n\nfunction FindMaxUnique(const s: string): integer;\nbegin\n  var used := new Dictionary<char, integer>;\n  var maxLength := 0;\n  var start := 0;\n  for var index := 0 to s.Length - 1 do\n  begin\n    var ch := s[index];\n    if used.ContainsKey(ch) and (start <= used[ch]) then\n      start := used[ch] + 1;\n    var currentLength := index - start + 1;\n    if currentLength > maxLength then\n      maxLength := currentLength;\n    used[ch] := index;\n  end;\n  Result := maxLength;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum length of the subarray with a sum equal to k.",
    "output": "uses System, System.Collections.Generic;\n\nfunction MaxLenK(const arr: array of integer; k: integer): integer;\nbegin\n  var firstIndex := new Dictionary<integer, integer>;\n  var prefix := 0;\n  var maxLength := 0;\n  for var i := 0 to arr.Length - 1 do\n  begin\n    prefix += arr[i];\n    if prefix = k then\n      maxLength := Max(maxLength, i + 1);\n    if firstIndex.ContainsKey(prefix - k) then\n      maxLength := Max(maxLength, i - firstIndex[prefix - k]);\n    if not firstIndex.ContainsKey(prefix) then\n      firstIndex[prefix] := i;\n  end;\n  Result := maxLength;\nend;"
  },
  {
    "instruction": "Write a function to find the longest substring where for every character, its lower and upper case both exist.",
    "output": "{$zerobasedstrings}\nuses System, System.Collections.Generic;\n\nfunction LongestNiceSubstringHelper(const s: string): string;\nbegin\n  if s.Length < 2 then\n  begin\n    Result := '';\n    exit;\n  end;\n  var chars := new HashSet<char>(s.ToCharArray);\n  for var i := 0 to s.Length - 1 do\n  begin\n    var c := s[i];\n    var upper := System.Char.ToUpper(c);\n    var lower := System.Char.ToLower(c);\n    if chars.Contains(upper) and chars.Contains(lower) then\n      continue;\n    var left := LongestNiceSubstringHelper(s.Substring(0, i));\n    var right := LongestNiceSubstringHelper(s.Substring(i + 1));\n    if left.Length >= right.Length then\n    begin\n      Result := left;\n      exit;\n    end\n    else\n    begin\n      Result := right;\n      exit;\n    end;\n  end;\n  Result := s;\nend;\n\nfunction LongestNiceSubstring(const s: string): string := LongestNiceSubstringHelper(s);"
  },
  {
    "instruction": "Write a function to check if a string of brackets is balanced. A string of brackets is considered balanced if each opening bracket has a corresponding closing bracket and the pairs of brackets are properly nested.",
    "output": "uses System.Collections.Generic;\n\nfunction IsBalancedBrackets(const s: string): boolean;\nbegin\n  var pairs := new Dictionary<char, char>;\n  pairs['}'] := '{';\n  pairs[']'] := '[';\n  pairs[')'] := '(';\n  var stack := new Stack<char>;\n  foreach var ch in s do\n    if not pairs.ContainsKey(ch) then\n      stack.Push(ch)\n    else\n    begin\n      if (stack.Count = 0) or (stack.Peek <> pairs[ch]) then\n        exit(false);\n      stack.Pop;\n    end;\n  Result := stack.Count = 0;\nend;"
  },
  {
    "instruction": "Write a function to find the longest substring with exactly k unique characters in a given string.",
    "output": "{$zerobasedstrings}\nuses System, System.Collections.Generic;\n\nfunction LongestSubstringWithKUnique(const s: string; k: integer): integer;\nbegin\n  if k <= 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  var counts := new Dictionary<char, integer>;\n  var left := 0;\n  var maxLength := 0;\n  for var right := 0 to s.Length - 1 do\n  begin\n    var ch := s[right];\n    if counts.ContainsKey(ch) then\n      counts[ch] := counts[ch] + 1\n    else\n      counts[ch] := 1;\n    while counts.Count > k do\n    begin\n      var leftChar := s[left];\n      counts[leftChar] := counts[leftChar] - 1;\n      if counts[leftChar] = 0 then\n        counts.Remove(leftChar);\n      Inc(left);\n    end;\n    if counts.Count = k then\n    begin\n      var currentLength := right - left + 1;\n      if currentLength > maxLength then\n        maxLength := currentLength;\n    end;\n  end;\n  Result := maxLength;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of all the missing numbers in a given list of integers ranging from 0 to n.",
    "output": "uses System;\n\nfunction MissingSum(const arr: array of integer): integer;\nbegin\n  var n := arr.Length;\n  var total := n * (n + 1) div 2;\n  foreach var value in arr do\n    total -= value;\n  Result := total;\nend;"
  },
  {
    "instruction": "Write a function that takes an array and two numbers as input and returns the number of array elements between the two given numbers (inclusive).",
    "output": "uses System;\n\nfunction CountElementsBetween(const arr: array of integer; num1, num2: integer): integer;\nbegin\n  Result := 0;\n  foreach var value in arr do\n    if (value >= num1) and (value <= num2) then\n      Inc(Result);\nend;"
  },
  {
    "instruction": "Write a function to calculate the sum of two numbers using bitwise operations.",
    "output": "function SumUsingBitwise(x, y: integer): integer;\nbegin\n  var a := x;\n  var b := y;\n  while b <> 0 do\n  begin\n    var carry := a and b;\n    a := a xor b;\n    b := carry shl 1;\n  end;\n  Result := a;\nend;"
  },
  {
    "instruction": "Write a function to return the minimum steps to convert a number to 1 by either subtracting 1 or dividing by any of its divisor.",
    "output": "uses System;\n\nfunction MinStepsToOne(n: integer): integer;\nbegin\n  if n <= 1 then\n    exit(0);\n  var dp := new integer[n + 1];\n  dp[1] := 0;\n  for var i := 2 to n do\n  begin\n    dp[i] := i;\n    for var j := 2 to i div 2 do\n      if i mod j = 0 then\n      begin\n        var candidate := dp[j] + dp[i div j];\n        if candidate < dp[i] then\n          dp[i] := candidate;\n      end;\n  end;\n  Result := dp[n];\nend;"
  },
  {
    "instruction": "Write a function to calculate the total surface area of a cylinder given its radius and height.",
    "output": "uses System;\n\nfunction CylinderSurfaceArea(radius, height: real): real;\nbegin\n  Result := 2 * Pi * radius * (radius + height);\nend;"
  },
  {
    "instruction": "Write a function to find the sum of all elements in a binary tree.",
    "output": "type Node = class\n  public\n    Val: integer;\n    Left, Right: Node;\n    constructor Create(value: integer; leftChild: Node := nil; rightChild: Node := nil);\n    begin\n      Val := value;\n      Left := leftChild;\n      Right := rightChild;\n    end;\nend;\n\nfunction TreeSum(root: Node): integer;\nbegin\n  if root = nil then\n    exit(0);\n  Result := root.Val + TreeSum(root.Left) + TreeSum(root.Right);\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of operations required to convert a given string into a palindrome. An operation is defined as inserting a single character anywhere in the string.",
    "output": "{$zerobasedstrings}\nuses System;\n\nfunction MinOperationsToPalindrome(const s: string): integer;\nbegin\n  var n := s.Length;\n  if n <= 1 then\n    exit(0);\n  var dp := new integer[n + 1, n + 1];\n  for var i := 0 to n - 1 do\n    for var j := 0 to n - 1 do\n      if s[i] = s[n - 1 - j] then\n        dp[i + 1, j + 1] := dp[i, j] + 1\n      else\n        dp[i + 1, j + 1] := Max(dp[i, j + 1], dp[i + 1, j]);\n  Result := n - dp[n, n];\nend;"
  },
  {
    "instruction": "Write a function to find the nth Fibonacci number using iteration.",
    "output": "function FibIterative(n: integer): integer;\nbegin\n  if n = 0 then\n    exit(0);\n  if n = 1 then\n    exit(1);\n  var a := 0;\n  var b := 1;\n  for var i := 2 to n do\n  begin\n    var sum := a + b;\n    a := b;\n    b := sum;\n  end;\n  Result := b;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of all numbers present in a given string. The string may contain alphanumeric characters and numbers. The function should only consider the numbers for sum calculation.",
    "output": "uses System, System.Text.RegularExpressions;\n\nfunction SumOfNumbersInString(const s: string): integer;\nbegin\n  var sum := 0;\n  var matches := Regex.Matches(s, '\\d+');\n  foreach m : &Match in matches do\n    sum += m.Value.ToInteger;\n  Result := sum;\nend;"
  },
  {
    "instruction": "Write a function to count the number of times a specific word appears in a list of strings.",
    "output": "uses System;\n\nfunction CountWordInList(const words: array of string; const word: string): integer;\nbegin\n  Result := 0;\n  foreach var w in words do\n    if w = word then\n      Inc(Result);\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of full bags that can be filled with given capacities, rocks, and additional rocks. The function should return the maximum number of full bags.",
    "output": "uses System, System.Collections.Generic;\n\nfunction MaximumBags(const capacity, rocks: array of integer; additionalRocks: integer): integer;\nbegin\n  var gaps := new List<integer>;\n  for var i := 0 to capacity.Length - 1 do\n    gaps.Add(capacity[i] - rocks[i]);\n  gaps.Sort;\n  var filled := 0;\n  foreach var gap in gaps do\n  begin\n    if gap = 0 then\n    begin\n      Inc(filled);\n      continue;\n    end;\n    if additionalRocks < gap then\n      break;\n    additionalRocks -= gap;\n    Inc(filled);\n  end;\n  Result := filled;\nend;"
  },
  {
    "instruction": "Write a function to find the number of square submatrices that have all ones in a given matrix of ones and zeros.",
    "output": "function CountSquareSubmatrices(matrix: array of array of integer): integer;\nbegin\n  var n := matrix.Length;\n  var m := matrix[0].Length;\n  var dp := new integer[n, m];\n  var sumval := 0;\n  for var i := 0 to n - 1 do\n  begin\n    dp[i,0] := matrix[i][0];\n    sumval += dp[i,0];\n  end;\n  for var j := 1 to m - 1 do\n  begin\n    dp[0,j] := matrix[0][j];\n    sumval += dp[0,j];\n  end;\n  for var i := 1 to n - 1 do\n    for var j := 1 to m - 1 do\n    begin\n      if matrix[i][j] = 1 then\n      begin\n        dp[i,j] := Min(dp[i-1,j], Min(dp[i,j-1], dp[i-1,j-1])) + 1;\n        sumval += dp[i,j];\n      end\n      else\n        dp[i,j] := 0;\n    end;\n  Result := sumval;\nend;"
  },
  {
    "instruction": "Write a function to find the area of the largest rectangle that can be formed within a binary matrix where each 1 represents a part of the rectangle and each 0 represents an empty space.",
    "output": "function LargestRectangleArea(matrix: array of array of integer): integer;\nbegin\n  if matrix = nil then\n  begin\n    Result := 0;\n    exit;\n  end;\n  var n := matrix[0].Length;\n  var height := new integer[n + 1]; // sentinel at end\n  var maxArea := 0;\n  for var r := 0 to matrix.Length - 1 do\n  begin\n    for var i := 0 to n - 1 do\n      if matrix[r][i] = 1 then\n        height[i] := height[i] + 1\n      else\n        height[i] := 0;\n    // stack using dynamic array of integers\n    var st := new List<integer>;\n    st.Add(-1);\n    for var i := 0 to n do\n    begin\n      var curH := height[i];\n      while (st.Count > 1) and (curH < height[st[st.Count - 1]]) do\n      begin\n        var h := height[st[st.Count - 1]];\n        st.RemoveAt(st.Count - 1);\n        var w := i - 1 - st[st.Count - 1];\n        maxArea := Max(maxArea, h * w);\n      end;\n      st.Add(i);\n    end;\n  end;\n  Result := maxArea;\nend;"
  },
  {
    "instruction": "Write a function to find the intersection of two given lists of tuples. The intersection should be defined as the tuples that appear in both lists.",
    "output": "function TupleIntersection(list1, list2: array of (integer, integer)): string;\nbegin\n  var common := new List<(integer,integer)>;\n  foreach var t in list1 do\n    foreach var u in list2 do\n      if (t = u) then\n        common.Add(t);\n  Result := common.ToString; // simple textual representation\nend;"
  },
  {
    "instruction": "Write a function to determine if a list represents a valid mountain array. A mountain array is defined as an array that:\n- Has at least 3 elements\n- There exists some index i with 0 < i < arr.length - 1 such that:\n  - arr[0] < arr[1] < ... < arr[i-1] < arr[i]\n  - arr[i] > arr[i+1] > ... > arr[arr.length - 1]",
    "output": "function ValidMount(A: array of integer): boolean;\nbegin\n  var lena := A.Length;\n  if lena < 3 then\n  begin\n    Result := False;\n    exit;\n  end;\n  var flag := 0; // 0 - increasing, 1 - decreasing\n  for var i := 0 to lena - 2 do\n  begin\n    if A[i] = A[i+1] then\n    begin\n      Result := False; exit;\n    end;\n    if (flag = 0) and (A[i] > A[i+1]) then\n    begin\n      if i = 0 then\n      begin\n        Result := False; exit;\n      end;\n      flag := 1;\n      continue;\n    end;\n    if (flag = 1) and (A[i] < A[i+1]) then\n    begin\n      Result := False; exit;\n    end;\n  end;\n  Result := flag = 1;\nend;"
  },
  {
    "instruction": "Write a function that checks if a given string is a valid password. A valid password must meet the following criteria:\n1. It must be at least 8 characters long.\n2. It must contain at least one uppercase letter, one lowercase letter, one digit, and one special character.",
    "output": "function CheckPassword(password: string): boolean;\nbegin\n  if password.Length < 8 then\n  begin\n    Result := False; exit;\n  end;\n  var hasLower := False;\n  var hasUpper := False;\n  var hasDigit := False;\n  var hasSpecial := False;\n  var specials := '!@#$%^&*(),.?\":{}|<>';\n  foreach var ch in password do\n  begin\n    if ch.IsLower then hasLower := True\n    else if ch.IsUpper then hasUpper := True\n    else if ch.IsDigit then hasDigit := True\n    else if specials.IndexOf(ch) >= 0 then hasSpecial := True;\n  end;\n  Result := hasLower and hasUpper and hasDigit and hasSpecial;\nend;"
  },
  {
    "instruction": "Write a function that returns the largest number in an array using a heap data structure.",
    "output": "function HeapMax(var arr: array of integer): integer;\nbegin\n  // PascalABC.NET does not expose heapq; implement simple linear scan or build max-heap manually.\n  // Simpler and idiomatic: linear scan\n  if arr.Length = 0 then\n    raise new System.ArgumentException('Empty array');\n  var best := arr[0];\n  for var i := 1 to arr.Length - 1 do\n    if arr[i] > best then best := arr[i];\n  Result := best;\nend;"
  },
  {
    "instruction": "Write a function to calculate the number of unique permutations of a given string.",
    "output": "function UniquePermutations(s: string): biginteger;\nbegin\n  var counts := new Dictionary<integer, integer>;\n  foreach var ch in s do\n  begin\n    var code := Ord(ch);\n    if counts.ContainsKey(code) then counts[code] += 1\n    else counts[code] := 1;\n  end;\n  var n := s.Length;\n  var res := BigInteger.One;\n  // factorial using BigInteger\n  var fact : function(k: integer): BigInteger := k ->\n    begin\n      var res := BigInteger.One;\n      for var i := 2 to k do res := res * i;\n      Result := res;\n    end;\n  res := fact(n);\n  foreach var kv in counts do\n    res := res / fact(kv.Value);\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns the maximum sum that can be achieved by adding non-consecutive elements. The function should use dynamic programming to solve this problem efficiently.",
    "output": "function MaxNonConsecutiveSum(arr: array of integer): integer;\nbegin\n  if arr.Length = 0 then begin Result := 0; exit; end;\n  if arr.Length = 1 then begin Result := arr[0]; exit; end;\n  if arr.Length = 2 then begin Result := Max(arr[0], arr[1]); exit; end;\n  var dp := new integer[arr.Length];\n  dp[0] := arr[0];\n  dp[1] := Max(arr[0], arr[1]);\n  for var i := 2 to arr.Length - 1 do\n    dp[i] := Max(dp[i-1], dp[i-2] + arr[i]);\n  Result := dp[arr.Length - 1];\nend;"
  },
  {
    "instruction": "Write a function that checks if a given list can be constructed by performing a series of operations on a starting list of all 1's. The operations include selecting an index and setting its value to the sum of all elements in the current list. Return True if it is possible to construct the given list, otherwise return False.",
    "output": "function IsPossibleTarget(target: array of integer): boolean;\nbegin\n  // Use a max-heap simulation using SortedDictionary of counts (since no built-in heap)\n  var total := 0;\n  foreach var v in target do total += v;\n  var dict := new Dictionary<integer, integer>;\n  foreach var v in target do\n    if dict.ContainsKey(v) then dict[v] += 1 else dict[v] := 1;\n  while True do\n  begin\n    // get current max\n    var num := dict.Keys.Max;\n    // remove one occurrence\n    dict[num] -= 1;\n    if dict[num] = 0 then dict.Remove(num);\n    total -= num;\n    if num = 1 then begin Result := True; exit; end;\n    if (total = 1) then begin Result := True; exit; end;\n    if (num < total) or (total = 0) or (num mod total = 0) then begin Result := False; exit; end;\n    var newnum := num mod total;\n    if dict.ContainsKey(newnum) then dict[newnum] += 1 else dict[newnum] := 1;\n    total += newnum;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to check whether two given strings are anagrams or not.",
    "output": "function IsAnagram(s, t: string): boolean;\nbegin\n  if s.Length <> t.Length then\n    exit(False);\n  // Sort and compare\n  var sa := s.ToCharArray; sa.Sort;\n  var ta := t.ToCharArray; ta.Sort;\n  Result := new string(sa) = new string(ta);\nend;"
  },
  {
    "instruction": "Write a function to find the intersection of two given lists. The intersection is defined as the common elements between the two lists, with each element appearing as many times as it shows in both lists.",
    "output": "function ListIntersection(nums1, nums2: array of integer): array of integer;\nbegin\n  var counter1 := new Dictionary<integer, integer>;\n  var counter2 := new Dictionary<integer, integer>;\n  foreach var num in nums1 do\n    if counter1.ContainsKey(num) then counter1[num] += 1 else counter1[num] := 1;\n  foreach var num in nums2 do\n    if counter2.ContainsKey(num) then counter2[num] += 1 else counter2[num] := 1;\n  var res := new List<integer>;\n  foreach var key in counter1.Keys do\n    if counter2.ContainsKey(key) then\n      for var i := 1 to Min(counter1[key], counter2[key]) do\n        res.Add(key);\n  Result := res.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum sum of non-adjacent elements in a list. You can start at any index and you can skip any number of indices.",
    "output": "function MaxSumNonadjacent(nums: array of integer): integer;\nbegin\n  if nums = nil then exit(0);\n  var incl := 0;\n  var excl := 0;\n  foreach var i in nums do\n  begin\n    var new_excl := Max(excl, incl);\n    incl := excl + i;\n    excl := new_excl;\n  end;\n  Result := Max(incl, excl);\nend;"
  },
  {
    "instruction": "Write a function to check if a given number can be expressed as the sum of two square numbers.",
    "output": "function IsSquareSum(c: integer): boolean;\nbegin\n  if c < 0 then begin Result := False; exit; end;\n  var limit := Trunc(Sqrt(c));\n  for var i := 0 to limit do\n  begin\n    var remain := c - i * i;\n    var r := Trunc(Sqrt(remain));\n    if r * r = remain then begin Result := True; exit; end;\n  end;\n  Result := False;\nend;"
  },
  {
    "instruction": "Create a function that converts a string from lowercase to title case, where the first letter of each word is capitalized.",
    "output": "function ToTitleCase(s: string): string;\nbegin\n  var parts := s.Split(' ');\n  for var i := 0 to parts.Length - 1 do\n    if parts[i].Length > 0 then\n      parts[i] := parts[i][0].ToUpper + parts[i].Substring(1);\n  Result := String.Join(' ', parts);\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to partition an integer into a sum of positive integers, considering the order of addends.",
    "output": "function Partitions(n: integer): integer;\nbegin\n  var p := new integer[n + 1];\n  for var i := 0 to n do p[i] := 0;\n  p[0] := 1;\n  for var k := 1 to n do\n    for var i := k to n do\n      p[i] += p[i - k];\n  Result := p[n];\nend;"
  },
  {
    "instruction": "Write a function to find the kth smallest element in a given unsorted array using QuickSelect algorithm.",
    "output": "function QuickSelect(arr: array of integer; k: integer): integer;\nbegin\n  // Implement simple QuickSelect using iterative partitioning\n  var a := arr.Clone() as array of integer;\n  var left := 0; var right := a.Length - 1;\n  while True do\n  begin\n    var pivot := a[(left + right) div 2];\n    var i := left; var j := right;\n    while i <= j do\n    begin\n      while a[i] < pivot do i += 1;\n      while a[j] > pivot do j -= 1;\n      if i <= j then\n      begin\n        var tmp := a[i]; a[i] := a[j]; a[j] := tmp;\n        i += 1; j -= 1;\n      end;\n    end;\n    if k - 1 <= j then right := j\n    else if k - 1 >= i then left := i\n    else begin Result := a[k - 1]; exit; end;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the nearest smaller values on left side in an array.",
    "output": "function NearestSmallerLeft(arr: array of integer): array of integer;\nbegin\n  var st := new List<integer>;\n  var res := new List<integer>;\n  foreach var x in arr do\n  begin\n    while (st.Count > 0) and (st[st.Count - 1] >= x) do\n      st.RemoveAt(st.Count - 1);\n    if st.Count = 0 then res.Add(-1) else res.Add(st[st.Count - 1]);\n    st.Add(x);\n  end;\n  Result := res.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to simulate a car race where cars can accelerate, decelerate, or maintain speed. The function should return the positions of all cars after a certain time.",
    "output": "function CarRace(initial_positions, speeds: array of integer; time: integer): array of integer;\nbegin\n  var positions := new integer[initial_positions.Length];\n  for var i := 0 to initial_positions.Length - 1 do\n    positions[i] := initial_positions[i] + speeds[i] * time;\n  Result := positions;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns the minimum number of moves required to make all the values in the list unique. A move consists of choosing any element in the list and incrementing it by 1.",
    "output": "function MinMovesToUnique(A: array of integer): integer;\nbegin\n  // Approach: count frequencies, then greedily assign\n  var MAX := 100000; // a cap similar to original implementation; adjust as needed\n  var counts := new Dictionary<integer, integer>;\n  foreach var x in A do\n    if counts.ContainsKey(x) then counts[x] += 1 else counts[x] := 1;\n  var taken := new Queue<integer>;\n  var ans := 0;\n  for var i := 0 to MAX - 1 do\n  begin\n    if counts.ContainsKey(i) and (counts[i] > 1) then\n      for var t := 1 to counts[i] - 1 do\n        taken.Enqueue(i)\n    else if (taken.Count > 0) and (not counts.ContainsKey(i) or (counts[i] = 0)) then\n    begin\n      ans += i - taken.Dequeue;\n    end;\n  end;\n  Result := ans;\nend;"
  },
  {
    "instruction": "Write a function to find the equilibrium index of an array. The equilibrium index of an array is any index such that the sum of integers at lower indexes is equal to the sum of integers at higher indexes.",
    "output": "function Equilibrium(arr: array of integer): integer;\nbegin\n  var total_sum := 0;\n  foreach var v in arr do total_sum += v;\n  var left_sum := 0;\n  for var i := 0 to arr.Length - 1 do\n  begin\n    total_sum -= arr[i];\n    if left_sum = total_sum then begin Result := i; exit; end;\n    left_sum += arr[i];\n  end;\n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to find the longest common prefix among a list of strings.",
    "output": "function LongestCommonPrefix(words: array of string): string;\nbegin\n  if (words = nil) or (words.Length = 0) then\n  begin\n    Result := '';\n    exit;\n  end;\n\n  var pref := words[0];\n  for var i := 1 to words.Length - 1 do\n  begin\n    while (pref.Length > 0) and (not words[i].StartsWith(pref)) do\n      pref := pref.Substring(0, pref.Length - 1);\n    if pref.Length = 0 then break;\n  end;\n\n  Result := pref;\nend;"
  },
  {
    "instruction": "Write a function to count the number of palindromic substrings in a given string.",
    "output": "function CountPalSub(s: string): integer;\nbegin\n  var cnt := 0;\n  // expand-around-center without local functions\n  for var center := 0 to s.Length - 1 do\n  begin\n    // odd-length\n    var l := center;\n    var r := center;\n    while (l >= 0) and (r < s.Length) and (s[l] = s[r]) do\n    begin\n      cnt += 1;\n      l -= 1;\n      r += 1;\n    end;\n\n    // even-length\n    l := center;\n    r := center + 1;\n    while (l >= 0) and (r < s.Length) and (s[l] = s[r]) do\n    begin\n      cnt += 1;\n      l -= 1;\n      r += 1;\n    end;\n  end;\n\n  Result := cnt;\nend;"
  },
  {
    "instruction": "Write a function to rotate an array to the right by k steps.",
    "output": "function RotateRight(a: array of integer; k: integer): array of integer;\nbegin\n  var n := a.Length;\n  if n = 0 then\n  begin\n    Result := a;\n    exit;\n  end;\n\n  var shift := k mod n;\n  var outArr := new integer[n];\n  for var i := 0 to n - 1 do\n    outArr[(i + shift) mod n] := a[i];\n\n  Result := outArr;\nend;"
  },
  {
    "instruction": "Write a function that returns True if two given strings are one edit distance apart.",
    "output": "function OneEdit(a, b: string): boolean;\nbegin\n  var la := a.Length;\n  var lb := b.Length;\n\n  if Abs(la - lb) > 1 then\n  begin\n    Result := False;\n    exit;\n  end;\n\n  var i := 0;\n  var j := 0;\n  var diff := 0;\n\n  while (i < la) and (j < lb) do\n  begin\n    if a[i] = b[j] then\n    begin\n      i += 1;\n      j += 1;\n    end\n    else\n    begin\n      diff += 1;\n      if diff > 1 then\n      begin\n        Result := False;\n        exit;\n      end;\n\n      if la > lb then i += 1\n      else if lb > la then j += 1\n      else begin i += 1; j += 1; end;\n    end;\n  end;\n\n  diff += (la - i) + (lb - j);\n\n  Result := diff = 1;\nend;"
  },
  {
    "instruction": "Write a function to check if a given matrix is Toeplitz (each diagonal from top-left to bottom-right has the same element).",
    "output": "function IsToeplitz(mtx: array of array of integer): boolean;\nbegin\n  var rows := mtx.Length;\n  var cols := mtx[0].Length;\n\n  for var r := 1 to rows - 1 do\n    for var c := 1 to cols - 1 do\n      if mtx[r][c] <> mtx[r - 1][c - 1] then\n      begin\n        Result := False;\n        exit;\n      end;\n\n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function to generate all subsets of a given list.",
    "output": "function AllSubsets(a: array of integer): array of array of integer;\nbegin\n  var n := a.Length;\n  var total := 1 shl n;\n  var res := new List<array of integer>;\n\n  for var mask := 0 to total - 1 do\n  begin\n    var temp := new List<integer>;\n    for var bit := 0 to n - 1 do\n      if ((mask shr bit) and 1) = 1 then\n        temp.Add(a[bit]);\n    res.Add(temp.ToArray);\n  end;\n\n  Result := res.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to compute the digital root of a number.",
    "output": "function DigitalRoot(x: integer): integer;\nbegin\n  if x = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  Result := 1 + (x - 1) mod 9;\nend;"
  },
  {
    "instruction": "Write a function to check if brackets in a string are balanced.",
    "output": "function BalancedBrackets(s: string): boolean;\nbegin\n  var st := new List<char>;\n\n  foreach var ch in s do\n  begin\n    if (ch = '(') or (ch = '[') or (ch = '{') then\n      st.Add(ch)\n    else if (ch = ')') or (ch = ']') or (ch = '}') then\n    begin\n      if st.Count = 0 then\n      begin\n        Result := False;\n        exit;\n      end;\n\n      var top := st[st.Count - 1];\n      st.RemoveAt(st.Count - 1);\n\n      if (ch = ')') and (top <> '(') then begin Result := False; exit; end;\n      if (ch = ']') and (top <> '[') then begin Result := False; exit; end;\n      if (ch = '}') and (top <> '{') then begin Result := False; exit; end;\n    end;\n  end;\n\n  Result := st.Count = 0;\nend;"
  },
  {
    "instruction": "Write a function to calculate the number of trailing zeros in n factorial.",
    "output": "function TrailingZeros(n: integer): integer;\nbegin\n  var countZeros := 0;\n  var t := n;\n  while t > 0 do\n  begin\n    t := t div 5;\n    countZeros += t;\n  end;\n  Result := countZeros;\nend;"
  },
  {
    "instruction": "Write a function to merge two sorted lists.",
    "output": "function MergeSorted(a, b: array of integer): array of integer;\nbegin\n  var i := 0;\n  var j := 0;\n  var merged := new List<integer>;\n\n  while (i < a.Length) and (j < b.Length) do\n  begin\n    if a[i] < b[j] then\n    begin\n      merged.Add(a[i]);\n      i += 1;\n    end\n    else\n    begin\n      merged.Add(b[j]);\n      j += 1;\n    end;\n  end;\n\n  while i < a.Length do\n  begin\n    merged.Add(a[i]);\n    i += 1;\n  end;\n\n  while j < b.Length do\n  begin\n    merged.Add(b[j]);\n    j += 1;\n  end;\n\n  Result := merged.ToArray;\nend;"
  },
  {
    "instruction": "Create a function that takes a string as input and returns the length of the longest substring that can be repeated to recreate the original string. If no such substring exists, return 1.",
    "output": "function LongestRepeatUnitLen(s: string): integer;\nbegin\n  // Find the longest prefix whose repetition forms the whole string.\n  var n := s.Length;\n  if n = 0 then\n  begin\n    Result := 0; exit;\n  end;\n  // Check divisors of n in descending order to find longest repeating unit\n  var bestLen := 1;\n  var d := n;\n  while d >= 1 do\n  begin\n    if (n mod d = 0) then\n    begin\n      var rep := s.Substring(0, d);\n      var ok := True;\n      var k := 1;\n      while (k * d) < n do\n      begin\n        if s.Substring(k * d, d) <> rep then\n        begin\n          ok := False; break;\n        end;\n        k += 1;\n      end;\n      if ok then\n      begin\n        bestLen := d;\n        // since we iterate descending, the first valid d is the longest\n        Result := bestLen; exit;\n      end;\n    end;\n    d -= 1;\n  end;\n  Result := bestLen;\nend;"
  },
  {
    "instruction": "Write a function to remove the minimum number of overlapping intervals to make the rest non-overlapping.  Given a list of intervals where each interval is [start, end), return the minimum number to remove.",
    "output": "function MinRemoveIntervals(intervals: array of array of integer): integer;\nbegin\n  if (intervals = nil) or (intervals.Length = 0) then\n  begin\n    Result := 0; exit;\n  end;\n  // Sort intervals by end ascending\n  var idxs := new List<integer>;\n  for var i := 0 to intervals.Length - 1 do idxs.Add(i);\n  idxs.Sort((a,b)->\n  begin\n    var ea := intervals[a][1];\n    var eb := intervals[b][1];\n    if ea < eb then Result := -1 else if ea > eb then Result := 1 else Result := 0;\n  end);\n\n  var kept := 0;\n  var lastEnd := -MaxInt; // very small\n  foreach var i in idxs do\n  begin\n    var st := intervals[i][0];\n    var en := intervals[i][1];\n    if st >= lastEnd then\n    begin\n      kept += 1;\n      lastEnd := en;\n    end;\n  end;\n  Result := intervals.Length - kept;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of operations to reduce x to exactly 0. An operation consists of choosing an element from either the start or the end of the array and subtracting it from x. Return the minimum count, or -1 if not possible.",
    "output": "function MinOpsReduceToZero(nums: array of integer; x: integer): integer;\nbegin\n  // Equivalent: find longest subarray whose sum is total - x\n  var n := nums.Length;\n  var total := 0;\n  for var i := 0 to n - 1 do total += nums[i];\n  var target := total - x;\n  if target < 0 then begin Result := -1; exit; end;\n  if target = 0 then begin Result := n; exit; end;\n\n  var left := 0;\n  var cur := 0;\n  var bestLen := -1;\n  for var right := 0 to n - 1 do\n  begin\n    cur += nums[right];\n    while (left <= right) and (cur > target) do\n    begin\n      cur -= nums[left];\n      left += 1;\n    end;\n    if cur = target then\n      bestLen := Max(bestLen, right - left + 1);\n  end;\n  if bestLen = -1 then Result := -1\n  else Result := n - bestLen;\nend;"
  },
  {
    "instruction": "Write a function to find the largest continuous sum in a given list of integers.",
    "output": "function MaxSubarraySum(arr: array of integer): integer;\nbegin\n  if (arr = nil) or (arr.Length = 0) then begin Result := 0; exit; end;\n  var best := arr[0];\n  var cur := arr[0];\n  for var i := 1 to arr.Length - 1 do\n  begin\n    cur := Max(arr[i], cur + arr[i]);\n    best := Max(best, cur);\n  end;\n  Result := best;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest power of 2 which is greater than or equal to the given number.",
    "output": "function NextPowerOfTwo(n: integer): integer;\nbegin\n  if n <= 1 then begin Result := 1; exit; end;\n  var v := 1;\n  while v < n do v := v shl 1;\n  Result := v;\nend;"
  },
  {
    "instruction": "Write a function that checks if a string is a palindrome and contains only alphanumeric characters. Do not consider case.",
    "output": "function IsAlnumPalindrome(s: string): boolean;\nbegin\n  var i := 0; var j := s.Length - 1;\n  while i < j do\n  begin\n    while (i < j) and (not Char.IsLetterOrDigit(s[i])) do i += 1;\n    while (i < j) and (not Char.IsLetterOrDigit(s[j])) do j -= 1;\n    if i < j then\n    begin\n      if Char.ToLower(s[i]) <> Char.ToLower(s[j]) then\n      begin\n        Result := False; exit;\n      end;\n      i += 1; j -= 1;\n    end;\n  end;\n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns True if the list contains a 0 next to a 0 somewhere.",
    "output": "function HasAdjacentZeros(a: array of integer): boolean;\nbegin\n  for var i := 0 to a.Length - 2 do\n    if (a[i] = 0) and (a[i+1] = 0) then\n    begin Result := True; exit; end;\n  Result := False;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of the digits of a given number in binary form.",
    "output": "function SumBinaryDigits(x: integer): integer;\nbegin\n  var cnt := 0;\n  var v := Abs(x);\n  while v > 0 do\n  begin\n    if (v and 1) = 1 then cnt += 1;\n    v := v shr 1;\n  end;\n  Result := cnt;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest substring in string S that contains all the characters of string T.",
    "output": "function MinWindowSubstring(s, t: string): string;\nbegin\n  if (t = '') or (s = '') then begin Result := ''; exit; end;\n  var need := new Dictionary<char,integer>;\n  foreach var ch in t do\n    if need.ContainsKey(ch) then need[ch] += 1 else need[ch] := 1;\n  var have := 0;\n  var required := need.Count;\n  var left := 0;\n  var minLen := MaxInt;\n  var minL := 0;\n  var windowCounts := new Dictionary<char,integer>;\n\n  for var right := 0 to s.Length - 1 do\n  begin\n    var rc := s[right];\n    if windowCounts.ContainsKey(rc) then windowCounts[rc] += 1 else windowCounts[rc] := 1;\n    if need.ContainsKey(rc) and (windowCounts[rc] = need[rc]) then\n      have += 1;\n\n    while (have = required) and (left <= right) do\n    begin\n      var curLen := right - left + 1;\n      if curLen < minLen then\n      begin\n        minLen := curLen; minL := left;\n      end;\n      var lc := s[left];\n      windowCounts[lc] -= 1;\n      if need.ContainsKey(lc) and (windowCounts[lc] < need[lc]) then\n        have -= 1;\n      left += 1;\n    end;\n  end;\n\n  if minLen = MaxInt then Result := '' else Result := s.Substring(minL, minLen);\nend;"
  },
  {
    "instruction": "Write a function to find the largest overlap between two binary images represented as 2D arrays. The function takes two images of equal sizes and returns the maximum number of overlapping ones after translation.",
    "output": "function LargestBinaryImageOverlap(A, B: array of array of integer): integer;\nbegin\n  var n := A.Length;\n  if (n = 0) then begin Result := 0; exit; end;\n  var m := A[0].Length;\n  var best := 0;\n  // Try all translations: shiftB relative to A\n  for var dx := -(n-1) to (n-1) do\n    for var dy := -(m-1) to (m-1) do\n    begin\n      var cur := 0;\n      for var i := 0 to n - 1 do\n        for var j := 0 to m - 1 do\n        begin\n          var ii := i + dx;\n          var jj := j + dy;\n          if (ii >= 0) and (ii < n) and (jj >= 0) and (jj < m) then\n            if (A[i][j] = 1) and (B[ii][jj] = 1) then cur += 1;\n        end;\n      if cur > best then best := cur;\n    end;\n  Result := best;\nend;"
  },
  {
    "instruction": "Write a function to check if two rectangles overlap.",
    "output": "function RectanglesOverlap(r1, r2: array of integer): boolean;\nbegin\n  // Each rectangle given as [x1,y1,x2,y2] where (x1,y1) is bottom-left and (x2,y2) is top-right\n  if (r1[2] <= r2[0]) or (r2[2] <= r1[0]) then begin Result := False; exit; end; // one is left of other\n  if (r1[3] <= r2[1]) or (r2[3] <= r1[1]) then begin Result := False; exit; end; // one is below other\n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function that takes a string, a pattern, and a replacement string as input and returns the modified string after replacing all occurrences of the pattern with the replacement.",
    "output": "function ReplaceAll(s, pattern, replacement: string): string;\nbegin\n  if (pattern = '') then begin Result := s; exit; end;\n  // Use .Replace which replaces all non-overlapping occurrences\n  Result := s.Replace(pattern, replacement);\nend;"
  },
  {
    "instruction": "Write a function to determine whether a given list of non-negative integers can be partitioned into two subsets such that the sums of elements in both subsets are equal.",
    "output": "function CanPartition(nums: array of integer): boolean;\nbegin\n  var total := 0;\n  foreach var v in nums do total += v;\n  if (total mod 2) <> 0 then begin Result := False; exit; end;\n  var target := total div 2;\n  var reachable := new boolean[target + 1];\n  reachable[0] := True;\n  foreach var v in nums do\n  begin\n    for var s := target downto v do\n      if reachable[s - v] then reachable[s] := True;\n  end;\n  Result := reachable[target];\nend;"
  },
  {
    "instruction": "Write a function to convert a list of lists into a 2D matrix, where each element is multiplied by a given scalar.",
    "output": "function ScaleToMatrix(lists: array of array of integer; scalar: integer): array [,] of integer;\nbegin\n  var rows := lists.Length;\n  if rows = 0 then\n    exit(new integer[0, 0]);\n  var cols := lists[0].Length;\n  Result := new integer[rows, cols];\n  for var i := 0 to rows - 1 do\n    for var j := 0 to cols - 1 do\n      Result[i, j] := lists[i][j] * scalar;\nend;"
  },
  {
    "instruction": "Write a function that takes two lists as input and returns a new list where each element is the product of the elements at the same index from the two input lists. If lists differ in length, stop at the shorter length.",
    "output": "function ElementwiseProduct(a, b: array of integer): array of integer;\nbegin\n  var n := Min(a.Length, b.Length);\n  var out := new integer[n - 1];\n  for var i := 0 to n - 1 do\n    out[i] := a[i] * b[i];\n  Result := out;\nend;"
  },
  {
    "instruction": "Write a function to find the element that is repeated n times in an integer array nums with the following property: the array has size 2n and contains n+1 unique elements, one of which is repeated n times. Return the repeated element.",
    "output": "function RepeatedNTimes(nums: array of integer): integer;\nbegin\n  var counts := new Dictionary<integer,integer>;\n  foreach var v in nums do\n  begin\n    if counts.ContainsKey(v) then counts[v] += 1 else counts[v] := 1;\n    if counts[v] > 1 then // the repeated element will quickly exceed 1 often\n    begin\n      if counts[v] >= nums.Length div 2 then begin Result := v; exit; end;\n    end;\n  end;\n  // fallback: find max count\n  var best := nums[0]; var bestCnt := 0;\n  foreach var kv in counts do\n    if kv.Value > bestCnt then begin bestCnt := kv.Value; best := kv.Key; end;\n  Result := best;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest set of vertices from which all nodes in a directed graph are reachable. The graph is given as number of nodes n and an edges list edges where each edge is [from, to].",
    "output": "function SmallestVertices(n: integer; edges: array of array of integer): array of integer;\nbegin\n  var indeg := new integer[n - 1];\n  for var i := 0 to n - 1 do indeg[i] := 0;\n  for var e := 0 to edges.Length - 1 do\n  begin\n    var toNode := edges[e][1];\n    indeg[toNode] += 1;\n  end;\n  var res := new List<integer>;\n  for var i := 0 to n - 1 do\n    if indeg[i] = 0 then res.Add(i);\n  Result := res.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest possible perimiter of a rectangle with a given area.",
    "output": "function MinPerimeterForArea(areaVal: integer): integer;\nbegin\n  if areaVal <= 0 then begin Result := 0; exit; end;\n  var best := MaxInt;\n  var i := 1;\n  while i * i <= areaVal do\n  begin\n    if (areaVal mod i) = 0 then\n    begin\n      var j := areaVal div i;\n      var p := 2 * (i + j);\n      if p < best then best := p;\n    end;\n    i += 1;\n  end;\n  Result := best;\nend;"
  },
  {
    "instruction": "Write a function to find the power of a number in a given modular value. The function should take three parameters: base, exponent, and modulus, and return (base^exponent) mod modulus efficiently.",
    "output": "function ModPow(baseVal: Int64; exponentVal: Int64; modulusVal: Int64): Int64;\nbegin\n  if modulusVal = 1 then begin Result := 0; exit; end;\n  var res := Int64(1) mod modulusVal;\n  var a := (baseVal mod modulusVal + modulusVal) mod modulusVal;\n  var e := exponentVal;\n  while e > 0 do\n  begin\n    if (e and 1) = 1 then res := (res * a) mod modulusVal;\n    a := (a * a) mod modulusVal;\n    e := e shr 1;\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as an argument and returns a dictionary where keys are the negative numbers and values are their squares.",
    "output": "function NegativesToSquares(nums: array of integer): Dictionary<integer, integer>;\nbegin\n  var map := new Dictionary<integer, integer>;\n  foreach var v in nums do\n    if v < 0 then\n      if not map.ContainsKey(v) then map[v] := v * v;\n  Result := map;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum sum of a subarray of size k in the given array.",
    "output": "function MaxSubarraySumK(arr: array of integer; k: integer): integer;\nbegin\n  if (arr = nil) or (k <= 0) or (k > arr.Length) then\n  begin\n    Result := 0;\n    exit;\n  end;\n\n  var windowSum := 0;\n  for var i := 0 to k - 1 do\n    windowSum += arr[i];\n  var best := windowSum;\n\n  for var i := k to arr.Length - 1 do\n  begin\n    windowSum := windowSum + arr[i] - arr[i - k];\n    if windowSum > best then best := windowSum;\n  end;\n\n  Result := best;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings, where each str... list where each word in the original strings has been reversed.",
    "output": "function ReverseWordsInStrings(stringsArr: array of string): array of string;\nbegin\n  if stringsArr = nil then\n  begin\n    Result := new string[0];\n    exit;\n  end;\n  var n := stringsArr.Length;\n  SetLength(Result, n);\n  for var i := 0 to n - 1 do\n  begin\n    var words := stringsArr[i].Split(' ');\n    var outWords := new List<string>;\n    for var w := 0 to words.Length - 1 do\n      outWords.Add(new string(words[w].ToCharArray.Reverse.ToArray));\n    Result[i] := String.Join(' ', outWords);\n  end;\nend;"
  },
  {
    "instruction": "Write a function to calculate the maximum depth of a g...a leaf node, counting the number of dictionary layers traversed.",
    "output": "function MaxDictDepth(obj: object): integer;\nbegin\n  // Computes maximum nesting depth of dictionaries. Non-dictionary values count as depth 0.\n  if obj = nil then begin Result := 0; exit; end;\n  var dictType := typeof(System.Collections.Generic.Dictionary<string, object>);\n  if obj.GetType() <> dictType then\n  begin\n    // If it's not the expected dictionary type, check assignability\n    if not (obj is System.Collections.Generic.IDictionary<string, object>) then\n    begin\n      Result := 0; exit;\n    end;\n  end;\n\n  var queue := new List<object>;\n  queue.Add(obj);\n  var depth := 0;\n  while queue.Count > 0 do\n  begin\n    var nextLevel := new List<object>;\n    foreach var item in queue do\n    begin\n      var d := item as System.Collections.Generic.IDictionary<string, object>;\n      if d <> nil then\n      begin\n        foreach var kv in d do\n          if (kv.Value <> nil) and (kv.Value is System.Collections.Generic.IDictionary<string, object>) then\n            nextLevel.Add(kv.Value);\n      end;\n    end;\n    depth += 1;\n    queue := nextLevel;\n  end;\n  Result := depth;\nend;"
  },
  {
    "instruction": "Write a function to check if a string can be rearranged so th...ble, return a rearranged string. If not, return an empty string.",
    "output": "function RearrangeNoAdjacent(s: string): string;\nbegin\n  if s = '' then begin Result := ''; exit; end;\n  var counts := new Dictionary<char,integer>;\n  foreach var ch in s do\n    if counts.ContainsKey(ch) then counts[ch] += 1 else counts[ch] := 1;\n\n  var maxCount := 0; var maxChar := #0;\n  foreach var kv in counts do\n    if kv.Value > maxCount then begin maxCount := kv.Value; maxChar := kv.Key; end;\n\n  if maxCount > (s.Length + 1) div 2 then begin Result := ''; exit; end;\n\n  // Greedy rebuild using a list of pairs sorted by remaining count\n  var resultChars := new List<char>;\n  var pq := new List<(char,integer)>;\n  foreach var kv in counts do pq.Add((kv.Key, kv.Value));\n\n  while pq.Count > 0 do\n  begin\n    pq.Sort((a,b)-> if a.Item2 > b.Item2 then Result := -1 else if a.Item2 < b.Item2 then Result := 1 else Result := 0);\n    var first := pq[0];\n    // pick first\n    resultChars.Add(first.Item1);\n    first := (first.Item1, first.Item2 - 1);\n    pq.RemoveAt(0);\n    if pq.Count = 0 then\n    begin\n      if first.Item2 > 0 then begin Result := ''; exit; end;\n      break;\n    end;\n    // pick second\n    pq.Sort((a,b)-> if a.Item2 > b.Item2 then Result := -1 else if a.Item2 < b.Item2 then Result := 1 else Result := 0);\n    var second := pq[0];\n    resultChars.Add(second.Item1);\n    second := (second.Item1, second.Item2 - 1);\n    pq.RemoveAt(0);\n    if first.Item2 > 0 then pq.Add(first);\n    if second.Item2 > 0 then pq.Add(second);\n  end;\n\n  Result := new string(resultChars.ToArray);\nend;"
  },
  {
    "instruction": "Write a function that checks if a given string has balanced p...g bracket of the same type and the brackets are properly nested.",
    "output": "function IsBalancedParentheses(s: string): boolean;\nbegin\n  var st := new List<char>;\n  foreach var ch in s do\n  begin\n    if (ch = '(') or (ch = '[') or (ch = '{') then st.Add(ch)\n    else if (ch = ')') or (ch = ']') or (ch = '}') then\n    begin\n      if st.Count = 0 then begin Result := False; exit; end;\n      var top := st[st.Count - 1]; st.RemoveAt(st.Count - 1);\n      if (ch = ')') and (top <> '(') then begin Result := False; exit; end;\n      if (ch = ']') and (top <> '[') then begin Result := False; exit; end;\n      if (ch = '}') and (top <> '{') then begin Result := False; exit; end;\n    end;\n  end;\n  Result := st.Count = 0;\nend;"
  },
  {
    "instruction": "Write a function to find the largest subarray with equal number of 0's and 1's.",
    "output": "function LargestEqualZeroOneSubarray(arr: array of integer): integer;\nbegin\n  // Return length of largest subarray with equal 0s and 1s\n  var n := arr.Length;\n  if n = 0 then begin Result := 0; exit; end;\n  var sum := 0;\n  var earliest := new Dictionary<integer, integer>;\n  earliest[0] := -1;\n  var best := 0;\n  for var i := 0 to n - 1 do\n  begin\n    if arr[i] = 0 then sum -= 1 else sum += 1;\n    if earliest.ContainsKey(sum) then\n      best := Max(best, i - earliest[sum])\n    else\n      earliest[sum] := i;\n  end;\n  Result := best;\nend;"
  },
  {
    "instruction": "Write a function to check if the given string is a val...utation is a string that can be rearranged to form a palindrome.",
    "output": "function CanPermutePalindrome(s: string): boolean;\nbegin\n  var counts := new Dictionary<char,integer>;\n  foreach var ch in s do\n    if counts.ContainsKey(ch) then counts[ch] += 1 else counts[ch] := 1;\n  var oddCount := 0;\n  foreach var kv in counts do\n    if (kv.Value and 1) = 1 then oddCount += 1;\n  // palindrome permutation allowed: at most one odd count\n  Result := oddCount <= 1;\nend;"
  },
  {
    "instruction": "Write a function to find the average temperature of each day from a list of hourly temperatures.",
    "output": "function DailyAverages(hourly: array of double; hoursPerDay: integer): array of double;\nbegin\n  if (hourly = nil) or (hoursPerDay <= 0) then\n  begin\n    Result := new double[0]; exit;\n  end;\n  var days := hourly.Length div hoursPerDay;\n  SetLength(Result, days);\n  for var d := 0 to days - 1 do\n  begin\n    var sum := 0.0;\n    for var h := 0 to hoursPerDay - 1 do\n      sum += hourly[d * hoursPerDay + h];\n    Result[d] := sum / hoursPerDay;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest and largest digits in a given integer.",
    "output": "function MinMaxDigits(n: Int64): array of integer;\nbegin\n  var v := Abs(n);\n  if v = 0 then\n  begin\n    SetLength(Result, 2);\n    Result[0] := 0; Result[1] := 0; exit;\n  end;\n  var minD := 9; var maxD := 0;\n  while v > 0 do\n  begin\n    var d := v mod 10;\n    if d < minD then minD := d;\n    if d > maxD then maxD := d;\n    v := v div 10;\n  end;\n  SetLength(Result, 2);\n  Result[0] := minD; Result[1] := maxD;\nend;"
  },
  {
    "instruction": "Write a function to find the top k largest numbers in an array.",
    "output": "function TopKLargest(nums: array of integer; k: integer): array of integer;\nbegin\n  if (nums = nil) or (k <= 0) then\n  begin\n    Result := new integer[0]; exit;\n  end;\n  var n := nums.Length;\n  if k >= n then\n  begin\n    var all := nums.Clone() as array of integer;\n    &Array.Sort(all);\n    &Array.Reverse(all);\n    Result := all; exit;\n  end;\n\n  // Use a small min-heap simulation via sorted list of size k\n  var topList := new List<integer>;\n  for var i := 0 to n - 1 do\n  begin\n    if topList.Count < k then\n    begin\n      topList.Add(nums[i]);\n      topList.Sort;\n    end\n    else if nums[i] > topList[0] then\n    begin\n      topList[0] := nums[i];\n      topList.Sort;\n    end;\n  end;\n  // topList is sorted ascending -> reverse to get descending\n  topList.Reverse;\n  Result := topList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of coins required to make a given amount.",
    "output": "function Mincoinchange(coins: array of integer; amount: integer): integer;\nbegin\n  \n  var dp := new integer[amount + 1];\n  var inf := amount + 1;\n  for var i := 0 to amount do dp[i] := inf;\n  dp[0] := 0;\n  for var i := 1 to amount do\n  begin\n    for var c := 0 to coins.Length - 1 do\n      if coins[c] <= i then\n        dp[i] := Min(dp[i], dp[i - coins[c]] + 1);\n  end;\n  if dp[amount] > amount then Result := -1 else Result := dp[amount];\nend;"
  },
  {
    "instruction": "Write a function to validate the given password based on the following conditions:\n- Minimum eight characters long\n- Contains at least one number\n- Contains at least one letter\n- Contains at least one special character (!@#$%^&*)",
    "output": "function ValidatePassword(password: string): boolean;\nbegin\n\nvar hasLower := False;\nvar hasUpper := False;\nvar hasDigit := False;\nvar hasSpecial := False;\nif password.Length < 8 then begin Result := False; exit; end;\nvar specials := '!@#$%^&*';\nforeach var ch in password do\nbegin\n  if Char.IsLower(ch) then hasLower := True\n  else if Char.IsUpper(ch) then hasUpper := True\n  else if Char.IsDigit(ch) then hasDigit := True\n  else if specials.IndexOf(ch) >= 0 then hasSpecial := True;\nend;\nResult := hasLower and hasUpper and hasDigit and hasSpecial;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns the list sorted in descending order using the bubble sort algorithm.",
    "output": "function BubbleSortDesc(arr: array of integer): array of integer;\nbegin\n\nvar n := arr.Length;\nif n <= 1 then begin Result := arr; exit; end;\nvar a := arr.Clone() as array of integer;\nfor var i := 0 to n - 2 do\n  for var j := 0 to n - 2 - i do\n    if a[j] < a[j+1] then\n    begin\n      var tmp := a[j]; a[j] := a[j+1]; a[j+1] := tmp;\n    end;\nResult := a;\nend;"
  },
  {
    "instruction": "Write a function to calculate the number of unique pairs in a given list of integers that have a specific difference.\n\nFor example, given the list [1, 3, 1, 5, 4] and the difference k = 0, the function should return 1 because there is one pair of integers that have a difference of 0, namely (1, 1).",
    "output": "function KDiffPairs(nums: array of integer; k: integer): integer;\nbegin\n\nvar cnt := 0;\nvar freq := new Dictionary<integer,integer>;\nforeach var v in nums do if freq.ContainsKey(v) then freq[v] += 1 else freq[v] := 1;\nif k = 0 then\nbegin\n  foreach var kv in freq do if kv.Value > 1 then cnt += 1;\n  Result := cnt; exit;\nend;\nforeach var kv in freq do if freq.ContainsKey(kv.Key + k) then cnt += 1;\nResult := cnt;\nend;"
  },
  {
    "instruction": "Write a function that takes a string and returns the number of alphabetic characters in it. Alphabetic characters are those that are letters of the alphabet, either upper case or lower case.",
    "output": "function AlphabeticCount(s: string): integer;\nbegin\n\nvar c := 0;\nforeach var ch in s do if Char.IsLetter(ch) then c += 1;\nResult := c;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings as input and returns a list where each string is reversed. If the input string contains any digits, the digit should be moved to the end of the string in the output.",
    "output": "function ReverseAndMoveDigits(stringsArr: array of string): array of string;\nbegin\n\nif stringsArr = nil then begin Result := new string[0]; exit; end;\nvar out := new string[stringsArr.Length - 1];\nfor var i := 0 to stringsArr.Length - 1 do\nbegin\n  var s := stringsArr[i];\n  var letters := new List<char>; var digits := new List<char>;\n  foreach var ch in s do if Char.IsDigit(ch) then digits.Add(ch) else letters.Add(ch);\n  letters.Reverse; digits.Reverse;\n  Result[i] := new string(letters.ToArray) + new string(digits.ToArray);\nend;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns a new list with each element's sign (positive, negative, or zero) as a string. Positive numbers should be represented as \"+\", negative numbers as \"-\", and zero as \"0\".",
    "output": "function SignList(numbers: array of integer): array of string;\nbegin\n\nvar out := new string[numbers.Length - 1];\nfor var i := 0 to numbers.Length - 1 do\n  if numbers[i] > 0 then out[i] := '+' else if numbers[i] < 0 then out[i] := '-' else out[i] := '0';\nResult := out;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to make change for a given amount using a given set of coin denominations.",
    "output": "function NumWaysToMakeChange(n: integer; denoms: array of integer): integer;\nbegin\n  var ways := ArrFill(n + 1, 0);\n  ways[0] := 1;\n  foreach var denom in denoms do\n    for var amount := 1 to n do\n      if denom <= amount then\n        ways[amount] += ways[amount - denom];\n  Result := ways[n];\nend;"
  },
  {
    "instruction": "Write a function to convert a string into a list of words.",
    "output": "function ConvertStringToList(str1: string): array of string;\nbegin\n  Result := str1.ToWords;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of Fibonacci numbers whose sum is equal to a given number. Each Fibonacci number can be used multiple times.",
    "output": "function FindFibonacciNumbers(num: integer): integer;\nbegin\n  if num = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  var fibs := Lst(1, 1);\n  while fibs.Last < num do\n    fibs.Add(fibs[fibs.Count - 1] + fibs[fibs.Count - 2]);\n  var count := 0;\n  while num > 0 do\n  begin\n    var idx := fibs.Count - 1;\n    while fibs[idx] > num do\n      idx -= 1;\n    num -= fibs[idx];\n    count += 1;\n  end;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the longest sequence of consecutive zeros surrounded by ones at the two ends in the binary representation of a given positive integer.",
    "output": "function LongestZeros(n: integer): integer;\nbegin\n  var binary := Convert.ToString(n, 2);\n  var maxZeros := 0;\n  var currentZeros := 0;\n  var started := False;\n  foreach var bit in binary do\n  begin\n    if bit = '0' then\n    begin\n      if started then\n        currentZeros += 1\n      else\n      begin\n        started := True;\n        currentZeros := 1;\n      end;\n    end\n    else\n    begin\n      if started then\n      begin\n        maxZeros := Max(maxZeros, currentZeros);\n        currentZeros := 0;\n      end;\n    end;\n  end;\n  Result := maxZeros;\nend;"
  },
  {
    "instruction": "Write a function to rotate an array by d elements.",
    "output": "function RotateArray(input: array of integer; d: integer): array of integer;\nbegin\n  Result := input[d:] + input[:d];\nend;"
  },
  {
    "instruction": "Write a function to find the number of times a target value appears in a sorted list.",
    "output": "function FindTargetCount(nums: array of integer; target: integer): integer;\n\n  function BinSearch(nums: array of integer; target: integer; leftBias: boolean): integer;\n  begin\n    var lp := 0;\n    var rp := nums.Length - 1;\n    var mid := 0;\n    var index := -1;\n    while lp <= rp do\n    begin\n      mid := (lp + rp) div 2;\n      if nums[mid] = target then\n      begin\n        index := mid;\n        if leftBias then\n          rp := mid - 1\n        else\n          lp := mid + 1;\n      end\n      else if nums[mid] > target then\n        rp := mid - 1\n      else\n        lp := mid + 1;\n    end;\n    Result := index;\n  end;\n\nbegin\n  var left := BinSearch(nums, target, True);\n  var right := BinSearch(nums, target, False);\n  if left = -1 then\n    Result := 0\n  else\n    Result := right - left + 1;\nend;"
  },
  {
    "instruction": "Write a function to count the number of times a given key appears in a list using recursion.",
    "output": "function CountKeyRecursively(lst: array of integer; key: integer): integer;\nbegin\n  if lst.Length = 0 then\n    Result := 0\n  else\n    Result := Ord(lst[0] = key) + CountKeyRecursively(lst[1:], key);\nend;"
  },
  {
    "instruction": "Write a function to find the intersection of two sorted lists.",
    "output": "function IntersectionSortedLists(list1, list2: array of integer): array of integer;\nbegin\n  var i := 0;\n  var j := 0;\n  var resultList := new List<integer>;\n  while (i < list1.Length) and (j < list2.Length) do\n  begin\n    if list1[i] < list2[j] then\n      i += 1\n    else if list1[i] > list2[j] then\n      j += 1\n    else\n    begin\n      resultList.Add(list1[i]);\n      i += 1;\n      j += 1;\n    end;\n  end;\n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the n-th digit of the Champernowne's constant. Champernowne's constant is a transcendental real constant whose decimal expansion has important properties in number theory. It is constructed by concatenating the positive integers: 0.123456789101112131415...",
    "output": "function NthDigitChampernowne(n: integer): integer;\nbegin\n  var count := 0;\n  var digit := 1;\n  while True do\n  begin\n    var rangeOfDigits := 9 * (Round(Power(10, digit - 1))) * digit;\n    if n <= rangeOfDigits + count then\n      break;\n    count += rangeOfDigits;\n    digit += 1;\n  end;\n  n -= count;\n  var number := Round(Power(10, digit - 1)) + (n - 1) div digit;\n  var numStr := number.ToString;\n  if digit > 1 then\n    Result := StrToInt(numStr[(n - 1) mod digit + 1])\n  else\n    Result := number;\nend;"
  },
  {
    "instruction": "Write a function that implements the Radix Sort algorithm to sort a given list of non-negative integers. Radix Sort is a non-comparative, integer sorting algorithm that sorts data with integer keys by grouping keys by the individual digits which share the same significant position and value. It works by processing individual digits of integer numbers, starting from the least significant digit and moving towards the most significant digit.",
    "output": "function RadixSort(nums: array of integer): array of integer;\n\n  function MaxBits(nums: array of integer): integer;\n  begin\n    var maxNum := nums.Max;\n    var bits := 0;\n    while maxNum > 0 do\n    begin\n      maxNum := maxNum div 10;\n      bits += 1;\n    end;\n    Result := bits;\n  end;\n\n  function GetDigit(num: integer; ind: integer): integer;\n  begin\n    Result := (num div (Round(Power(10, ind)))) mod 10;\n  end;\n\nbegin\n  var digits := MaxBits(nums);\n  for var d := 0 to digits - 1 do\n  begin\n    var buckets := new List<integer>[10];\n    for var i := 0 to 9 do\n      buckets[i] := new List<integer>;\n    foreach var num in nums do\n    begin\n      var digit := GetDigit(num, d);\n      buckets[digit].Add(num);\n    end;\n    var tempList := new List<integer>;\n    for var i := 0 to 9 do\n      tempList.AddRange(buckets[i]);\n    nums := tempList.ToArray;\n  end;\n  Result := nums;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of the digits of a given integer in reverse order.",
    "output": "function ReverseSumDigits(num: integer): integer;\nbegin\n  var sum := 0;\n  while num > 0 do\n  begin\n    sum += num mod 10;\n    num := num div 10;\n  end;\n  Result := sum;\nend;"
  },
  {
    "instruction": "Write a function to perform the element-wise multiplication of two given tuples.",
    "output": "function TupleElementwiseMultiplication(t1, t2: (integer, integer)): (integer, integer);\nbegin\n  Result := (t1[0] * t2[0], t1[1] * t2[1]);\nend;"
  },
  {
    "instruction": "Write a function to sort an array of integers in ascending order by the number of 1's in their binary representation. In case of a tie, sort them in ascending order.",
    "output": "function CountOnes(n: integer): integer;\n  begin\n    var binary := Convert.ToString(n, 2);\n    Result := binary.Count(c -> c = '1');\n  end;\n function SortByBits(arr: array of integer): array of integer;\nbegin\n  Result := arr.OrderBy(x -> (CountOnes(x), x)).ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the Greatest Common Divisor (GCD) of two numbers.",
    "output": "function FindGCD(x, y: integer): integer;\nbegin\n  while y <> 0 do\n  begin\n    (x, y) := (y, x mod y);\n  end;\n  Result := x;\nend;"
  },
  {
    "instruction": "Write a function to check if a given string is a valid IPv4 address.\n\nAn IP address is considered valid if it consists of four parts separated by dots, where each part is a decimal number from 0 to 255. Each part should not contain leading zeroes unless it is 0.",
    "output": "function IsValidIP(ip: string): boolean;\nbegin\n  var parts := ip.Split('.');\n  if parts.Length <> 4 then\n  begin\n    Result := False;\n    exit;\n  end;\n  foreach var part in parts do\n  begin\n    if not part.All(Char.IsDigit) then\n    begin\n      Result := False;\n      exit;\n    end;\n    if (part.Length > 1) and (part[1] = '0') then\n    begin\n      Result := False;\n      exit;\n    end;\n    var num := StrToInt(part);\n    if (num < 0) or (num > 255) then\n    begin\n      Result := False;\n      exit;\n    end;\n  end;\n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function to find the longest sequence of consecutive zeros in the binary representation of a given positive integer that is surrounded by ones at both ends.",
    "output": "function FindLongestConsecutiveZeros(n: integer): integer;\nbegin\n  var binary := Convert.ToString(n, 2);\n  var maxGap := 0;\n  var currentGap := 0;\n  var previousBit: char := #0;\n  foreach var bit in binary do\n  begin\n    if bit = '1' then\n    begin\n      if previousBit = '0' then\n        maxGap := Max(maxGap, currentGap);\n      currentGap := 0;\n    end\n    else\n      currentGap += 1;\n    previousBit := bit;\n  end;\n  Result := maxGap;\nend;"
  },
  {
    "instruction": "Write a function to find the number of possible ways to arrange n pairs of parentheses such that they are balanced.",
    "output": "function NumBalancedParentheses(n: integer): integer;\nbegin\n  var catalan := ArrFill(n + 1, 0);\n  catalan[0] := 1;\n  catalan[1] := 1;\n  for var i := 2 to n do\n    for var j := 0 to i - 1 do\n      catalan[i] += catalan[j] * catalan[i - j - 1];\n  Result := catalan[n];\nend;"
  },
  {
    "instruction": "Write a function to check if a given matrix can be modified in place to contain 0s at the positions specified in a list of tuples. Each tuple contains the row and column indices where the cell should be set to 0. The function should return True if the matrix can be modified without changing the values of other cells and False otherwise. Note: The matrix should not be modified during the check.",
    "output": "function CanSetZeros(matrix: array [,] of integer; zeros: array of (integer, integer)): boolean;\nbegin\n  var R := matrix.GetLength(0);\n  var C := matrix.GetLength(1);\n  foreach var tuple in zeros do\n  begin\n    var first := tuple[0];\n    var second := tuple[1];\n    if (first < 0) or (first >= R) or (second < 0) or (second >= C) then\n    begin\n      Result := False;\n      exit;\n    end;\n    for var k := 0 to C - 1 do\n      if (matrix[first, k] = 0) and not zeros.Contains((first, k)) then\n      begin\n        Result := False;\n        exit;\n      end;\n    for var k := 0 to R - 1 do\n      if (matrix[k, second] = 0) and not zeros.Contains((k, second)) then\n      begin\n        Result := False;\n        exit;\n      end;\n  end;\n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum depth of a binary tree.",
    "output": "type\n  TreeNode = class\n    val: integer;\n    left, right: TreeNode;\n    constructor(x: integer; leftNode: TreeNode := nil; rightNode: TreeNode := nil);\n    begin\n      val := x;\n      left := leftNode;\n      right := rightNode;\n    end;\n  end;\n\nfunction MaxDepth(root: TreeNode): integer;\nbegin\n  if root = nil then\n    Result := 0\n  else\n  begin\n    var depthL := MaxDepth(root.left) + 1;\n    var depthR := MaxDepth(root.right) + 1;\n    Result := Max(depthL, depthR);\n  end;\nend;"
  },
  {
    "instruction": "Write a function to rearrange the elements of a given list such that all negative numbers appear before all positive numbers, while maintaining the relative order of the positive and negative elements.",
    "output": "function SegregateElement(arr: array of integer): array of integer;\nbegin\n  var temp := ArrFill(arr.Length, 0);\n  var j := 0;\n  for var i := 0 to arr.Length - 1 do\n    if arr[i] < 0 then\n    begin\n      temp[j] := arr[i];\n      j += 1;\n    end;\n  if (j = arr.Length) or (j = 0) then\n  begin\n    Result := arr;\n    exit;\n  end;\n  for var i := 0 to arr.Length - 1 do\n    if arr[i] >= 0 then\n    begin\n      temp[j] := arr[i];\n      j += 1;\n    end;\n  for var k := 0 to arr.Length - 1 do\n    arr[k] := temp[k];\n  Result := arr;\nend;"
  },
  {
    "instruction": "Write a function to merge two lists of tuples by summing the corresponding elements of the tuples.",
    "output": "function MergeTuples(list1, list2: array of (integer, integer)): array of (integer, integer);\nbegin\n  var mergedList := new List<(integer, integer)>;\n  for var i := 0 to list1.Length - 1 do\n  begin\n    var mergedTuple := (list1[i][0] + list2[i][0], list1[i][1] + list2[i][1]);\n    mergedList.Add(mergedTuple);\n  end;\n  Result := mergedList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to determine if a given string 'typed' could be a long-pressed version of another string 'name'. A string is considered long-pressed if it can be obtained by pressing and holding one or more characters of the original string for a longer period.\n\nFor example, 'leet' can become 'lleeett' by holding the 'e' and 't' characters longer.",
    "output": "function IsLongPressedName(name, typed: string): boolean;\nbegin\n  var nameIndex := 0;\n  var typedIndex := 0;\n  while (nameIndex < name.Length) and (typedIndex < typed.Length) do\n  begin\n    if name[nameIndex] = typed[typedIndex] then\n    begin\n      nameIndex += 1;\n      typedIndex += 1;\n    end\n    else if (typedIndex > 0) and (typed[typedIndex] = typed[typedIndex - 1]) then\n      typedIndex += 1\n    else\n    begin\n      Result := False;\n      exit;\n    end;\n  end;\n  if nameIndex = name.Length then\n    Result := True\n  else\n    Result := False;\nend;"
  },
  {
    "instruction": "Write a function to find the number of subarrays in a given list of integers that have a product less than a given threshold.",
    "output": "function SubarrayProductLessThanK(nums: array of integer; k: integer): integer;\nbegin\n  if k <= 1 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  var prod := 1;\n  var ans := 0;\n  var left := 0;\n  for var right := 0 to nums.Length - 1 do\n  begin\n    prod *= nums[right];\n    while prod >= k do\n    begin\n      prod := prod div nums[left];\n      left += 1;\n    end;\n    ans += right - left + 1;\n  end;\n  Result := ans;\nend;"
  },
  {
    "instruction": "Write a function to convert a given string to uppercase without using the built-in `ToUpper()` function.",
    "output": "function Uppercase(s: string): string;\nbegin\n  var chars := s.ToCharArray;\n  for var i := 0 to chars.Length - 1 do\n    if ('a' <= chars[i]) and (chars[i] <= 'z') then\n      chars[i] := Chr(Ord(chars[i]) - 32);\n  Result := new string(chars);\nend;"
  },
  {
    "instruction": "Write a function that accepts a string and a numerical value. The function should return the string repeated the number of times specified by the numerical value. If the numerical value is less than 1, the function should return an empty string.",
    "output": "function RepeatString(s: string; n: integer): string;\nbegin\n  if n < 1 then\n    Result := ''\n  else\n    Result := s * n;\nend;"
  },
  {
    "instruction": "Write a function to flatten a nested list of integers and return the sum of all elements.",
    "output": "function FlattenHelper(lst: List<object>): sequence of integer;\n  begin\n    foreach var i in lst do\n      if i is List<object> then\n        foreach var inner in FlattenHelper(i as List<object>) do\n          yield inner\n      else\n        yield integer(i);\n  end;\n function FlattenAndSum(nestedList: List<object>): integer;\nbegin\n  Result := FlattenHelper(nestedList).Sum;\nend;"
  },
  {
    "instruction": "Write a function that takes a string as input and returns the number of alphabetic characters in the string.",
    "output": "function CountAlphabeticChars(s: string): integer;\nbegin\n  var count := 0;\n  foreach var char in s do\n    if char.IsLetter then\n      count += 1;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns a tuple containing the maximum, minimum, and average values of the list.",
    "output": "function MaxMinAvg(lst: array of integer): (integer, integer, real);\nbegin\n  var maxValue := lst.Max;\n  var minValue := lst.Min;\n  var avgValue := lst.Average;\n  Result := (maxValue, minValue, avgValue);\nend;"
  },
  {
    "instruction": "Write a function to find the maximum sum of a subarray with the length of exactly k.",
    "output": "function MaxSubarraySumK(arr: array of integer; k: integer): integer;\nbegin\n  if (arr.Length = 0) or (k <= 0) then\n  begin\n    Result := 0;\n    exit;\n  end;\n  if k > arr.Length then\n  begin\n    Result := arr.Sum;\n    exit;\n  end;\n  var maxSum := arr[:k].Sum;\n  var currentSum := maxSum;\n  for var i := k to arr.Length - 1 do\n  begin\n    currentSum += arr[i] - arr[i - k];\n    maxSum := Max(maxSum, currentSum);\n  end;\n  Result := maxSum;\nend;"
  },
  {
    "instruction": "Write a function to check whether a given number is a perfect number or not. A perfect number is a positive integer that is equal to the sum of its proper divisors.",
    "output": "function CheckPerfectNum(n: integer): boolean;\nbegin\n  var sum := 0;\n  for var i := 1 to n - 1 do\n    if n mod i = 0 then\n      sum := sum + i;\n  Result := sum = n;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum area of a rectangle that can be formed by the histogram given the height of each bar in the histogram.",
    "output": "function FindMaxArea(height: array of integer): integer;\nbegin\n  var stack := new Stack<integer>;\n  var maxArea := 0;\n  var index := 0;\n  while index < height.Length do\n  begin\n    if (stack.Count = 0) or (height[index] >= height[stack.Peek]) then\n    begin\n      stack.Push(index);\n      index += 1;\n    end\n    else\n    begin\n      var top := stack.Pop;\n      var area := height[top] * (if stack.Count = 0 then index else index - stack.Peek - 1);\n      maxArea := Max(maxArea, area);\n    end;\n  end;\n  while stack.Count > 0 do\n  begin\n    var top := stack.Pop;\n    var area := height[top] * (if stack.Count = 0 then index else index - stack.Peek - 1);\n    maxArea := Max(maxArea, area);\n  end;\n  Result := maxArea;\nend;"
  },
  {
    "instruction": "Write a function that calculates the total profit from a given list of stock prices, where you can buy and sell multiple times (but you must sell the stock before you buy again).",
    "output": "function CalculateProfit(prices: array of integer): integer;\nbegin\n  var totalProfit := 0;\n  for var i := 1 to prices.Length - 1 do\n    if prices[i] > prices[i - 1] then\n      totalProfit += prices[i] - prices[i - 1];\n  Result := totalProfit;\nend;"
  },
  {
    "instruction": "Write a function to find the number of occurrences of an element in a sorted list using binary search.",
    "output": "function BinarySearchOccurrence(arr: array of integer; target: integer): integer;\n\n  function FindLeftIndex(arr: array of integer; target: integer): integer;\n  begin\n    var left := 0;\n    var right := arr.Length - 1;\n    while left <= right do\n    begin\n      var mid := left + (right - left) div 2;\n      if arr[mid] < target then\n        left := mid + 1\n      else\n        right := mid - 1;\n    end;\n    Result := left;\n  end;\n\n  function FindRightIndex(arr: array of integer; target: integer): integer;\n  begin\n    var left := 0;\n    var right := arr.Length - 1;\n    while left <= right do\n    begin\n      var mid := left + (right - left) div 2;\n      if arr[mid] <= target then\n        left := mid + 1\n      else\n        right := mid - 1;\n    end;\n    Result := right;\n  end;\n\nbegin\n  var leftIndex := FindLeftIndex(arr, target);\n  if (leftIndex = arr.Length) or (arr[leftIndex] <> target) then\n  begin\n    Result := 0;\n    exit;\n  end;\n  var rightIndex := FindRightIndex(arr, target);\n  Result := rightIndex - leftIndex + 1;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest element in a given list of numbers.",
    "output": "function GetSmallestElement(numbers: array of integer): integer;\nbegin\n  var smallest := numbers[0];\n  foreach var number in numbers do\n    if number < smallest then\n      smallest := number;\n  Result := smallest;\nend;"
  },
  {
    "instruction": "Write a function to create a histogram from a given list of integers. The histogram should be a list of tuples where each tuple contains an integer from the input list and the number of times it appears in the list.",
    "output": "function Histogram(lst: array of integer): array of (integer, integer);\nbegin\n  var hist := new Dictionary<integer, integer>;\n  foreach var i in lst do\n    if hist.ContainsKey(i) then\n      hist[i] += 1\n    else\n      hist[i] := 1;\n  Result := hist.Select(p -> (p.Key, p.Value)).ToArray;\nend;"
  },
  {
    "instruction": "Write a function to implement the Josephus problem. In this problem, people are standing in a circle waiting to be executed. Counting begins at a specified point in the circle and proceeds around the circle in a specified direction. After a specified number of people are skipped, the next person is executed. The procedure is repeated with the remaining people, starting with the next person, going in the same direction and skipping the same number of people, until only one person remains, and is freed.",
    "output": "function JosephusProblem(n, m: integer): integer;\nbegin\n  if n = 1 then\n    Result := 1\n  else\n    Result := (JosephusProblem(n - 1, m) + m - 1) mod n + 1;\nend;"
  },
  {
    "instruction": "Write a function that returns the largest Fibonacci number that is less than or equal to a given number.",
    "output": "function LargestFibonacci(n: integer): integer;\nbegin\n  if n <= 1 then\n  begin\n    Result := n;\n    exit;\n  end;\n  var fib1 := 0;\n  var fib2 := 1;\n  var fibn := 1;\n  while fibn <= n do\n  begin\n    fib1 := fib2;\n    fib2 := fibn;\n    fibn := fib1 + fib2;\n  end;\n  Result := fib2;\nend;"
  },
  {
    "instruction": "Write a function to find the town judge from a trust relationship list. In a town, there is a person called the town judge, who trusts nobody and everybody else trusts him/her. You are given the number of people in the town, N, and a list of trust relationships. Each trust relationship is represented as a pair [a, b], which means that person a trusts person b. You need to find the town judge and return his/her identity. If there is no town judge, return -1.",
    "output": "function FindTownJudge(N: integer; trust: array of (integer, integer)): integer;\nbegin\n  var relationship := new Dictionary<integer, HashSet<integer>>;\n  foreach var relation in trust do\n  begin\n    if not relationship.ContainsKey(relation[0]) then\n      relationship[relation[0]] := new HashSet<integer>;\n    relationship[relation[0]].Add(relation[1]);\n  end;\n  var possibleTownJudge: integer := -1;\n  for var i := 1 to N do\n    if (not relationship.ContainsKey(i)) or (relationship[i].Count = 0) then\n      possibleTownJudge := i;\n  for var i := 1 to N do\n    if possibleTownJudge <> i then\n      if (not relationship.ContainsKey(i)) or (not relationship[i].Contains(possibleTownJudge)) then\n      begin\n        Result := -1;\n        exit;\n      end;\n  Result := possibleTownJudge;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of steps required to transform a given number into 1 by performing the following operations:\n1. If the number is even, divide it by 2.\n2. If the number is odd, either increment or decrement it by 1.",
    "output": "function TransformToOne(n: integer): integer;\nbegin\n  var steps := 0;\n  while n <> 1 do\n  begin\n    if n mod 2 = 0 then\n      n := n div 2\n    else\n    begin\n      if (n = 3) or (n mod 4 = 1) then\n        n -= 1\n      else\n        n += 1;\n    end;\n    steps += 1;\n  end;\n  Result := steps;\nend;"
  },
  {
    "instruction": "Write a function to check whether a given number is an Armstrong number or not. An Armstrong number is a number that is equal to the sum of its own digits each raised to the power of the number of digits.",
    "output": "function IsArmstrong(num: integer): boolean;\nbegin\n  var strNum := num.ToString;\n  var order := strNum.Length;\n  var sum := 0;\n  var temp := num;\n  while temp > 0 do\n  begin\n    var digit := temp mod 10;\n    sum += Round(Power(digit, order));\n    temp := temp div 10;\n  end;\n  Result := num = sum;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of all numbers in a list that are a power of 2.",
    "output": "function SumOfPowersOf2(lst: array of integer): integer;\nbegin\n  var powerOf2 := new List<integer>;\n  foreach var num in lst do\n    if (num <> 0) and ((num and (num - 1)) = 0) then\n      powerOf2.Add(num);\n  Result := powerOf2.Sum;\nend;"
  },
  {
    "instruction": "Write a function to calculate the sum of all the numbers that are divisible by 3 or 5, between 0 and a given number n (inclusive).",
    "output": "function SumDivisibleBy3Or5(n: integer): integer;\nbegin\n  var sum := 0;\n  for var i := 0 to n do\n    if (i mod 3 = 0) or (i mod 5 = 0) then\n      sum += i;\n  Result := sum;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of characters that can be formed by using the words in a given list of words. You can use each word in the list multiple times. The function should return the maximum number of characters that can be formed.",
    "output": "function MaxCharacters(words: array of string): integer;\nbegin\n  var maxChars := 0;\n  foreach var word in words do\n    maxChars += word.Length;\n  Result := maxChars;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of operations required to convert a string into a palindrome.\n\nAn operation is defined as inserting a character into the string.",
    "output": "function MinimumOperationsToPalindrome(s: string): integer;\nbegin\n  var n := s.Length;\n  var dp := new integer[n, n];\n  for var len := 2 to n do\n  begin\n    for var i := 0 to n - len do\n    begin\n      var j := i + len - 1;\n      if s[i + 1] = s[j + 1] then\n        dp[i, j] := dp[i + 1, j - 1]\n      else\n        dp[i, j] := Min(dp[i + 1, j], dp[i, j - 1]) + 1;\n    end;\n  end;\n  Result := dp[0, n - 1];\nend;"
  },
  {
    "instruction": "Write a function to find the union of two sorted lists.",
    "output": "function UnionSortedLists(list1, list2: array of integer): array of integer;\nbegin\n  var i := 0;\n  var j := 0;\n  var unionList := new List<integer>;\n  while (i < list1.Length) and (j < list2.Length) do\n  begin\n    if list1[i] < list2[j] then\n    begin\n      unionList.Add(list1[i]);\n      i += 1;\n    end\n    else if list1[i] > list2[j] then\n    begin\n      unionList.Add(list2[j]);\n      j += 1;\n    end\n    else\n    begin\n      unionList.Add(list1[i]);\n      i += 1;\n      j += 1;\n    end;\n  end;\n  while i < list1.Length do\n  begin\n    unionList.Add(list1[i]);\n    i += 1;\n  end;\n  while j < list2.Length do\n  begin\n    unionList.Add(list2[j]);\n    j += 1;\n  end;\n  Result := unionList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to determine if one string is a rotation of another string.",
    "output": "function IsRotation(str1, str2: string): boolean;\nbegin\n  if str1.Length <> str2.Length then\n  begin\n    Result := False;\n    exit;\n  end;\n  var temp := str1 + str1;\n  Result := str2 in temp;\nend;"
  },
  {
    "instruction": "Write a function to rotate a 2D list of integers 90 degrees clockwise.",
    "output": "function Rotate2DList(matrix: array[,] of integer): array[,] of integer;\nbegin\n  var rows := matrix.GetLength(0);\n  var cols := matrix.GetLength(1);\n  var res := new integer[cols, rows];\n  for var i := 0 to rows - 1 do\n    for var j := 0 to cols - 1 do\n      res[j, rows - 1 - i] := matrix[i, j];\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function that determines if a given number n can be expressed as the sum of any two distinct elements from a given list of numbers. If the number can be expressed as such a sum, return True, otherwise return False.",
    "output": "function CanBeSum(lst: array of integer; n: integer): boolean;\nbegin\n  var numSet := new HashSet<integer>(lst);\n  foreach var num in lst do\n    if (n - num in numSet) and (n - num <> num) then\n    begin\n      Result := True;\n      exit;\n    end;\n  Result := False;\nend;"
  },
  {
    "instruction": "Write a function to find the number of distinct subarrays with at least k distinct elements.",
    "output": "function CountDistinctSubarrays(arr: array of integer; k: integer): integer;\n\n  function AtMostKDistinct(arr: array of integer; k: integer): integer;\n  begin\n    var count := new Dictionary<integer, integer>;\n    var left := 0;\n    var resultCount := 0;\n    for var right := 0 to arr.Length - 1 do\n    begin\n      if not count.ContainsKey(arr[right]) then\n        count[arr[right]] := 0;\n      if count[arr[right]] = 0 then\n        k -= 1;\n      count[arr[right]] += 1;\n      while k < 0 do\n      begin\n        count[arr[left]] -= 1;\n        if count[arr[left]] = 0 then\n          k += 1;\n        left += 1;\n      end;\n      resultCount += right - left + 1;\n    end;\n    Result := resultCount;\n  end;\n\nbegin\n  Result := AtMostKDistinct(arr, k) - AtMostKDistinct(arr, k - 1);\nend;"
  },
  {
    "instruction": "Write a function that finds the maximum number of envelopes that can be nested inside each other. An envelope can be nested inside another if its width and height are both smaller than the other envelope's width and height.",
    "output": "function MaxNestedEnvelopes(envelopes: array of (integer, integer)): integer;\nbegin\n  envelopes := envelopes.OrderBy(e -> (e[0], -e[1])).ToArray;\n  var heights := envelopes.Select(e -> e[1]).ToArray;\n  var dp := new List<integer>;\n  foreach var height in heights do\n  begin\n    var i := dp.BinarySearch(height);\n    if i < 0 then\n      i := -(i + 1);\n    if i = dp.Count then\n      dp.Add(height)\n    else\n      dp[i] := height;\n  end;\n  Result := dp.Count;\nend;"
  },
  {
    "instruction": "Write a function to find the most repeated elements in a given list.",
    "output": "function MostRepeatedElements(lst: array of integer): array of integer;\nbegin\n  var count := new Dictionary<integer, integer>;\n  foreach var i in lst do\n  begin\n    if count.ContainsKey(i) then\n      count[i] += 1\n    else\n      count[i] := 1;\n  end;\n  var maxCount := count.Values.Max;\n  Result := count.Where(p -> p.Value = maxCount).Select(p -> p.Key).ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest subarray length with a given sum using a sliding window approach.",
    "output": "function SmallestSubarrayLength(arr: array of integer; target: integer): integer;\nbegin\n  var start := 0;\n  var minLength := integer.MaxValue;\n  var currentSum := 0;\n  for var endIndex := 0 to arr.Length - 1 do\n  begin\n    currentSum += arr[endIndex];\n    while currentSum >= target do\n    begin\n      minLength := Min(minLength, endIndex - start + 1);\n      currentSum -= arr[start];\n      start += 1;\n    end;\n  end;\n  if minLength <> integer.MaxValue then\n    Result := minLength\n  else\n    Result := 0;\nend;"
  },
  {
    "instruction": "Write a function to remove all instances of a specific value from a list in-place and return the new length of the list.",
    "output": "function RemoveElement(var nums: array of integer; val: integer): integer;\nbegin\n  var index := 0;\n  for var i := 0 to nums.Length - 1 do\n    if nums[i] <> val then\n    begin\n      nums[index] := nums[i];\n      index += 1;\n    end;\n  Result := index;\nend;"
  },
  {
    "instruction": "Write a function to find the most frequent element in a given list.",
    "output": "function FrequentElement(list1: array of integer): integer;\nbegin\n  var counter := new Dictionary<integer, integer>;\n  foreach var i in list1 do\n  begin\n    if counter.ContainsKey(i) then\n      counter[i] += 1\n    else\n      counter[i] := 1;\n  end;\n  Result := counter.OrderByDescending(p -> p.Value).First.Key;\nend;"
  },
  {
    "instruction": "Write a function to sort a list of strings by their length from smallest to largest.",
    "output": "function StringLengthSort(strings: array of string): array of string;\nbegin\n  Result := strings.OrderBy(s -> s.Length).ToArray;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and a target sum. It should return a list of all combinations of numbers from the list that add up to the target sum. Each combination should be a list, and the function should return a list of these lists. The numbers in the list can be used multiple times in the combinations.",
    "output": "function FindCombinations(nums: array of integer; target: integer): List<List<integer>>;\n\n  procedure Dfs(path: List<integer>; index: integer; remaining: integer; resultList: List<List<integer>>);\n  begin\n    if remaining = 0 then\n    begin\n      resultList.Add(new List<integer>(path));\n      exit;\n    end;\n    for var i := index to nums.Length - 1 do\n    begin\n      if remaining - nums[i] < 0 then break;\n      path.Add(nums[i]);\n      Dfs(path, i, remaining - nums[i], resultList);\n      path.RemoveAt(path.Count - 1);\n    end;\n  end;\n\nbegin\n  var resultList := new List<List<integer>>;\n  Dfs(new List<integer>, 0, target, resultList);\n  Result := resultList;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of meeting rooms that are occupied at the same time given a list of meeting times. Each meeting has a start and an end time.",
    "output": "function MaxMeetingRooms(meetings: array of (integer, integer)): integer;\nbegin\n  if meetings.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  var startTimes := meetings.Select(m -> m[0]).Order.ToArray;\n  var endTimes := meetings.Select(m -> m[1]).Order.ToArray;\n  var maxRooms := 0;\n  var currentRooms := 0;\n  var i := 0;\n  var j := 0;\n  while (i < meetings.Length) and (j < meetings.Length) do\n  begin\n    if startTimes[i] < endTimes[j] then\n    begin\n      currentRooms += 1;\n      i += 1;\n    end\n    else\n    begin\n      currentRooms -= 1;\n      j += 1;\n    end;\n    maxRooms := Max(maxRooms, currentRooms);\n  end;\n  Result := maxRooms;\nend;"
  },
  {
    "instruction": "Write a function to find the largest negative number in a list of integers.",
    "output": "function LargestNegative(lst: array of integer): integer;\nbegin\n  var negLst := lst.Where(num -> num < 0).ToArray;\n  if negLst.Length = 0 then\n    Result := integer.MinValue\n  else\n    Result := negLst.Max;\nend;"
  },
  {
    "instruction": "Write a function which accepts a list of integers and returns a list containing only the even numbers from the input list.",
    "output": "function ExtractEvens(nums: array of integer): array of integer;\nbegin\n  var evenNums := new List<integer>;\n  foreach var num in nums do\n    if num mod 2 = 0 then\n      evenNums.Add(num);\n  Result := evenNums.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the greatest common divisor of the two given numbers.",
    "output": "function GetGCD(x, y: integer): integer;\nbegin\n  while y <> 0 do\n  begin\n    (x, y) := (y, x mod y);\n  end;\n  Result := x;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum sum of a subarray with the length of exactly k.",
    "output": "function MaxSumSubarray(arr: array of integer; k: integer): integer;\nbegin\n  if arr.Length < k then\n  begin\n    Result := 0;\n    exit;\n  end;\n  var maxSum := arr[\n      :k\n    ].Sum;\n  var tempSum := maxSum;\n  for var i := k to arr.Length - 1 do\n  begin\n    tempSum := tempSum - arr[i - k\n    ] + arr[i\n    ];\n    maxSum := Max(maxSum, tempSum);\n  end;\n  Result := maxSum;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of operations required to convert a given source string to a given target string by using the operations of insert a character, remove a character, or replace a character.",
    "output": "function StringTransformation(source, target: string): integer;\nbegin\n  var lenSource := source.Length;\n  var lenTarget := target.Length;\n  var dp := new integer[lenSource + 1, lenTarget + 1\n    ];\n  for var i := 0 to lenSource do\n    for var j := 0 to lenTarget do\n    begin\n      if i = 0 then\n        dp[i, j\n    ] := j\n      else if j = 0 then\n        dp[i, j\n    ] := i\n      else if source[i - 1\n    ] = target[j - 1\n    ] then\n        dp[i, j\n    ] := dp[i - 1, j - 1\n    ]\n      else\n        dp[i, j\n    ] := 1 + Min(Min(dp[i - 1, j\n    ], dp[i, j - 1\n    ]), dp[i - 1, j - 1\n    ]);\n    end;\n  Result := dp[lenSource, lenTarget\n    ];\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest subsequence in a given array that is strictly increasing.",
    "output": "function LengthOfLongestIncreasingSubsequence(nums: array of integer): integer;\nbegin\n  var sub := new List<integer>;\n  foreach var x in nums do\n  begin\n    var i := sub.BinarySearch(x);\n    if i < 0 then\n      i := -(i + 1);\n    if i = sub.Count then\n      sub.Add(x)\n    else\n      sub[i\n    ] := x;\n  end;\n  Result := sub.Count;\nend;"
  },
  {
    "instruction": "Write a program that checks if a given string matches a specific pattern. The pattern can contain any lowercase English letters and the special characters '.' and '*'. The '.' character matches any single character, while the '*' character matches zero or more of the preceding element. The function should return True if the string matches the entire pattern, otherwise False.",
    "output": "function PatternMatch(s, p: string): boolean;\nbegin\n  var dp := new boolean[s.Length + 1, p.Length + 1\n    ];\n  dp[\n      0, 0\n    ] := True;\n  for var j := 1 to p.Length do\n    if (p[j - 1\n    ] = '*') and dp[\n      0, j - 2\n    ] then\n      dp[\n      0, j\n    ] := True;\n  for var i := 1 to s.Length do\n    for var j := 1 to p.Length do\n    begin\n      if (p[j - 1\n    ] = s[i - 1\n    ]) or (p[j - 1\n    ] = '.') then\n        dp[i, j\n    ] := dp[i - 1, j - 1\n    ]\n      else if p[j - 1\n    ] = '*' then\n        dp[i, j\n    ] := dp[i, j - 2\n    ] or (dp[i - 1, j\n    ] and ((s[i - 1\n    ] = p[j - 2\n    ]) or (p[j - 2\n    ] = '.')));\n    end;\n  Result := dp[s.Length, p.Length\n    ];\nend;"
  },
  {
    "instruction": "Write a function that converts a number to a list of its digits.\n\nFor example, if the number is 1234, the function should return [1, 2, 3, 4].",
    "output": "function ConvertToDigits(number: integer): array of integer;\nbegin\n  if number = 0 then\n  begin\n    Result := Arr(0);\n    exit;\n  end;\n  var digits := new List<integer>;\n  while number > 0 do\n  begin\n    digits.Add(number mod 10);\n    number := number div 10;\n  end;\n  digits.Reverse;\n  Result := digits.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to calculate the minimum number of parentheses that must be removed to make a string of parentheses valid.\n\nA string of parentheses is considered valid if every opening parenthesis '(' has a corresponding closing parenthesis ')' and the pairs are properly nested.",
    "output": "function MinRemoveParentheses(s: string): integer;\nbegin\n  var left := 0;\n  var right := 0;\n  var remove := 0;\n  foreach var paren in s do\n  begin\n    if paren = '(' then\n      left += 1\n    else if (paren = ')') and (left > 0) then\n      left -= 1\n    else\n      remove += 1;\n  end;\n  Result := remove + left;\nend;"
  },
  {
    "instruction": "Write a function to find the subarray with a given sum in a list of non-negative numbers.",
    "output": "function FindSubarrayWithGivenSum(arr: array of integer; targetSum: integer): (integer, integer);\nbegin\n  var currSum := 0;\n  var start := 0;\n  for var endIndex := 0 to arr.Length - 1 do\n  begin\n    currSum += arr[endIndex\n    ];\n    while (currSum > targetSum) and (start < endIndex) do\n    begin\n      currSum -= arr[start\n    ];\n      start += 1;\n    end;\n    if currSum = targetSum then\n    begin\n      Result := (start, endIndex);\n      exit;\n    end;\n  end;\n  Result := (-1,-1);\nend;"
  },
  {
    "instruction": "Write a function that simulates the process of typing a string into a text editor with backspace operations. The function should return the final string after all backspace operations have been applied.\n\nFor example, if the input string is \"ab#c\", it means that the sequence of keystrokes is 'a', 'b', 'c', and a backspace operation. The backspace operation removes the last character, so the final string is \"ac\".",
    "output": "function BackspaceTyping(inputString: string): string;\nbegin\n  var stack := new Stack<char>;\n  foreach var char in inputString do\n  begin\n    if char <> '#' then\n      stack.Push(char)\n    else if stack.Count > 0 then\n      stack.Pop;\n  end;\n  Result := new string(stack.Reverse.ToArray);\nend;"
  },
  {
    "instruction": "Write a function to count the number of times a number can be evenly divided by 2 before it becomes odd.",
    "output": "function CountDivisibleBy2(n: integer): integer;\nbegin\n  var count := 0;\n  while n mod 2 = 0 do\n  begin\n    count += 1;\n    n := n div 2;\n  end;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings and returns a new list with the strings that have the most vowels.",
    "output": "function CountVowelsLocal(vowels: string; word: string): integer;\n  begin\n    var cnt := 0;\n    foreach var c in word do\n      if vowels.Contains(c) then cnt += 1;\n    Result := cnt;\n  end;\n\nfunction MostVowels(words: array of string): array of string;\nbegin\n  var vowels := 'aeiouAEIOU';\n\n  var maxV := 0;\n  foreach var w in words do\n    maxV := Max(maxV, CountVowelsLocal(vowels, w));\n\n  var list := new List<string>;\n  foreach var w in words do\n    if CountVowelsLocal(vowels, w) = maxV then\n      list.Add(w);\n\n  Result := list.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the list of words in a given string that starts with a specific character.",
    "output": "function FindWordsStartingWith(s: string; startChar: char): array of string;\nbegin\n  var parts := s.Split(' ');\n  var resultList := new List<string>;\n  foreach var word in parts do\n    if (word <> '') and (LowerCase(word[1]) = LowerCase(startChar)) then\n      resultList.Add(word);\n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the most occurring character in the given string. If there are multiple characters with the same highest frequency, return the one that occurs first in the string.",
    "output": "function MostOccurringChar(inputString: string): char;\nbegin\n  var frequency := new Dictionary<char, integer>;\n  var maxFreq := 0;\n  var maxChar := #0;\n  foreach var char in inputString do\n  begin\n    if frequency.ContainsKey(char) then\n      frequency[char\n    ] += 1\n    else\n      frequency[char\n    ] := 1;\n    if frequency[char\n    ] > maxFreq then\n    begin\n      maxFreq := frequency[char\n    ];\n      maxChar := char;\n    end;\n  end;\n  Result := maxChar;\nend;"
  },
  {
    "instruction": "Create a function that takes two parameters, the length and width of a rectangle. This function should calculate and return the area of the rectangle. However, if the length or width is less than or equal to 0, the function should return 0 as area.",
    "output": "function CalcArea(length, width: integer): integer;\nbegin\n  if (length <= 0) or (width <= 0) then\n    Result := 0\n  else\n    Result := length * width;\nend;"
  },
  {
    "instruction": "Write a function to calculate the total price of a shopping cart after applying the discount. The function takes a list of product prices and a discount percentage as input.",
    "output": "function TotalPriceAfterDiscount(prices: array of real; discount: real): real;\nbegin\n  var totalPrice := prices.Sum;\n  var discountAmount := totalPrice * (discount / 100);\n  Result := totalPrice - discountAmount;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns true if there are any three consecutive numbers in the list.",
    "output": "function HasThreeConsecutive(nums: array of integer): boolean;\nbegin\n  for var i := 0 to nums.Length - 3 do\n    if (nums[i\n    ] + 1 = nums[i + 1\n    ]) and (nums[i\n    ] + 2 = nums[i + 2\n    ]) then\n    begin\n      Result := True;\n      exit;\n    end;\n  Result := False;\nend;"
  },
  {
    "instruction": "Write a function to find the sublist having the maximum sum.",
    "output": "function MaxSumSublist(lst: array of array of integer): array of integer;\nbegin\n  var maxSum := lst.Max(x -> x.Sum);\n  Result := lst.First(x -> x.Sum = maxSum);\nend;"
  },
  {
    "instruction": "Write a function to find the sum of the digits in the factorial of a given number.",
    "output": "function SumFactorialDigits(n: integer): integer;\nbegin\n  var factorial := 1bi;\n  for var i := 2 to n do\n    factorial *= i;\n  var sumDigits := 0;\n  while factorial > 0 do\n  begin\n    sumDigits += integer(factorial mod 10);\n    factorial := factorial div 10;\n  end;\n  Result := sumDigits;\nend;"
  },
  {
    "instruction": "Write a function to find the number of trailing zeros in the factorial of a given number.",
    "output": "function TrailingZeros(n: integer): integer;\nbegin\n  var count := 0;\n  var i := 5;\n  while n div i >= 1 do\n  begin\n    count += n div i;\n    i *= 5;\n  end;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum width ramp in a list of integers. A width ramp is a pair of indices (i, j) where i < j and nums[i] <= nums[j]. The width of the ramp is j - i.",
    "output": "function MaxWidthRamp(nums: array of integer): integer;\nbegin\n  var pairs := new List<(integer, integer)>;\n  for var i := 0 to nums.Length - 1 do\n    pairs.Add((nums[i], i));\n\n  pairs.Sort((a, b) -> a.Item1.CompareTo(b.Item1));\n\n  var minIndex := MaxInt;\n  var res := 0;\n\n  foreach var p in pairs do\n  begin\n    var idx := p.Item2;\n    res := Max(res, idx - minIndex);\n    minIndex := Min(minIndex, idx);\n  end;\n\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum profit from buying and selling stocks given a list of daily stock prices. You are only allowed to make one transaction (i.e., buy one and sell one share of the stock), and you must sell the stock before you buy again.",
    "output": "function StockProfit(prices: array of integer): integer;\nbegin\n  if prices.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  var minPrice := integer.MaxValue;\n  var maxProfit := 0;\n  foreach var price in prices do\n  begin\n    minPrice := Min(minPrice, price);\n    maxProfit := Max(maxProfit, price - minPrice);\n  end;\n  Result := maxProfit;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns a new list that contains elements which are not repeated in the original list.",
    "output": "function RemoveRepeated(arr: array of integer): array of integer;\nbegin\n  var counts := new Dictionary<integer, integer>;\n  foreach var num in arr do\n  begin\n    if counts.ContainsKey(num) then\n      counts[num] += 1\n    else\n      counts[num] := 1;\n  end;\n  var resultList := new List<integer>;\n  foreach var num in arr do\n    if counts[num] = 1 then\n      resultList.Add(num);\n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to count the number of non-empty (contiguous) substrings in a binary string that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.",
    "output": "function CountBinarySubstrings(s: string): integer;\nbegin\n  var pre := 0;\n  var cur := 1;\n  var cnt := 0;\n  for var i := 1 to s.Length - 1 do\n  begin\n    if s[i\n    ] = s[i - 1\n    ] then\n      cur += 1\n    else\n    begin\n      cnt += Min(pre, cur);\n      pre := cur;\n      cur := 1;\n    end;\n  end;\n  Result := cnt + Min(pre, cur);\nend;"
  },
  {
    "instruction": "Write a function to find the total distance covered by a vehicle within a given time, if it starts from rest and accelerates at a constant rate.\n\nNote: The function should return the answer in meter if the acceleration is provided in m/s^2 and time is provided in seconds.",
    "output": "function DistanceCovered(acceleration, time: real): real;\nbegin\n  Result := 0.5 * acceleration * time * time;\nend;"
  },
  {
    "instruction": "Write a function to flatten a nested list structure into a single list.",
    "output": "function FlattenList(nestedList: List<object>): List<integer>;\nbegin\n  var resultList := new List<integer>;\n  foreach var i in nestedList do\n    if i is List<object> then\n      resultList.AddRange(FlattenList(i as List<object>))\n    else\n      resultList.Add(integer(i));\n  Result := resultList;\nend;"
  },
  {
    "instruction": "Write a function to get the largest number that is smaller than the given number and is made up of the same digits.",
    "output": "function GetPrevNumber(n: integer): integer;\nbegin\n  var s := n.ToString;\n  var l := s.Length;\n  for var i := l - 1 downto 1 do\n  begin\n    if s[i\n    ] < s[i - 1\n    ] then\n    begin\n      var m := s[i - 1\n    ];\n      var chars := s.ToCharArray;\n      chars[i - 1\n    ] := chars[i\n    ];\n      chars[i\n    ] := m;\n      s := new string(chars);\n      s := s[\n      :i\n    ] + new string(s[i:\n    ].Order.ToArray);\n      if s[\n      1\n    ] = '0' then\n        Result := -1\n      else\n        Result := StrToInt(s);\n      exit;\n    end;\n  end;\n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of tuples, where each tuple contains two integers representing the start and end indices of a segment of a line. Your task is to merge overlapping segments and return a list of the merged segments.",
    "output": "function MergeSegments(segments: array of (integer, integer)): array of (integer, integer);\nbegin\n  segments := segments.Order.ToArray;\n  var merged := new List<(integer, integer)>;\n  foreach var seg in segments do\n  begin\n    if (merged.Count = 0) or (merged.Last[\n      1\n    ] < seg[\n      0\n    ]) then\n      merged.Add(seg)\n    else\n      merged[merged.Count - 1\n    ] := (merged.Last[\n      0\n    ], Max(merged.Last[\n      1\n    ], seg[\n      1\n    ]));\n  end;\n  Result := merged.ToArray;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings (representing file names) and returns a dictionary mapping file extensions to the count of files with that extension. The file extension is everything after the last dot in the file name.",
    "output": "function FileExtensionCount(files: array of string): Dictionary<string, integer>;\nbegin\n  var extensionCount := new Dictionary<string, integer>;\n\n  foreach var fname in files do\n  begin\n    var parts := fname.Split('.');\n    if parts.Length > 1 then\n    begin\n      var ext := parts[parts.Length - 1];\n\n      if extensionCount.ContainsKey(ext) then\n        extensionCount[ext] := extensionCount[ext] + 1\n      else\n        extensionCount[ext] := 1;\n    end;\n  end;\n\n  Result := extensionCount;\nend;"
  },
  {
    "instruction": "Write a function that returns the sum of two numbers passed as arguments.",
    "output": "function Add(a, b: integer): integer;\nbegin\n  Result := a + b;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways a robot can move from the top-left corner to the bottom-right corner of a grid. The robot can only move either down or right at any point in time.",
    "output": "function UniqueRobotPaths(m, n: integer): integer;\nbegin\n  var dp := new integer[m, n];\n  dp[0, 0] := 1;\n  for var r := 0 to m - 1 do\n    for var c := 0 to n - 1 do\n    begin\n      if r > 0 then\n        dp[r, c] += dp[r - 1, c];\n      if c > 0 then\n        dp[r, c] += dp[r, c - 1];\n    end;\n  Result := dp[m - 1, n - 1];\nend;"
  },
  {
    "instruction": "Write a function that takes a positive integer and returns the number of digits in its factorial.",
    "output": "function FactorialDigitCount(n: integer): integer;\nbegin\n  if n = 0 then\n  begin\n    Result := 1;\n    exit;\n  end;\n  var digits := n * Log10(n / Exp(1)) + Log10(2 * Pi * n) / 2;\n  Result := integer(digits) + 1;\nend;"
  },
  {
    "instruction": "Write a function to count the number of positive numbers in a sorted matrix.\nThe matrix is sorted in non-decreasing order both row-wise and column-wise.\n\nExample 1:\nInput: matrix = [[-3,-2,-1,1],[0,1,2,3],[4,5,6,7]]\nOutput: 7\nExplanation: There are 7 positive numbers in the matrix.\n\nExample 2:\nInput: matrix = [[-1,-1],[-1,-1]]\nOutput: 0\n\nExample 3:\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: 9\n\nConstraints:\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 100\n-100 <= matrix[i][j] <= 100",
    "output": "function CountPositives(matrix: array [,] of integer): integer;\nbegin\n  Result := 0;\n  foreach var a in matrix do\n    if a > 0 then\n      Result += 1;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of perfect square numbers which sum to 'n'. A perfect square is an integer that is the square of an integer, for example, 1, 4, 9, 16.",
    "output": "function MinSquares(n: integer): integer;\nbegin\n  if n <= 3 then\n  begin\n    Result := n;\n    exit;\n  end;\n  var dp := ArrFill(n + 1, 0);\n  for var i := 1 to n do\n  begin\n    dp[i\n    ] := i;\n    for var j := 1 to integer(Sqrt(i)) do\n      dp[i\n    ] := Min(dp[i\n    ], dp[i - j * j\n    ] + 1);\n  end;\n  Result := dp[n\n    ];\nend;"
  },
  {
    "instruction": "Write a function that takes an array of integers and returns the array with each element swapped with the next one. If the array has an odd number of elements, the last element should remain in its position.",
    "output": "function SwapPairs(arr: array of integer): array of integer;\nbegin\n  for var i := 0 to arr.Length - 2 step 2 do\n    Swap(arr[i\n    ], arr[i + 1\n    ]);\n  Result := arr;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum absolute difference between any two elements in a given array.",
    "output": "function FindMinAbsDifference(nums: array of integer): integer;\nbegin\n  nums := nums.Order.ToArray;\n  var minDiff := integer.MaxValue;\n  for var i := 1 to nums.Length - 1 do\n  begin\n    var diff := Abs(nums[i\n    ] - nums[i - 1\n    ]);\n    if diff < minDiff then\n      minDiff := diff;\n  end;\n  Result := minDiff;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings and returns the list sorted in reverse alphabetical order.",
    "output": "function ReverseAlphabeticalSort(strings: array of string): array of string;\nbegin\n  Result := strings.OrderDescending.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to return the missing element in the second array. The second array is a shuffled version of the first array with one element missing.",
    "output": "function MissingElement(arr1, arr2: array of integer): integer;\nbegin\n  arr1 := arr1.Order.ToArray;\n  arr2 := arr2.Order.ToArray;\n  for var i := 0 to arr2.Length - 1 do\n    if arr1[i\n    ] <> arr2[i\n    ] then\n    begin\n      Result := arr1[i\n    ];\n      exit;\n    end;\n  Result := arr1[^1\n    ];\nend;"
  },
  {
    "instruction": "Write a function to determine if a given word follows the standard capitalization rules. A word is considered to follow the rules if it is all in uppercase, all in lowercase, or only the first letter is capitalized and the rest are lowercase.",
    "output": "function IsCorrectCapitalization(word: string): boolean;\nbegin\n  if (word = word.ToUpper) then\n  begin\n    Result := True;\n    exit;\n  end;\n  if (word = word.ToLower) then\n  begin\n    Result := True;\n    exit;\n  end;\n\n  if (word.Length > 0) and (word[1] = word[1].ToUpper) and\n     (word.Substring(1) = word.Substring(1).ToLower) then\n  begin\n    Result := True;\n    exit;\n  end;\n\n  Result := False;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns a new list with only the even numbers from the original list, sorted in ascending order.",
    "output": "function EvenSort(numbers: array of integer): array of integer;\nbegin\n  var evenNumbers := numbers.Where(num -> num mod 2 = 0).ToArray;\n  Result := evenNumbers.Order.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to generate the cartesian product of 2 lists.",
    "output": "function CartesianProduct(list1, list2: array of integer): array of (integer, integer);\nbegin\n  var product := new List<(integer, integer)>;\n  foreach var x in list1 do\n    foreach var y in list2 do\n      product.Add((x, y));\n  Result := product.ToArray;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of numbers as an argument and returns a new list with the numbers sorted in ascending order. However, if the list contains any strings, the function should sort the numbers and strings separately, with numbers first and strings last, in their respective sorted orders.",
    "output": "function SortMixedList(lst: array of object): array of object;\nbegin\n  var numList := new List<integer>;\n  var strList := new List<string>;\n\n  foreach var x in lst do\n  begin\n    if x is integer then\n      numList.Add(integer(x))\n    else if x is string then\n      strList.Add(string(x));\n  end;\n\n  numList.Sort;\n  strList.Sort;\n\n  var resultList := new List<object>;\n  foreach var n in numList do\n    resultList.Add(n);\n  foreach var s in strList do\n    resultList.Add(s);\n\n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of words in a sentence from a list of sentences.",
    "output": "function MaxWords(sentences: array of string): integer;\n\n  function CountWords(s: string): integer;\n  begin\n    var parts := s.Split(' ');\n    var cnt := 0;\n    foreach var p in parts do\n      if p <> '' then cnt += 1;\n    Result := cnt;\n  end;\n\nbegin\n  var maxVal := 0;\n  foreach var s in sentences do\n    maxVal := Max(maxVal, CountWords(s));\n  Result := maxVal;\nend;"
  },
  {
    "instruction": "Write a function to find the largest number in a list that is strictly less than a given number.",
    "output": "function FindLargestLessThan(listNums: array of integer; target: integer): integer;\nbegin\n  var filteredList := listNums.Where(num -> num < target).ToArray;\n  if filteredList.Length = 0 then\n    Result := 0\n  else\n    Result := filteredList.Max;\nend;"
  },
  {
    "instruction": "Write a function to find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.",
    "output": "function CombinationSum3(k, n: integer): List<List<integer>>;\n\n  procedure Dfs(path: List<integer>; start: integer; target: integer; res: List<List<integer>>);\n  begin\n    if path.Count = k then\n    begin\n      if target = 0 then\n        res.Add(new List<integer>(path));\n      exit;\n    end;\n\n    for var i := start to 9 do\n    begin\n      if i > target then break;\n\n      path.Add(i);\n      Dfs(path, i + 1, target - i, res);\n      path.RemoveAt(path.Count - 1);\n    end;\n  end;\n\nbegin\n  var resultList := new List<List<integer>>;\n  Dfs(new List<integer>, 1, n, resultList);\n  Result := resultList;\nend;"
  },
  {
    "instruction": "Write a function to check if a given list of integers contains any duplicates.",
    "output": "function ContainsDuplicate(nums: array of integer): boolean;\nbegin\n  var a := new HashSet<integer>;\n  foreach var i in nums do\n  begin\n    if i in a then\n    begin\n      Result := True;\n      exit;\n    end\n    else\n      a.Add(i);\n  end;\n  Result := False;\nend;"
  },
  {
    "instruction": "Write a function to check if a word matches a given pattern. The pattern may contain lowercase letters and '?' characters. The '?' can match any single character. The function should return True if the word matches the pattern, otherwise False.",
    "output": "function MatchPattern(word, pattern: string): boolean;\nbegin\n  var i := 1;\n  var j := 1;\n  while (i <= word.Length) and (j <= pattern.Length) do\n  begin\n    if (pattern[j\n    ] = '?') or (pattern[j\n    ] = word[i\n    ]) then\n    begin\n      i += 1;\n      j += 1;\n    end\n    else\n    begin\n      Result := False;\n      exit;\n    end;\n  end;\n  if (i = word.Length + 1) and (j = pattern.Length + 1) then\n    Result := True\n  else if (i = word.Length + 1) and (pattern[j\n    ] = '?') then\n    Result := MatchPattern(word, pattern[j + 1:\n    ])\n  else if (j = pattern.Length + 1) and (word[i\n    ] = pattern[j - 1\n    ]) then\n    Result := MatchPattern(word[i + 1:\n    ], pattern)\n  else\n    Result := False;\nend;"
  },
  {
    "instruction": "Write a function to determine if a given sequence of transactions can be completed successfully. Each transaction consists of a customer paying with either 5, 10, or 20 dollar bills for a lemonade that costs 5 dollars. Your function should return True if all transactions can be completed successfully, ensuring you can provide correct change for each transaction, or False otherwise.",
    "output": "function LemonadeChange(bills: array of integer): boolean;\nbegin\n  var five := 0;\n  var ten := 0;\n  foreach var bill in bills do\n  begin\n    if bill = 5 then\n      five += 1\n    else if bill = 10 then\n    begin\n      if five = 0 then\n      begin\n        Result := False;\n        exit;\n      end;\n      five -= 1;\n      ten += 1;\n    end\n    else\n    begin\n      if (ten > 0) and (five > 0) then\n      begin\n        ten -= 1;\n        five -= 1;\n      end\n      else if five >= 3 then\n        five -= 3\n      else\n      begin\n        Result := False;\n        exit;\n      end;\n    end;\n  end;\n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function to check whether the given number is a prime number or not.",
    "output": "function IsPrime(n: integer): boolean;\nbegin\n  if n <= 1 then\n  begin\n    Result := False;\n    exit;\n  end;\n  if n <= 3 then\n  begin\n    Result := True;\n    exit;\n  end;\n  if (n mod 2 = 0) or (n mod 3 = 0) then\n  begin\n    Result := False;\n    exit;\n  end;\n  var i := 5;\n  while i * i <= n do\n  begin\n    if (n mod i = 0) or (n mod (i + 2) = 0) then\n    begin\n      Result := False;\n      exit;\n    end;\n    i += 6;\n  end;\n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function to rotate the elements of an array to the right by 'k' steps, where 'k' is non-negative.",
    "output": "function RotateArray(var nums: array of integer; k: integer): array of integer;\nbegin\n  k := k mod nums.Length;\n  nums := nums[^k:\n    ] + nums[\n      :^k\n    ];\n  Result := nums;\nend;"
  },
  {
    "instruction": "Write a function to find the longest substring where each character is a vowel.",
    "output": "function LongestVowelSubstring(s: string): string;\nbegin\n  var vowels := 'aeiou';\n  var longest := '';\n  var current := '';\n  foreach var c in s do\n  begin\n    if vowels.Contains(c.ToLower) then\n      current += c\n    else\n    begin\n      if current.Length > longest.Length then\n        longest := current;\n      current := '';\n    end;\n  end;\n  if current.Length > longest.Length then\n    longest := current;\n  Result := longest;\nend;"
  },
  {
    "instruction": "Write a function that converts an integer into a binary string and counts the number of '1' bits in the binary representation.",
    "output": "function BinaryCounter(n: integer): (string, integer);\nbegin\n  var binaryString := Convert.ToString(n, 2);\n  var countOnes := binaryString.Count(c -> c = '1');\n  Result := (binaryString, countOnes);\nend;"
  },
  {
    "instruction": "Write a function to find the most frequent character in a given string.",
    "output": "function MostFrequentChar(s: string): char;\nbegin\n  var count := new Dictionary<char, integer>;\n  foreach var char in s do\n  begin\n    if count.ContainsKey(char) then\n      count[char\n    ] += 1\n    else\n      count[char\n    ] := 1;\n  end;\n  Result := count.OrderByDescending(p -> p.Value).First.Key;\nend;"
  },
  {
    "instruction": "Write a function to check if a number is a strong number. A strong number is a number where the sum of the factorial of its digits is equal to the number itself.",
    "output": "function CheckStrong(num: integer): boolean;\n\n  function Factorial(n: integer): integer;\n  begin\n    if n = 0 then\n      Result := 1\n    else\n      Result := n * Factorial(n - 1);\n  end;\n\nbegin\n  var temp := num;\n  var sum := 0;\n  while temp > 0 do\n  begin\n    var digit := temp mod 10;\n    sum += Factorial(digit);\n    temp := temp div 10;\n  end;\n  Result := sum = num;\nend;"
  },
  {
    "instruction": "Write a function to return the most common word in a given paragraph of text. The function should ignore case sensitivity and punctuation marks.",
    "output": "function CommonWord(paragraph: string): string;\nbegin\n  paragraph := paragraph.ToLower;\n\n  var cleaned := '';\n  foreach var c in paragraph do\n    if c.IsLetter or char.IsWhiteSpace(c) then\n      cleaned += c;\n\n  var parts := cleaned.Split(' ');\n\n  var wordCounts := new Dictionary<string, integer>;\n  foreach var w in parts do\n    if w <> '' then\n    begin\n      if wordCounts.ContainsKey(w) then\n        wordCounts[w] := wordCounts[w] + 1\n      else\n        wordCounts[w] := 1;\n    end;\n\n  var maxKey := '';\n  var maxVal := -1;\n  foreach var kv in wordCounts do\n  begin\n    if kv.Value > maxVal then\n    begin\n      maxVal := kv.Value;\n      maxKey := kv.Key;\n    end;\n  end;\n\n  Result := maxKey;\nend;"
  },
  {
    "instruction": "Write a function to check whether the given number is an Armstrong number or not.\nAn Armstrong number of three digits is an integer such that the sum of the cubes of its digits is equal to the number itself.\nFor example, 371 is an Armstrong number since 3**3 + 7**3 + 1**3 = 371.",
    "output": "function CheckArmstrongNumber(num: integer): boolean;\nbegin\n  var strNum := num.ToString;\n  var sum := 0;\n  foreach var c in strNum do\n  begin\n    var digit := StrToInt(c);\n    sum += Round(Power(digit, strNum.Length));\n  end;\n  Result := num = sum;\nend;"
  },
  {
    "instruction": "Write a function to print the elements of a list in reverse order.",
    "output": "function PrintReverse(lst: array of integer): array of integer;\nbegin\n  Result := lst.Reverse.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to check if a given string is a valid URL.",
    "output": "function ValidURL(url: string): boolean;\nbegin var regex := new System.Text.RegularExpressions.Regex(\n    '^(?:http|ftp)s?: //' +\n    '(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|' +\n    'localhost|' +\n    '\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})' +\n    '(?::\\d+)?' +\n    '(?:/?|[/?]\\S+)$', System.Text.RegularExpressions.RegexOptions.IgnoreCase);\n  Result := regex.IsMatch(url);\nend;"
  },
  {
    "instruction": "Write a function to find the smallest positive integer that cannot be represented as the sum of any subset of a given list of positive integers.",
    "output": "function SmallestMissingSum(arr: array of integer): integer;\nbegin\n  arr := arr.Order.ToArray;\n  var smallestMissing := 1;\n  foreach var num in arr do\n  begin\n    if num > smallestMissing then\n    begin\n      Result := smallestMissing;\n      exit;\n    end;\n    smallestMissing += num;\n  end;\n  Result := smallestMissing;\nend;"
  },
  {
    "instruction": "Write a function that takes a string of brackets and returns the minimum number of brackets that must be removed to make the string valid. A valid string of brackets is one in which every open bracket is matched with a corresponding close bracket and the brackets are properly nested.",
    "output": "function RemoveBracket(bracketString: string): integer;\nbegin\n  var stack := new Stack<char>;\n  var count := 0;\n  foreach var bracket in bracketString do\n  begin\n    if bracket = '(' then\n      stack.Push(bracket)\n    else if (bracket = ')') and (stack.Count > 0) then\n      stack.Pop\n    else\n      count += 1;\n  end;\n  count += stack.Count;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to check if a given string is an anagram of a palindrome.",
    "output": "function IsAnagramOfPalindrome(s: string): boolean;\nbegin\n  var charCount := new Dictionary<char, integer>;\n  foreach var char in s do\n  begin\n    if charCount.ContainsKey(char) then\n      charCount[char\n    ] += 1\n    else\n      charCount[char\n    ] := 1;\n  end;\n  var oddCounts := 0;\n  foreach var count in charCount.Values do\n    if count mod 2 <> 0 then\n      oddCounts += 1;\n  Result := oddCounts <= 1;\nend;"
  },
  {
    "instruction": "Write a function to check if a given list of integers can be rearranged to form a sequence of consecutive numbers.",
    "output": "function ConsecutiveSequence(nums: array of integer): boolean;\nbegin\n  if nums.Length = 0 then\n  begin\n    Result := False;\n    exit;\n  end;\n  nums := nums.Order.ToArray;\n  for var i := 1 to nums.Length - 1 do\n    if nums[i\n    ] <> nums[i - 1\n    ] + 1 then\n    begin\n      Result := False;\n      exit;\n    end;\n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function to find the number of longest increasing subsequences in the given list.",
    "output": "function NumOfLIS(nums: array of integer): integer;\nbegin\n  if nums.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  var length := nums.Length;\n  var dpLen := ArrFill(length,1);\n  var dpNum := ArrFill(length, 1);\n  var maxLen := 1;\n  var res := 0;\n  for var i := 1 to length - 1 do\n  begin\n    for var j := 0 to i - 1 do\n    begin\n      if nums[i\n    ] > nums[j\n    ] then\n      begin\n        if dpLen[j\n    ] + 1 > dpLen[i\n    ] then\n        begin\n          dpLen[i\n    ] := dpLen[j\n    ] + 1;\n          dpNum[i\n    ] := dpNum[j\n    ];\n        end\n        else if dpLen[j\n    ] + 1 = dpLen[i\n    ] then\n          dpNum[i\n    ] += dpNum[j\n    ];\n      end;\n    end;\n    maxLen := Max(maxLen, dpLen[i\n    ]);\n  end;\n  for var i := 0 to length - 1 do\n    if dpLen[i\n    ] = maxLen then\n      res += dpNum[i\n    ];\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum nested depth of a given dictionary.",
    "output": "function FindMaxDepth(d: Dictionary<string, object>): integer;\n\n  function GetDepth(currentDict: Dictionary<string, object>): integer;\n  begin\n    if (currentDict = nil) or (currentDict.Count = 0) then\n    begin\n      Result := 0;\n      exit;\n    end;\n    var maxChildDepth := 0;\n    foreach var value in currentDict.Values do\n    begin\n      if value is Dictionary<string, object> then\n        maxChildDepth := Max(maxChildDepth, GetDepth(value as Dictionary<string, object>));\n    end;\n    Result := 1 + maxChildDepth;\n  end;\n\nbegin\n  Result := GetDepth(d);\nend;"
  },
  {
    "instruction": "Write a function to find the maximum sum of non-adjacent elements in a circular array.",
    "output": "function CircularHouseRobber(nums: array of integer): integer;\n\n  function HouseRobber(nums: array of integer): integer;\n  begin\n    var rob1 := 0;\n    var rob2 := 0;\n    foreach var n in nums do\n    begin\n      var newRob := Max(rob1 + n, rob2);\n      rob1 := rob2;\n      rob2 := newRob;\n    end;\n    Result := rob2;\n  end;\n\nbegin\n  Result := Max(HouseRobber(nums[\n      :^1\n    ]), HouseRobber(nums[\n      1:\n    ]));\nend;"
  },
  {
    "instruction": "Create a function that utilizes the linked list data structure provided in the algorithm to create a new linked list, and then adds, deletes, and retrieves elements as specified. The function will take the following parameters:\n1. A list of integers to initialize the linked list.\n2. A command string that could be \"addAtHead\", \"addAtTail\", \"addAtIndex\", \"deleteAtIndex\", or \"get\".\n3. The value to be added or the index to be accessed or deleted (as applicable).",
    "output": "type\n  Node = class\n    val: integer;\n    next: Node;\n    constructor(v: integer);\n    begin\n      val := v;\n      next := nil;\n    end;\n  end;\n\n  MyLinkedList = class\n    head: Node;\n    size: integer;\n    constructor;\n    begin\n      head := nil;\n      size := 0;\n    end;\n\n    function Get(index: integer): integer;\n    begin\n      if (index >= size) or (index < 0) then\n      begin\n        Result := -1;\n        exit;\n      end;\n      var currNode := head;\n      for var k := 1 to index do\n        currNode := currNode.next;\n      Result := currNode.val;\n    end;\n\n    procedure AddAtHead(val: integer);\n    begin\n      var newNode := new Node(val);\n      if head = nil then\n        head := newNode\n      else\n      begin\n        newNode.next := head;\n        head := newNode;\n      end;\n      size += 1;\n    end;\n\n    procedure AddAtTail(val: integer);\n    begin\n      var newNode := new Node(val);\n      if head = nil then\n        head := newNode\n      else\n      begin\n        var currNode := head;\n        while currNode.next <> nil do\n          currNode := currNode.next;\n        currNode.next := newNode;\n      end;\n      size += 1;\n    end;\n\n    procedure AddAtIndex(index: integer; val: integer);\n    begin\n      if (index < 0) or (index > size) then\n        exit;\n      var newNode := new Node(val);\n      var currNode := head;\n      if index = 0 then\n      begin\n        newNode.next := head;\n        head := newNode;\n      end\n      else\n      begin\n        for var k := 1 to index - 1 do\n          currNode := currNode.next;\n        newNode.next := currNode.next;\n        currNode.next := newNode;\n      end;\n      size += 1;\n    end;\n\n    procedure DeleteAtIndex(index: integer);\n    begin\n      if (index < 0) or (size <= index) then\n        exit;\n      if head = nil then\n        exit;\n      var currNode := head;\n      if index = 0 then\n        head := head.next\n      else\n      begin\n        for var k := 1 to index - 1 do\n          currNode := currNode.next;\n        currNode.next := currNode.next.next;\n      end;\n      size -= 1;\n    end;\n  end;\n\nfunction LinkedListOperations(initialList: array of integer; command: string; params args: array of integer): integer;\nbegin\n  var listOperations := new MyLinkedList;\n  foreach var num in initialList do\n    listOperations.AddAtTail(num);\n  case command of\n    'addAtHead': listOperations.AddAtHead(args[\n      0\n    ]);\n    'addAtTail': listOperations.AddAtTail(args[\n      0\n    ]);\n    'addAtIndex': listOperations.AddAtIndex(args[\n      0\n    ], args[\n      1\n    ]);\n    'get': Result := listOperations.Get(args[\n      0\n    ]);\n    'deleteAtIndex': listOperations.DeleteAtIndex(args[\n      0\n    ]);\n  else\n    Print('Invalid command');\n  end;\n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function that takes in a list of integers and returns True if there exists a subsequence of length 3 that is an arithmetic progression with a common difference of 1. Otherwise, return False.",
    "output": "function FindArithmeticSubsequence(nums: array of integer): boolean;\nbegin\n  for var i := 0 to nums.Length - 3 do\n    if (nums[i + 1\n    ] - nums[i\n    ] = 1) and (nums[i + 2\n    ] - nums[i + 1\n    ] = 1) then\n    begin\n      Result := True;\n      exit;\n    end;\n  Result := False;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns the maximum product of any two distinct numbers in the list.",
    "output": "function MaxProduct(nums: array of integer): integer;\nbegin\n  nums := nums.Order.ToArray;\n  Result := Max(nums[\n      0\n    ] * nums[\n      1\n    ], nums[^1\n    ] * nums[^2\n    ]);\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns the list with each element's square root.",
    "output": "function SquareRootList(numbers: array of integer): array of real;\nbegin\n  Result := numbers.Select(x -> Sqrt(x)).ToArray;\nend;"
  },
  {
    "instruction": "Write a function to reverse the order of the elements in an array, but do not use any built-in reverse or sort functions. The function should modify the array in-place.",
    "output": "procedure ReverseArray(var arr: array of integer);\nbegin\n  var start := 0;\n  var endIndex := arr.Length - 1;\n  while start < endIndex do\n  begin\n    Swap(arr[start\n    ], arr[endIndex\n    ]);\n    start += 1;\n    endIndex -= 1;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to detect if two rectangles defined by their bottom-left corner (x1, y1) and top-right corner (x2, y2) overlap with each other.",
    "output": "function Overlap(rect1, rect2: (integer, integer, integer, integer)): boolean;\nbegin\n  var (x1, y1, x2, y2) := rect1;\n  var (x3, y3, x4, y4) := rect2;\n  if (x2 < x3) or (x4 < x1) or (y2 < y3) or (y4 < y1) then\n    Result := False\n  else\n    Result := True;\nend;"
  },
  {
    "instruction": "Write a function to convert the given list of numbers into a dictionary where keys are the numbers and the values are their square roots.",
    "output": "function NumbersToSqrtDict(numbers: array of integer): Dictionary<integer, real>;\nbegin\n  var numberDict := new Dictionary<integer, real>;\n  foreach var number in numbers do\n    numberDict[number\n    ] := Sqrt(number);\n  Result := numberDict;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of toys that can be purchased with a given amount of money. Each toy has a price, and you can buy as many toys of each type as you want. The function should return the maximum number of toys that can be bought.",
    "output": "function MaxToys(prices: array of integer; k: integer): integer;\nbegin\n  prices := prices.Order.ToArray;\n  var count := 0;\n  foreach var price in prices do\n  begin\n    if k >= price then\n    begin\n      k -= price;\n      count += 1;\n    end\n    else\n      break;\n  end;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the count of all unique substrings of a given string.",
    "output": "function CountUniqueSubstring(s: string): integer;\nbegin\n  var n := s.Length;\n  var uniqueSubstrings := new HashSet<string>;\n  for var i := 0 to n - 1 do\n    for var j := i + 1 to n do\n      uniqueSubstrings.Add(s.Substring(i, j - i));\n  Result := uniqueSubstrings.Count;\nend;"
  },
  {
    "instruction": "Write a function that slices a given list into multiple sublists based on the provided slicing ranges. The function should return a list of elements from the original list that fall within each slicing range.",
    "output": "function SliceList(arr: array of integer; ranges: array of (integer, integer)): array of array of integer;\nbegin\n  var resultList := new List<array of integer>;\n  foreach var r in ranges do\n  begin\n    var startIdx := r[0];\n    var endIdx := r[1];\n    if startIdx < 0 then startIdx := 0;\n    if endIdx > arr.Length then endIdx := arr.Length;\n    var sublist := new List<integer>;\n    for var i := startIdx to endIdx - 1 do\n      sublist.Add(arr[i]);\n    resultList.Add(sublist.ToArray);\n  end;\n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to count the number of groups of consecutive 1's and 0's in a binary string. A group is defined as a sequence of one or more consecutive 1's or 0's.\n\nFor example, in the binary string \"110001111010\", there are 6 groups: \"11\", \"000\", \"1111\", \"0\", \"1\", and \"0\".",
    "output": "function CountGroups(binaryString: string): integer;\nbegin\n  var count := 0;\n  var i := 1;\n  while i <= binaryString.Length do\n  begin\n    count += 1;\n    while (i < binaryString.Length) and (binaryString[i\n    ] = binaryString[i - 1\n    ]) do\n      i += 1;\n    i += 1;\n  end;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the longest increasing subsequence in a given array.",
    "output": "function LongestIncreasingSubsequence(arr: array of integer): integer;\nbegin\n  var n := arr.Length;\n  var lis := ArrFill(n,1);\n  for var i := 1 to n - 1 do\n    for var j := 0 to i - 1 do\n      if (arr[i\n] > arr[j\n]) and (lis[i\n] < lis[j\n] + 1) then\n        lis[i\n] := lis[j\n] + 1;\n  var maximum := 0;\n  for var i := 0 to n - 1 do\n    maximum := Max(maximum, lis[i\n]);\n  Result := maximum;\nend;"
  },
  {
    "instruction": "Write a function to shift the elements of a list to the right by a given number of positions. The elements that are shifted beyond the last position are re-introduced at the beginning of the list.",
    "output": "function ShiftList(nums: array of integer; k: integer): array of integer;\nbegin\n  k := k mod nums.Length;\n  Result := nums[^k:\n    ] + nums[\n      :^k\n    ];\nend;"
  },
  {
    "instruction": "Write a function to find the number of inversions in a list. An inversion is a pair of indices (i, j) such that i < j and lst[i] > lst[j].",
    "output": "function NumInversions(lst: array of integer): integer;\n\n  function MergeCount(arr: array of integer; left, right: integer): integer;\n  begin\n    if left >= right then\n    begin\n      Result := 0;\n      exit;\n    end;\n    var mid := (left + right) div 2;\n    var invCount := MergeCount(arr, left, mid) + MergeCount(arr, mid + 1, right);\n    \n    var temp := new integer[right - left + 1];\n    var i := left;\n    var j := mid + 1;\n    var k := 0;\n    \n    while (i <= mid) and (j <= right) do\n    begin\n      if arr[i] <= arr[j] then\n      begin\n        temp[k] := arr[i];\n        i += 1;\n      end\n      else\n      begin\n        temp[k] := arr[j];\n        j += 1;\n        invCount += mid - i + 1;\n      end;\n      k += 1;\n    end;\n    \n    while i <= mid do\n    begin\n      temp[k] := arr[i];\n      i += 1;\n      k += 1;\n    end;\n    \n    while j <= right do\n    begin\n      temp[k] := arr[j];\n      j += 1;\n      k += 1;\n    end;\n    \n    for var idx := 0 to temp.Length - 1 do\n      arr[left + idx] := temp[idx];\n    \n    Result := invCount;\n  end;\n\nbegin\n  var arrCopy := Copy(lst);\n  Result := MergeCount(arrCopy, 0, lst.Length - 1);\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of intervals needed to cover all given points on a line.",
    "output": "function FindMinIntervals(intervals: array of (integer, integer)): integer;\nbegin\n  if intervals.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  intervals := intervals.OrderBy(i -> (i[\n      0\n    ], -i[\n      1\n    ])).ToArray;\n  var coveredPoints := new HashSet<integer>;\n  var minIntervals := 0;\n  foreach var (start, endVal) in intervals do\n  begin\n    if not coveredPoints.Any(point -> (point >= start) and (point <= endVal)) then\n    begin\n      minIntervals += 1;\n      for var point := start to endVal do\n        coveredPoints.Add(point);\n    end;\n  end;\n  Result := minIntervals;\nend;"
  },
  {
    "instruction": "Write a function to find the number of distinct islands in a given 2D binary matrix.",
    "output": "function DistinctIslands(grid: array [,] of integer): integer;\n\n  function Dfs(i, j: integer; var grid: array [,] of integer; base: string): string;\n  begin\n    if (i < 0) or (j < 0) or (i >= grid.GetLength(0)) or (j >= grid.GetLength(1)) or (grid[i, j\n    ] <> 1) then\n    begin\n      Result := '';\n      exit;\n    end;\n    grid[i, j\n    ] := 0;\n    Result := base + '(' + Dfs(i + 1, j, grid, 'd') + Dfs(i - 1, j, grid, 'u') + Dfs(i, j + 1, grid, 'r') + Dfs(i, j - 1, grid, 'l') + ')';\n  end;\n\nbegin\n  var islands := new HashSet<string>;\n  for var i := 0 to grid.GetLength(0) - 1 do\n    for var j := 0 to grid.GetLength(1) - 1 do\n      if grid[i, j\n    ] = 1 then\n        islands.Add(Dfs(i, j, grid, ''));\n  Result := islands.Count;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum path sum in a binary tree.",
    "output": "type\n  TreeNode = class\n    val: integer;\n    left, right: TreeNode;\n    constructor(x: integer);\n    begin\n      val := x;\n      left := nil;\n      right := nil;\n    end;\n  end;\n\nfunction MaxPathSum(nums: array of integer): integer;\n\n  function CreateTree(var root: TreeNode; nums: array of integer; i: integer): TreeNode;\n  begin\n    if i < nums.Length then\n    begin\n      if nums[i\n    ] = 0 then\n        Result := nil\n      else\n      begin\n        root := new TreeNode(nums[i\n    ]);\n        root.left := CreateTree(root.left, nums,2 * i + 1);\n        root.right := CreateTree(root.right, nums,2 * i + 2);\n        Result := root;\n      end;\n    end\n    else\n      Result := nil;\n  end;\n\n  function MaxGain(node: TreeNode; var maxSum: integer): integer;\n  begin\n    if node = nil then\n    begin\n      Result := 0;\n      exit;\n    end;\n    var leftGain := Max(MaxGain(node.left, maxSum),0);\n    var rightGain := Max(MaxGain(node.right, maxSum),0);\n    var priceNewpath := node.val + leftGain + rightGain;\n    maxSum := Max(maxSum, priceNewpath);\n    Result := node.val + Max(leftGain, rightGain);\n  end;\n\nbegin\n  var root: TreeNode := nil;\n  root := CreateTree(root, nums,0);\n  var maxSum := integer.MinValue;\n  MaxGain(root, maxSum);\n  Result := maxSum;\nend;"
  },
  {
    "instruction": "Write a function to find the longest valid parentheses in a string.",
    "output": "function LongestValidParentheses(s: string): integer;\nbegin\n  var longest := 0;\n  var stack := new Stack<integer>;\n  stack.Push(-1);\n  for var i := 0 to s.Length - 1 do\n  begin\n    if s[i + 1\n    ] = '(' then\n      stack.Push(i)\n    else\n    begin\n      stack.Pop;\n      if stack.Count = 0 then\n        stack.Push(i)\n      else\n        longest := Max(longest, i - stack.Peek);\n    end;\n  end;\n  Result := longest;\nend;"
  },
  {
    "instruction": "Write a function to find the largest number in a list that is smaller than a given number.",
    "output": "function FindSmaller(lst: array of integer; num: integer): integer;\nbegin\n  var smallerNums := lst.Where(x -> x < num).ToArray;\n  if smallerNums.Length = 0 then\n    Result := 0\n  else\n    Result := smallerNums.Max;\nend;"
  },
  {
    "instruction": "Write a function to find the majority element in a given array. The majority element is the element that appears more than \u230an/2\u230b times in the array.",
    "output": "function MajorityElement(nums: array of integer): integer;\nbegin\n  var count := 0;\n  var candidate := 0;\n  foreach var n in nums do\n  begin\n    if count = 0 then\n      candidate := n;\n    if n = candidate then\n      count += 1\n    else\n      count -= 1;\n  end;\n  Result := candidate;\nend;"
  },
  {
    "instruction": "Write a function to find the first non-repeating character in a given string.",
    "output": "function FirstNonRepeatingCharacter(s: string): char;\nbegin\n  var charCount := new Dictionary<char, integer>;\n  foreach var char in s do\n  begin\n    if charCount.ContainsKey(char) then\n      charCount[char\n    ] += 1\n    else\n      charCount[char\n    ] := 1;\n  end;\n  foreach var char in s do\n    if charCount[char\n    ] = 1 then\n    begin\n      Result := char;\n      exit;\n    end;\n  Result := #0;\nend;"
  },
  {
    "instruction": "Write a function to find the intersection of two sets using the most efficient method.",
    "output": "function EfficientIntersection(set1, set2: HashSet<integer>): HashSet<integer>;\nbegin\n  Result := set1.Intersect(set2).ToHashSet;\nend;"
  },
  {
    "instruction": "Write a function to check if a string s can be transformed into a string t by rearranging the characters in s. The characters in s can be rearranged in any order, as long as the relative order among the characters of the same type remains unchanged.",
    "output": "function IsTransformable(s, t: string): boolean;\nbegin\n  if s.Length <> t.Length then\n  begin\n    Result := False;\n    exit;\n  end;\n  var sCounter := new Dictionary<char, integer>;\n  var tCounter := new Dictionary<char, integer>;\n  foreach var char in s do\n  begin\n    if sCounter.ContainsKey(char) then\n      sCounter[char\n    ] += 1\n    else\n      sCounter[char\n    ] := 1;\n  end;\n  foreach var char in t do\n  begin\n    if tCounter.ContainsKey(char) then\n      tCounter[char\n    ] += 1\n    else\n      tCounter[char\n    ] := 1;\n  end;\n  foreach var char in tCounter.Keys do\n    if (not sCounter.ContainsKey(char)) or (tCounter[char\n    ] > sCounter[char\n    ]) then\n    begin\n      Result := False;\n      exit;\n    end;\n  var sSorted := s.ToCharArray.Order.ToArray;\n  var tSorted := t.ToCharArray.Order.ToArray;\n  for var i := 0 to s.Length - 1 do\n    if sSorted[i\n    ] <> tSorted[i\n    ] then\n    begin\n      Result := False;\n      exit;\n    end;\n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum length of a palindrome that can be built with the letters of the given string. Each letter can be used at most once and the palindrome does not have to be a valid word.",
    "output": "function MaxPalindrome(s: string): integer;\nbegin\n  var count := new Dictionary<char, integer>;\n  foreach var c in s do\n  begin\n    if count.ContainsKey(c) then\n      count[c] := count[c] + 1\n    else\n      count[c] := 1;\n  end;\n\n  var res := 0;\n  var hasOdd := False;\n\n  foreach var v in count.Values do\n  begin\n    if v mod 2 = 0 then\n      res += v\n    else\n    begin\n      res += v - 1;\n      hasOdd := True;\n    end;\n  end;\n\n  if hasOdd then\n    res += 1;\n\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the first unique character in a given string.",
    "output": "function FirstUniqueCharacter(s: string): integer;\nbegin\n  var charCount := new Dictionary<char, integer>;\n  foreach var char in s do\n  begin\n    if charCount.ContainsKey(char) then\n      charCount[char\n    ] += 1\n    else\n      charCount[char\n    ] := 1;\n  end;\n  for var index := 1 to s.Length do\n    if charCount[s[index\n      ]\n    ] = 1 then\n    begin\n      Result := index - 1;\n      exit;\n    end;\n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest substring without repeating characters.",
    "output": "function LenLongestSubstring(s: string): integer;\nbegin\n  var last := new Dictionary<char, integer>;\n  var left := 0;\n  var best := 0;\n\n  for var right := 0 to s.Length - 1 do\n  begin\n    var c := s[right + 1];\n\n    if last.ContainsKey(c) and (last[c] >= left) then\n      left := last[c] + 1;\n\n    last[c] := right;\n\n    var cur := right - left + 1;\n    if cur > best then best := cur;\n  end;\n\n  Result := best;\nend;"
  },
  {
    "instruction": "Write a function that counts the number of ways a given integer can be expressed as the sum of unique positive integers.",
    "output": "function CountUniqueSums(n: integer): integer;\nbegin\n  var memo := ArrFill(n + 1,0);\n  memo[\n      0\n] := 1;\n  for var i := 1 to n do\n    for var j := i to n do\n      memo[j\n] += memo[j - i\n];\n  Result := memo[n\n];\nend;"
  },
  {
    "instruction": "Write a function to find the shortest path in a directed graph from a given source node to a given target node using breadth-first search.",
    "output": "function ShortestPath(edges: array of (integer, integer); source, target: integer): array of integer;\nbegin\n  var graph := new Dictionary<integer, List<integer>>;\n  foreach var edge in edges do\n  begin\n    if not graph.ContainsKey(edge[\n      0\n    ]) then\n      graph[edge[\n        0\n      ]\n    ] := new List<integer>;\n    graph[edge[\n        0\n      ]\n    ].Add(edge[\n      1\n    ]);\n  end;\n  var queue := new Queue<integer>;\n  queue.Enqueue(source);\n  var path := new Dictionary<integer, array of integer>;\n  path[source\n    ] := Arr(source);\n  while queue.Count > 0 do\n  begin\n    var current := queue.Dequeue;\n    if current = target then\n      break;\n    if graph.ContainsKey(current) then\n      foreach var neighbor in graph[current\n    ] do\n        if not path.ContainsKey(neighbor) then\n        begin\n          queue.Enqueue(neighbor);\n          path[neighbor\n    ] := path[current\n    ] + Arr(neighbor);\n        end;\n  end;\n  if path.ContainsKey(target) then\n    Result := path[target\n    ]\n  else\n    Result := nil;\nend;"
  },
  {
    "instruction": "Write a function to find the prime numbers within a given range.",
    "output": "function PrimeNumbersRange(low, high: integer): array of integer;\nbegin\n  var primes := new List<integer>;\n  for var num := low to high do\n  begin\n    if num > 1 then\n    begin\n      var isPrime := True;\n      for var i := 2 to num - 1 do\n        if num mod i = 0 then\n        begin\n          isPrime := False;\n          break;\n        end;\n      if isPrime then\n        primes.Add(num);\n    end;\n  end;\n  Result := primes.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to calculate the number of jumps required for a frog to reach the other side of a flower pond. The pond is represented as an array A, where each element represents the maximum jump length from that position. The frog starts at position 0 and must reach position n-1. The function should return -1 if it's not possible for the frog to cross the pond.",
    "output": "function FrogJump(A: array of integer): integer;\nbegin\n  var n := A.Length;\n  var jumps := 0;\n  var currReach := 0;\n  var farthest := 0;\n  for var i := 0 to n - 2 do\n  begin\n    farthest := Max(farthest, i + A[i\n    ]);\n    if i = currReach then\n    begin\n      jumps += 1;\n      currReach := farthest;\n    end;\n    if currReach >= n - 1 then\n    begin\n      Result := jumps;\n      exit;\n    end;\n  end;\n  if currReach < n - 1 then\n    Result := -1\n  else\n    Result := jumps;\nend;"
  },
  {
    "instruction": "Write a function to find the first and last occurrence of a target element in a sorted list of integers. If the element is not found, return [-1, -1].",
    "output": "function SearchElementRange(nums: array of integer; target: integer): (integer, integer);\nbegin\n  if nums.Length = 0 then\n  begin\n    Result := (-1,-1);\n    exit;\n  end;\n  var lo := 0;\n  var hi := nums.Length - 1;\n  var center := -1;\n  while lo <= hi do\n  begin\n    var mid := (lo + hi) div 2;\n    if nums[mid\n] = target then\n    begin\n      center := mid;\n      break;\n    end\n    else if nums[mid\n] > target then\n      hi := mid - 1\n    else\n      lo := mid + 1;\n  end;\n  if center = -1 then\n  begin\n    Result := (-1,-1);\n    exit;\n  end;\n  lo := center;\n  hi := center;\n  while (lo - 1 >= 0) and (nums[lo - 1\n] = target) do\n    lo -= 1;\n  while (hi + 1 <= nums.Length - 1) and (nums[hi + 1\n] = target) do\n    hi += 1;\n  Result := (lo, hi);\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings and returns a list of strings with each string being a palindrome. A palindrome is a word that reads the same backward as forward.",
    "output": "function StringToPalindrome(lst: array of string): array of string;\nbegin\n  Result := lst.Select(s -> s.Reverse.JoinToString('')).ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to reach the last cell of a grid from the first cell using only right and down moves. The grid is represented as a list of lists, where 0 represents an open cell and 1 represents a blocked cell.",
    "output": "function GridPath(grid: array [,] of integer): integer;\nbegin\n  var m := grid.GetLength(0);\n  var n := grid.GetLength(1);\n  var dp := new integer[m, n];\n  \n  if grid[0, 0] = 0 then\n    dp[0, 0] := 1\n  else\n    dp[0, 0] := 0;\n    \n  for var i := 0 to m - 1 do\n    for var j := 0 to n - 1 do\n    begin\n      if grid[i, j] = 1 then\n        dp[i, j] := 0\n      else\n      begin\n        if i > 0 then\n          dp[i, j] += dp[i - 1, j];\n        if j > 0 then\n          dp[i, j] += dp[i, j - 1];\n      end;\n    end;\n  Result := dp[m - 1, n - 1];\nend;"
  },
  {
    "instruction": "Write a function to find the smallest palindrome in a given string. The palindrome must be at least a certain length and consist of only lowercase letters. A palindrome is a word that reads the same backward as forward.",
    "output": "function SmallestPalindrome(s: string; k: integer): string;\n\n  function ExpandAroundCenter(left, right: integer): string;\n  begin\n    while (left >= 1) and (right <= s.Length) and (s[left\n    ] = s[right\n    ]) do\n    begin\n      left -= 1;\n      right += 1;\n    end;\n    Result := s.Substring(left + 1, right - left - 1);\n  end;\n\nbegin\n  var smallest: string := nil;\n  for var i := 1 to s.Length do\n  begin\n    var palindrome1 := ExpandAroundCenter(i, i);\n    var palindrome2 := ExpandAroundCenter(i, i + 1);\n    if (palindrome1.Length >= k) and ((smallest = nil) or (palindrome1.Length < smallest.Length)) then\n      smallest := palindrome1;\n    if (palindrome2.Length >= k) and ((smallest = nil) or (palindrome2.Length < smallest.Length)) then\n      smallest := palindrome2;\n  end;\n  Result := smallest;\nend;"
  },
  {
    "instruction": "Write a function that takes a sentence and a number as inputs, and returns the sentence after shifting the letters in the sentence by the number. If the number is greater than 26, it should wrap around to the beginning of the alphabet. The function should preserve the case of the letters and ignore any non-alphabet characters.",
    "output": "function ShiftSentence(sentence: string; n: integer): string;\nbegin\n  var answer := new List<char>;\n  for var i := 1 to sentence.Length do\n  begin\n    var alpha := Ord(sentence[i\n    ]);\n    var letter := alpha + n;\n    if (65 <= alpha) and (alpha <= 90) then\n    begin\n      if letter > 90 then\n        letter := 64 + (letter - 90);\n      answer.Add(Chr(letter));\n    end\n    else if (97 <= alpha) and (alpha <= 122) then\n    begin\n      if letter > 122 then\n        letter := 96 + (letter - 122);\n      answer.Add(Chr(letter));\n    end\n    else\n      answer.Add(sentence[i\n    ]);\n  end;\n  Result := answer.JoinToString('');\nend;"
  },
  {
    "instruction": "Write a function to find the shortest distance from every cell with value 1 to the nearest 0 in a binary matrix.",
    "output": "function ShortestDistance(mat: array [,] of integer): array [,] of integer;\nbegin\n  var queue := new Queue<(integer, integer, integer)>;\n  var seen := new HashSet<(integer, integer)>;\n  for var i := 0 to mat.GetLength(0) - 1 do\n    for var j := 0 to mat.GetLength(1) - 1 do\n      if mat[i, j\n    ] = 0 then\n      begin\n        queue.Enqueue((i, j,0));\n        seen.Add((i, j));\n      end;\n  while queue.Count > 0 do\n  begin\n    var (i, j, steps) := queue.Dequeue;\n    var directions := Arr((0,1), (1,0), (-1,0), (0,-1));\n    foreach var (di, dj) in directions do\n    begin\n      var p := i + di;\n      var q := j + dj;\n      if (0 <= p) and (p < mat.GetLength(0)) and (0 <= q) and (q < mat.GetLength(1)) and not seen.Contains((p, q)) then\n      begin\n        seen.Add((p, q));\n        queue.Enqueue((p, q, steps + 1));\n        mat[p, q\n] := steps + 1;\n      end;\n    end;\n  end;\n  Result := mat;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns a new list with each element squared. Then, reverse the squared list and return it.",
    "output": "function SquareAndReverse(lst: array of integer): array of integer;\nbegin\n  var squaredLst := lst.Select(i -> i * i).ToArray;\n  Result := squaredLst.Reverse.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the greatest common divisor (GCD) of two given numbers using the Euclidean algorithm.",
    "output": "function EuclideanGCD(a, b: integer): integer;\nbegin\n  while b <> 0 do\n  begin\n    (a, b) := (b, a mod b);\n  end;\n  Result := a;\nend;"
  },
  {
    "instruction": "Write a function to find the count of all unique substrings of a given string that are palindromes.",
    "output": "function CountPalindromicSubstring(s: string): integer;\n\n  function ExpandAroundCenter(s: string; left, right: integer): integer;\n  begin\n    var count := 0;\n    while (left >= 1) and (right <= s.Length) and (s[left\n    ] = s[right\n    ]) do\n    begin\n      count += 1;\n      left -= 1;\n      right += 1;\n    end;\n    Result := count;\n  end;\n\nbegin\n  var totalCount := 0;\n  for var i := 1 to s.Length do\n  begin\n    totalCount += ExpandAroundCenter(s, i, i);\n    totalCount += ExpandAroundCenter(s, i, i + 1);\n  end;\n  Result := totalCount;\nend;"
  },
  {
    "instruction": "Write a function to generate all possible strings by pressing keys on a telephone keypad.",
    "output": "function Keypad(num: integer): array of string;\nbegin\n  var keypadMap := new Dictionary<integer, array of char>;\n\n  keypadMap[1] := Arr('a', 'b', 'c');\n  keypadMap[2] := Arr('d', 'e', 'f');\n  keypadMap[3] := Arr('g', 'h', 'i');\n  keypadMap[4] := Arr('j', 'k', 'l');\n  keypadMap[5] := Arr('m', 'n', 'o');\n  keypadMap[6] := Arr('p', 'q', 'r', 's');\n  keypadMap[7] := Arr('t', 'u', 'v');\n  keypadMap[8] := Arr('w', 'x', 'y', 'z');\n  keypadMap[9] := Arr(' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9');\n\n  if keypadMap.ContainsKey(num) then\n    Result := keypadMap[num].Cast&<string>().ToArray()\n  else\n    Result := nil;\nend;"
  },
  {
    "instruction": "Write a function to return the indices of buildings where you can see the sunset given the heights of buildings. A building can see the sunset if it is taller than all the buildings to its right. The function should return the indices of these buildings in ascending order.",
    "output": "function SunsetViews(buildings: array of integer): array of integer;\nbegin\n  if buildings.Length = 0 then\n  begin\n    Result := nil;\n    exit;\n  end;\n  var resultList := new List<integer>;\n  var maxHeight := buildings[buildings.Length - 1];\n  resultList.Add(buildings.Length - 1);\n  for var i := buildings.Length - 2 downto 0 do\n  begin\n    if buildings[i] > maxHeight then\n    begin\n      resultList.Add(i);\n      maxHeight := buildings[i];\n    end;\n  end;\n  resultList.Reverse;\n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the number of unique binary search trees (BSTs) that store values 1...n.",
    "output": "function UniqueBST(n: integer): integer;\nbegin\n  if n <= 1 then\n  begin\n    Result := 1;\n    exit;\n  end;\n  var dp := ArrFill(n + 1,0);\n  dp[\n      0\n] := 1;\n  dp[\n      1\n] := 1;\n  for var i := 2 to n do\n    for var j := 0 to i - 1 do\n      dp[i\n] += dp[j\n] * dp[i - j - 1\n];\n  Result := dp[n\n];\nend;"
  },
  {
    "instruction": "Write a function to check the validity of a password. A valid password should have at least 8 characters, contain at least one uppercase letter, one lowercase letter, one digit, and one special character.",
    "output": "function PasswordValidity(password: string): boolean;\nbegin\n  if password.Length < 8 then\n  begin\n    Result := False;\n    exit;\n  end;\n  if not password.Any(c -> c.IsLower) then\n  begin\n    Result := False;\n    exit;\n  end;\n  if not password.Any(c -> c.IsUpper) then\n  begin\n    Result := False;\n    exit;\n  end;\n  if not password.Any(c -> c.IsDigit) then\n  begin\n    Result := False;\n    exit;\n  end;\n  var specialChars := '!@#$%^&*()_+=-{}<>?:;|.,';\n  if not password.Any(c -> specialChars.Contains(c)) then\n  begin\n    Result := False;\n    exit;\n  end;\n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings and returns a new list where each string is converted to title case.",
    "output": "function ConvertToTitleCase(strings: array of string): array of string;\nbegin\n  var resultList := new List<string>;\n  foreach var s in strings do\n  begin\n    if s.Length > 0 then\n      resultList.Add(s[1].ToUpper + s.Substring(1).ToLower)\n    else\n      resultList.Add(s);\n  end;\n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to count the number of valleys a hiker has traversed given a path of 'U' for up and 'D' for down. A valley is defined as the sequence of down and up steps that takes the hiker below sea level and then back up to sea level.",
    "output": "function CountingValleys(steps: integer; path: string): integer;\nbegin\n  var valley := 0;\n  var current := 0;\n  for var i := 1 to steps do\n  begin\n    var previous := current;\n    if path[i\n    ] = 'U' then\n      current += 1;\n    if path[i\n    ] = 'D' then\n      current -= 1;\n    if (current = 0) and (i <> 1) then\n      if previous = -1 then\n        valley += 1;\n  end;\n  Result := valley;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns the product of all the elements in the list that are smaller than the maximum element in the list.",
    "output": "function ProductSmallerThanMax(nums: array of integer): integer;\nbegin\n  var maxNum := nums.Max;\n  var product := 1;\n  foreach var num in nums do\n    if num < maxNum then\n      product *= num;\n  Result := product;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum element in each subarray of a given size in an array.",
    "output": "function MaxInSubarrays(arr: array of integer; k: integer): array of integer;\nbegin\n  if (arr.Length = 0) or (k <= 0) then\n  begin\n    Result := nil;\n    exit;\n  end;\n  var resultList := new List<integer>;\n  var deque := new Queue<integer>;\n  for var i := 0 to arr.Length - 1 do\n  begin\n    while (deque.Count > 0) and (deque.Peek <= i - k) do\n      deque.Dequeue;\n    while (deque.Count > 0) and (arr[deque.Peek] <= arr[i]) do\n      deque.Dequeue;\n    deque.Enqueue(i);\n    if i >= k - 1 then\n      resultList.Add(arr[deque.Peek]);\n  end;\n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum cost path in a 2D matrix from the top left corner to the bottom right corner. You can only move right or down.",
    "output": "function MinCostPath(matrix: array [,] of integer): integer;\nbegin\n  var m := matrix.GetLength(0);\n  var n := matrix.GetLength(1);\n  for var i := 1 to n - 1 do\n    matrix[\n      0, i\n    ] += matrix[\n      0, i - 1\n    ];\n  for var i := 1 to m - 1 do\n    matrix[i,0\n] += matrix[i - 1,0\n];\n  for var i := 1 to m - 1 do\n    for var j := 1 to n - 1 do\n      matrix[i, j\n] += Min(matrix[i - 1, j\n], matrix[i, j - 1\n]);\n  Result := matrix[m - 1, n - 1\n];\nend;"
  },
  {
    "instruction": "Write a function to check if an Excel sheet can be evaluated based on the given rules. The Excel sheet is defined by cells containing values or mathematical expressions, and the function should determine if the sheet can be evaluated without any cyclic dependencies.",
    "output": "function BuildGraph(cells: array of string): Dictionary<string, List<string>>;\nbegin\n  var graph := new Dictionary<string, List<string>>;\n\n  foreach var cell in cells do\n  begin\n    var s := cell.Replace(' ', '');\n    var pos := s.IndexOf('=');\n\n    if pos > 0 then\n    begin\n      var name := s.Substring(0, pos);\n      var expr := s.Substring(pos + 1);\n\n      var deps := new List<string>;\n      var cur := '';\n\n      foreach var ch in expr do\n      begin\n        if ch.IsLetter or ch.IsDigit then\n          cur += ch\n        else\n        begin\n          if (cur <> '') and (cur.Any(c -> c.IsDigit)) then\n            deps.Add(cur);\n          cur := '';\n        end;\n      end;\n\n      if (cur <> '') and (cur.Any(c -> c.IsDigit)) then\n        deps.Add(cur);\n\n      graph[name] := deps;\n    end;\n  end;\n\n  Result := graph;\nend;\n\n\nfunction DfsCheck(node: string; graph: Dictionary<string, List<string>>;\n                  visited, rec: HashSet<string>): boolean;\nbegin\n  if rec.Contains(node) then\n  begin\n    Result := True;\n    exit;\n  end;\n\n  if visited.Contains(node) then\n  begin\n    Result := False;\n    exit;\n  end;\n\n  visited.Add(node);\n  rec.Add(node);\n\n  if graph.ContainsKey(node) then\n    foreach var nb in graph[node] do\n      if DfsCheck(nb, graph, visited, rec) then\n      begin\n        Result := True;\n        exit;\n      end;\n\n  rec.Remove(node);\n  Result := False;\nend;\n\n\nfunction HasCycle(graph: Dictionary<string, List<string>>): boolean;\nbegin\n  var visited := new HashSet<string>;\n  var rec := new HashSet<string>;\n\n  foreach var k in graph.Keys do\n    if DfsCheck(k, graph, visited, rec) then\n    begin\n      Result := True;\n      exit;\n    end;\n\n  Result := False;\nend;\n\n\nfunction CanEvaluateExcel(cells: array of string): boolean;\nbegin\n  var g := BuildGraph(cells);\n  Result := not HasCycle(g);\nend;"
  },
  {
    "instruction": "Write a function to find out whether a given phone book has any numbers that are prefixes of other numbers.",
    "output": "function PhoneBookCheck(phoneBook: array of string): boolean;\nbegin\n  var phoneDict := new Dictionary<string, integer>;\n  foreach var p in phoneBook do\n    for var i := 1 to p.Length - 1 do\n      phoneDict[p[\n        :i\n      ]\n    ] := 1;\n  foreach var p in phoneBook do\n    if phoneDict.ContainsKey(p) then\n    begin\n      Result := False;\n      exit;\n    end;\n  Result := True;\nend;"
  },
  {
    "instruction": "Create a function that takes a list of integers and returns a dictionary where the keys are the integers and the values are their frequency of appearance in the list.",
    "output": "function CreateFreqDict(numbers: array of integer): Dictionary<integer, integer>;\nbegin\n  var freqDict := new Dictionary<integer, integer>;\n  foreach var num in numbers do\n  begin\n    if freqDict.ContainsKey(num) then\n      freqDict[num\n    ] += 1\n    else\n      freqDict[num\n    ] := 1;\n  end;\n  Result := freqDict;\nend;"
  },
  {
    "instruction": "Write a function to sort a list of dictionaries based on a specific key.",
    "output": "function SortDictListByKey(dictList: array of Dictionary<string, integer>; key: string): array of Dictionary<string, integer>;\nbegin\n  Result := dictList.OrderBy(d -> d[key\n    ]).ToArray;\nend;"
  },
  {
    "instruction": "Write a function that checks if a given string can be rearranged into a palindrome by swapping any two characters exactly once. If it's possible, return True, otherwise, return False.",
    "output": "function CanSwapToPalindrome(s: string): boolean;\nbegin\n  var counts := new Dictionary<char, integer>;\n  var oddCounts := 0;\n  foreach var char in s do\n  begin\n    if counts.ContainsKey(char) then\n      counts[char\n    ] += 1\n    else\n      counts[char\n    ] := 1;\n  end;\n  foreach var count in counts.Values do\n    if count mod 2 <> 0 then\n      oddCounts += 1;\n  if oddCounts > 1 then\n  begin\n    Result := False;\n    exit;\n  end;\n  if (s.Length mod 2 = 0) and (oddCounts = 1) then\n  begin\n    Result := False;\n    exit;\n  end;\n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function to find the lowest missing positive integer from a given list of integers.",
    "output": "function FindLowestMissingPositive(nums: array of integer): integer;\nbegin\n  nums := nums.Where(num -> num > 0).Distinct.Order.ToArray;\n  var missing := 1;\n  foreach var num in nums do\n  begin\n    if num = missing then\n      missing += 1\n    else if num > missing then\n      break;\n  end;\n  Result := missing;\nend;"
  },
  {
    "instruction": "Write a function to find the power of the given number using recursion.",
    "output": "function GetPower(n, p: integer): integer;\nbegin\n  if p = 0 then\n    Result := 1\n  else if p = 1 then\n    Result := n\n  else\n    Result := n * GetPower(n, p - 1);\nend;"
  },
  {
    "instruction": "Write a function to find the number of steps required to make all the elements of an array equal, where in each step you can increment or decrement an element by 1.",
    "output": "function StepsToEqual(arr: array of integer): integer;\nbegin\n  arr := arr.Order.ToArray;\n  var median := arr[arr.Length div 2\n    ];\n  var steps := 0;\n  foreach var num in arr do\n    steps += Abs(num - median);\n  Result := steps;\nend;"
  },
  {
    "instruction": "Write a function to find the longest subarray where the absolute difference between any two elements is less than or equal to a given threshold.",
    "output": "function LongestSubarrayWithinThreshold(arr: array of integer; threshold: integer): integer;\nbegin\n  if arr.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  var maxLen := 0;\n  var minVal := arr[\n      0\n    ];\n  var maxVal := arr[\n      0\n    ];\n  var start := 0;\n  for var endIndex := 0 to arr.Length - 1 do\n  begin\n    minVal := Min(minVal, arr[endIndex\n    ]);\n    maxVal := Max(maxVal, arr[endIndex\n    ]);\n    while maxVal - minVal > threshold do\n    begin\n      if arr[start\n    ] = minVal then\n        minVal := arr[start + 1:endIndex + 1\n    ].Min\n      else if arr[start\n    ] = maxVal then\n        maxVal := arr[start + 1:endIndex + 1\n    ].Max;\n      start += 1;\n    end;\n    maxLen := Max(maxLen, endIndex - start + 1);\n  end;\n  Result := maxLen;\nend;"
  },
  {
    "instruction": "Write a function that takes in a list of integers and returns the first duplicate number for which the second occurrence has the minimal index. In other words, if there are multiple duplicated numbers, return the number for which the second occurrence has a smaller index than the second occurrence of the other number does. If there are no such elements, your function should return -1.",
    "output": "function FirstDuplicate(a: array of integer): integer;\nbegin\n  var seen := new HashSet<integer>;\n  foreach var num in a do\n  begin\n    if num in seen then\n    begin\n      Result := num;\n      exit;\n    end;\n    seen.Add(num);\n  end;\n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum value in a given list of numbers without using the built-in max() function.",
    "output": "function MaxNum(nums: array of integer): integer;\nbegin\n  if nums.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  var maxVal := nums[\n      0\n    ];\n  foreach var num in nums do\n    if num > maxVal then\n      maxVal := num;\n  Result := maxVal;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to make up a certain amount of money with a given list of coin denominations.",
    "output": "function CountMoneyWays(amount: integer; coins: array of integer): integer;\nbegin\n  var dp := ArrFill(amount + 1,0);\n  dp[\n      0\n] := 1;\n  foreach var coin in coins do\n    for var x := coin to amount do\n      dp[x\n] += dp[x - coin\n];\n  Result := dp[amount\n];\nend;"
  },
  {
    "instruction": "Develop a function that shifts all zeros in a list to the end of the list. The order of non-zero elements must be preserved.",
    "output": "function ShiftZeros(arr: array of integer): array of integer;\nbegin\n  var zeroCounter := 0;\n  var noZeroArr := new List<integer>;\n  foreach var num in arr do\n  begin\n    if num = 0 then\n      zeroCounter += 1\n    else\n      noZeroArr.Add(num);\n  end;\n  Result := noZeroArr.ToArray + ArrFill(zeroCounter,0);\nend;"
  },
  {
    "instruction": "Write a function to convert a given column number to its corresponding column title as it appears in an Excel sheet.\n\nFor example:\n1 -> A\n2 -> B\n3 -> C\n...\n26 -> Z\n27 -> AA\n28 -> AB",
    "output": "function NumberToTitle(n: integer): string;\nbegin\n  var res := '';\n  while n > 0 do\n  begin\n    var r := (n - 1) mod 26;\n    res := Chr(65 + r) + res;\n    n := (n - 1) div 26;\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the number of unique pairs in an array that have a difference of k.",
    "output": "function FindKDiffPairs(nums: array of integer; k: integer): integer;\nbegin\n  var answer := 0;\n  var cnt := new Dictionary<integer, integer>;\n  foreach var num in nums do\n  begin\n    if cnt.ContainsKey(num) then\n      cnt[num\n    ] += 1\n    else\n      cnt[num\n    ] := 1;\n  end;\n  foreach var num in cnt.Keys do\n  begin\n    if (k > 0) and cnt.ContainsKey(num + k) then\n      answer += 1;\n    if (k = 0) and (cnt[num\n    ] > 1) then\n      answer += 1;\n  end;\n  Result := answer;\nend;"
  },
  {
    "instruction": "Write a function to find the nth Catalan Number. Catalan Number is a sequence of natural numbers that has applications in combinatorial mathematics. The nth Catalan number can be calculated using the formula: Cn = (1/(n+1)) * (2n choose n)",
    "output": "function Catalan(n: integer): integer;\nbegin\n  if n <= 1 then\n  begin\n    Result := 1;\n    exit;\n  end;\n  var res := 0;\n  for var i := 0 to n - 1 do\n    res += Catalan(i) * Catalan(n - i - 1);\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the number of students doing homework at a given time.",
    "output": "function BusyStudent(startTime, endTime: array of integer; queryTime: integer): integer;\nbegin\n  var x := 0;\n  for var i := 0 to Max(startTime.Length, endTime.Length) - 1 do\n    if (startTime[i\n    ] <= queryTime) and (endTime[i\n    ] >= queryTime) then\n      x += 1;\n  Result := x;\nend;"
  },
  {
    "instruction": "Given two arrays of integers nums and index. Your task is to create target array under the following rules:\nInitially target array is empty.\nFrom left to right read nums[i] and index[i], insert at index index[i] the value nums[i] in target array.\nRepeat the previous step until there are no elements to read in nums and index.\nReturn the target array.\nIt is guaranteed that the insertion operations will be valid.",
    "output": "function CreateTargetArray(nums, index: array of integer): array of integer;\nbegin\n  var target := new List<integer>;\n  for var i := 0 to nums.Length - 1 do\n  begin\n    if index[i\n    ] = target.Count then\n      target.Add(nums[i\n    ])\n    else\n      target := target[\n      :index[i\n      ]\n    ] + Lst(nums[i\n    ]) + target[index[i\n      ]:\n    ];\n  end;\n  Result := target.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to convert a string to a list of characters.",
    "output": "function StrToCharList(s: string): array of char;\nbegin\n  Result := s.ToCharArray;\nend;"
  },
  {
    "instruction": "Write a function to find if a path exists between two nodes in a graph represented by a list of edges. The graph is undirected.",
    "output": "function ValidPath(n: integer; edges: array of (integer, integer); source, destination: integer): boolean;\nbegin\n  var g := new Dictionary<integer, List<integer>>;\n\n  foreach var e in edges do\n  begin\n    var a := e.Item1;\n    var b := e.Item2;\n    if not g.ContainsKey(a) then g[a] := new List<integer>;\n    if not g.ContainsKey(b) then g[b] := new List<integer>;\n    g[a].Add(b);\n    g[b].Add(a);\n  end;\n\n  var visited := new HashSet<integer>;\n  var stack := new Stack<integer>;\n  stack.Push(source);\n\n  while stack.Count > 0 do\n  begin\n    var v := stack.Pop;\n    if v = destination then\n    begin\n      Result := True;\n      exit;\n    end;\n    if visited.Contains(v) then continue;\n    visited.Add(v);\n    if g.ContainsKey(v) then\n      foreach var nx in g[v] do\n        if not visited.Contains(nx) then\n          stack.Push(nx);\n  end;\n\n  Result := False;\nend;"
  },
  {
    "instruction": "Write a function to calculate the sum of series 1!+2!+3!+\u2026.+n!.",
    "output": "function SumOfFactorials(number: integer): integer;\n\n  function Factorial(n: integer): integer;\n  begin\n    if n = 0 then\n      Result := 1\n    else\n      Result := n * Factorial(n - 1);\n  end;\n\nbegin\n  var total := 0;\n  for var i := 1 to number do\n    total += Factorial(i);\n  Result := total;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of all the unique elements in a list of integers.",
    "output": "function SumUnique(arr: array of integer): integer;\nbegin\n  var uniqueElements := new HashSet<integer>(arr);\n  Result := uniqueElements.Sum;\nend;"
  },
  {
    "instruction": "Write a function to find the number of valid parentheses strings of length n.\nA valid parentheses string is one that is an empty string, or a string that can be written as AB (A concatenated with B), where A and B are valid strings, or a string that can be written as (A), where A is a valid string.",
    "output": "function NumValidParentheses(n: integer): integer;\nbegin\n  var dp := ArrFill(n + 1,0);\n  dp[\n      0\n] := 1;\n  for var i := 1 to n do\n    for var j := 0 to i - 1 do\n      dp[i\n] += dp[j\n] * dp[i - j - 1\n];\n  Result := dp[n\n];\nend;"
  },
  {
    "instruction": "Write a function to find the number of distinct prime factors of a given number.",
    "output": "function DistinctPrimeFactors(n: integer): integer;\nbegin\n  var i := 2;\n  var factors := new HashSet<integer>;\n  while i * i <= n do\n  begin\n    if n mod i = 0 then\n    begin\n      n := n div i;\n      factors.Add(i);\n    end\n    else\n      i += 1;\n  end;\n  if n > 1 then\n    factors.Add(n);\n  Result := factors.Count;\nend;"
  },
  {
    "instruction": "Write a function to determine if a person can attend all job interviews given the start and end times of each interview.",
    "output": "function CanAttendInterviews(intervals: array of (integer, integer)): boolean;\nbegin\n  intervals := intervals.OrderBy(i -> i[\n      0\n    ]).ToArray;\n  for var i := 0 to intervals.Length - 2 do\n    if intervals[i\n    ][\n      1\n    ] > intervals[i + 1\n    ][\n      0\n    ] then\n    begin\n      Result := False;\n      exit;\n    end;\n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function to generate a dictionary from a given list, where the dictionary keys are the elements of the list, and the values are the number of times each element appears in the list.",
    "output": "function ListToDictWithCount(lst: array of integer): Dictionary<integer, integer>;\nbegin\n  var d := new Dictionary<integer, integer>;\n  foreach var x in lst do\n    if d.ContainsKey(x) then d[x] := d[x] + 1 else d[x] := 1;\n  Result := d;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns a new list where each element is the factorial of the corresponding element in the input list.",
    "output": "function ListFactorial(lst: array of integer): array of integer;\n\n  function Factorial(n: integer): integer;\n  begin\n    if n <= 1 then\n      Result := 1\n    else\n      Result := n * Factorial(n - 1);\n  end;\n\nbegin\n  var resultList := new List<integer>;\n  foreach var i in lst do\n  begin\n    if i >= 0 then\n      resultList.Add(Factorial(i))\n    else\n      resultList.Add(0);\n  end;\n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the second largest element in a given list of integers.",
    "output": "function SecondLargest(nums: array of integer): integer;\nbegin\n  if nums.Length < 2 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  var largest := Max(nums[\n      0\n    ], nums[\n      1\n    ]);\n  var secondLargest := Min(nums[\n      0\n    ], nums[\n      1\n    ]);\n  for var i := 2 to nums.Length - 1 do\n  begin\n    if nums[i\n    ] > largest then\n    begin\n      secondLargest := largest;\n      largest := nums[i\n    ];\n    end\n    else if (nums[i\n    ] > secondLargest) and (nums[i\n    ] <> largest) then\n      secondLargest := nums[i\n    ];\n  end;\n  Result := secondLargest;\nend;"
  },
  {
    "instruction": "Write a function which implements the Josephus problem. The Josephus problem is a theoretical problem related to a certain counting-out game. People are standing in a circle waiting to be executed. Counting begins at a specified point in the circle and proceeds around the circle in a specified direction. After a specified number of people are skipped, the next person is executed. The procedure is repeated with the remaining people, starting with the next person, going in the same direction and skipping the same number of people, until only one person remains, and is freed.",
    "output": "function SolveJosephus(n, k: integer): integer;\nbegin\n  if n = 1 then\n    Result := 1\n  else\n    Result := (SolveJosephus(n - 1, k) + k - 1) mod n + 1;\nend;"
  },
  {
    "instruction": "Write a function that takes an array of integers and returns a new array where each element is replaced by the next greater element to the right. If there is no greater element, replace it with -1.",
    "output": "function ReplaceWithNextGreater(nums: array of integer): array of integer;\nbegin\n  var stack := new Stack<integer>;\n  var res := ArrFill(nums.Length,-1);\n  for var i := 0 to nums.Length - 1 do\n  begin\n    while (stack.Count > 0) and (nums[stack.Peek\n] < nums[i\n]) do\n    begin\n      res[stack.Peek\n] := nums[i\n];\n      stack.Pop;\n    end;\n    stack.Push(i);\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of meeting rooms required for a list of meeting intervals.",
    "output": "function MeetingRoomsII(intervals: array of (integer, integer)): integer;\nbegin\n  intervals := intervals.Order.ToArray;\n  var pq := new SortedSet<integer>;\n  pq.Add(intervals[\n      0\n    ][\n      1\n    ]);\n  for var i := 1 to intervals.Length - 1 do\n  begin\n    if (pq.Count > 0) and (intervals[i\n    ][\n      0\n    ] >= pq.Min) then\n      pq.Remove(pq.Min);\n    pq.Add(intervals[i\n    ][\n      1\n    ]);\n  end;\n  Result := pq.Count;\nend;"
  },
  {
    "instruction": "Write a function to check if a given string follows the camel case naming convention. The camel case naming convention rules are as follows:\n- The first word is in lowercase.\n- Each subsequent word starts with an uppercase letter.\n- There are no spaces or underscores between words.",
    "output": "function CamelCaseChecker(s: string): boolean;\nbegin\n  if not s[\n      1\n    ].IsLower then\n  begin\n    Result := False;\n    exit;\n  end;\n  for var i := 2 to s.Length do\n  begin\n    if s[i - 1\n    ].IsLower and not s[i\n    ].IsUpper then\n    begin\n      Result := False;\n      exit;\n    end;\n    if s[i - 1\n    ].IsUpper and not s[i\n    ].IsLower then\n    begin\n      Result := False;\n      exit;\n    end;\n  end;\n  if s.Contains(' ') or s.Contains('_') then\n  begin\n    Result := False;\n    exit;\n  end;\n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function to remove specified values from a list in.",
    "output": "function RemoveValuesFromList(theList: array of integer; vals: array of integer): array of integer;\nbegin\n  Result := theList.Where(value -> not vals.Contains(value)).ToArray;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings and returns a list of lists, where each inner list contains the words from the original string split by whitespace.",
    "output": "function SplitStrings(lst: array of string): array of array of string;\nbegin\n  Result := lst.Select(s -> s.ToWords).ToArray;\nend;"
  },
  {
    "instruction": "Write a function to encode a message using the Caesar cipher. The function should shift the characters of the alphabet by a specified number of places. Lower case letters should wrap around to the beginning of the alphabet.",
    "output": "function CaesarCipherEncode(message: string; shift: integer): string;\nbegin\n  var encoded := '';\n  foreach var c in message do\n  begin\n    if c.IsLetter then\n    begin\n      var base := Ord(c.IsUpper ? 'A' : 'a');\n      encoded += Chr((Ord(c) - base + shift) mod 26 + base);\n    end\n    else\n      encoded += c;\n  end;\n  Result := encoded;\nend;"
  },
  {
    "instruction": "Write a function to find the difference between two dates in days.",
    "output": "function FindDateDiff(date1, date2: string): integer;\nbegin\n  var dateFormat := 'yyyy-MM-dd';\n  var a := DateTime.Parse(date1);\n  var b := DateTime.Parse(date2);\n  var delta := b - a;\n  Result := delta.Days;\nend;"
  },
  {
    "instruction": "Write a function to count the number of ways to partition an integer n into distinct parts.",
    "output": "function CountPartition(n: integer): integer;\nbegin\n  var partitions := ArrFill(n + 1,0);\n  partitions[\n      0\n] := 1;\n  for var i := 1 to n do\n    for var j := i to n do\n      partitions[j\n] += partitions[j - i\n];\n  Result := partitions[n\n];\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of coins required to make a given amount using the given denominations of coins.",
    "output": "function MinimumCoins(coins: array of integer; amount: integer): integer;\nbegin\n  var dp := ArrFill(amount + 1, integer.MaxValue);\n  dp[\n      0\n    ] := 0;\n  foreach var coin in coins do\n    for var x := coin to amount do\n      if dp[x - coin\n    ] <> integer.MaxValue then\n        dp[x\n    ] := Min(dp[x\n    ], dp[x - coin\n    ] + 1);\n  if dp[amount\n    ] = integer.MaxValue then\n    Result := -1\n  else\n    Result := dp[amount\n    ];\nend;"
  },
  {
    "instruction": "Write a function to calculate the maximum product of cutting a rope into integer lengths.\n\nGiven a rope of length `n` integers, the task is to cut the rope in such a way that the product of lengths of different pieces is maximum. At least one cut has to be made.",
    "output": "function MaxProductAfterCutting(n: integer): integer;\nbegin\n  if n <= 3 then\n  begin\n    Result := n - 1;\n    exit;\n  end;\n  var (a, b) := (n div 3 - 1, n mod 3);\n  var p := 1000000007;\n  var (x, rem) := (3,1);\n  while a > 0 do\n  begin\n    if a mod 2 = 1 then\n      rem := (rem * x) mod p;\n    x := (x * x) mod p;\n    a := a div 2;\n  end;\n  case b of\n    0: Result := (rem * 3) mod p;\n    1: Result := (rem * 4) mod p;\n    2: Result := (rem * 6) mod p;\n  end;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of lists, where each inner list represents a point in 3D space (x, y, z), and returns the point that is farthest from the origin (0, 0, 0).",
    "output": "function FarthestPoint(points: array of array of integer): array of integer;\nbegin\n  var maxDistance := 0.0;\n  var farthest := points[\n      0\n    ];\n  foreach var point in points do\n  begin\n    var distance := Sqrt(point[\n      0\n    ] ** 2 + point[\n      1\n    ] ** 2 + point[\n      2\n    ] ** 2);\n    if distance > maxDistance then\n    begin\n      maxDistance := distance;\n      farthest := point;\n    end;\n  end;\n  Result := farthest;\nend;"
  },
  {
    "instruction": "Write a function to separate even and odd numbers from a given list and return them as a tuple of two lists: the first list should contain all even numbers, and the second list should contain all odd numbers.",
    "output": "function SeparateEvenOdd(nums: array of integer): (array of integer, array of integer);\nbegin\n  var evenList := new List<integer>;\n  var oddList := new List<integer>;\n  foreach var num in nums do\n    if num mod 2 = 0 then\n      evenList.Add(num)\n    else\n      oddList.Add(num);\n  Result := (evenList.ToArray, oddList.ToArray);\nend;"
  },
  {
    "instruction": "Write a function that takes a string as input, and returns a new string where each word's characters have their case inverted. If the character is lowercase, it becomes uppercase, and vice versa. The function should preserve the original spacing of the words.",
    "output": "function CaseInvert(s: string): string;\nbegin\n  var words := s.Split(' ');\n  var transformed := words.Select(w -> string.Join('', w.Select(c -> (c.IsLower ? c.ToUpper : (c.IsUpper ? c.ToLower : c))))).ToArray;\n  Result := string.Join(' ', transformed);\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest consecutive sequence in an array of integers.",
    "output": "function FindLongestConsecutiveSequence(nums: array of integer): integer;\nbegin\n  if nums.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  var numsSet := new HashSet<integer>(nums);\n  var longest := 0;\n  foreach var num in numsSet do\n  begin\n    if not numsSet.Contains(num - 1) then\n    begin\n      var currentNum := num;\n      var currentStreak := 1;\n      while numsSet.Contains(currentNum + 1) do\n      begin\n        currentNum += 1;\n        currentStreak += 1;\n      end;\n      longest := Max(longest, currentStreak);\n    end;\n  end;\n  Result := longest;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of all numbers that can be expressed as the sum of nth power of their digits.\n\nFor example, the number 1634 can be expressed as 1^4 + 6^4 + 3^4 + 4^4 = 1634.",
    "output": "function SumOfNthPowers(n: integer): integer;\nbegin\n  var totalSum := 0;\n  var upperBound := n * Round(Power(9, n));\n  for var num := 2 to upperBound do\n  begin\n    var sumOfPowers := 0;\n    var temp := num;\n    while temp > 0 do\n    begin\n      var digit := temp mod 10;\n      sumOfPowers += Round(Power(digit, n));\n      temp := temp div 10;\n    end;\n    if sumOfPowers = num then\n      totalSum += num;\n  end;\n  Result := totalSum;\nend;"
  },
  {
    "instruction": "Write a function to return the first maximum and the second maximum number in the list. If the list has less than 2 unique elements, return nil for the second maximum. If the list has no elements, return (nil, nil).",
    "output": "function FindTwoMax(arr: array of integer): (integer?, integer?);\nbegin\n  if arr.Length = 0 then\n  begin\n    Result := Tuple.Create&<integer?, integer?>(nil, nil);\n    exit;\n  end;\n\n  var distinct := arr.Distinct.OrderBy(x -> x).ToArray;\n  if distinct.Length = 1 then\n  begin\n    Result := Tuple.Create&<integer?, integer?>(distinct[0], nil);\n    exit;\n  end;\n\n  Result := (distinct[distinct.Length - 1], distinct[distinct.Length - 2]);\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest palindromic subsequence in a given string.",
    "output": "function FindLongestPalindromicSubseq(s: string): integer;\nbegin\n  var n := s.Length;\n  var dp := new integer[n, n\n    ];\n  for var i := n - 1 downto 0 do\n  begin\n    dp[i, i\n    ] := 1;\n    for var j := i + 1 to n - 1 do\n    begin\n      if s[i + 1\n    ] = s[j + 1\n    ] then\n        dp[i, j\n    ] := dp[i + 1, j - 1\n    ] + 2\n      else\n        dp[i, j\n    ] := Max(dp[i + 1, j\n    ], dp[i, j - 1\n    ]);\n    end;\n  end;\n  Result := dp[\n      0, n - 1\n    ];\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of nested lists within a given list.",
    "output": "function FindMaxNestedList(lst: List<object>): integer;\n\n  function Dfs(lst: List<object>; depth: integer): integer;\n  begin\n    if not (lst is List<object>) then\n    begin\n      Result := depth;\n      exit;\n    end;\n    var maxDepth := depth;\n    foreach var x in lst as List<object> do\n      maxDepth := Max(maxDepth, Dfs(x as List<object>, depth + 1));\n    Result := maxDepth;\n  end;\n\nbegin\n  Result := Dfs(lst,1) - 1;\nend;"
  },
  {
    "instruction": "Write a function to generate a list of prime numbers up to a given number n.",
    "output": "function GeneratePrimes(n: integer): array of integer;\nbegin\n  var primes := new List<integer>;\n  for var num := 2 to n do\n  begin\n    var isPrime := True;\n    for var i := 2 to Round(Sqrt(num)) do\n      if num mod i = 0 then\n      begin\n        isPrime := False;\n        break;\n      end;\n    if isPrime then\n      primes.Add(num);\n  end;\n  Result := primes.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the closest pair of points in a given list of points in 2D plane. The function should return the distance between the closest pair of points.",
    "output": "function FindClosestPoints(points: array of (real, real)): real;\nbegin\n  if points.Length < 2 then\n  begin\n    Result := 0;\n    exit;\n  end;\n\n  var minD := real.MaxValue;\n\n  for var i := 0 to points.Length - 1 do\n    for var j := i + 1 to points.Length - 1 do\n    begin\n      var dx := points[j].Item1 - points[i].Item1;\n      var dy := points[j].Item2 - points[i].Item2;\n      var d := Sqrt(dx*dx + dy*dy);\n      if d < minD then minD := d;\n    end;\n\n  Result := minD;\nend;"
  },
  {
    "instruction": "Write a function that takes a string as an argument and returns a dictionary where the keys are the characters from the string, and the values are the counts of those characters in the string. The function should ignore spaces and be case-sensitive.",
    "output": "function CharFreq(str1: string): Dictionary<char, integer>;\nbegin\n  var cleaned := str1.Replace(' ', '');\n  var res := new Dictionary<char, integer>;\n  foreach var c in cleaned do\n  begin\n    if res.ContainsKey(c) then\n      res[c] += 1\n    else\n      res[c] := 1;\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of all the numbers in a list that are not divisible by 3.",
    "output": "function SumNotDivisibleByThree(lst: array of integer): integer;\nbegin\n  Result := lst.Where(i -> i mod 3 <> 0).Sum;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and a number k, and returns the maximum values of each sliding window of size k in the list.",
    "output": "function MaxWindow(nums: array of integer; k: integer): array of integer;\nbegin\n  if (nums.Length = 0) or (k <= 0) then\n  begin\n    Result := nil;\n    exit;\n  end;\n  var resultList := new List<integer>;\n  var deque := new Queue<integer>;\n  for var i := 0 to nums.Length - 1 do\n  begin\n    while (deque.Count > 0) and (deque.Peek <= i - k) do\n      deque.Dequeue;\n    while (deque.Count > 0) and (nums[deque.Peek] <= nums[i]) do\n      deque.Dequeue;\n    deque.Enqueue(i);\n    if i >= k - 1 then\n      resultList.Add(nums[deque.Peek]);\n  end;\n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns a new list with only the even numbers from the original list, sorted in ascending order.",
    "output": "function EvenNumbersSorted(numbers: array of integer): array of integer;\nbegin\n  var evenNumbers := numbers.Where(number -> number mod 2 = 0).ToArray;\n  Result := evenNumbers.Order.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the number of subarrays with k odd numbers in a given list of integers.",
    "output": "function NumberOfSubarrays(nums: array of integer; k: integer): integer;\nbegin\n  var count := new Dictionary<integer, integer>;\n  count[0] := 1;\n  var odd := 0;\n  var res := 0;\n\n  foreach var x in nums do\n  begin\n    odd += x mod 2;\n    if count.ContainsKey(odd - k) then\n      res += count[odd - k];\n    if count.ContainsKey(odd) then\n      count[odd] := count[odd] + 1\n    else\n      count[odd] := 1;\n  end;\n\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function that takes a string and returns a new string in which every character is doubled.",
    "output": "function DoubleChars(s: string): string;\nbegin\n  Result := string.Join('', s.Select(c -> c + c));\nend;"
  },
  {
    "instruction": "Write a function to generate a list of numbers from 'start' to 'end' (inclusive) in steps of 'step'. If 'step' is not provided, the default step should be 1.",
    "output": "function RangeList(start, endVal: integer; step: integer := 1): array of integer;\nbegin\n  if step = 0 then\n    raise new Exception('Step cannot be zero.');\n  var resultList := new List<integer>;\n  var current := start;\n  if step > 0 then\n  begin\n    while current <= endVal do\n    begin\n      resultList.Add(current);\n      current += step;\n    end;\n  end\n  else\n  begin\n    while current >= endVal do\n    begin\n      resultList.Add(current);\n      current += step;\n    end;\n  end;\n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest increasing subsequence in an array.",
    "output": "function LenLongestIncreasingSubsequence(nums: array of integer): integer;\nbegin\n  if nums.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  var dp := ArrFill(nums.Length,1);\n  for var i := 0 to nums.Length - 1 do\n    for var j := 0 to i - 1 do\n      if nums[i\n] > nums[j\n] then\n        dp[i\n] := Max(dp[i\n], dp[j\n] + 1);\n  Result := dp.Max;\nend;"
  },
  {
    "instruction": "Write a function to find the mode(s) of a list of numbers. The mode is the number that appears most frequently in a list. If there are multiple numbers with the same highest frequency, return all of them in a list.",
    "output": "function GetModes(numbers: array of integer): array of integer;\nbegin\n  var counter := new Dictionary<integer, integer>;\n  foreach var num in numbers do\n  begin\n    if counter.ContainsKey(num) then\n      counter[num\n    ] += 1\n    else\n      counter[num\n    ] := 1;\n  end;\n  var maxCount := counter.Values.Max;\n  Result := counter.Where(p -> p.Value = maxCount).Select(p -> p.Key).ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of operations required to convert a string to another string. An operation is defined as replacing a character with another character.",
    "output": "function OperationsRequired(str1, str2: string): integer;\nbegin\n  var m := str1.Length;\n  var n := str2.Length;\n  var dp := new integer[m + 1, n + 1\n    ];\n  for var i := 0 to m do\n    for var j := 0 to n do\n    begin\n      if i = 0 then\n        dp[i, j\n    ] := j\n      else if j = 0 then\n        dp[i, j\n    ] := i\n      else if str1[i\n    ] = str2[j\n    ] then\n        dp[i, j\n    ] := dp[i - 1, j - 1\n    ]\n      else\n        dp[i, j\n    ] := 1 + Min(Min(dp[i - 1, j\n    ], dp[i, j - 1\n    ]), dp[i - 1, j - 1\n    ]);\n    end;\n  Result := dp[m, n\n    ];\nend;"
  },
  {
    "instruction": "Write a function to print all the nodes of a binary tree from top to bottom, using a breadth-first search (BFS) approach.",
    "output": "type\n  BinaryNode = class\n    val: integer;\n    left, right: BinaryNode;\n    constructor Create(v: integer);\n    begin\n      val := v;\n    end;\n  end;\n\nfunction PrintFromTopToBottom(root: BinaryNode): array of integer;\nbegin\n  if root = nil then\n  begin\n    Result := new integer[0];\n    exit;\n  end;\n\n  var q := new Queue<BinaryNode>;\n  var resultList := new List<integer>;\n\n  q.Enqueue(root);\n\n  while q.Count > 0 do\n  begin\n    var cur := q.Dequeue;\n    resultList.Add(cur.val);\n\n    if cur.left <> nil then q.Enqueue(cur.left);\n    if cur.right <> nil then q.Enqueue(cur.right);\n  end;\n\n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to encode a message using a Caesar cipher. The Caesar cipher is a type of substitution cipher in which each letter in the plaintext is shifted a certain number of places down or up the alphabet.",
    "output": "function CaesarCipherEncode(message: string; shift: integer): string;\nbegin\n  var encodedMessage := '';\n  foreach var c in message do\n  begin\n    if c.IsLetter then\n    begin\n      var asciiOffset := c.IsUpper ? 65 : 97;\n      encodedMessage += Chr((Ord(c) - asciiOffset + shift) mod 26 + asciiOffset);\n    end\n    else\n      encodedMessage += c;\n  end;\n  Result := encodedMessage;\nend;"
  },
  {
    "instruction": "Write a function to calculate the average of all the numbers in a given list, excluding any negative numbers.",
    "output": "function AveragePositiveNumbers(numbers: array of integer): real;\nbegin\n  var positiveNumbers := numbers.Where(num -> num > 0).ToArray;\n  if positiveNumbers.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  Result := positiveNumbers.Sum / positiveNumbers.Length;\nend;"
  },
  {
    "instruction": "Write a function that finds the minimum number of perfect square numbers which sum up to a given number n.",
    "output": "function MinPerfectSquares(n: integer): integer;\nbegin\n  var dp := ArrFill(n + 1, integer.MaxValue);\n  dp[\n      0\n    ] := 0;\n  for var i := 1 to n do\n  begin\n    var j := 1;\n    while j * j <= i do\n    begin\n      dp[i\n    ] := Min(dp[i\n    ], dp[i - j * j\n    ] + 1);\n      j += 1;\n    end;\n  end;\n  Result := dp[n\n    ];\nend;"
  },
  {
    "instruction": "Write a function to find the smallest and second smallest unique elements in a given list of integers.",
    "output": "function FindTwoSmallest(numbers: array of integer): (integer, integer);\nbegin\n  var uniq := numbers.Distinct.OrderBy(x -> x).ToArray;\n\n  if uniq.Length = 0 then\n  begin\n    Result := (0, 0);\n    exit;\n  end;\n\n  if uniq.Length = 1 then\n  begin\n    Result := (uniq[0], 0);\n    exit;\n  end;\n\n  Result := (uniq[0], uniq[1]);\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of steps required to convert a given binary string to a palindrome by flipping characters.",
    "output": "function MinStepsPalindrome(binaryStr: string): integer;\nbegin\n  var n := binaryStr.Length;\n  var steps := 0;\n  for var i := 1 to n div 2 do\n    if binaryStr[i\n    ] <> binaryStr[n - i + 1\n    ] then\n      steps += 1;\n  Result := steps;\nend;"
  },
  {
    "instruction": "Write a function that takes a string as input and returns a dictionary where the keys are the characters in the string, and the values are the number of times each character appears in the string.",
    "output": "function CharFrequency(string: string): Dictionary<char, integer>;\nbegin\n  var freq := new Dictionary<char, integer>;\n  foreach var i in string do\n  begin\n    if freq.ContainsKey(i) then\n      freq[i\n    ] += 1\n    else\n      freq[i\n    ] := 1;\n  end;\n  Result := freq;\nend;"
  },
  {
    "instruction": "Write a function to find the longest valid parentheses in a string.\n\nThe valid parentheses are defined as a pair of open '(' and close ')' parentheses with no unmatched parentheses inside them.\n\nFor example, \"(()())\" is valid, while \"(()\" and \")(\" are not.",
    "output": "function MaxValidParentheses(s: string): integer;\nbegin\n  var maxLen := 0;\n  var stack := new Stack<integer>;\n  stack.Push(-1);\n  for var i := 1 to s.Length do\n  begin\n    if s[i\n    ] = '(' then\n      stack.Push(i - 1)\n    else\n    begin\n      stack.Pop;\n      if stack.Count = 0 then\n        stack.Push(i - 1)\n      else\n        maxLen := Max(maxLen, i - 1 - stack.Peek);\n    end;\n  end;\n  Result := maxLen;\nend;"
  },
  {
    "instruction": "Write a function to check if a given string is a palindrome and contains only lowercase letters.",
    "output": "function IsPalindromeLowercase(s: string): boolean;\nbegin\n  Result := (s = new string(s.Reverse.ToArray)) and s.All(c -> c.IsLower);\nend;"
  },
  {
    "instruction": "Write a function to find the maximum product of three elements in a list.",
    "output": "function MaxProductThree(nums: array of integer): integer;\nbegin\n  nums := nums.Order.ToArray;\n  Result := Max(nums[\n      0\n    ] * nums[\n      1\n    ] * nums[^1\n    ], nums[^1\n    ] * nums[^2\n    ] * nums[^3\n    ]);\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest sublist in a given list of lists.",
    "output": "function LongestSublist(lists: array of array of integer): integer;\nbegin\n  Result := lists.Max(sublist -> sublist.Length);\nend;"
  },
  {
    "instruction": "Write a function to find the closest value to the target number in a given list of numbers. Assume that the list contains only numbers and the target is also a number. There could be more than one closest value in the list, return the smallest one.",
    "output": "function ClosestValue(lst: array of integer; target: integer): integer;\nbegin\n  Result := lst.OrderBy(x -> (Abs(x - target), x)).First;\nend;"
  },
  {
    "instruction": "Write a function to find the kth smallest distinct prime number in an array.",
    "output": "function FindKthSmallestPrime(arr: array of integer; k: integer): integer;\nbegin\n  var primes := new List<integer>;\n  var primeCount := new Dictionary<integer, integer>;\n  var isPrime := ArrFill(arr.Max + 1, True);\n  isPrime[\n      0\n    ] := False;\n  isPrime[\n      1\n    ] := False;\n  for var i := 2 to isPrime.Length - 1 do\n  begin\n    if isPrime[i\n    ] then\n    begin\n      primes.Add(i);\n      for var j := i * i to isPrime.Length - 1 step i do\n        isPrime[j\n    ] := False;\n    end;\n  end;\n  foreach var num in arr do\n    if isPrime[num\n    ] then\n    begin\n      if primeCount.ContainsKey(num) then\n        primeCount[num\n    ] += 1\n      else\n        primeCount[num\n    ] := 1;\n    end;\n  var primesInArray := primeCount.Keys.Order.ToArray;\n  Result := primesInArray[k - 1\n    ];\nend;"
  },
  {
    "instruction": "Write a function to find the difference between two given dates in days.",
    "output": "function FindDateDifference(date1, date2: string): integer;\nbegin\n  var formatStr := 'yyyy-MM-dd';\n  var d1 := DateTime.Parse(date1);\n  var d2 := DateTime.Parse(date2);\n  var delta := d2 - d1;\n  Result := Abs(delta.Days);\nend;"
  },
  {
    "instruction": "Write a function to find the digital root of a number. The digital root is the recursive sum of all the digits in a number until the result has only one digit. For example, digital root of 89 is 8 because 8 + 9 = 17, and 1 + 7 = 8.",
    "output": "function DigitalRoot(num: integer): integer;\nbegin\n  var s := num.ToString;\n  while s.Length > 1 do\n  begin\n    var summ := 0;\n    foreach var i in s do\n      summ += integer(i) - integer('0');\n    s := summ.ToString;\n  end;\n  Result := StrToInt(s);\nend;"
  },
  {
    "instruction": "Write a function to find the minimum cost to reach the bottom-right corner of a grid from the top-left corner. You can only move either down or right at any point in time. Each cell in the grid contains a non-negative integer representing the cost of passing through that cell.",
    "output": "function MinCostPath(cost: array [,] of integer): integer;\nbegin\n  var m := cost.GetLength(0);\n  var n := cost.GetLength(1);\n  for var r := 0 to m - 1 do\n    for var c := 0 to n - 1 do\n    begin\n      if (r > 0) and (c > 0) then\n        cost[r, c\n    ] += Min(cost[r - 1, c\n    ], cost[r, c - 1\n    ])\n      else if r > 0 then\n        cost[r, c\n    ] += cost[r - 1, c\n    ]\n      else if c > 0 then\n        cost[r, c\n    ] += cost[r, c - 1\n    ];\n    end;\n  Result := cost[m - 1, n - 1\n    ];\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of operations required to convert a given number 'start' to a goal number using a list of numbers 'nums'. In one operation, you can either add, subtract or XOR any number from 'nums' to 'start'.",
    "output": "function MinimumOperations(nums: array of integer; start, goal: integer): integer;\nbegin\n  var q := new Queue<(integer, integer)>;\n  q.Enqueue((start,0));\n  var seen := new HashSet<integer>;\n  while q.Count > 0 do\n  begin\n    var (n, steps) := q.Dequeue;\n    if n = goal then\n    begin\n      Result := steps;\n      exit;\n    end;\n    if (n < 0) or (n > 1000) then\n      continue;\n    if n in seen then\n      continue;\n    seen.Add(n);\n    foreach var cand in nums do\n    begin\n      var x := n + cand;\n      var y := n - cand;\n      var z := n xor cand;\n      q.Enqueue((x, steps + 1));\n      q.Enqueue((y, steps + 1));\n      q.Enqueue((z, steps + 1));\n    end;\n  end;\n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to check if it's possible to reach the last index of an array by jumping based on the value at each index.",
    "output": "function CanJumpOnePass(nums: array of integer): boolean;\nbegin\n  var goal := nums.Length - 1;\n  var i := nums.Length - 2;\n  while i >= 0 do\n  begin\n    var stepsNeeded := goal - i;\n    if nums[i\n    ] >= stepsNeeded then\n      goal := i;\n    i -= 1;\n  end;\n  Result := goal = 0;\nend;"
  },
  {
    "instruction": "Write a function to find the common elements between two lists and return the smallest one. If there are no common elements, return -1.",
    "output": "function GetCommon(nums1, nums2: array of integer): integer;\nbegin\n  var res := new List<integer>;\n  var nums2Set := new HashSet<integer>(nums2);\n  foreach var i in nums1 do\n    if i in nums2Set then\n      res.Add(i);\n  if res.Count = 0 then\n    Result := -1\n  else\n    Result := res.Min;\nend;"
  },
  {
    "instruction": "Write a function to find the number of times a given value appears in a list of lists.",
    "output": "function CountValueInListOfLists(listOfLists: array of array of integer; value: integer): integer;\nbegin\n  var count := 0;\n  foreach var sublist in listOfLists do\n    count += sublist.Count(x -> x = value);\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the shortest superstring that contains both s and t for given strings s and t.",
    "output": "function OverlapLength(a, b: string): integer;\nbegin\n  var maxOverlap := 0;\n  for var i := 1 to Min(a.Length, b.Length) do\n  begin\n    if a.EndsWith(b.Substring(0, i)) then\n      maxOverlap := i;\n    if b.EndsWith(a.Substring(0, i)) then\n      maxOverlap := Max(maxOverlap, i);\n  end;\n  Result := maxOverlap;\nend;\n\nfunction ShortestSuperstring(s, t: string): string;\nbegin\n  var shortestSuperstring: string := '';\n  \n  if s.Length > t.Length then\n    (s, t) := (t, s);\n\n  for var i := s.Length downto 0 do\n  begin\n    if s.StartsWith(t.Substring(t.Length - i)) then\n    begin\n      shortestSuperstring := t + s.Substring(i);\n      break;\n    end;\n    if t.StartsWith(s.Substring(s.Length - i)) then\n    begin\n      shortestSuperstring := s + t.Substring(i);\n      break;\n    end;\n  end;\n\n  if shortestSuperstring = '' then\n    shortestSuperstring := s + t;\n\n  Result := shortestSuperstring;\nend;"
  },
  {
    "instruction": "Write a function to find the cheapest cost to connect all islands. There are n islands and you want to build bridges to connect all islands. You can only build bridges between two islands at a time. The cost of building a bridge between island i and island j is given in costs[i][j]. Find the minimum cost to connect all islands.",
    "output": "function FindCheapestCost(n: integer; costs: array of (integer, integer, integer)): integer;\nbegin\n  var graph := new Dictionary<integer, List<(integer, integer)>>;\n  foreach var (u, v, w) in costs do\n  begin\n    if not graph.ContainsKey(u) then\n      graph[u] := new List<(integer, integer)>;\n    if not graph.ContainsKey(v) then\n      graph[v] := new List<(integer, integer)>;\n    graph[u].Add((v, w));\n    graph[v].Add((u, w));\n  end;\n\n  var visited := ArrFill(n, False);\n  var minHeap := new List<(integer, integer)>;\n  minHeap.Add((0, 0));\n  var totalCost := 0;\n\n  while minHeap.Count > 0 do\n  begin\n    var (cost, island) := minHeap.First;\n    minHeap.RemoveAt(0);\n    if visited[island] then\n      continue;\n    visited[island] := True;\n    totalCost += cost;\n    foreach var (nextIsland, nextCost) in graph[island] do\n    begin\n      if not visited[nextIsland] then\n      begin\n        minHeap.Add((nextCost, nextIsland));\n        minHeap := minHeap.OrderBy(x -> x.Item1).ToList;\n      end;\n    end;\n  end;\n\n  Result := totalCost;\nend;"
  },
  {
    "instruction": "Write a function that finds the most common sequence of two consecutive words (bigram) in a given text.",
    "output": "function FindMostCommonBigram(text: string): (string, string);\nbegin\n  var words := text.ToWords;\n  var bigramCounts := new Dictionary<(string, string), integer>;\n  \n  for var i := 0 to words.Length - 2 do\n  begin\n    var bigram := (words[i], words[i + 1]);\n    if bigramCounts.ContainsKey(bigram) then\n      bigramCounts[bigram] += 1\n    else\n      bigramCounts[bigram] := 1;\n  end;\n\n  var maxBigram := bigramCounts.OrderByDescending(x -> x.Value).First.Key;\n  Result := maxBigram;\nend;"
  },
  {
    "instruction": "Write a function to return a list of unique elements in the input list, maintaining the original order of appearance.",
    "output": "function UniqueOrderedList(lst: array of integer): array of integer;\nbegin\n  var seen := new HashSet<integer>;\n  var res := new List<integer>;\n  \n  foreach var x in lst do\n  begin\n    if not seen.Contains(x) then\n    begin\n      res.Add(x);\n      seen.Add(x);\n    end;\n  end;\n  \n  Result := res.ToArray;\nend;"
  },
  {
    "instruction": "Write a function that accepts a list of integers and returns the smallest even number in the list. If there are no even numbers, the function should return nil.",
    "output": "function SmallestEven(lst: array of integer): integer?;\nbegin\n  var evens := lst.Where(x -> x mod 2 = 0);\n  if evens.Any then\n    Result := evens.Min\n  else\n    Result := nil;\nend;"
  },
  {
    "instruction": "Write a function to find the largest number that is divisible by both x and y from a list of numbers.",
    "output": "function LargestDivisible(nums: array of integer; x, y: integer): integer;\nbegin\n  var largest := -1;\n  foreach var num in nums do\n  begin\n    if (num mod x = 0) and (num mod y = 0) then\n    begin\n      if num > largest then\n        largest := num;\n    end;\n  end;\n  Result := largest;\nend;"
  },
  {
    "instruction": "Write a function to convert a list of digits into an integer, then add one to that integer, and finally convert it back to a list of digits.",
    "output": "function PlusOne(digits: array of integer): array of integer;\nbegin\n  var numStr := string.Join('', digits.Select(d -> d.ToString));\n  var num := StrToInt(numStr) + 1;\n  Result := num.ToString.ToCharArray.Select(c -> StrToInt(c.ToString)).ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of all numbers between two given numbers a and b. If a is greater than b, the function should still return the correct sum.",
    "output": "function SumBetween(a, b: integer): integer;\nbegin\n  var res := 0;\n  if b > a then\n    for var i := a to b do\n      res += i\n  else if a = b then\n    res := a\n  else\n    for var j := b to a do\n      res += j;\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to calculate the nth Fibonacci number using an iterative approach.",
    "output": "function FibonacciNumber(n: integer): integer;\nbegin\n  if n <= 0 then\n    Result := 0\n  else if n = 1 then\n    Result := 1\n  else\n  begin\n    var a := 0;\n    var b := 1;\n    for var i := 2 to n do\n    begin\n      (a, b) := (b, a + b);\n    end;\n    Result := b;\n  end;\nend;"
  },
  {
    "instruction": "Write a function that takes a string and returns the number of distinct characters in that string.",
    "output": "function DistinctCharacters(str: string): integer;\nbegin\n  var distinctChars := new HashSet<char>(str);\n  Result := distinctChars.Count;\nend;"
  },
  {
    "instruction": "Write a function to find the number of occurrences of a specific value in a matrix. The matrix is represented as a list of lists, where each inner list represents a row of the matrix.",
    "output": "function CountMatrixValue(matrix: array of array of integer; value: integer): integer;\nbegin\n  var count := 0;\n  foreach var row in matrix do\n    count += row.Count(x -> x = value);\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the two largest numbers in a list and returns their product.",
    "output": "function ProductOfTwoLargest(numbers: array of integer): integer;\nbegin\n  var sorted := numbers.OrderByDescending(x -> x).ToArray;\n  Result := sorted[0] * sorted[1];\nend;"
  },
  {
    "instruction": "Write a function to calculate the intersection of multiple lists.",
    "output": "function MultipleListsIntersection(lists: array of array of integer): array of integer;\nbegin\n  if lists.Length = 0 then\n  begin\n    Result := new integer[0];\n    exit;\n  end;\n\n  var sets := lists.Select(lst -> new HashSet<integer>(lst)).ToArray;\n  var intersection := sets[0];\n  for var i := 1 to sets.Length - 1 do\n    intersection.IntersectWith(sets[i]);\n\n  Result := intersection.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the longest consecutive character in a string and return the character along with its count.",
    "output": "function LongestConsecutiveChar(s: string): (char, integer);\nbegin\n  if s.Length = 0 then\n  begin\n    Result := (#0, 0);\n    exit;\n  end;\n\n  var maxCount := 1;\n  var maxChar := s[1];\n  var count := 1;\n\n  for var i := 2 to s.Length do\n  begin\n    if s[i] = s[i - 1] then\n      count += 1\n    else\n    begin\n      if count > maxCount then\n      begin\n        maxCount := count;\n        maxChar := s[i - 1];\n      end;\n      count := 1;\n    end;\n  end;\n\n  if count > maxCount then\n  begin\n    maxCount := count;\n    maxChar := s[s.Length];\n  end;\n\n  Result := (maxChar, maxCount);\nend;"
  },
  {
    "instruction": "Write a function to find the number of seconds in a given number of hours, minutes, and seconds.",
    "output": "function ConvertToSeconds(hours, minutes, seconds: integer): integer;\nbegin\n  Result := hours * 3600 + minutes * 60 + seconds;\nend;"
  },
  {
    "instruction": "Write a function to check if a given sentence is a circular sentence or not. A circular sentence is a sentence where the last character of each word is the same as the first character of the next word, and the last character of the last word is the same as the first character of the first word.",
    "output": "function IsCircularSentence(sentence: string): boolean;\nbegin\n  var words := sentence.ToWords;\n  for var i := 0 to words.Length - 2 do\n  begin\n    if words[i][words[i].Length] <> words[i + 1][1] then\n    begin\n      Result := False;\n      exit;\n    end;\n  end;\n  Result := words[0][1] = words[words.Length - 1][words[words.Length - 1].Length];\nend;"
  },
  {
    "instruction": "Write a function to find the duplicate elements in a list and their counts. The function should return a dictionary where keys are the duplicate elements and values are their counts.",
    "output": "function DuplicateElementsCount(elementsList: array of integer): Dictionary<integer, integer>;\nbegin\n  var elementCounts := new Dictionary<integer, integer>;\n  foreach var element in elementsList do\n  begin\n    if elementCounts.ContainsKey(element) then\n      elementCounts[element] += 1\n    else\n      elementCounts[element] := 1;\n  end;\n  \n  Result := elementCounts.Where(kv -> kv.Value > 1).ToDictionary(kv -> kv.Key, kv -> kv.Value);\nend;"
  },
  {
    "instruction": "Write a function to find the least amount of time needed to complete all tasks given a specific cooldown period. Each task can be represented by a single uppercase English letter, and the same tasks must be separated by at least n units of time.",
    "output": "function LeastTime(tasks: string; n: integer): integer;\nbegin\n  var count := new Dictionary<char, integer>;\n  foreach var task in tasks do\n  begin\n    if count.ContainsKey(task) then\n      count[task] += 1\n    else\n      count[task] := 1;\n  end;\n\n  var maxHeap := new List<integer>;\n  foreach var cnt in count.Values do\n    maxHeap.Add(-cnt);\n  maxHeap.Sort;\n\n  var q := new Queue<(integer, integer)>;\n  var t := 0;\n\n  while (q.Count > 0) or (maxHeap.Count > 0) do\n  begin\n    t += 1;\n    if maxHeap.Count > 0 then\n    begin\n      var cnt := -maxHeap.First + 1;\n      maxHeap.RemoveAt(0);\n      if cnt > 0 then\n        q.Enqueue((cnt, t + n));\n    end;\n    \n    if (q.Count > 0) and (q.Peek.Item2 = t) then\n    begin\n      var el := q.Dequeue.Item1;\n      maxHeap.Add(-el);\n      maxHeap.Sort;\n    end;\n  end;\n  \n  Result := t;\nend;"
  },
  {
    "instruction": "Write a function called `check_balance` that takes a string of parentheses and returns True if the parentheses are balanced and False otherwise. A string of parentheses is considered balanced if every opening parenthesis \"(\" has a corresponding closing parenthesis \")\" and they are properly nested.",
    "output": "function CheckBalance(parentheses: string): boolean;\nbegin\n  var balance := 0;\n  foreach var ch in parentheses do\n  begin\n    if ch = '(' then\n      balance += 1\n    else if ch = ')' then\n      balance -= 1;\n    \n    if balance < 0 then\n    begin\n      Result := False;\n      exit;\n    end;\n  end;\n  Result := balance = 0;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of the two largest prime numbers in an array of integers.",
    "output": "function IsPrime(n: integer): boolean;\nbegin\n  if n <= 1 then\n  begin\n    Result := False;\n    exit;\n  end;\n  for var i := 2 to Round(Sqrt(n)) do\n    if n mod i = 0 then\n    begin\n      Result := False;\n      exit;\n    end;\n  Result := True;\nend;\n\nfunction SumOfLargestPrimes(nums: array of integer): integer?;\nbegin\n  var primeNums := new List<integer>;\n  foreach var n in nums do\n    if IsPrime(n) then\n      primeNums.Add(n);\n  \n  primeNums.Sort;\n  \n  if primeNums.Count >= 2 then\n    Result := primeNums[primeNums.Count - 1] + primeNums[primeNums.Count - 2]\n  else\n    Result := nil;\nend;"
  },
  {
    "instruction": "Create a function to convert a roman numeral to an integer. Note that the input is guaranteed to be valid and within the range of 1 to 3999.",
    "output": "function RomanToInt(s: string): integer;\nbegin\n  var roman := new Dictionary<string, integer>;\n  roman['I'] := 1; roman['V'] := 5; roman['X'] := 10; roman['L'] := 50;\n  roman['C'] := 100; roman['D'] := 500; roman['M'] := 1000;\n  roman['IV'] := 4; roman['IX'] := 9; roman['XL'] := 40; roman['XC'] := 90;\n  roman['CD'] := 400; roman['CM'] := 900;\n\n  var i := 1;\n  var num := 0;\n  while i <= s.Length do\n  begin\n    if (i < s.Length) and roman.ContainsKey(s.Substring(i - 1, 2)) then\n    begin\n      num += roman[s.Substring(i - 1, 2)];\n      i += 2;\n    end\n    else\n    begin\n      num += roman[s[i].ToString];\n      i += 1;\n    end;\n  end;\n  Result := num;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns a new list where the elements at odd indices are sorted in ascending order, while the elements at even indices remain unchanged.",
    "output": "function SortOddIndices(lst: array of integer): array of integer;\nbegin\n  var oddIndices := new List<integer>;\n  for var i := 1 to lst.Length - 1 step 2 do\n    oddIndices.Add(lst[i]);\n  \n  oddIndices.Sort;\n  var res := new List<integer>;\n  var oddIdx := 0;\n  \n  for var i := 0 to lst.Length - 1 do\n  begin\n    if i mod 2 = 0 then\n      res.Add(lst[i])\n    else\n    begin\n      res.Add(oddIndices[oddIdx]);\n      oddIdx += 1;\n    end;\n  end;\n  \n  Result := res.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the largest palindrome made from the product of two n-digit numbers.",
    "output": "function IsLargestPalindrome(n: integer): integer;\nbegin\n  var largestPalindrome := 0;\n  var startNum := Round(Power(10, n - 1));\n  var endNum := Round(Power(10, n)) - 1;\n  \n  for var i := startNum to endNum do\n  begin\n    for var j := i to endNum do\n    begin\n      var product := i * j;\n      var productStr := product.ToString;\n      var reversedStr := new string(productStr.Reverse.ToArray);\n      \n      if (productStr = reversedStr) and (product > largestPalindrome) then\n        largestPalindrome := product;\n    end;\n  end;\n  Result := largestPalindrome;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of consecutive 1's in the array if you can change at most k 0's to 1's.",
    "output": "function MaxConsecutive1s(nums: array of integer; k: integer): integer;\nbegin\n  var left := 0;\n  \n  for var right := 0 to nums.Length - 1 do\n  begin\n    if nums[right] = 0 then\n      k -= 1;\n    \n    if k < 0 then\n    begin\n      if nums[left] = 0 then\n        k += 1;\n      left += 1;\n    end;\n  end;\n  \n  Result := nums.Length - left;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of the first n prime numbers.",
    "output": "function IsPrime(num: integer): boolean;\nbegin\n  if num < 2 then\n  begin\n    Result := False;\n    exit;\n  end;\n  for var i := 2 to Round(Sqrt(num)) do\n    if num mod i = 0 then\n    begin\n      Result := False;\n      exit;\n    end;\n  Result := True;\nend;\n\nfunction SumOfFirstNPrimes(n: integer): integer;\nbegin\n  var primeCount := 0;\n  var sumPrimes := 0;\n  var num := 2;\n  \n  while primeCount < n do\n  begin\n    if IsPrime(num) then\n    begin\n      primeCount += 1;\n      sumPrimes += num;\n    end;\n    num += 1;\n  end;\n  \n  Result := sumPrimes;\nend;"
  },
  {
    "instruction": "Write a function to calculate the volume of a 3D cuboid given its minimum and maximum coordinates on the x, y, and z axes. The function should also check if the cuboid is valid, meaning that the minimum coordinates are less than or equal to the maximum coordinates in all dimensions.",
    "output": "type\n  Cuboid = class\n    MinX, MaxX, MinY, MaxY, MinZ, MaxZ: integer;\n    \n    constructor Create(minX, maxX, minY, maxY, minZ, maxZ: integer);\n    begin\n      Self.MinX := minX;\n      Self.MaxX := maxX;\n      Self.MinY := minY;\n      Self.MaxY := maxY;\n      Self.MinZ := minZ;\n      Self.MaxZ := maxZ;\n    end;\n  end;\n\nfunction ValidCuboid(cuboid: Cuboid): integer?;\nbegin\n  if (cuboid.MinX > cuboid.MaxX) or (cuboid.MinY > cuboid.MaxY) or (cuboid.MinZ > cuboid.MaxZ) then\n    Result := nil\n  else\n    Result := (cuboid.MaxX - cuboid.MinX + 1) * (cuboid.MaxY - cuboid.MinY + 1) * (cuboid.MaxZ - cuboid.MinZ + 1);\nend;"
  },
  {
    "instruction": "Write a function to find the number of pairs in a list that their sum is divisible by a given number.",
    "output": "function NumPairsDivisible(arr: array of integer; divider: integer): integer;\nbegin\n  var d := new Dictionary<integer, integer>;\n  var count := 0;\n  \n  for var i := 0 to arr.Length - 1 do\n  begin\n    var v := arr[i];\n    var remainder := v mod divider;\n    \n    var c : integer;\n    if remainder = 0 then\n      count += d.TryGetValue(0, c) ? c : 0\n    else\n      count += d.TryGetValue(divider - remainder, c) ? c : 0;\n    \n    if d.ContainsKey(remainder) then\n      d[remainder] += 1\n    else\n      d[remainder] := 1;\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the longest bitonic subsequence in the given array. A subsequence is bitonic if it is first increasing and then decreasing.",
    "output": "function LongestBitonicSubsequence(arr: array of integer): integer;\nbegin\n  var n := arr.Length;\n  var inc := ArrFill(n, 1);\n  var dec := ArrFill(n, 1);\n\n  for var i := 1 to n - 1 do\n    for var j := 0 to i - 1 do\n      if (arr[i] > arr[j]) and (inc[i] < inc[j] + 1) then\n        inc[i] := inc[j] + 1;\n\n  for var i := n - 2 downto 0 do\n    for var j := n - 1 downto i + 1 do\n      if (arr[i] > arr[j]) and (dec[i] < dec[j] + 1) then\n        dec[i] := dec[j] + 1;\n\n  var maxLen := 0;\n  for var i := 0 to n - 1 do\n    maxLen := Max(maxLen, inc[i] + dec[i] - 1);\n\n  Result := maxLen;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum profit that can be earned from selling and buying stocks given a list of prices where the ith element is the price of the ith day.",
    "output": "function MaxProfit(prices: array of integer): integer;\nbegin\n  if prices.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n\n  var profit := 0;\n  var minPrice := prices[0];\n  \n  foreach var price in prices do\n  begin\n    profit := Max(profit, price - minPrice);\n    minPrice := Min(minPrice, price);\n  end;\n\n  Result := profit;\nend;"
  },
  {
    "instruction": "Write a function to find the number of good digits in a range from 1 to N. A good digit is a digit that is not the same when rotated 180 degrees. For example, 2, 5, 6, 9 are good digits. 0, 1, and 8 are considered not good because they look the same after rotation. 3, 4, and 7 are considered bad because they cannot be rotated to form a valid digit.",
    "output": "function IsGood(num: integer): boolean;\nbegin\n  var selfs := [0, 1, 8];\n  var goods := [2, 5, 6, 9];\n  var bad := [3, 4, 7];\n  var goodCount := 0;\n  \n  foreach var ch in num.ToString do\n  begin\n    var digit := StrToInt(ch);\n    if digit in bad then\n    begin\n      Result := False;\n      exit;\n    end;\n    if digit in goods then\n      goodCount += 1;\n  end;\n  \n  Result := goodCount > 0;\nend;\n\nfunction RotatedDigits(N: integer): integer;\nbegin\n  var valid := 0;\n  for var q := 1 to N do\n    if IsGood(q) then\n      valid += 1;\n  \n  Result := valid;\nend;"
  },
  {
    "instruction": "Write a function that takes a string and returns all possible permutations of the string with all possible letter case combinations.",
    "output": "procedure Backtrack(i: integer; current: string; const S: string; var result: List<string>);\nbegin\n  if i >= S.Length then\n  begin\n    result.Add(current);\n    exit;\n  end;\n  \n  Backtrack(i + 1, current + S[i + 1], S, result);\n  \n  if S[i + 1].IsLetter then\n  begin\n    if S[i + 1].IsLower then\n      Backtrack(i + 1, current + S[i + 1].ToUpper, S, result)\n    else\n      Backtrack(i + 1, current + S[i + 1].ToLower, S, result);\n  end;\nend;\n\nfunction CasePermutation(S: string): List<string>;\nbegin\n  var res := new List<string>;\n  Backtrack(0, '', S, res);\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum sum of elements in two non-overlapping (contiguous) subarrays, which have lengths L and M. The subarrays can be in any order in the array.",
    "output": "function MaxSumTwoSubarrays(A: array of integer; L, M: integer): integer;\nbegin\n  var preSum := ArrFill(A.Length + 1, 0);\n  for var i := 1 to preSum.Length - 1 do\n    preSum[i] := preSum[i - 1] + A[i - 1];\n    \n  var Lmax := preSum[L];\n  var Mmax := preSum[M];\n  var ans := preSum[L + M];\n  \n  for var i := L + M + 1 to preSum.Length - 1 do\n  begin\n    Lmax := Max(Lmax, preSum[i - M] - preSum[i - M - L]);\n    Mmax := Max(Mmax, preSum[i - L] - preSum[i - L - M]);\n    ans := Max(ans, Lmax + preSum[i] - preSum[i - M], Mmax + preSum[i] - preSum[i - L]);\n  end;\n  \n  Result := ans;\nend;"
  },
  {
    "instruction": "Write a function to find the number of subarrays with a given sum.",
    "output": "function FindSubarraysWithGivenSum(nums: array of integer; k: integer): integer;\nbegin\n  var count := 0;\n  var currentSum := 0;\n  var dictSum := new Dictionary<integer, integer>;\n  dictSum[0] := 1;\n  \n  for var i := 0 to nums.Length - 1 do\n  begin\n    currentSum += nums[i];\n    if dictSum.ContainsKey(currentSum - k) then\n      count += dictSum[currentSum - k];\n    \n    if dictSum.ContainsKey(currentSum) then\n      dictSum[currentSum] += 1\n    else\n      dictSum[currentSum] := 1;\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the most occurring character in a string. If there are multiple characters with the same highest frequency, return the character that appears first in the string.",
    "output": "function FindMostOccurringChar(s: string): char;\nbegin\n  var charCounts := new Dictionary<char, integer>;\n  var maxCount := 0;\n  var mostOccurringChar := #0;\n  \n  foreach var ch in s do\n  begin\n    if charCounts.ContainsKey(ch) then\n      charCounts[ch] += 1\n    else\n      charCounts[ch] := 1;\n    \n    if charCounts[ch] > maxCount then\n    begin\n      maxCount := charCounts[ch];\n      mostOccurringChar := ch;\n    end;\n  end;\n  \n  Result := mostOccurringChar;\nend;"
  },
  {
    "instruction": "Write a function to find the largest binary gap within a positive integer N.",
    "output": "function LargestBinaryGap(N: integer): integer;\nbegin\n  var binary := Convert.ToString(N, 2);\n  var maxGap := 0;\n  var currentGap := 0;\n\n  foreach var b in binary do\n  begin\n    if b = '1' then\n    begin\n      if currentGap > maxGap then\n        maxGap := currentGap;\n      currentGap := 0;\n    end\n    else\n      currentGap += 1;\n  end;\n\n  Result := maxGap;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of consecutive 1's in the array if you can change at most k 0's to 1's.",
    "output": "function MaxConsecutiveOnes(nums: array of integer; k: integer): integer;\nbegin\n  var left := 0;\n  var maxLength := 0;\n  var zeroCount := 0;\n  \n  for var right := 0 to nums.Length - 1 do\n  begin\n    if nums[right] = 0 then\n      zeroCount += 1;\n    \n    while zeroCount > k do\n    begin\n      if nums[left] = 0 then\n        zeroCount -= 1;\n      left += 1;\n    end;\n    \n    maxLength := Max(maxLength, right - left + 1);\n  end;\n  \n  Result := maxLength;\nend;"
  },
  {
    "instruction": "Write a function that checks if the input string has alternating uppercase and lowercase letters. The function should return True if the string follows the pattern and False otherwise.",
    "output": "function CheckAlternating(s: string): boolean;\nbegin\n  if s.Length <= 1 then\n  begin\n    Result := True;\n    exit;\n  end;\n  \n  for var i := 1 to s.Length - 1 do\n  begin\n    if (i mod 2 = 0) and not s[i].IsLower then\n    begin\n      Result := False;\n      exit;\n    end;\n    if (i mod 2 = 1) and not s[i].IsUpper then\n    begin\n      Result := False;\n      exit;\n    end;\n  end;\n  \n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function to generate all unique permutations of a given list of numbers, which might contain duplicates.",
    "output": "procedure Permute(perm: List<integer>; remainingNums: List<integer>; var results: List<List<integer>>);\nbegin\n  if remainingNums.Count = 0 then\n  begin\n    results.Add(new List<integer>(perm));\n    exit;\n  end;\n  \n  for var i := 0 to remainingNums.Count - 1 do\n  begin\n    if (i > 0) and (remainingNums[i] = remainingNums[i - 1]) then\n      continue;\n    \n    var newPerm := new List<integer>(perm);\n    newPerm.Add(remainingNums[i]);\n    \n    var newRemainingNums := new List<integer>(remainingNums);\n    newRemainingNums.RemoveAt(i);\n    \n    Permute(newPerm, newRemainingNums, results);\n  end;\nend;\n\nfunction GeneratePerms(nums: array of integer): List<List<integer>>;\nbegin\n  var results := new List<List<integer>>;\n  var sortedNums := nums.ToList;\n  sortedNums.Sort;\n  Permute(new List<integer>, sortedNums, results);\n  Result := results;\nend;"
  },
  {
    "instruction": "Write a function to find the difference of two sorted arrays. The function should return a list containing elements that are present in the first array but not in the second array. Both input arrays are assumed to be sorted in non-decreasing order.",
    "output": "function DifferenceSortedArrays(arr1, arr2: array of integer): List<integer>;\nbegin\n  var difference := new List<integer>;\n  var p1 := 0;\n  var p2 := 0;\n\n  while (p1 < arr1.Length) and (p2 < arr2.Length) do\n  begin\n    if arr1[p1] < arr2[p2] then\n    begin\n      difference.Add(arr1[p1]);\n      p1 += 1;\n    end\n    else if arr1[p1] > arr2[p2] then\n      p2 += 1\n    else\n    begin\n      p1 += 1;\n      p2 += 1;\n    end;\n  end;\n\n  while p1 < arr1.Length do\n  begin\n    difference.Add(arr1[p1]);\n    p1 += 1;\n  end;\n\n  Result := difference;\nend;"
  },
  {
    "instruction": "Write a function to find the degree of a polynomial from its coefficients. The degree of a polynomial is the highest power of x in the polynomial. For example, the degree of the polynomial 4x^3 + 3x^2 + 2x + 1 is 3.",
    "output": "function FindDegree(coefficients: array of real): integer;\nbegin\n  for var i := coefficients.Length - 1 downto 0 do\n    if coefficients[i] <> 0 then\n    begin\n      Result := i;\n      exit;\n    end;\n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to check if a binary tree is balanced. A balanced binary tree is defined to be a tree such that the heights of the two subtrees of any node never differ by more than one.",
    "output": "type\n  BinaryTree = class\n    Value: integer;\n    Left, Right: BinaryTree;\n    \n    constructor Create(value: integer; left: BinaryTree := nil; right: BinaryTree := nil);\n    begin\n      Self.Value := value;\n      Self.Left := left;\n      Self.Right := right;\n    end;\n  end;\n\nfunction Height(node: BinaryTree): integer;\nbegin\n  if node = nil then\n  begin\n    Result := 0;\n    exit;\n  end;\n  Result := 1 + Max(Height(node.Left), Height(node.Right));\nend;\n\nfunction IsBalancedTree(root: BinaryTree): boolean;\nbegin\n  if root = nil then\n  begin\n    Result := True;\n    exit;\n  end;\n  \n  var leftHeight := Height(root.Left);\n  var rightHeight := Height(root.Right);\n  \n  if (Abs(leftHeight - rightHeight) <= 1) and IsBalancedTree(root.Left) and IsBalancedTree(root.Right) then\n    Result := True\n  else\n    Result := False;\nend;"
  },
  {
    "instruction": "Write a function to find the total number of continuous subarrays whose sum equals to k.",
    "output": "function FindSubarraySum(arr: array of integer; k: integer): integer;\nbegin\n  var count := 0;\n  var sum := 0;\n  var hashMap := new Dictionary<integer, integer>;\n  hashMap[0] := 1;\n  \n  for var i := 0 to arr.Length - 1 do\n  begin\n    sum += arr[i];\n    if hashMap.ContainsKey(sum - k) then\n      count += hashMap[sum - k];\n    \n    if hashMap.ContainsKey(sum) then\n      hashMap[sum] += 1\n    else\n      hashMap[sum] := 1;\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to reverse the order of words in a sentence and capitalize the first letter of each word.",
    "output": "function ReverseAndCapitalize(sentence: string): string;\nbegin\n  var words := sentence.ToWords;\n  var reversedWords := new List<string>;\n  \n  for var i := words.Length - 1 downto 0 do\n  begin\n    var word := words[i];\n    if word.Length > 0 then\n      reversedWords.Add(word[1].ToUpper + word.Substring(2).ToLower)\n    else\n      reversedWords.Add(word);\n  end;\n  \n  Result := string.Join(' ', reversedWords);\nend;"
  },
  {
    "instruction": "Write a function to count the number of inversions in an array. An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].",
    "output": "function Merge(var arr, tempArr: array of integer; left, mid, right: integer): integer;\nbegin\n  var i := left;\n  var j := mid + 1;\n  var k := left;\n  var invCount := 0;\n\n  while (i <= mid) and (j <= right) do\n  begin\n    if arr[i] <= arr[j] then\n    begin\n      tempArr[k] := arr[i];\n      k += 1;\n      i += 1;\n    end\n    else\n    begin\n      tempArr[k] := arr[j];\n      invCount += (mid - i + 1);\n      k += 1;\n      j += 1;\n    end;\n  end;\n\n  while i <= mid do\n  begin\n    tempArr[k] := arr[i];\n    k += 1;\n    i += 1;\n  end;\n\n  while j <= right do\n  begin\n    tempArr[k] := arr[j];\n    k += 1;\n    j += 1;\n  end;\n\n  for var idx := left to right do\n    arr[idx] := tempArr[idx];\n\n  Result := invCount;\nend;\n\nfunction MergeSort(var arr, tempArr: array of integer; left, right: integer): integer;\nbegin\n  var invCount := 0;\n  if left < right then\n  begin\n    var mid := (left + right) div 2;\n\n    invCount += MergeSort(arr, tempArr, left, mid);\n    invCount += MergeSort(arr, tempArr, mid + 1, right);\n    invCount += Merge(arr, tempArr, left, mid, right);\n  end;\n  Result := invCount;\nend;\n\nfunction CountInversions(arr: array of integer): integer;\nbegin\n  var tempArr := new integer[arr.Length];\n  Result := MergeSort(arr, tempArr, 0, arr.Length - 1);\nend;"
  },
  {
    "instruction": "Write a function to find the shortest path from the start point to the end point in a grid. The grid contains obstacles which cannot be passed and each move has a cost associated with it. The function should return the minimum cost to reach the end point. The grid is represented as a list of lists where 'S' is the start point, 'E' is the end point, 'X' is an obstacle, and '.' is a valid path. The cost of moving from one cell to an adjacent cell is 1.",
    "output": "function FindShortestPathCost(grid: array of array of char): integer;\nbegin\n  if (grid.Length = 0) or (grid[0].Length = 0) then\n  begin\n    Result := -1;\n    exit;\n  end;\n\n  var rows := grid.Length;\n  var cols := grid[0].Length;\n  var directions := Arr((0, 1), (1, 0), (0, -1), (-1, 0));\n  var start: (integer, integer) := nil;\n  var finish: (integer, integer) := nil;\n  \n  for var i := 0 to rows - 1 do\n    for var j := 0 to cols - 1 do\n    begin\n      if grid[i][j] = 'S' then\n        start := (i, j)\n      else if grid[i][j] = 'E' then\n        finish := (i, j);\n    end;\n\n  if (start = nil) or (finish = nil) then\n  begin\n    Result := -1;\n    exit;\n  end;\n\n  var queue := new Queue<(integer, integer, integer)>;\n  queue.Enqueue((start.Item1, start.Item2, 0));\n  var visited := new HashSet<(integer, integer)>;\n  visited.Add((start.Item1, start.Item2));\n\n  while queue.Count > 0 do\n  begin\n    var (x, y, cost) := queue.Dequeue;\n    if (x, y) = finish then\n    begin\n      Result := cost;\n      exit;\n    end;\n    \n    foreach var (dx, dy) in directions do\n    begin\n      var nx := x + dx;\n      var ny := y + dy;\n      if (nx >= 0) and (nx < rows) and (ny >= 0) and (ny < cols) and \n         (grid[nx][ny] <> 'X') and not visited.Contains((nx, ny)) then\n      begin\n        visited.Add((nx, ny));\n        queue.Enqueue((nx, ny, cost + 1));\n      end;\n    end;\n  end;\n\n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of steps required to convert a given binary string to a string with alternating characters.",
    "output": "function MinStepsAlternating(s: string): integer;\nbegin\n  var count0 := 0;\n  var count1 := 0;\n  \n  for var i := 1 to s.Length do\n  begin\n    if i mod 2 = 1 then\n    begin\n      if s[i] = '1' then\n        count0 += 1\n      else\n        count1 += 1;\n    end\n    else\n    begin\n      if s[i] = '1' then\n        count1 += 1\n      else\n        count0 += 1;\n    end;\n  end;\n  \n  Result := Min(count0, count1);\nend;"
  },
  {
    "instruction": "Write a function to find the maximum size of a square sub-matrix with all 1's in a binary matrix.",
    "output": "function FindMaxSquare(matrix: array of array of integer): integer;\nbegin\n  if matrix.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var rows := matrix.Length;\n  var cols := matrix[0].Length;\n  var dp := new integer[rows, cols];\n  var maxSide := 0;\n  \n  for var i := 0 to rows - 1 do\n    for var j := 0 to cols - 1 do\n    begin\n      if matrix[i][j] = 1 then\n      begin\n        if (i = 0) or (j = 0) then\n          dp[i, j] := 1\n        else\n          dp[i, j] := Min(Min(dp[i-1, j], dp[i, j-1]), dp[i-1, j-1]) + 1;\n        \n        maxSide := Max(maxSide, dp[i, j]);\n      end;\n    end;\n  \n  Result := maxSide;\nend;"
  },
  {
    "instruction": "Given the coordinates of four points in 2D space, write a function to determine if these points can form a valid square.",
    "output": "function Dist(p1, p2: (real, real)): real;\nbegin\n  Result := Sqrt(Power(p1.Item1 - p2.Item1, 2) + Power(p1.Item2 - p2.Item2, 2));\nend;\n\nfunction ValidSquare(p1, p2, p3, p4: (real, real)): boolean;\nbegin\n  var points := Arr(p1, p2, p3, p4);\n  var distances := new List<real>;\n  \n  for var i := 0 to 3 do\n    for var j := i + 1 to 3 do\n      distances.Add(Dist(points[i], points[j]));\n  \n  distances.Sort;\n  \n  Result := (distances[0] = distances[1]) and (distances[1] = distances[2]) and \n            (distances[2] = distances[3]) and (distances[4] = distances[5]) and \n            (distances[0] <> 0);\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns a new list with their binary representations as strings.",
    "output": "function IntListToBin(lst: array of integer): List<string>;\nbegin\n  Result := lst.Select(num -> Convert.ToString(num, 2)).ToList;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings and returns a new list where each string has been converted to uppercase and has been reversed.",
    "output": "function ReverseAndUpper(lst: array of string): List<string>;\nbegin\n  Result := lst.Select(s -> new string(s.ToUpper.Reverse.ToArray)).ToList;\nend;"
  },
  {
    "instruction": "Write a function to find the third words that immediately follow two specified words in a sentence.",
    "output": "function FindThirdWord(text, first, second: string): List<string>;\nbegin\n  var ans := new List<string>;\n  var (a, b, c) := (string.Empty, string.Empty, string.Empty);\n  var words := text.ToWords;\n  \n  for var i := 0 to words.Length - 1 do\n  begin\n    (a, b, c) := (b, c, words[i]);\n    if (a = first) and (b = second) then\n      ans.Add(c);\n  end;\n  \n  Result := ans;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns a dictionary where the keys are the integers from the list and the values are the frequencies of those integers in the list.",
    "output": "function ListToFreqDict(lst: array of integer): Dictionary<integer, integer>;\nbegin\n  var res := new Dictionary<integer, integer>;\n  foreach var i in lst do\n  begin\n    if res.ContainsKey(i) then\n      res[i] += 1\n    else\n      res[i] := 1;\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the number of possible paths from the top-left corner to the bottom-right corner of a grid. You can only move either down or right at any point in time.",
    "output": "function NumOfPaths(m, n: integer): integer;\nbegin\n  var dp := new integer[m, n];\n  \n  for var i := 0 to m - 1 do\n    dp[i, 0] := 1;\n  for var j := 0 to n - 1 do\n    dp[0, j] := 1;\n  \n  for var i := 1 to m - 1 do\n    for var j := 1 to n - 1 do\n      dp[i, j] := dp[i-1, j] + dp[i, j-1];\n  \n  Result := dp[m-1, n-1];\nend;"
  },
  {
    "instruction": "Write a function to generate the Lucas numbers up to a given limit. The Lucas numbers are similar to the Fibonacci sequence, except that the first two numbers are 2 and 1 instead of 0 and 1. The sequence is defined as follows: L(0) = 2, L(1) = 1, and L(n) = L(n-1) + L(n-2) for n > 1.",
    "output": "function GenerateLucas(limit: integer): List<integer>;\nbegin\n  if limit < 0 then\n  begin\n    Result := new List<integer>;\n    exit;\n  end\n  else if limit = 0 then\n  begin\n    Result := new List<integer>([2]);\n    exit;\n  end\n  else if limit = 1 then\n  begin\n    Result := new List<integer>([2, 1]);\n    exit;\n  end\n  else\n  begin\n    var lucas := new List<integer>([2, 1]);\n    for var i := 2 to limit - 1 do\n      lucas.Add(lucas[i-1] + lucas[i-2]);\n    Result := lucas;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum length of a subarray that sums to a given value k.",
    "output": "function FindMaxLengthSubarray(nums: array of integer; k: integer): integer;\nbegin\n  var maxLength := 0;\n  var prefixSum := new Dictionary<integer, integer>;\n  prefixSum[0] := -1;\n  var sumSoFar := 0;\n\n  for var i := 0 to nums.Length - 1 do\n  begin\n    sumSoFar += nums[i];\n\n    if prefixSum.ContainsKey(sumSoFar - k) then\n      maxLength := Max(maxLength, i - prefixSum[sumSoFar - k]);\n    \n    if not prefixSum.ContainsKey(sumSoFar) then\n      prefixSum[sumSoFar] := i;\n  end;\n\n  Result := maxLength;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers representing the heights of walls, and calculates how much rainwater can be trapped between the walls. The function should return the total volume of trapped rainwater.",
    "output": "function TrapRainwater(heights: array of integer): integer;\nbegin\n  var n := heights.Length;\n  if n < 3 then\n  begin\n    Result := 0;\n    exit;\n  end;\n\n  var leftMax := ArrFill(n, heights[0]);\n  for var i := 1 to n - 1 do\n    leftMax[i] := Max(leftMax[i - 1], heights[i]);\n\n  var rightMax := ArrFill(n, heights[n - 1]);\n  for var i := n - 2 downto 0 do\n    rightMax[i] := Max(rightMax[i + 1], heights[i]);\n\n  var res := 0;\n  for var i := 0 to n - 1 do\n    res += Min(leftMax[i], rightMax[i]) - heights[i];\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to convert a given number to a roman numeral.",
    "output": "function NumToRoman(num: integer): string;\nbegin\n  var val := |1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1|;\n  var syb := |'M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'|;\n  \n  var romanNum := '';\n  var i := 0;\n  var tempNum := num;\n  \n  while tempNum > 0 do\n  begin\n    for var j := 1 to tempNum div val[i] do\n    begin\n      romanNum += syb[i];\n      tempNum -= val[i];\n    end;\n    i += 1;\n  end;\n  \n  Result := romanNum;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings and a master string of characters as input, and returns the total length of all strings that can be formed using the characters from the master string. Each character in the master string can only be used once.",
    "output": "function CountFormableStrings(words: array of string; chars: string): integer;\nbegin\n  var count := 0;\n  var charsCounter := new Dictionary<char, integer>;\n  \n  foreach var ch in chars do\n  begin\n    if charsCounter.ContainsKey(ch) then\n      charsCounter[ch] += 1\n    else\n      charsCounter[ch] := 1;\n  end;\n  \n  foreach var word in words do\n  begin\n    var wordCounter := new Dictionary<char, integer>;\n    foreach var ch in word do\n    begin\n      if wordCounter.ContainsKey(ch) then\n        wordCounter[ch] += 1\n      else\n        wordCounter[ch] := 1;\n    end;\n    \n    var canForm := true;\n    foreach var kv in wordCounter do\n    begin\n      if (not charsCounter.ContainsKey(kv.Key)) or (charsCounter[kv.Key] < kv.Value) then\n      begin\n        canForm := false;\n        break;\n      end;\n    end;\n    \n    if canForm then\n      count += word.Length;\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns the maximum sum of non-adjacent elements in the list.",
    "output": "function MaxNonAdjSum(nums: array of integer): integer;\nbegin\n  if nums.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var incl := 0;\n  var excl := 0;\n  \n  foreach var i in nums do\n  begin\n    var newExcl := Max(excl, incl);\n    incl := excl + i;\n    excl := newExcl;\n  end;\n  \n  Result := Max(excl, incl);\nend;"
  },
  {
    "instruction": "Write a function that checks if a given string can be transformed into another string by performing exactly k operations. Each operation consists of shifting a character by a certain amount in the alphabet. If the string can be transformed, return True; otherwise, return False.",
    "output": "function CanTransformString(s, t: string; k: integer): boolean;\nbegin\n  if s.Length <> t.Length then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  if s = t then\n  begin\n    Result := true;\n    exit;\n  end;\n\n  var counts := new Dictionary<integer, integer>;\n\n  for var i := 0 to s.Length - 1 do\n  begin\n    var shift := (Ord(t[i]) - Ord(s[i])) mod 26;\n    if shift < 0 then\n      shift += 26;\n      \n    if shift > 0 then\n    begin\n      if counts.ContainsKey(shift) then\n        counts[shift] += 1\n      else\n        counts[shift] := 1;\n    end;\n  end;\n\n  foreach var kv in counts do\n  begin\n    var totalShift := kv.Key + 26 * (kv.Value - 1);\n    if totalShift > k then\n    begin\n      Result := false;\n      exit;\n    end;\n  end;\n\n  Result := true;\nend;"
  },
  {
    "instruction": "Write a function to generate a Pascal's triangle of a given number of rows.",
    "output": "function PascalsTriangle(numRows: integer): List<List<integer>>;\nbegin\n  var res := new List<List<integer>>;\n  for var i := 0 to numRows - 1 do\n  begin\n    var row := new List<integer>;\n    for var j := 0 to i do\n      row.Add(1);\n    res.Add(row);\n  end;\n  \n  for var i := 0 to numRows - 1 do\n    for var j := 1 to i - 1 do\n      res[i][j] := res[i-1][j-1] + res[i-1][j];\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the number of times a specific number appears in a list of lists.",
    "output": "function CountNumberInListOfLists(listOfLists: List<List<integer>>; number: integer): integer;\nbegin\n  var count := 0;\n  foreach var sublist in listOfLists do\n    foreach var elem in sublist do\n      if elem = number then\n        count += 1;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the total number of ways to change `n` cents with the given `coins`. Return the number of ways.",
    "output": "function CountChangeWays(n: integer; coins: array of integer): integer;\nbegin\n  var dp := ArrFill(n + 1, 0);\n  dp[0] := 1;\n  \n  foreach var coin in coins do\n    for var i := coin to n do\n      dp[i] += dp[i - coin];\n  \n  Result := dp[n];\nend;"
  },
  {
    "instruction": "Write a function to get the last element of each sublist.",
    "output": "function LastElement(lst: List<List<integer>>): List<integer>;\nbegin\n  Result := lst.Select(item -> item[item.Count - 1]).ToList;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of n terms of a geometric progression series.",
    "output": "function SumOfGeometricProgression(a, r: real; n: integer): real;\nbegin\n  var sum := 0.0;\n  var current := a;\n  for var i := 1 to n do\n  begin\n    sum += current;\n    current *= r;\n  end;\n  Result := sum;\nend;"
  },
  {
    "instruction": "Write a function to find the n-th pentagonal number.",
    "output": "function FindPentNum(n: integer): integer;\nbegin\n  Result := n * (3 * n - 1) div 2;\nend;"
  },
  {
    "instruction": "Write a function to count the number of pairs in an array that sums up to a given target value.",
    "output": "function CountTargetPairs(arr: array of integer; target: integer): integer;\nbegin\n  var count := 0;\n  var n := arr.Length;\n  for var i := 0 to n - 1 do\n    for var j := i + 1 to n - 1 do\n      if arr[i] + arr[j] = target then\n        count += 1;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function that returns the number of even numbers in a given list of integers.",
    "output": "function EvenCount(lst: array of integer): integer;\nbegin\n  var count := 0;\n  foreach var num in lst do\n    if num mod 2 = 0 then\n      count += 1;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum unique value in a list of integers.",
    "output": "function MinUniqueValue(nums: array of integer): integer;\nbegin\n  var counts := new Dictionary<integer, integer>;\n  foreach var num in nums do\n  begin\n    if counts.ContainsKey(num) then\n      counts[num] += 1\n    else\n      counts[num] := 1;\n  end;\n  \n  var unique := counts.Where(kv -> kv.Value = 1).Select(kv -> kv.Key).ToList;\n  if unique.Count > 0 then\n    Result := unique.Min\n  else\n    Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to find out the maximum profit from stock prices for the given list of stock prices where you can perform at most two transactions.",
    "output": "function MaxProfitTwoTransactions(prices: array of integer): integer;\nbegin\n  if prices.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n\n  var buy1 := integer.MaxValue;\n  var buy2 := integer.MaxValue;\n  var profit1 := 0;\n  var profit2 := 0;\n\n  foreach var price in prices do\n  begin\n    buy1 := Min(buy1, price);\n    profit1 := Max(profit1, price - buy1);\n    buy2 := Min(buy2, price - profit1);\n    profit2 := Max(profit2, price - buy2);\n  end;\n\n  Result := profit2;\nend;"
  },
  {
    "instruction": "Write a function to find the number of times a prefix appears in a list of strings.",
    "output": "function PrefixCounter(words: array of string; prefix: string): integer;\nbegin\n  var count := 0;\n  foreach var word in words do\n    if word.StartsWith(prefix) then\n      count += 1;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the largest prime factor of a given number.",
    "output": "function LargestPrimeFactor(n: integer): integer;\nbegin\n  var i := 2;\n  var tempN := n;\n  while i * i <= tempN do\n  begin\n    if tempN mod i <> 0 then\n      i += 1\n    else\n      tempN := tempN div i;\n  end;\n  Result := tempN;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of numbers as input and returns a new list where each number is cubed.",
    "output": "function CubeNumbers(numbers: array of integer): List<integer>;\nbegin\n  Result := numbers.Select(number -> number * number * number).ToList;\nend;"
  },
  {
    "instruction": "Write a function to check if two given strings are anagrams of each other.",
    "output": "function CheckAnagrams(str1, str2: string): boolean;\nbegin\n  var sorted1 := new string(str1.ToCharArray.Sorted.ToArray);\n  var sorted2 := new string(str2.ToCharArray.Sorted.ToArray);\n  Result := sorted1 = sorted2;\nend;"
  },
  {
    "instruction": "Write a function to check if a given string can be segmented into space-separated words in the dictionary.",
    "output": "function WordBreak(s: string; wordDict: array of string): boolean;\nbegin\n  var dp := ArrFill(s.Length + 1, false);\n  dp[0] := true;\n\n  for var i := 1 to s.Length do\n    for var j := 0 to i - 1 do\n      if dp[j] and wordDict.Contains(s.Substring(j, i - j)) then\n      begin\n        dp[i] := true;\n        break;\n      end;\n\n  Result := dp[s.Length];\nend;"
  },
  {
    "instruction": "Write a function to determine if two rectangles intersect with each other. The rectangles are defined by their top-left and bottom-right coordinates.",
    "output": "function RectangleIntersection(p1, p2, p3, p4: (integer, integer)): boolean;\nbegin\n  var (x1, y1) := p1;\n  var (x2, y2) := p2;\n  var (x3, y3) := p3;\n  var (x4, y4) := p4;\n  \n  if (x3 > x2) or (x4 < x1) or (y3 > y2) or (y4 < y1) then\n    Result := false\n  else\n    Result := true;\nend;"
  },
  {
    "instruction": "Create a function that takes a list of integers and returns a new list where the elements are reversed and each element is multiplied by 2.",
    "output": "function ReverseAndDouble(nums: array of integer): List<integer>;\nbegin\n  Result := nums.Reverse.Select(i -> i * 2).ToList;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum cost to reach the bottom right corner of a grid from the top left corner. You can only move either down or right at any point in time. Each cell in the grid contains a non-negative integer representing the cost of passing through that cell.",
    "output": "function MinCostPath(cost: array of array of integer): integer;\nbegin\n  var m := cost.Length;\n  var n := cost[0].Length;\n  \n  for var i := 1 to n - 1 do\n    cost[0][i] += cost[0][i-1];\n  \n  for var i := 1 to m - 1 do\n    cost[i][0] += cost[i-1][0];\n  \n  for var i := 1 to m - 1 do\n    for var j := 1 to n - 1 do\n      cost[i][j] += Min(cost[i-1][j], cost[i][j-1]);\n  \n  Result := cost[m-1][n-1];\nend;"
  },
  {
    "instruction": "Write a function that takes a list of numbers as input and returns a new list with the numbers sorted in descending order using a heap sort algorithm.",
    "output": "function HeapSortDesc(arr: array of integer): List<integer>;\nbegin\n  var heap := new List<integer>(arr);\n  heap.Sort;\n  heap.Reverse;\n  Result := heap;\nend;"
  },
  {
    "instruction": "Define a function called 'calculate_fuel' that calculates the amount of fuel a spaceship needs for its journey. The function should take in three parameters: 'current_fuel', 'distance', 'fuel_per_km'. 'fuel_per_km' should be the amount of fuel the spaceship consumes for every kilometer. The function should return the amount of additional fuel the spaceship needs to travel the remaining distance. If the current fuel is more than enough, the function should return 0.",
    "output": "function CalculateFuel(currentFuel, distance, fuelPerKm: real): real;\nbegin\n  var totalNeededFuel := distance * fuelPerKm;\n  var additionalFuel := totalNeededFuel - currentFuel;\n  Result := Max(0, additionalFuel);\nend;"
  },
  {
    "instruction": "Write a function that takes a string as input and returns the number of times the character 'a' appears in it, considering case sensitivity.",
    "output": "function CountCharA(str: string): integer;\nbegin\n  var count := 0;\n  foreach var ch in str do\n    if ch = 'a' then\n      count += 1;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function that takes two lists of integers as input and returns a new list containing only the unique elements that are present in both lists. The order of the elements in the output list should follow the order of their first occurrence in the first list.",
    "output": "function UniqueCommonElements(list1, list2: array of integer): List<integer>;\nbegin\n  var commonSet := (new HashSet<integer>(list1)).Intersect(new HashSet<integer>(list2));\n  var res := new List<integer>;\n  \n  foreach var elem in list1 do\n    if commonSet.Contains(elem) and (not res.Contains(elem)) then\n      res.Add(elem);\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as an argument and returns the index of the minimum element in the list. If the list is empty, the function should return -1.",
    "output": "function FindMinIndex(nums: array of integer): integer;\nbegin\n  if nums.Length = 0 then\n  begin\n    Result := -1;\n    exit;\n  end;\n  \n  var minIndex := 0;\n  for var i := 1 to nums.Length - 1 do\n    if nums[i] < nums[minIndex] then\n      minIndex := i;\n  Result := minIndex;\nend;"
  },
  {
    "instruction": "Write a function to calculate the number of days between two given dates. The function will take two dates (in the format 'YYYY-MM-DD') as input and return the number of days between them.",
    "output": "function DaysUntil(date1, date2: string): integer;\nbegin\n  var d1 := DateTime.Parse(date1);\n  var d2 := DateTime.Parse(date2);\n  var delta := d2 - d1;\n  Result := Abs(delta.Days);\nend;"
  },
  {
    "instruction": "Write a function to count the number of unique combinations of two letters in a string. For example, for the input string \"abca\", the function should return 2 because there are 2 unique combinations: \"ab\" and \"ac\". Note that \"ba\" and \"ca\" are not considered unique as they are simply the reverse of \"ab\" and \"ac\" respectively.",
    "output": "function CountUniqueCombinations(s: string): integer;\nbegin\n  var letters := new HashSet<char>(s);\n  var combinations := new HashSet<(char, char)>;\n  \n  foreach var i in letters do\n    foreach var j in letters do\n      if i <> j then\n        combinations.Add((Min(i, j), Max(i, j)));\n  \n  Result := combinations.Count;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings and returns a list of unique strings (removing duplicates) while preserving the original order of appearance of the strings.",
    "output": "function UniqueStringsPreserveOrder(strings: array of string): List<string>;\nbegin\n  var uniqueStrings := new List<string>;\n  var seen := new HashSet<string>;\n  \n  foreach var str in strings do\n    if not seen.Contains(str) then\n    begin\n      uniqueStrings.Add(str);\n      seen.Add(str);\n    end;\n  \n  Result := uniqueStrings;\nend;"
  },
  {
    "instruction": "Write a function to find all unique quadruplets in the array which gives the sum of the target.",
    "output": "function FindQuadruplets(nums: array of integer; target: integer): List<List<integer>>;\nbegin\n  var res := new List<List<integer>>;\n  var tempNums := nums.ToList;\n  tempNums.Sort;\n  \n  for var i := 0 to tempNums.Count - 4 do\n  begin\n    if (i > 0) and (tempNums[i] = tempNums[i-1]) then\n      continue;\n    \n    for var j := i + 1 to tempNums.Count - 3 do\n    begin\n      if (j > i + 1) and (tempNums[j] = tempNums[j-1]) then\n        continue;\n      \n      var l := j + 1;\n      var r := tempNums.Count - 1;\n      \n      while l < r do\n      begin\n        var total := tempNums[i] + tempNums[j] + tempNums[l] + tempNums[r];\n        if total < target then\n          l += 1\n        else if total > target then\n          r -= 1\n        else\n        begin\n          res.Add(new List<integer>([tempNums[i], tempNums[j], tempNums[l], tempNums[r]]));\n          while (l < r) and (tempNums[l] = tempNums[l + 1]) do\n            l += 1;\n          while (l < r) and (tempNums[r] = tempNums[r - 1]) do\n            r -= 1;\n          l += 1;\n          r -= 1;\n        end;\n      end;\n    end;\n  end;\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to calculate the sum of all the elements in a list of numbers. However, if an element in the list is 13, it does not count towards the sum and neither does the number immediately following it.",
    "output": "function SumExcept13(nums: array of integer): integer;\nbegin\n  var total := 0;\n  var skip := false;\n  \n  foreach var num in nums do\n  begin\n    if num = 13 then\n      skip := true\n    else if skip then\n      skip := false\n    else\n      total += num;\n  end;\n  \n  Result := total;\nend;"
  },
  {
    "instruction": "Write a function to determine if a list is an arithmetic sequence.",
    "output": "function IsArithmeticSequence(nums: array of integer): boolean;\nbegin\n  if nums.Length < 2 then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  var diff := nums[1] - nums[0];\n  for var i := 2 to nums.Length - 1 do\n    if nums[i] - nums[i-1] <> diff then\n    begin\n      Result := false;\n      exit;\n    end;\n  \n  Result := true;\nend;"
  },
  {
    "instruction": "Write a function to return the first element of a given list of integers that is not consecutive by value with the previous element in the list.",
    "output": "function FirstNonConsecutive(arr: array of integer): integer?;\nbegin\n  for var i := 1 to arr.Length - 1 do\n    if arr[i] <> arr[i-1] + 1 then\n    begin\n      Result := arr[i];\n      exit;\n    end;\n  Result := nil;\nend;"
  },
  {
    "instruction": "Write a function to find the next greatest number that can be formed using the digits of the given number.",
    "output": "function NextGreatestNumber(n: integer): integer;\nbegin\n  var numStr := n.ToString;\n  var length := numStr.Length;\n  var i := length - 2;\n  \n  while i >= 0 do\n  begin\n    if numStr[i + 1] > numStr[i] then\n      break;\n    i -= 1;\n  end;\n  \n  if i = -1 then\n  begin\n    Result := -1;\n    exit;\n  end;\n  \n  var j := length - 1;\n  while numStr[j] <= numStr[i] do\n    j -= 1;\n  \n  while (j > 0) and (numStr[j] = numStr[j - 1]) do\n    j -= 1;\n  \n  var chars := numStr.ToCharArray;\n  var temp := chars[i];\n  chars[i] := chars[j];\n  chars[j] := temp;\n  \n  var tail := chars.Skip(i + 1).Reverse.ToArray;\n  for var k := i + 1 to length - 1 do\n    chars[k] := tail[k - i - 1];\n  \n  Result := StrToInt(new string(chars));\nend;"
  },
  {
    "instruction": "Write a function to find the longest subarray with an equal number of 0's and 1's in a given binary array.",
    "output": "function FindLongestEqualSubarray(nums: array of integer): integer;\nbegin\n  var d := new Dictionary<integer, integer>;\n  d[0] := -1;\n  var sum := 0;\n  var res := 0;\n  \n  for var i := 0 to nums.Length - 1 do\n  begin\n    sum += 2 * nums[i] - 1;\n    if d.ContainsKey(sum) then\n      res := Max(res, i - d[sum])\n    else\n      d[sum] := i;\n  end;\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function that multiplies two non-negative integers represented as strings and returns the product as a string. You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.",
    "output": "function StringMultiplication(num1, num2: string): string;\nbegin\n  if (num1 = '0') or (num2 = '0') then\n  begin\n    Result := '0';\n    exit;\n  end;\n\n  var len1 := num1.Length;\n  var len2 := num2.Length;\n  var res := ArrFill(len1 + len2, 0);\n\n  for var i := len1 - 1 downto 0 do\n    for var j := len2 - 1 downto 0 do\n    begin\n      var mul := (Ord(num1[i + 1]) - Ord('0')) * (Ord(num2[j + 1]) - Ord('0'));\n      var p1 := i + j;\n      var p2 := i + j + 1;\n      var sum := mul + res[p2];\n\n      res[p1] += sum div 10;\n      res[p2] := sum mod 10;\n    end;\n\n  var resultStr := string.Join('', res.Select(x -> x.ToString));\n  Result := resultStr.TrimStart('0');\nend;"
  },
  {
    "instruction": "Write a function to convert a given string to lowercase if it's in uppercase and to uppercase if it's in lowercase.",
    "output": "function StringCaseConverter(s: string): string;\nbegin\n  if s.ToUpper = s then\n    Result := s.ToLower\n  else\n    Result := s.ToUpper;\nend;"
  },
  {
    "instruction": "Write a function to find the longest palindrome sub-sequence in a given string.",
    "output": "function LongestPalindromeSubseq(s: string): integer;\nbegin\n  var n := s.Length;\n  var dp := new integer[n, n];\n  \n  for var i := n - 1 downto 0 do\n  begin\n    dp[i, i] := 1;\n    for var j := i + 1 to n - 1 do\n    begin\n      if s[i + 1] = s[j + 1] then\n        dp[i, j] := dp[i + 1, j - 1] + 2\n      else\n        dp[i, j] := Max(dp[i + 1, j], dp[i, j - 1]);\n    end;\n  end;\n  \n  Result := dp[0, n - 1];\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest substring in a given string where all characters are the same.",
    "output": "function MaxConsecutiveChars(s: string): integer;\nbegin\n  if s.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var maxLen := 1;\n  var currLen := 1;\n  \n  for var i := 2 to s.Length do\n  begin\n    if s[i] = s[i - 1] then\n    begin\n      currLen += 1;\n      maxLen := Max(maxLen, currLen);\n    end\n    else\n      currLen := 1;\n  end;\n  \n  Result := maxLen;\nend;"
  },
  {
    "instruction": "Write a function to calculate the average of two numbers in a given list of tuples. Each tuple in the list contains two numbers.",
    "output": "function AverageTuples(tuplesList: List<(real, real)>): real;\nbegin\n  var total := 0.0;\n  foreach var tup in tuplesList do\n    total += (tup.Item1 + tup.Item2) / 2;\n  Result := total / tuplesList.Count;\nend;"
  },
  {
    "instruction": "Write a function that takes two lists of integers as parameters and returns the sum of the product of their corresponding elements. If the lists are of unequal lengths, the function should only consider the length of the shorter list.",
    "output": "function SumOfProduct(list1, list2: array of integer): integer;\nbegin\n  var minLength := Min(list1.Length, list2.Length);\n  var res := 0;\n  for var i := 0 to minLength - 1 do\n    res += list1[i] * list2[i];\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of the first n natural numbers.",
    "output": "function SumOfNaturalNumbers(n: integer): integer;\nbegin\n  if n <= 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  Result := n * (n + 1) div 2;\nend;"
  },
  {
    "instruction": "Write a function that normalizes a list of strings by converting them to lowercase and removing any leading or trailing whitespace.",
    "output": "function NormalizeStrings(strings: array of string): List<string>;\nbegin\n  var normalizedStrings := new List<string>;\n  foreach var str in strings do\n    normalizedStrings.Add(str.Trim.ToLower);\n  Result := normalizedStrings;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of operations that you can perform on the given array. In one operation, you pick two distinct indices i and j where nums[i] + nums[j] == k and remove these two elements from the array. Return the maximum number of such operations you can perform on the array.",
    "output": "function FindMaxOperations(nums: array of integer; k: integer): integer;\nbegin\n  var mp := new Dictionary<integer, integer>;\n  var ans := 0;\n  \n  foreach var i in nums do\n  begin\n    if i >= k then\n      continue;\n    \n    var m := k - i;\n    if mp.ContainsKey(m) and (mp[m] >= 1) then\n    begin\n      ans += 1;\n      mp[m] -= 1;\n    end\n    else\n    begin\n      if mp.ContainsKey(i) then\n        mp[i] += 1\n      else\n        mp[i] := 1;\n    end;\n  end;\n  \n  Result := ans;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of deletions required to make a string balanced. A string is considered balanced if the number of 'a's and 'b's in it are equal.",
    "output": "function MinimumDeletions(s: string): integer;\nbegin\n  var aCount := 0;\n  var bCount := 0;\n  \n  foreach var ch in s do\n  begin\n    if ch = 'a' then\n      aCount += 1\n    else\n      bCount += 1;\n  end;\n  \n  if aCount = bCount then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  Result := Abs(aCount - bCount);\nend;"
  },
  {
    "instruction": "Write a function to check whether the given number is a perfect square or not.",
    "output": "function CheckPerfectSquare(n: integer): string;\nbegin\n  var sqrt := Round(Sqrt(n));\n  if sqrt * sqrt = n then\n    Result := 'Yes'\n  else\n    Result := 'No';\nend;"
  },
  {
    "instruction": "Write a function to find the number of good pairs in a list. A pair (i, j) is called good if nums[i] == nums[j] and i < j.",
    "output": "function FindGoodPairs(nums: array of integer): integer;\nbegin\n  var freq := new Dictionary<integer, integer>;\n  var pairs := 0;\n  \n  foreach var x in nums do\n  begin\n    if freq.ContainsKey(x) then\n      freq[x] += 1\n    else\n      freq[x] := 1;\n  end;\n  \n  foreach var kv in freq do\n  begin\n    var pair := kv.Value * (kv.Value - 1) div 2;\n    pairs += pair;\n  end;\n  \n  Result := pairs;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum length of a subarray with a positive product. Given a list of integers, find the maximum length of a contiguous subarray whose product is positive. You may assume that the list does not contain 0.",
    "output": "function GetMaxLength(nums: array of integer; startIndex: integer): integer;\nbegin\n  var j := startIndex;\n  var n := 0;\n  var max1 := 0;\n  var n_s := -1;\n  var n_e := -1;\n  \n  while (j < nums.Length) and (nums[j] <> 0) do\n  begin\n    if nums[j] < 0 then\n    begin\n      if n_s = -1 then\n        n_s := j;\n      n_e := j;\n      n += 1;\n    end;\n\n    if n mod 2 = 0 then\n      max1 := Max(max1, j - startIndex + 1)\n    else\n    begin\n      max1 := Max(max1, j - n_s);\n      max1 := Max(max1, n_e - startIndex);\n    end;\n    j += 1;\n  end;\n\n  if (j + 1 < nums.Length - 1) then\n    Result := Max(max1, GetMaxLength(nums, j + 1))\n  else\n    Result := max1;\nend;\n\nfunction MaxPositiveProduct(nums: array of integer): integer;\nbegin\n  Result := GetMaxLength(nums, 0);\nend;"
  },
  {
    "instruction": "Write a function to determine if a given array can be partitioned into two subsets such that the sum of elements in both subsets is equal.",
    "output": "function PartitionEqual(arr: array of integer): boolean;\nbegin\n  var total := arr.Sum;\n  if total mod 2 <> 0 then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  var target := total div 2;\n  var dp := ArrFill(target + 1, false);\n  dp[0] := true;\n  \n  foreach var num in arr do\n    for var i := target downto num do\n      dp[i] := dp[i] or dp[i - num];\n  \n  Result := dp[target];\nend;"
  },
  {
    "instruction": "Write a function to find the number of times a given number appears in a sorted array.",
    "output": "function FindNumberOccurrences(arr: array of integer; num: integer): integer;\nbegin\n  if arr.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var left := 0;\n  var right := arr.Length - 1;\n  \n  while left < right do\n  begin\n    var mid := left + (right - left) div 2;\n    if arr[mid] < num then\n      left := mid + 1\n    else\n      right := mid;\n  end;\n  \n  if arr[left] <> num then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var startIndex := left;\n  right := arr.Length - 1;\n  \n  while left < right do\n  begin\n    var mid := left + (right - left + 1) div 2;\n    if arr[mid] > num then\n      right := mid - 1\n    else\n      left := mid;\n  end;\n  \n  Result := right - startIndex + 1;\nend;"
  },
  {
    "instruction": "Write a function to convert an integer to its binary representation as a string.",
    "output": "function IntToBin(n: integer): string;\nbegin\n  Result := Convert.ToString(n, 2);\nend;"
  },
  {
    "instruction": "Write a function to check if a given list of integers contains a subarray with a sum of zero.",
    "output": "function HasSubarrayWithZeroSum(nums: array of integer): boolean;\nbegin\n  var hashSet := new HashSet<integer>;\n  var currentSum := 0;\n  \n  foreach var num in nums do\n  begin\n    currentSum += num;\n    if (currentSum = 0) or hashSet.Contains(currentSum) then\n    begin\n      Result := true;\n      exit;\n    end;\n    hashSet.Add(currentSum);\n  end;\n  \n  Result := false;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of all proper divisors of a given number. A proper divisor of a number is a divisor that is strictly less than the number.",
    "output": "function ProperDivisorSum(n: integer): integer;\nbegin\n  if n <= 1 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var divisors := new List<integer>([1]);\n  for var i := 2 to Round(Sqrt(n)) do\n  begin\n    if n mod i = 0 then\n    begin\n      if i = n div i then\n        divisors.Add(i)\n      else\n      begin\n        divisors.Add(i);\n        divisors.Add(n div i);\n      end;\n    end;\n  end;\n  \n  Result := divisors.Sum;\nend;"
  },
  {
    "instruction": "Write a function to find the volume of a sphere given its radius.",
    "output": "function VolumeOfSphere(r: real): real;\nbegin\n  Result := (4/3) * Pi * Power(r, 3);\nend;"
  },
  {
    "instruction": "Write a function to find the median of two sorted arrays.",
    "output": "function FindMedianSortedArrays(nums1, nums2: array of integer): real;\nbegin\n  var merged := new List<integer>;\n  var i := 0;\n  var j := 0;\n  \n  while (i < nums1.Length) and (j < nums2.Length) do\n  begin\n    if nums1[i] < nums2[j] then\n    begin\n      merged.Add(nums1[i]);\n      i += 1;\n    end\n    else\n    begin\n      merged.Add(nums2[j]);\n      j += 1;\n    end;\n  end;\n  \n  while i < nums1.Length do\n  begin\n    merged.Add(nums1[i]);\n    i += 1;\n  end;\n  \n  while j < nums2.Length do\n  begin\n    merged.Add(nums2[j]);\n    j += 1;\n  end;\n  \n  var n := merged.Count;\n  if n mod 2 = 0 then\n    Result := (merged[n div 2 - 1] + merged[n div 2]) / 2\n  else\n    Result := merged[n div 2];\nend;"
  },
  {
    "instruction": "Write a function to find the duplicate number in a list of numbers from 0 to n. The list has exactly one duplicate number.",
    "output": "function FindDuplicateNumber(nums: array of integer): integer;\nbegin\n  var i := 0;\n  while i < nums.Length do\n  begin\n    if nums[i] = i then\n    begin\n      i += 1;\n      continue;\n    end;\n    if nums[nums[i]] = nums[i] then\n    begin\n      Result := nums[i];\n      exit;\n    end;\n    var temp := nums[nums[i]];\n    nums[nums[i]] := nums[i];\n    nums[i] := temp;\n  end;\n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function that takes an integer n and returns the nth Fibonacci number. The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. That is, fib(0) = 0, fib(1) = 1, and fib(n) = fib(n - 1) + fib(n - 2) for n > 1.",
    "output": "function NthFibonacci(n: integer): integer;\nbegin\n  if n = 0 then\n    Result := 0\n  else if n = 1 then\n    Result := 1\n  else\n  begin\n    var a := 0;\n    var b := 1;\n    for var i := 2 to n do\n    begin\n      var temp := a + b;\n      a := b;\n      b := temp;\n    end;\n    Result := b;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest positive number that is not present in the given list.",
    "output": "function SmallestMissingPos(list1: array of integer): integer;\nbegin\n  var positiveList := list1.Where(i -> i > 0).ToList;\n  positiveList.Sort;\n  \n  if positiveList.Count = 0 then\n  begin\n    Result := 1;\n    exit;\n  end;\n  \n  if positiveList[0] > 1 then\n  begin\n    Result := 1;\n    exit;\n  end;\n  \n  for var i := 0 to positiveList.Count - 2 do\n  begin\n    if positiveList[i + 1] - positiveList[i] > 1 then\n    begin\n      Result := positiveList[i] + 1;\n      exit;\n    end;\n  end;\n  \n  Result := positiveList[positiveList.Count - 1] + 1;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum sum of non-adjacent elements in a circular array. You are given a circular array of integers named `slices`. Your task is to select a subset of non-adjacent elements from `slices` such that the sum of these elements is maximized. However, you cannot select the first and last elements together because the array is circular. Your function should return the maximum possible sum of such a subset.",
    "output": "function Dfs(index, count: integer; hasPre, root: boolean; const slices: array of integer): integer;\nbegin\n  if index = slices.Length then\n  begin\n    if (count <> slices.Length div 3) or (hasPre and root) then\n      Result := integer.MinValue\n    else\n      Result := 0;\n    exit;\n  end;\n  \n  var res := Dfs(index + 1, count, false, root, slices);\n  if (not hasPre) and (count + 1 <= slices.Length div 3) then\n    res := Max(res, Dfs(index + 1, count + 1, true, root, slices) + slices[index]);\n  \n  Result := res;\nend;\n\nfunction MaxSizeSlices(slices: array of integer): integer;\nbegin\n  var n := slices.Length;\n  Result := Max(Dfs(1, 1, true, true, slices) + slices[0], Dfs(1, 0, false, false, slices));\nend;"
  },
  {
    "instruction": "Write a function to find the minimum area of any rectangle formed from given points in the xy-plane, with sides not necessarily parallel to the x and y axes. If there isn't any rectangle, return 0.",
    "output": "function Distance(pointX, pointY: (real, real)): real;\nbegin\n  Result := Sqrt(Power(pointX.Item1 - pointY.Item1, 2) + Power(pointX.Item2 - pointY.Item2, 2));\nend;\n\nfunction IsMiddle(pointX2, pointY2: ((real, real), (real, real))): boolean;\nbegin\n  Result := ((pointX2.Item1.Item1 + pointX2.Item2.Item1) / 2 = (pointY2.Item1.Item1 + pointY2.Item2.Item1) / 2) and\n            ((pointX2.Item1.Item2 + pointX2.Item2.Item2) / 2 = (pointY2.Item1.Item2 + pointY2.Item2.Item2) / 2);\nend;\n\nfunction MinAreaFreeRect(points: array of (real, real)): real;\nbegin\n  var dictsDistance := new Dictionary<real, List<((real, real), (real, real))>>;\n  \n  for var i := 0 to points.Length - 1 do\n    for var j := i + 1 to points.Length - 1 do\n    begin\n      var pointsDistance := Distance(points[i], points[j]);\n      if not dictsDistance.ContainsKey(pointsDistance) then\n        dictsDistance[pointsDistance] := new List<((real, real), (real, real))>;\n      dictsDistance[pointsDistance].Add((points[i], points[j]));\n    end;\n  \n  var minArea := real.MaxValue;\n  \n  foreach var key in dictsDistance.Keys do\n  begin\n    if dictsDistance[key].Count < 2 then\n      continue;\n    \n    for var i1 := 0 to dictsDistance[key].Count - 2 do\n      for var i2 := i1 + 1 to dictsDistance[key].Count - 1 do\n      begin\n        var points4 := Arr(dictsDistance[key][i1], dictsDistance[key][i2]);\n        if IsMiddle(points4[0], points4[1]) then\n        begin\n          var p2 := points4[0].Item1;\n          var (p1, p3) := points4[1];\n          var area := Distance(p2, p1) * Distance(p2, p3);\n          minArea := Min(minArea, area);\n        end;\n      end;\n  end;\n  \n  if minArea = real.MaxValue then\n    Result := 0\n  else\n    Result := minArea;\nend;"
  },
  {
    "instruction": "Write a function to check if a given array can be sorted using the following operations: You can perform a cyclic shift on any segment of the array. A cyclic shift on a segment [L, R] replaces the segment with A[L], A[L+1], ..., A[R-1], A[R] rotated cyclically (either to the left or to the right).",
    "output": "function CyclicSort(nums: array of integer): boolean;\nbegin\n  var n := nums.Length;\n  if n <= 1 then\n  begin\n    Result := true;\n    exit;\n  end;\n\n  var disordered := 0;\n  for var i := 1 to n - 1 do\n  begin\n    if nums[i-1] > nums[i] then\n      disordered += 1;\n  end;\n\n  if nums[n-1] > nums[0] then\n    disordered += 1;\n\n  Result := disordered <= 1;\nend;"
  },
  {
    "instruction": "Write a function to determine if two rectangles intersect. The rectangles are represented as (x1, y1, x2, y2) where (x1, y1) is the bottom-left corner and (x2, y2) is the top-right corner.",
    "output": "function DoRectanglesIntersect(rect1, rect2: (real, real, real, real)): boolean;\nbegin\n  var (x1, y1, x2, y2) := rect1;\n  var (p, q, r, s) := rect2;\n  \n  if (x2 < p) or (r < x1) or (y2 < q) or (s < y1) then\n    Result := false\n  else\n    Result := true;\nend;"
  },
  {
    "instruction": "Write a function to find the first recurring character in a given string.",
    "output": "function FindFirstRecurringChar(s: string): char;\nbegin\n  var seen := new HashSet<char>;\n  foreach var ch in s do\n  begin\n    if seen.Contains(ch) then\n    begin\n      Result := ch;\n      exit;\n    end;\n    seen.Add(ch);\n  end;\n  Result := #0;\nend;"
  },
  {
    "instruction": "Write a function to determine if a given string has all unique characters. The function should return True if all characters in the string are unique, and False otherwise.",
    "output": "function HasUniqueCharacters(s: string): boolean;\nbegin\n  var seen := new HashSet<char>;\n  foreach var ch in s do\n  begin\n    if seen.Contains(ch) then\n    begin\n      Result := false;\n      exit;\n    end;\n    seen.Add(ch);\n  end;\n  Result := true;\nend;"
  },
  {
    "instruction": "Write a function to check if a string contains only digits.",
    "output": "function IsDigitOnly(str1: string): boolean;\nbegin\n  Result := str1.All(ch -> ch in ['0'..'9']);\nend;"
  },
  {
    "instruction": "Write a function to generate the nth row of Pascal's triangle.",
    "output": "function PascalsTriangleRow(n: integer): array of integer;\nbegin\n  var res := ArrFill(n + 1, 0);\n  res[0] := 1;\n  \n  for var i := 1 to n do\n  begin\n    var pre := res.ToArray;\n    for var j := 1 to i do\n      res[j] := pre[j-1] + pre[j];\n  end;\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to convert an amount of time into minutes and seconds.",
    "output": "function TimeToMinutesSeconds(totalSeconds: integer): (string, string);\nbegin\n  var minutes := totalSeconds div 60;\n  var seconds := totalSeconds mod 60;\n  Result := (minutes.ToString + ' minutes', seconds.ToString + ' seconds');\nend;"
  },
  {
    "instruction": "Implement a function `calculate_expression(expression: str) -> int` that calculates the result of a mathematical expression given as a string. The expression will consist of digits, the four basic arithmetic operators (`+`, `-`, `*`, `/`), and parentheses. The function should follow the standard rules of arithmetic operations, including the precedence of operations (parentheses first, then multiplication and division, and finally addition and subtraction), and it should handle division as integer division.",
    "output": "procedure ApplyOperator(operands: List<integer>; op: char);\nbegin\n  var b := operands[operands.Count - 1];\n  operands.RemoveAt(operands.Count - 1);\n  var a := operands[operands.Count - 1];\n  operands.RemoveAt(operands.Count - 1);\n  \n  case op of\n    '+': operands.Add(a + b);\n    '-': operands.Add(a - b);\n    '*': operands.Add(a * b);\n    '/': operands.Add(a div b);\n  end;\nend;\n\nfunction GreaterPrecedence(op1, op2: char): boolean;\nbegin\n  var precedence := new Dictionary<char, integer>;\n  precedence['+'] := 1; precedence['-'] := 1;\n  precedence['*'] := 2; precedence['/'] := 2;\n  Result := precedence[op1] > precedence[op2];\nend;\n\nfunction Evaluate(expr: string): integer;\nbegin\n  var operands := new List<integer>;\n  var operators := new List<char>;\n  var i := 0;\n  \n  while i < expr.Length do\n  begin\n    if expr[i + 1] = ' ' then\n    begin\n      i += 1;\n      continue;\n    end;\n    \n    if expr[i + 1].IsDigit then\n    begin\n      var val := 0;\n      while (i < expr.Length) and expr[i + 1].IsDigit do\n      begin\n        val := (val * 10) + StrToInt(expr[i + 1]);\n        i += 1;\n      end;\n      operands.Add(val);\n      continue;\n    end\n    else if expr[i + 1] = '(' then\n      operators.Add(expr[i + 1])\n    else if expr[i + 1] = ')' then\n    begin\n      while operators[operators.Count - 1] <> '(' do\n      begin\n        ApplyOperator(operands, operators[operators.Count - 1]);\n        operators.RemoveAt(operators.Count - 1);\n      end;\n      operators.RemoveAt(operators.Count - 1);\n    end\n    else\n    begin\n      while (operators.Count > 0) and (operators[operators.Count - 1] <> '(') and\n            GreaterPrecedence(operators[operators.Count - 1], expr[i + 1]) do\n      begin\n        ApplyOperator(operands, operators[operators.Count - 1]);\n        operators.RemoveAt(operators.Count - 1);\n      end;\n      operators.Add(expr[i + 1]);\n    end;\n    i += 1;\n  end;\n  \n  while operators.Count > 0 do\n  begin\n    ApplyOperator(operands, operators[operators.Count - 1]);\n    operators.RemoveAt(operators.Count - 1);\n  end;\n  \n  Result := operands[0];\nend;\n\nfunction CalculateExpression(expression: string): integer;\nbegin\n  Result := Evaluate(expression.Replace(' ', ''));\nend;"
  },
  {
    "instruction": "Write a function to find the nth element of the Lucas sequence. The Lucas sequence is similar to the Fibonacci sequence, but it starts with 2 and 1 instead of 0 and 1. The sequence is defined as follows: L(n) = L(n-1) + L(n-2) for n > 1 L(0) = 2, L(1) = 1",
    "output": "function LucasNumber(n: integer): integer;\nbegin\n  if n = 0 then\n    Result := 2\n  else if n = 1 then\n    Result := 1\n  else\n  begin\n    var lucas := ArrFill(n + 1, 0);\n    lucas[0] := 2;\n    lucas[1] := 1;\n    for var i := 2 to n do\n      lucas[i] := lucas[i-1] + lucas[i-2];\n    Result := lucas[n];\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of k-sum pairs in an array.",
    "output": "function MaxKSumPairs(nums: array of integer; k: integer): integer;\nbegin\n  var count := 0;\n  var pairs := 0;\n  var tempNums := nums.ToList;\n  tempNums.Sort;\n  var left := 0;\n  var right := tempNums.Count - 1;\n\n  while left < right do\n  begin\n    if tempNums[left] + tempNums[right] = k then\n    begin\n      pairs += 1;\n      left += 1;\n      right -= 1;\n    end\n    else if tempNums[left] + tempNums[right] < k then\n      left += 1\n    else\n      right -= 1;\n  end;\n\n  Result := pairs;\nend;"
  },
  {
    "instruction": "Write a function to find the second highest number in a given list. Do not use built-in functions like max() or sort().",
    "output": "function FindSecondHighest(lst: array of integer): integer;\nbegin\n  if lst.Length < 2 then\n  begin\n    Result := -1;\n    exit;\n  end;\n  \n  var highest := integer.MinValue;\n  var secondHighest := integer.MinValue;\n  \n  foreach var num in lst do\n  begin\n    if num > highest then\n    begin\n      secondHighest := highest;\n      highest := num;\n    end\n    else if (num > secondHighest) and (num <> highest) then\n      secondHighest := num;\n  end;\n  \n  if secondHighest = integer.MinValue then\n    Result := -1\n  else\n    Result := secondHighest;\nend;"
  },
  {
    "instruction": "Write a function to convert a list of strings to a list of integers.",
    "output": "function ConvertList(lst: array of string): List<integer>;\nbegin\n  var res := new List<integer>;\n  foreach var i in lst do\n    res.Add(StrToInt(i));\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest valid (well-formed) parentheses substring.",
    "output": "function LengthOfLongestValidParentheses(s: string): integer;\nbegin\n  var maxLen := 0;\n  var stack := new List<integer>;\n  stack.Add(-1);\n  \n  for var i := 0 to s.Length - 1 do\n  begin\n    if s[i + 1] = '(' then\n      stack.Add(i)\n    else\n    begin\n      stack.RemoveAt(stack.Count - 1);\n      if stack.Count = 0 then\n        stack.Add(i)\n      else\n        maxLen := Max(maxLen, i - stack[stack.Count - 1]);\n    end;\n  end;\n\n  Result := maxLen;\nend;"
  },
  {
    "instruction": "Write a function to check if a given list is a permutation of an arithmetic sequence.",
    "output": "function IsArithmeticPermutation(lst: array of integer): boolean;\nbegin\n  if lst.Length < 2 then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  var sortedLst := lst.ToList;\n  sortedLst.Sort;\n  var diff := sortedLst[1] - sortedLst[0];\n  \n  for var i := 2 to sortedLst.Count - 1 do\n    if sortedLst[i] - sortedLst[i-1] <> diff then\n    begin\n      Result := false;\n      exit;\n    end;\n  \n  Result := true;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum second value in a list of tuples.",
    "output": "function MaxSecondValue(lst: List<(integer, integer)>): integer;\nbegin\n  Result := lst.Max(t -> t.Item2);\nend;"
  },
  {
    "instruction": "Write a function to find the character that appears the most in a string. If there is a tie, return the character that appears first in the string.",
    "output": "function FindMaxChar(s: string): char;\nbegin\n  var charCount := new Dictionary<char, integer>;\n  var maxChar := #0;\n  var maxFreq := 0;\n  \n  foreach var ch in s do\n  begin\n    if charCount.ContainsKey(ch) then\n      charCount[ch] += 1\n    else\n      charCount[ch] := 1;\n    \n    if charCount[ch] > maxFreq then\n    begin\n      maxFreq := charCount[ch];\n      maxChar := ch;\n    end;\n  end;\n  \n  Result := maxChar;\nend;"
  },
  {
    "instruction": "Write a function to find the closest integer square root of a given number x.",
    "output": "function ClosestSquareRoot(x: integer): integer;\nbegin\n  if x = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var curNum := 2;\n  var prevNum := 1;\n  \n  for var i := 1 to x div 2 do\n  begin\n    if curNum * curNum > x then\n      break;\n    curNum += 1;\n    prevNum += 1;\n  end;\n  \n  if curNum * curNum = x then\n    Result := curNum\n  else\n    Result := prevNum;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest prime number in a list of integers.",
    "output": "function IsPrime(n: integer): boolean;\nbegin\n  if n < 2 then\n  begin\n    Result := false;\n    exit;\n  end;\n  for var i := 2 to Round(Sqrt(n)) do\n    if n mod i = 0 then\n    begin\n      Result := false;\n      exit;\n    end;\n  Result := true;\nend;\n\nfunction SmallestPrime(numbers: array of integer): integer;\nbegin\n  var primes := new List<integer>;\n  foreach var num in numbers do\n    if IsPrime(num) then\n      primes.Add(num);\n  \n  if primes.Count > 0 then\n    Result := primes.Min\n  else\n    Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to find the number of islands in a given grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "output": "procedure Dfs(var grid: array of array of integer; i, j: integer);\nbegin\n  if (i < 0) or (i >= grid.Length) or (j < 0) or (j >= grid[0].Length) or (grid[i][j] <> 1) then\n    exit;\n  \n  grid[i][j] := -1;\n  Dfs(grid, i+1, j);\n  Dfs(grid, i-1, j);\n  Dfs(grid, i, j+1);\n  Dfs(grid, i, j-1);\nend;\n\nfunction IslandCounter(grid: array of array of integer): integer;\nbegin\n  var islands := 0;\n  for var i := 0 to grid.Length - 1 do\n    for var j := 0 to grid[0].Length - 1 do\n      if grid[i][j] = 1 then\n      begin\n        Dfs(grid, i, j);\n        islands += 1;\n      end;\n  \n  Result := islands;\nend;"
  },
  {
    "instruction": "Write a function that returns the largest integer less than or equal to the square root of a given number without using the built-in square root function.",
    "output": "function IntegerSquareRoot(n: integer): integer;\nbegin\n  if n < 0 then\n    raise new System.ArgumentException('n must be non-negative');\n  \n  var x := n;\n  var y := (x + 1) div 2;\n  \n  while y < x do\n  begin\n    x := y;\n    y := (x + n div x) div 2;\n  end;\n  \n  Result := x;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to decode a message using a specific mapping of numbers to letters. The mapping is \"A\" -> 1, \"B\" -> 2, ..., \"Z\" -> 26. For example, the string \"12\" could be decoded as \"AB\" (1 2) or \"L\" (12).",
    "output": "function CountDecoding(s: string): integer;\nbegin\n  if (s.Length = 0) or (s[1] = '0') then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var n := s.Length;\n  var dp := ArrFill(n + 1, 0);\n  dp[0] := 1;\n  dp[1] := 1;\n  \n  for var i := 2 to n do\n  begin\n    var single := StrToInt(s[i].ToString);\n    var double := StrToInt(s.Substring(i-1, 2));\n    \n    if (single >= 1) and (single <= 9) then\n      dp[i] += dp[i - 1];\n    \n    if (double >= 10) and (double <= 26) then\n      dp[i] += dp[i - 2];\n  end;\n  \n  Result := dp[n];\nend;"
  },
  {
    "instruction": "Write a function to find the total number of continuous subarrays whose sum equals to a given number k.",
    "output": "function TotalSubarrays(nums: array of integer; k: integer): integer;\nbegin\n  var kCount := 0;\n  var s := 0;\n  var countBySum := new Dictionary<integer, integer>;\n  countBySum[0] := 1;\n  \n  foreach var num in nums do\n  begin\n    s += num;\n    if countBySum.ContainsKey(s - k) then\n      kCount += countBySum[s - k];\n    \n    if countBySum.ContainsKey(s) then\n      countBySum[s] += 1\n    else\n      countBySum[s] := 1;\n  end;\n  \n  Result := kCount;\nend;"
  },
  {
    "instruction": "Write a function that accepts a list of numbers and returns the sum of all even numbers and the product of all odd numbers in the list. If the list is empty, return (0, 1). If the list contains no even numbers, the sum should be 0. If the list contains no odd numbers, the product should be 1.",
    "output": "function SumEvenProductOdd(numbers: array of integer): (integer, integer);\nbegin\n  var sumEven := 0;\n  var productOdd := 1;\n  var hasOdd := false;\n  \n  foreach var number in numbers do\n  begin\n    if number mod 2 = 0 then\n      sumEven += number\n    else\n    begin\n      productOdd *= number;\n      hasOdd := true;\n    end;\n  end;\n  \n  if not hasOdd then\n    productOdd := 1;\n  \n  Result := (sumEven, productOdd);\nend;"
  },
  {
    "instruction": "Write a function to find the cumulative sum of a list of numbers.",
    "output": "function RunningSum(nums: array of integer): List<integer>;\nbegin\n  var res := new List<integer>;\n  var total := 0;\n  \n  foreach var num in nums do\n  begin\n    total += num;\n    res.Add(total);\n  end;\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function that will check if a given string can be a palindrome by removing not more than one character.",
    "output": "function Helper(l, r: integer; delete: boolean; const s: string): boolean;\nbegin\n  while l < r do\n  begin\n    if s[l + 1] <> s[r + 1] then\n    begin\n      if delete then\n        Result := Helper(l, r-1, false, s) or Helper(l+1, r, false, s)\n      else\n        Result := false;\n      exit;\n    end;\n    l += 1;\n    r -= 1;\n  end;\n  Result := true;\nend;\n\nfunction IsAlmostPalindrome(s: string): boolean;\nbegin\n  Result := Helper(0, s.Length - 1, true, s);\nend;"
  },
  {
    "instruction": "Write a function to convert a list of integers into a single integer by concatenating the digits.",
    "output": "function IntFromList(lst: array of integer): integer;\nbegin\n  var numStr := string.Join('', lst.Select(x -> x.ToString));\n  Result := StrToInt(numStr);\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest string in a given list of strings.",
    "output": "function FindLongestLength(strings: array of string): integer;\nbegin\n  if strings.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  Result := strings.Max(s -> s.Length);\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to express a number as a sum of consecutive positive integers.",
    "output": "function NumConsecutiveSum(n: integer): integer;\nbegin\n  var count := 0;\n  for var i := 1 to Round(Sqrt(2 * n)) do\n  begin\n    if (n - (i * (i - 1) div 2)) mod i = 0 then\n    begin\n      var value := (n - (i * (i - 1) div 2)) div i;\n      if value > 0 then\n        count += 1;\n    end;\n  end;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to calculate the square root of a positive number using the Newton's method.",
    "output": "function NewtonSquareRoot(num: real): real;\nbegin\n  if num < 0 then\n  begin\n    Result := -1;\n    exit;\n  end;\n  \n  var precision := 0.00000001;\n  var x: real;\n  \n  if num < 1 then\n    x := num\n  else\n    x := num / 2;\n  \n  while true do\n  begin\n    var nextX := (x + num / x) / 2;\n    if Abs(nextX - x) < precision then\n    begin\n      Result := nextX;\n      exit;\n    end;\n    x := nextX;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to rotate a list by a certain number of steps. The function should take a list and an integer as input, and return a new list that is rotated to the right by the specified number of steps. If the rotation number is greater than the length of the list, the rotation should wrap around.",
    "output": "function RotList(lst: array of integer; num: integer): List<integer>;\nbegin\n  var n := lst.Length;\n  var actualNum := num mod n;\n  var rotated := lst.Skip(n - actualNum).Concat(lst.Take(n - actualNum)).ToList;\n  Result := rotated;\nend;"
  },
  {
    "instruction": "Write a function to find the next higher number that has the same number of 1 bits as the given number in its binary representation.",
    "output": "function NextHigherSameBits(n: integer): integer;\nbegin\n  var cntCurrent := Convert.ToString(n, 2).Count(ch -> ch = '1');\n  var e := n + 1;\n  \n  while true do\n  begin\n    if Convert.ToString(e, 2).Count(ch -> ch = '1') = cntCurrent then\n    begin\n      Result := e;\n      exit;\n    end\n    else\n      e += 1;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the number of times an element appears in a list in a recursive manner.",
    "output": "function CountElementRecursively(lst: array of integer; element: integer): integer;\nbegin\n  if lst.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var count := 0;\n  if lst[0] = element then\n    count := 1;\n  \n  Result := count + CountElementRecursively(lst.Skip(1).ToArray, element);\nend;"
  },
  {
    "instruction": "Write a function to find if a list of words contains any palindromes. A palindrome is a word that reads the same backward as forward.",
    "output": "function FindPalindrome(words: array of string): boolean;\nbegin\n  foreach var word in words do\n  begin\n    var reversed := new string(word.Reverse.ToArray);\n    if word = reversed then\n    begin\n      Result := true;\n      exit;\n    end;\n  end;\n  Result := false;\nend;"
  },
  {
    "instruction": "Write a function to calculate the grade of a student based on the total marks.",
    "output": "function CalculateGrade(marks: integer): string;\nbegin\n  if marks >= 90 then\n    Result := 'A'\n  else if marks >= 80 then\n    Result := 'B'\n  else if marks >= 70 then\n    Result := 'C'\n  else if marks >= 60 then\n    Result := 'D'\n  else if marks >= 50 then\n    Result := 'E'\n  else\n    Result := 'F';\nend;"
  },
  {
    "instruction": "Write a function to find the maximum, minimum, and average of a list of numbers without using the built-in functions max(), min(), and sum().",
    "output": "function CalculateStats(numbers: array of integer): (integer, integer, real);\nbegin\n  if numbers.Length = 0 then\n  begin\n    Result := (0, 0, 0);\n    exit;\n  end;\n  \n  var maxNum := numbers[0];\n  var minNum := numbers[0];\n  var total := 0;\n  \n  foreach var num in numbers do\n  begin\n    if num > maxNum then\n      maxNum := num;\n    if num < minNum then\n      minNum := num;\n    total += num;\n  end;\n  \n  var avg := total / numbers.Length;\n  Result := (maxNum, minNum, avg);\nend;"
  },
  {
    "instruction": "Write a function that finds and returns the index of a target value in a rotated sorted array. The array may be rotated at an unknown pivot. For example, an array [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]. If the target is not found in the array, return -1.",
    "output": "function FindPivot(nums: array of integer): integer;\nbegin\n  var left := 0;\n  var right := nums.Length - 1;\n  \n  while left < right do\n  begin\n    var mid := (left + right) div 2;\n    if nums[mid] > nums[right] then\n      left := mid + 1\n    else\n      right := mid;\n  end;\n  Result := left;\nend;\n\nfunction BinarySearch(nums: array of integer; target, left, right: integer): integer;\nbegin\n  while left <= right do\n  begin\n    var mid := (left + right) div 2;\n    if nums[mid] = target then\n    begin\n      Result := mid;\n      exit;\n    end\n    else if nums[mid] < target then\n      left := mid + 1\n    else\n      right := mid - 1;\n  end;\n  Result := -1;\nend;\n\nfunction FindInRotatedArray(nums: array of integer; target: integer): integer;\nbegin\n  var pivot := FindPivot(nums);\n  if (pivot = 0) or (target < nums[0]) then\n    Result := BinarySearch(nums, target, pivot, nums.Length - 1)\n  else\n    Result := BinarySearch(nums, target, 0, pivot - 1);\nend;"
  },
  {
    "instruction": "Write a function to find the length of the largest subarray with at most k distinct elements.",
    "output": "function LargestSubarrayLength(nums: array of integer; k: integer): integer;\nbegin\n  var i := 0;\n  var ans := 0;\n  var win := new Dictionary<integer, integer>;\n  \n  for var j := 0 to nums.Length - 1 do\n  begin\n    if not win.ContainsKey(nums[j]) then\n      win[nums[j]] := 0;\n    \n    if win[nums[j]] = 0 then\n      k -= 1;\n    \n    win[nums[j]] += 1;\n    \n    while k < 0 do\n    begin\n      win[nums[i]] -= 1;\n      if win[nums[i]] = 0 then\n        k += 1;\n      i += 1;\n    end;\n    \n    ans := Max(ans, j - i + 1);\n  end;\n  \n  Result := ans;\nend;"
  },
  {
    "instruction": "Write a function to find the number of times a given number appears in a list and the indices at which it appears.",
    "output": "function FrequencyAndIndices(a: array of integer; x: integer): (integer, List<integer>);\nbegin\n  var count := 0;\n  var indices := new List<integer>;\n  \n  for var i := 0 to a.Length - 1 do\n  begin\n    if a[i] = x then\n    begin\n      count += 1;\n      indices.Add(i);\n    end;\n  end;\n  \n  Result := (count, indices);\nend;"
  },
  {
    "instruction": "Write a function to rearrange a given alphanumeric string so that all the letters appear before all the digits. The relative order of the letters and digits should remain the same.",
    "output": "function RearrangeAlphanumeric(s: string): string;\nbegin\n  var letters := new List<char>;\n  var digits := new List<char>;\n  \n  foreach var ch in s do\n  begin\n    if ch.IsLetter then\n      letters.Add(ch)\n    else\n      digits.Add(ch);\n  end;\n  \n  Result := string.Join('', letters.Concat(digits));\nend;"
  },
  {
    "instruction": "Write a function to check whether the sum of numbers in the first half of a list is equal to the sum of numbers in the second half.",
    "output": "function CheckBalance(numberList: array of integer): boolean;\nbegin\n  var half := numberList.Length div 2;\n  var firstHalfSum := numberList.Take(half).Sum;\n  var secondHalfSum := numberList.Skip(half).Sum;\n  Result := firstHalfSum = secondHalfSum;\nend;"
  },
  {
    "instruction": "Write a function to find the product of two numbers without using multiplication operator. Use recursion method to solve this problem.",
    "output": "function ProductWithoutMultiplication(x, y: integer): integer;\nbegin\n  if y = 0 then\n    Result := 0\n  else if y > 0 then\n    Result := x + ProductWithoutMultiplication(x, y - 1)\n  else\n    Result := -ProductWithoutMultiplication(x, -y);\nend;"
  },
  {
    "instruction": "Write a function to calculate the number of combinations (not permutations) of rolling n six-sided dice to get a total sum of s.",
    "output": "function DiceCombinations(n, s: integer): integer;\nbegin\n  var dp := ArrFill(s + 1, 0);\n  for var i := 1 to 6 do\n    if i <= s then\n      dp[i] := 1;\n\n  for var i := 1 to n - 1 do\n    for var j := s downto 1 do\n    begin\n      var sum := 0;\n      for var k := Max(0, j - 6) to j - 1 do\n        sum += dp[k];\n      dp[j] := sum;\n    end;\n\n  Result := dp[s];\nend;"
  },
  {
    "instruction": "Write a function to find the factorial of a given number.",
    "output": "function FactorialNumber(n: integer): integer;\nbegin\n  if n = 0 then\n    Result := 1\n  else\n    Result := n * FactorialNumber(n - 1);\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of operations required to convert a number n into 1. The operations allowed are: 1. If n is even, divide it by 2. 2. If n is odd, either increment or decrement it by 1. The function should return the minimum number of operations required.",
    "output": "function StepCount(n: integer): integer;\nbegin\n  var count := 0;\n  var tempN := n;\n  \n  while tempN > 1 do\n  begin\n    if tempN mod 2 = 0 then\n      tempN := tempN div 2\n    else if (tempN = 3) or (tempN mod 4 = 1) then\n      tempN := tempN - 1\n    else\n      tempN := tempN + 1;\n    count += 1;\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to calculate the total duration of being poisoned based on the given attack times and the duration of each attack.",
    "output": "function CalculatePoisonDuration(timeSeries: array of integer; duration: integer): integer;\nbegin\n  if timeSeries.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n\n  var res := 0;\n  var n := timeSeries.Length;\n  \n  for var i := 1 to n - 1 do\n  begin\n    var diff := timeSeries[i] - timeSeries[i - 1];\n    if diff < duration then\n      res += diff\n    else\n      res += duration;\n  end;\n  \n  Result := res + duration;\nend;"
  },
  {
    "instruction": "Write a function to find the count of unique characters in a given string.",
    "output": "function UniqueCharacterCount(s: string): integer;\nbegin\n  var uniqueChars := new HashSet<char>(s);\n  Result := uniqueChars.Count;\nend;"
  },
  {
    "instruction": "Write a function to find the shortest unique substring from a given array of characters in a string.",
    "output": "function Check(s: string; a: array of char): boolean;\nbegin\n  var dic := new HashSet<char>(a);\n  foreach var item in s do\n    if dic.Contains(item) then\n      dic.Remove(item);\n  Result := dic.Count = 0;\nend;\n\nfunction GetShortestUniqueSubstring(arr: array of char; str: string): string;\nbegin\n  var checkLength: integer := -1;\n  var dic := new Dictionary<char, integer>;\n  var output: string := '';\n  \n  foreach var item in arr do\n    dic[item] := 1;\n  \n  for var index := 0 to str.Length - 1 do\n  begin\n    var item := str[index + 1];\n    if dic.ContainsKey(item) then\n      dic.Remove(item);\n    \n    if dic.Count = 0 then\n    begin\n      checkLength := index + 1;\n      output := str.Substring(0, index + 1);\n      break;\n    end;\n  end;\n  \n  if checkLength = -1 then\n  begin\n    Result := '';\n    exit;\n  end;\n  \n  var start := 1;\n  checkLength -= 1;\n  \n  while start + checkLength <= str.Length do\n  begin\n    if Check(str.Substring(start - 1, checkLength), arr) then\n    begin\n      output := str.Substring(start - 1, checkLength);\n      checkLength -= 1;\n    end\n    else\n      start += 1;\n  end;\n  \n  Result := output;\nend;"
  },
  {
    "instruction": "Write a function that takes two lists of integers as parameters and returns the sum of the products of the corresponding elements in the lists. If the lists are of unequal length, the extra elements in the longer list should be ignored.",
    "output": "function ListProductSum(list1, list2: array of integer): integer;\nbegin\n  var minLength := Min(list1.Length, list2.Length);\n  var productSum := 0;\n  \n  for var i := 0 to minLength - 1 do\n    productSum += list1[i] * list2[i];\n  \n  Result := productSum;\nend;"
  },
  {
    "instruction": "Write a function to check if a number is a power of 2 using bitwise operators.",
    "output": "function IsPowerOf2(n: integer): boolean;\nbegin\n  if n <= 0 then\n    Result := false\n  else\n    Result := (n and (n - 1)) = 0;\nend;"
  },
  {
    "instruction": "Write a function that receives a list of integers and returns a list containing only the even numbers from the input list, in reverse order.",
    "output": "function ReverseEvenNumbers(numbers: array of integer): List<integer>;\nbegin\n  var evenNumbers := numbers.Where(num -> num mod 2 = 0).ToList;\n  evenNumbers.Reverse;\n  Result := evenNumbers;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of three Integers from a list such that the sum is closest to a given number.",
    "output": "function FindClosestSum(nums: array of integer; target: integer): integer;\nbegin\n  var tempNums := nums.ToList;\n  tempNums.Sort;\n  var closestSum := integer.MaxValue;\n  \n  for var i := 0 to tempNums.Count - 3 do\n  begin\n    var left := i + 1;\n    var right := tempNums.Count - 1;\n    \n    while left < right do\n    begin\n      var currentSum := tempNums[i] + tempNums[left] + tempNums[right];\n      if Abs(target - currentSum) < Abs(target - closestSum) then\n        closestSum := currentSum;\n      \n      if currentSum < target then\n        left += 1\n      else if currentSum > target then\n        right -= 1\n      else\n      begin\n        Result := currentSum;\n        exit;\n      end;\n    end;\n  end;\n  \n  Result := closestSum;\nend;"
  },
  {
    "instruction": "Write a function to convert a given list of string numbers into a list of integers.",
    "output": "function ConvertStringToIntList(stringList: array of string): List<integer>;\nbegin\n  Result := stringList.Select(x -> StrToInt(x)).ToList;\nend;"
  },
  {
    "instruction": "Write a function to split a string into chunks of a given size and return a list of the chunks.",
    "output": "function SplitStringIntoChunks(str: string; size: integer): List<string>;\nbegin\n  var res := new List<string>;\n  for var i := 0 to str.Length - 1 step size do\n  begin\n    var chunk := str.Substring(i, Min(size, str.Length - i));\n    res.Add(chunk);\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to determine the minimum number of steps needed to solve a Tower of Hanoi problem with a given number of disks.",
    "output": "function Hanoi(n: integer): integer;\nbegin\n  if n = 1 then\n    Result := 1\n  else\n    Result := 2 * Hanoi(n - 1) + 1;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest substring without repeating characters.",
    "output": "function LengthOfLongestSubstring(s: string): integer;\nbegin\n  var charSet := new HashSet<char>;\n  var left := 0;\n  var maxLength := 0;\n\n  for var right := 0 to s.Length - 1 do\n  begin\n    while charSet.Contains(s[right + 1]) do\n    begin\n      charSet.Remove(s[left + 1]);\n      left += 1;\n    end;\n\n    charSet.Add(s[right + 1]);\n    maxLength := Max(maxLength, right - left + 1);\n  end;\n\n  Result := maxLength;\nend;"
  },
  {
    "instruction": "Write a function to count the number of times a sorted array has been rotated. The array may have duplicates.",
    "output": "function CountRotationsWithDuplicates(arr: array of integer): integer;\nbegin\n  var start := 0;\n  var finish := arr.Length - 1;\n  \n  while start < finish do\n  begin\n    var mid := start + (finish - start) div 2;\n    \n    if (mid < finish) and (arr[mid] > arr[mid + 1]) then\n    begin\n      Result := mid + 1;\n      exit;\n    end;\n    \n    if (mid > start) and (arr[mid - 1] > arr[mid]) then\n    begin\n      Result := mid;\n      exit;\n    end;\n\n    if (arr[start] = arr[mid]) and (arr[finish] = arr[mid]) then\n    begin\n      if (start < arr.Length - 1) and (arr[start] > arr[start + 1]) then\n      begin\n        Result := start + 1;\n        exit;\n      end;\n      start += 1;\n      \n      if (finish > 0) and (arr[finish - 1] > arr[finish]) then\n      begin\n        Result := finish;\n        exit;\n      end;\n      finish -= 1;\n    end\n    else if (arr[start] < arr[mid]) or ((arr[start] = arr[mid]) and (arr[mid] > arr[finish])) then\n      start := mid + 1\n    else\n      finish := mid - 1;\n  end;\n  \n  Result := 0;\nend;"
  },
  {
    "instruction": "Write a function to check if a binary tree is a sub-tree of another binary tree.",
    "output": "type\n  TreeNode = class\n    Value: integer;\n    Left, Right: TreeNode;\n    \n    constructor Create(x: integer);\n    begin\n      Value := x;\n      Left := nil;\n      Right := nil;\n    end;\n  end;\n\nfunction InorderTraversal(root: TreeNode): List<integer>;\nbegin\n  if root = nil then\n  begin\n    Result := new List<integer>;\n    exit;\n  end;\n  Result := InorderTraversal(root.Left).Concat(new List<integer>([root.Value])).Concat(InorderTraversal(root.Right)).ToList;\nend;\n\nfunction IsSubtree(s, t: TreeNode): boolean;\nbegin\n  var sInorder := string.Join('', InorderTraversal(s).Select(x -> x.ToString));\n  var tInorder := string.Join('', InorderTraversal(t).Select(x -> x.ToString));\n  Result := sInorder.Contains(tInorder);\nend;"
  },
  {
    "instruction": "Write a function to convert a given number into a list of digits.",
    "output": "function ConvertToDigits(number: integer): List<integer>;\nbegin\n  Result := number.ToString.ToCharArray.Select(digit -> StrToInt(digit.ToString)).ToList;\nend;"
  },
  {
    "instruction": "Write a function to find the number of times a given number appears in a sorted array.",
    "output": "function FindNumberOccurrences(arr: array of integer; num: integer): integer;\nbegin\n  if arr.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var left := 0;\n  var right := arr.Length - 1;\n  \n  while left < right do\n  begin\n    var mid := left + (right - left) div 2;\n    if arr[mid] < num then\n      left := mid + 1\n    else\n      right := mid;\n  end;\n  \n  if arr[left] <> num then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var startIndex := left;\n  right := arr.Length - 1;\n  \n  while left < right do\n  begin\n    var mid := left + (right - left + 1) div 2;\n    if arr[mid] > num then\n      right := mid - 1\n    else\n      left := mid;\n  end;\n  \n  Result := right - startIndex + 1;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the largest subarray with a sum of zero.",
    "output": "function MaxLengthSubarray(arr: array of integer): integer;\nbegin\n  var maxLength := 0;\n  var sumDict := new Dictionary<integer, integer>;\n  sumDict[0] := -1;\n  var currentSum := 0;\n  \n  for var i := 0 to arr.Length - 1 do\n  begin\n    currentSum += arr[i];\n    if not sumDict.ContainsKey(currentSum) then\n      sumDict[currentSum] := i\n    else\n      maxLength := Max(maxLength, i - sumDict[currentSum]);\n  end;\n  \n  Result := maxLength;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest substring that can be obtained by replacing at most 'k' characters in the given string 's'.",
    "output": "function CharacterReplacement(s: string; k: integer): integer;\nbegin\n  var chCountInWindow := new Dictionary<char, integer>;\n  var l := 0;\n  var N := s.Length;\n  var ans := 0;\n  \n  for var r := 0 to N - 1 do\n  begin\n    if not chCountInWindow.ContainsKey(s[r + 1]) then\n      chCountInWindow[s[r + 1]] := 0;\n    chCountInWindow[s[r + 1]] += 1;\n\n    var windowSize := r - l + 1;\n    var candidateSize := chCountInWindow.Values.Max;\n    var nonCandidateSize := windowSize - candidateSize;\n\n    if nonCandidateSize > k then\n    begin\n      chCountInWindow[s[l + 1]] -= 1;\n      l += 1;\n    end;\n    \n    windowSize := r - l + 1;\n    ans := Max(ans, windowSize);\n  end;\n  \n  Result := ans;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns a new list with all the elements reversed in order and squared.",
    "output": "function ReverseAndSquare(lst: array of integer): List<integer>;\nbegin\n  var reversed := lst.Reverse.ToArray;\n  Result := reversed.Select(x -> x * x).ToList;\nend;"
  },
  {
    "instruction": "Write a function that finds the smallest integer that can't be represented as a sum of consecutive positive integers starting from 1, with a given integer array.",
    "output": "function FindMissingConsecutive(arr: array of integer): integer;\nbegin\n  var maxNum := arr.Max;\n  var missing := 1;\n  \n  for var i := 1 to maxNum + 1 do\n  begin\n    if not arr.Contains(i) then\n    begin\n      missing := i;\n      break;\n    end;\n  end;\n  \n  Result := missing;\nend;"
  },
  {
    "instruction": "Write a function to check if a string is a palindrome, ignoring case, spaces, and punctuation.",
    "output": "function IsPalindrome(s: string): boolean;\nbegin\n  var cleaned := (new string(s.Where(ch -> char.IsLetterOrDigit(ch)).ToArray)).ToLower;\n  var reversed := new string(cleaned.Reverse.ToArray);\n  Result := cleaned = reversed;\nend;"
  },
  {
    "instruction": "Write a function to convert a string from a base 26 number system (where A=1, B=2, ..., Z=26) to a base 10 number system.",
    "output": "function Base26ToBase10(s: string): integer;\nbegin\n  var ans := 0;\n  foreach var c in s do\n  begin\n    ans *= 26;\n    ans += Ord(c) - Ord('A') + 1;\n  end;\n  Result := ans;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of tuples, where each tuple contains city names and their corresponding points. The function should return the city name with the highest points. If there are multiple cities with the same highest points, return them in the order they appear in the list.",
    "output": "function CityWithHighestPoints(cityPoints: List<(integer, string)>): List<string>;\nbegin\n  var maxPoints := cityPoints.Max(t -> t.Item1);\n  var citiesWithMaxPoints := cityPoints.Where(t -> t.Item1 = maxPoints).Select(t -> t.Item2).ToList;\n  \n  if citiesWithMaxPoints.Count = 1 then\n    Result := new List<string>([citiesWithMaxPoints[0]])\n  else\n    Result := citiesWithMaxPoints;\nend;"
  },
  {
    "instruction": "Write a function to calculate the greatest common divisor (GCD) and least common multiple (LCM) of two given numbers.",
    "output": "function Gcd(x, y: integer): integer;\nbegin\n  while y <> 0 do\n  begin\n    (x, y) := (y, x mod y);\n  end;\n  Result := x;\nend;\n\nfunction Lcm(x, y: integer): integer;\nbegin\n  Result := (x * y) div Gcd(x, y);\nend;\n\nfunction GcdLcm(a, b: integer): (integer, integer);\nbegin\n  Result := (Gcd(a, b), Lcm(a, b));\nend;"
  },
  {
    "instruction": "Write a function to check whether the given number is an Armstrong number or not. An Armstrong number is a number that is equal to the sum of its own digits each raised to the power of the number of digits.",
    "output": "function CheckArmstrong(n: integer): boolean;\nbegin\n  var sum := 0;\n  var temp := n;\n  var order := n.ToString.Length;\n  \n  while temp > 0 do\n  begin\n    var digit := temp mod 10;\n    sum += Round(Power(digit, order));\n    temp := temp div 10;\n  end;\n  \n  Result := n = sum;\nend;"
  },
  {
    "instruction": "Write a function to check if a given array has a subarray with a given sum.",
    "output": "function HasSubarrayWithSum(arr: array of integer; sum: integer): boolean;\nbegin\n  var currentSum := 0;\n  var start := 0;\n  \n  for var i := 0 to arr.Length - 1 do\n  begin\n    currentSum += arr[i];\n    \n    while (currentSum > sum) and (start < i) do\n    begin\n      currentSum -= arr[start];\n      start += 1;\n    end;\n    \n    if currentSum = sum then\n    begin\n      Result := true;\n      exit;\n    end;\n  end;\n  \n  Result := false;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum profit from stock prices with at most k transactions.",
    "output": "function MaxProfitWithKTransactions(prices: array of integer; k: integer): integer;\nbegin\n  if prices.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n\n  var buildDP := new integer[k + 1, prices.Length];\n\n  for var row := 1 to k do\n  begin\n    var maxSeen := integer.MinValue;\n\n    for var col := 1 to prices.Length - 1 do\n    begin\n      maxSeen := Max(maxSeen, -prices[col-1] + buildDP[row-1, col-1]);\n      buildDP[row, col] := Max(buildDP[row, col-1], prices[col] + maxSeen);\n    end;\n  end;\n\n  Result := buildDP[k, prices.Length - 1];\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of consecutive 1's in the array if you can change at most one 0 to a 1.",
    "output": "function MaximumConsecutiveOnes(nums: array of integer): integer;\nbegin\n  var left := 0;\n  var right := 0;\n  var zeroCount := 0;\n  var maxCount := 0;\n  \n  while right < nums.Length do\n  begin\n    if nums[right] = 0 then\n      zeroCount += 1;\n    \n    while zeroCount > 1 do\n    begin\n      if nums[left] = 0 then\n        zeroCount -= 1;\n      left += 1;\n    end;\n    \n    maxCount := Max(maxCount, right - left + 1);\n    right += 1;\n  end;\n  \n  Result := maxCount;\nend;"
  },
  {
    "instruction": "Write a function to find the binary representation of a given decimal number.",
    "output": "function BinDec(num: integer): string;\nbegin\n  Result := Convert.ToString(num, 2);\nend;"
  },
  {
    "instruction": "Write a function to find the smallest possible number that can be expressed as the sum of two cubes of positive integers in two different ways.",
    "output": "function SmallestNumberWithTwoCubes(limit: integer): integer;\nbegin\n  var cubes := new List<integer>;\n  for var i := 1 to Round(Power(limit, 1/3)) do\n    cubes.Add(i * i * i);\n  \n  var sums := new Dictionary<integer, boolean>;\n  \n  for var i := 0 to cubes.Count - 1 do\n  begin\n    for var j := i to cubes.Count - 1 do\n    begin\n      var s := cubes[i] + cubes[j];\n      if s > limit then\n        break;\n      \n      if sums.ContainsKey(s) then\n      begin\n        Result := s;\n        exit;\n      end;\n      sums[s] := true;\n    end;\n  end;\n  \n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to convert a number into a list of its digits.",
    "output": "function NumberToDigits(number: integer): List<integer>;\nbegin\n  if number = 0 then\n  begin\n    Result := new List<integer>([0]);\n    exit;\n  end;\n  \n  var digits := new List<integer>;\n  var temp := number;\n  \n  while temp > 0 do\n  begin\n    digits.Add(temp mod 10);\n    temp := temp div 10;\n  end;\n  \n  digits.Reverse;\n  Result := digits;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of numbers as input and returns a list of the numbers sorted in ascending order. However, there is a twist. The function should sort the numbers using the \"Bogosort\" algorithm, also known as \"stupid sort\", which is considered the least efficient sorting algorithm. The algorithm works by repeatedly shuffling the list until it happens to be sorted.",
    "output": "function IsSorted(lst: array of integer): boolean;\nbegin\n  for var i := 0 to lst.Length - 2 do\n    if lst[i] > lst[i + 1] then\n    begin\n      Result := false;\n      exit;\n    end;\n  Result := true;\nend;\n\nfunction StupidSort(lst: array of integer): List<integer>;\nbegin\n  var tempList := lst.ToList;\n  var random := new System.Random;\n  \n  while not IsSorted(tempList.ToArray) do\n  begin\n    for var i := tempList.Count - 1 downto 1 do\n    begin\n      var j := random.Next(i + 1);\n      var temp := tempList[i];\n      tempList[i] := tempList[j];\n      tempList[j] := temp;\n    end;\n  end;\n  \n  Result := tempList;\nend;"
  },
  {
    "instruction": "Write a function to check if a given number (n) can be expressed as the power of another number (k), where k is greater than 1 and less than or equal to n.",
    "output": "function CheckPower(n, k: integer): boolean;\nbegin\n  if n = 1 then\n    Result := true\n  else if n < k then\n    Result := false\n  else if n mod k = 0 then\n    Result := CheckPower(n div k, k)\n  else\n    Result := false;\nend;"
  },
  {
    "instruction": "Write a function that calculates the average of all the even numbers in a given list of integers.",
    "output": "function EvenAverage(lst: array of integer): real;\nbegin\n  var evenNumbers := lst.Where(num -> num mod 2 = 0).ToList;\n  if evenNumbers.Count > 0 then\n    Result := evenNumbers.Average\n  else\n    Result := 0;\nend;"
  },
  {
    "instruction": "Write a function to find the number of binary strings of length N that do not contain consecutive 1s.",
    "output": "function CountBinaryStr(n: integer): integer;\nbegin\n  if n <= 1 then\n  begin\n    Result := 2;\n    exit;\n  end;\n  \n  var a := 1;\n  var b := 2;\n  \n  for var i := 2 to n - 1 do\n  begin\n    var temp := a + b;\n    a := b;\n    b := temp;\n  end;\n  \n  Result := a + b;\nend;"
  },
  {
    "instruction": "Create a function that takes a list of dictionaries as an argument. Each dictionary represents a person with keys 'name' and 'age'. The function should return a new list of dictionaries sorted by the age of the person in descending order.",
    "output": "function SortPeopleByAge(people: List<Dictionary<string, object>>): List<Dictionary<string, object>>;\nbegin\n  Result := people.OrderByDescending(person -> integer(person['age'])).ToList;\nend;"
  },
  {
    "instruction": "Write a function to find all numbers within a given range where the sum of the digits is equal to the given number. The function should return a list of those numbers.",
    "output": "function FindNumbersWithDigitSum(startNum, endNum, targetSum: integer): List<integer>;\nbegin\n  var res := new List<integer>;\n  for var num := startNum to endNum do\n  begin\n    var digitSum := num.ToString.ToCharArray.Sum(ch -> StrToInt(ch.ToString));\n    if digitSum = targetSum then\n      res.Add(num);\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of nested lists in a given list.",
    "output": "function FindMaxNestedLists(lst: array of Object): integer;\nbegin\n  var maxDepth := 1;\n  var currentDepth := 1;\n  var stack := new Stack<(integer, array of Object)>;\n  \n  foreach var item in lst do\n  begin\n    if item is array of Object then\n    begin\n      stack.Push((currentDepth, Arr(item)));\n      currentDepth += 1;\n      if currentDepth > maxDepth then\n        maxDepth := currentDepth;\n    end\n    else\n    begin\n      while (stack.Count > 0) and not (item is array of Object) do\n      begin\n        var (depth, arr) := stack.Pop;\n        currentDepth := depth;\n      end;\n    end;\n  end;\n  \n  Result := maxDepth;\nend;"
  },
  {
    "instruction": "Write a function to determine if a given binary tree is a valid binary search tree (BST).",
    "output": "type\n  TreeNode = class\n    val: integer;\n    left, right: TreeNode;\n    \n    constructor(v: integer; l: TreeNode := nil; r: TreeNode := nil);\n    begin\n      val := v;\n      left := l;\n      right := r;\n    end;\n  end;\n\nfunction IsValidBst(root: TreeNode): boolean;\nbegin\n  if root = nil then\n  begin\n    Result := true;\n    exit;\n  end;\n  \n  var stack := new Stack<(TreeNode, real, real)>;\n  stack.Push((root, real.MinValue, real.MaxValue));\n  \n  while stack.Count > 0 do\n  begin\n    var (node, lower, upper) := stack.Pop;\n    if node = nil then\n      continue;\n    \n    var value := node.val;\n    if (value <= lower) or (value >= upper) then\n    begin\n      Result := false;\n      exit;\n    end;\n    \n    stack.Push((node.right, value, upper));\n    stack.Push((node.left, lower, value));\n  end;\n  \n  Result := true;\nend;"
  },
  {
    "instruction": "Write a function to find all possible combinations of brackets in a given string that are correctly matched and closed. The function should return a list of strings, each representing a valid combination of brackets.",
    "output": "function FindBracketCombinations(n: integer): List<string>;\n\nprocedure GenerateBrackets(openCount, closeCount: integer; currentString: string; var res: List<string>);\nbegin\n  if (openCount = 0) and (closeCount = 0) then\n  begin\n    res.Add(currentString);\n    exit;\n  end;\n  \n  if openCount > 0 then\n    GenerateBrackets(openCount - 1, closeCount, currentString + '(', res);\n  \n  if closeCount > openCount then\n    GenerateBrackets(openCount, closeCount - 1, currentString + ')', res);\nend;\n\nbegin\n  var res := new List<string>;\n  GenerateBrackets(n, n, '', res);\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to check if a string matches the pattern \"abba\", where 'a' and 'b' are distinct characters from the input string.",
    "output": "function MatchPattern(inputString: string): boolean;\nbegin\n  for var i := 1 to inputString.Length - 1 do\n  begin\n    if (inputString.Substring(0, i) <> inputString.Substring(i, i)) or (inputString[i] = inputString[0]) then\n      continue;\n    \n    if (inputString.Substring(i, i) = inputString.Substring(2*i, i)) or (inputString.Substring(0, i) <> inputString.Substring(3*i, i)) then\n    begin\n      Result := false;\n      exit;\n    end;\n    \n    Result := true;\n    exit;\n  end;\n  \n  Result := false;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the smallest string that can be formed by concatenating '1's and is divisible by a given number k.",
    "output": "function SmallestRepunitDivisibleByK(k: integer): integer;\nbegin\n  if (k mod 2 = 0) or (k mod 5 = 0) then\n  begin\n    Result := -1;\n    exit;\n  end;\n  \n  var remainder := 1;\n  var nLen := 1;\n  \n  while true do\n  begin\n    if remainder mod k = 0 then\n    begin\n      Result := nLen;\n      exit;\n    end;\n    \n    remainder := (remainder * 10 + 1) mod k;\n    nLen += 1;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to calculate the total number of bits needed to represent a non-negative integer in binary, including the sign bit and leading zeros up to a specified number of bits.",
    "output": "function CalcBitLength(n, bits: integer): integer;\nbegin\n  if n = 0 then\n    Result := bits\n  else\n    Result := Max(bits, System.Convert.ToString(n, 2).Length + 1);\nend;"
  },
  {
    "instruction": "Write a function that takes two lists, A and B, and returns a list of two integers. The first integer is an element from list A that, when swapped with the second integer (an element from list B), will result in both lists having the same sum. The function should return the smallest possible value for the first integer.",
    "output": "function FairCandySwap(A, B: array of integer): array of integer;\nbegin\n  var num1 := A.Sum;\n  var num2 := B.Sum;\n  var sumAll := num1 + num2;\n  var everyone := sumAll div 2;\n  var jiaohuanshu := everyone - num1;\n  var aSet := new HashSet<integer>(A);\n  \n  foreach var item in B do\n  begin\n    if aSet.Contains(item - jiaohuanshu) then\n    begin\n      Result := |item - jiaohuanshu, item|;\n      exit;\n    end;\n  end;\n  \n  Result := |0, 0|;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of words and returns the length of the longest word that can be formed by concatenating words from the list, where each word in the list can be used at most once. The function should return -1 if no such word can be formed.",
    "output": "function Dfs(word: string; wordSet: HashSet<string>): boolean;\nbegin\n  for var i := 1 to word.Length - 1 do\n  begin\n    var prefix := word.Substring(0, i);\n    var suffix := word.Substring(i);\n    \n    if wordSet.Contains(prefix) and (wordSet.Contains(suffix) or Dfs(suffix, wordSet)) then\n    begin\n      Result := true;\n      exit;\n    end;\n  end;\n  \n  Result := false;\nend;\n\nfunction LongestConcat(words: List<string>): integer;\nbegin\n  words.Sort((x, y) -> y.Length.CompareTo(x.Length));\n  var wordSet := new HashSet<string>(words);\n  var maxLength := 0;\n  \n  foreach var word in words do\n  begin\n    if Dfs(word, wordSet) then\n    begin\n      maxLength := Max(maxLength, word.Length);\n      wordSet.Remove(word);\n    end;\n  end;\n  \n  if maxLength > 0 then\n    Result := maxLength\n  else\n    Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to find the number of days between two given dates.",
    "output": "function NumDaysBetween(date1, date2: string): integer;\nbegin\n  var d1 := System.DateTime.Parse(date1);\n  var d2 := System.DateTime.Parse(date2);\n  var delta := d2 - d1;\n  Result := Abs(delta.Days);\nend;"
  },
  {
    "instruction": "Write a function to check if a binary tree is symmetric around its center.",
    "output": "type\n  TreeNode = class\n    val: integer;\n    left, right: TreeNode;\n    \n    constructor(v: integer; l: TreeNode := nil; r: TreeNode := nil);\n    begin\n      val := v;\n      left := l;\n      right := r;\n    end;\n  end;\n\nfunction IsSymmetric(root: TreeNode): boolean;\n\nfunction IsMirror(t1, t2: TreeNode): boolean;\nbegin\n  if (t1 = nil) and (t2 = nil) then\n  begin\n    Result := true;\n    exit;\n  end;\n  \n  if (t1 = nil) or (t2 = nil) then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  Result := (t1.val = t2.val) and IsMirror(t1.right, t2.left) and IsMirror(t1.left, t2.right);\nend;\n\nbegin\n  if root = nil then\n  begin\n    Result := true;\n    exit;\n  end;\n  \n  Result := IsMirror(root.left, root.right);\nend;"
  },
  {
    "instruction": "Write a function to find the nth Bell Number. The Bell Number is the number of ways to partition a set that has exactly n elements.",
    "output": "function NthBellNumber(n: integer): integer;\nbegin\n  var bell := new integer[n+1, n+1];\n  bell[0,0] := 1;\n  \n  for var i := 1 to n do\n  begin\n    bell[i,0] := bell[i-1,i-1];\n    for var j := 1 to i do\n    begin\n      bell[i,j] := bell[i-1,j-1] + bell[i,j-1];\n    end;\n  end;\n  \n  Result := bell[n,0];\nend;"
  },
  {
    "instruction": "Write a function to find the number of times a given value appears in a list and its positions.",
    "output": "function FindValuePositions(lst: array of integer; value: integer): (integer, List<integer>);\nbegin\n  var count := 0;\n  var positions := new List<integer>;\n  \n  for var i := 0 to lst.Length - 1 do\n  begin\n    if lst[i] = value then\n    begin\n      count += 1;\n      positions.Add(i);\n    end;\n  end;\n  \n  Result := (count, positions);\nend;"
  },
  {
    "instruction": "Write a function to find the lowest common multiple (LCM) of two integers.",
    "output": "function Gcd(a, b: integer): integer;\nbegin\n  while b <> 0 do\n  begin\n    var temp := b;\n    b := a mod b;\n    a := temp;\n  end;\n  Result := a;\nend;\n\nfunction LowestCommonMultiple(x, y: integer): integer;\nbegin\n  Result := x * y div Gcd(x, y);\nend;"
  },
  {
    "instruction": "Write a function to find the sum of all elements in a given array.",
    "output": "function SumArray(nums: array of integer): integer;\nbegin\n  Result := nums.Sum;\nend;"
  },
  {
    "instruction": "Write a function that takes a 2D list of integers as input and returns the length of the longest increasing path within the matrix. You may move in four directions: up, down, left, and right. The path does not have to be continuous. However, once you move to a new cell, you cannot move back to the previous cell.",
    "output": "function Dfs(i, j: integer; var dp: array[,] of integer; const matrix: array of array of integer): integer;\nbegin\n  if dp[i, j] <> -1 then\n  begin\n    Result := dp[i, j];\n    exit;\n  end;\n  \n  var directions := |(0,1), (0,-1), (1,0), (-1,0)|;\n  dp[i, j] := 1;\n  \n  foreach var (dx, dy) in directions do\n  begin\n    var x := i + dx;\n    var y := j + dy;\n    \n    if (x < 0) or (x >= matrix.Length) or (y < 0) or (y >= matrix[0].Length) or (matrix[x][y] <= matrix[i][j]) then\n      continue;\n    \n    dp[i, j] := Max(dp[i, j], Dfs(x, y, dp, matrix) + 1);\n  end;\n  \n  Result := dp[i, j];\nend;\n\nfunction LongestIncreasingPath(matrix: array of array of integer): integer;\nbegin\n  if matrix.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var n := matrix.Length;\n  var m := matrix[0].Length;\n  var dp := new integer[n, m];\n  \n  for var i := 0 to n - 1 do\n    for var j := 0 to m - 1 do\n      dp[i, j] := -1;\n  \n  var res := 0;\n  for var i := 0 to n - 1 do\n    for var j := 0 to m - 1 do\n      res := Max(res, Dfs(i, j, dp, matrix));\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the longest consecutive repeating character in a string.",
    "output": "function LongestConsecutiveChar(s: string): string;\nbegin\n  if s = '' then\n  begin\n    Result := '';\n    exit;\n  end;\n  \n  var maxLen := 1;\n  var maxChar := s[1];\n  var curLen := 1;\n  \n  for var i := 2 to s.Length do\n  begin\n    if s[i] = s[i-1] then\n      curLen += 1\n    else\n      curLen := 1;\n    \n    if curLen > maxLen then\n    begin\n      maxLen := curLen;\n      maxChar := s[i];\n    end;\n  end;\n  \n  Result := maxChar;\nend;"
  },
  {
    "instruction": "Write a function to find the number of good paths in an undirected weighted graph. A good path is a path between two nodes where the maximum value of a node on the path is equal to the minimum value of a node on the path.",
    "output": "function NumberOfGoodPaths(vals: array of integer; edges: array of (integer, integer)): integer;\n\nfunction Find(x: integer; var parents: array of integer): integer;\nbegin\n  if parents[x] <> x then\n    parents[x] := Find(parents[x], parents);\n  Result := parents[x];\nend;\n\nprocedure Union(x, y: integer; var parents: array of integer; var ranks: array of integer);\nbegin\n  var px := Find(x, parents);\n  var py := Find(y, parents);\n  \n  if px = py then\n    exit;\n  \n  var rx := ranks[px];\n  var ry := ranks[py];\n  \n  if rx < ry then\n  begin\n    var temp := px;\n    px := py;\n    py := temp;\n  end;\n  \n  parents[py] := px;\n  if rx = ry then\n    ranks[px] += 1;\nend;\n\nbegin\n  var n := vals.Length;\n  var adj := new Dictionary<integer, HashSet<integer>>;\n  \n  foreach var (u, v) in edges do\n  begin\n    if not adj.ContainsKey(u) then\n      adj[u] := new HashSet<integer>;\n    if not adj.ContainsKey(v) then\n      adj[v] := new HashSet<integer>;\n    \n    adj[u].Add(v);\n    adj[v].Add(u);\n  end;\n  \n  var parents := new integer[n];\n  var ranks := new integer[n];\n  \n  for var i := 0 to n - 1 do\n    parents[i] := i;\n  \n  var ans := 0;\n  var valsNodesMap := new Dictionary<integer, List<integer>>;\n  \n  for var i := 0 to n - 1 do\n  begin\n    if not valsNodesMap.ContainsKey(vals[i]) then\n      valsNodesMap[vals[i]] := new List<integer>;\n    valsNodesMap[vals[i]].Add(i);\n  end;\n  \n  var sortedVals := valsNodesMap.Keys.ToList;\n  sortedVals.Sort;\n  \n  foreach var val in sortedVals do\n  begin\n    foreach var x in valsNodesMap[val] do\n    begin\n      if adj.ContainsKey(x) then\n      begin\n        foreach var neighbor in adj[x] do\n        begin\n          if vals[neighbor] <= val then\n            Union(neighbor, x, parents, ranks);\n        end;\n      end;\n    end;\n    \n    var groupCounts := new Dictionary<integer, integer>;\n    foreach var x in valsNodesMap[val] do\n    begin\n      var parent := Find(x, parents);\n      if not groupCounts.ContainsKey(parent) then\n        groupCounts[parent] := 0;\n      groupCounts[parent] += 1;\n    end;\n    \n    foreach var size in groupCounts.Values do\n      ans += (size + 1) * size div 2;\n  end;\n  \n  Result := ans;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and a target value, and returns the index of the target value in the list using binary search if the list is sorted and rotated. If the target value is not found, return -1. The list is guaranteed to have distinct values.",
    "output": "function Search(nums: array of integer; target: integer): integer;\nbegin\n  if (nums.Length = 0) then\n  begin\n    Result := -1;\n    exit;\n  end;\n  \n  var start := 0;\n  var finish := nums.Length - 1;\n  \n  while start + 1 < finish do\n  begin\n    var mid := (start + finish) div 2;\n    \n    if nums[mid] = target then\n    begin\n      Result := mid;\n      exit;\n    end\n    else if (nums[mid] >= nums[start]) and (target < nums[mid]) and (target >= nums[start]) then\n      finish := mid\n    else if nums[mid] >= nums[start] then\n      start := mid\n    else if (nums[mid] <= nums[finish]) and (target > nums[mid]) and (target <= nums[finish]) then\n      start := mid\n    else\n      finish := mid;\n  end;\n  \n  if nums[start] = target then\n    Result := start\n  else if nums[finish] = target then\n    Result := finish\n  else\n    Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to check if it's possible to make the given array non-decreasing by modifying at most one element.",
    "output": "function CheckPossibility(nums: array of integer): boolean;\nbegin\n  var n := nums.Length;\n  var cnt := 0;\n  \n  for var i := 1 to n - 1 do\n  begin\n    if nums[i-1] > nums[i] then\n    begin\n      if (cnt > 0) or ((i > 1) and (i < n - 1) and (nums[i-2] > nums[i]) and (nums[i+1] < nums[i-1])) then\n      begin\n        Result := false;\n        exit;\n      end;\n      cnt += 1;\n    end;\n  end;\n  \n  Result := true;\nend;"
  },
  {
    "instruction": "Write a function that takes a string as input and returns a new string where the letters at even indices are in uppercase and the letters at odd indices are in lowercase.",
    "output": "function UpperEvenLowerOdd(s: string): string;\nbegin\n  var sb := new StringBuilder;\n  \n  for var i := 1 to s.Length do\n  begin\n    if i mod 2 = 1 then\n      sb.Append(s[i].ToUpper)\n    else\n      sb.Append(s[i].ToLower);\n  end;\n  \n  Result := sb.ToString;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum subarray sum such that the subarray crosses the midpoint of the array.",
    "output": "function MaxCrossingSum(arr: array of integer): integer;\n\nfunction MaxSum(left, right, mid: integer; const arr: array of integer): integer;\nbegin\n  var sumLeft := integer.MinValue;\n  var currentSum := 0;\n  \n  for var i := mid downto left do\n  begin\n    currentSum += arr[i];\n    if currentSum > sumLeft then\n      sumLeft := currentSum;\n  end;\n  \n  var sumRight := integer.MinValue;\n  currentSum := 0;\n  \n  for var i := mid + 1 to right do\n  begin\n    currentSum += arr[i];\n    if currentSum > sumRight then\n      sumRight := currentSum;\n  end;\n  \n  Result := sumLeft + sumRight;\nend;\n\nfunction Solve(left, right: integer; const arr: array of integer): integer;\nbegin\n  if left = right then\n  begin\n    Result := arr[left];\n    exit;\n  end;\n  \n  var mid := (left + right) div 2;\n  var leftSum := Solve(left, mid, arr);\n  var rightSum := Solve(mid + 1, right, arr);\n  var crossingSum := MaxSum(left, right, mid, arr);\n  \n  Result := Max(Max(leftSum, rightSum), crossingSum);\nend;\n\nbegin\n  Result := Solve(0, arr.Length - 1, arr);\nend;"
  },
  {
    "instruction": "Write a function that checks if a given grid has a valid path from the top-left corner to the bottom-right corner. A valid path can only be made through connected streets, and you cannot change any street. Grid cells represent streets as follows:\n1: a street connecting the left cell and the right cell.\n2: a street connecting the upper cell and the lower cell.\n3: a street connecting the left cell and the lower cell.\n4: a street connecting the right cell and the lower cell.\n5: a street connecting the left cell and the upper cell.\n6: a street connecting the right cell and the upper cell.",
    "output": "function Dfs(r, c: integer; const grid: array of array of integer; var seen: HashSet<integer>): boolean;\nbegin\n  var height := grid.Length;\n  var width := grid[0].Length;\n  var key := r * width + c;\n  \n  if seen.Contains(key) then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  seen.Add(key);\n  \n  if (r = height - 1) and (c = width - 1) then\n  begin\n    Result := true;\n    exit;\n  end;\n  \n  var diffs := |(1,0), (-1,0), (0,1), (0,-1)|;\n  var streets := new Dictionary<integer, HashSet<string>>;\n  \n  streets[1] := new HashSet<string>(|'l', 'r'.ToString()|);\n  streets[2] := new HashSet<string>(|'u', 'd'.ToString()|);\n  streets[3] := new HashSet<string>(|'l', 'd'.ToString()|);\n  streets[4] := new HashSet<string>(|'r', 'd'.ToString()|);\n  streets[5] := new HashSet<string>(|'l', 'u'.ToString()|);\n  streets[6] := new HashSet<string>(|'u', 'r'.ToString()|);\n  \n  var depToArr := new Dictionary<string, string>;\n  depToArr['d'] := 'u';\n  depToArr['u'] := 'd';\n  depToArr['r'] := 'l';\n  depToArr['l'] := 'r';\n  \n  foreach var (rowDiff, colDiff) in diffs do\n  begin\n    var newRow := r + rowDiff;\n    var newCol := c + colDiff;\n    \n    if (newRow < 0) or (newRow >= height) or (newCol < 0) or (newCol >= width) then\n      continue;\n    \n    var newKey := newRow * width + newCol;\n    if seen.Contains(newKey) then\n      continue;\n    \n    var departureDirection: string;\n    if rowDiff = 1 then\n      departureDirection := 'd'\n    else if rowDiff = -1 then\n      departureDirection := 'u'\n    else if colDiff = 1 then\n      departureDirection := 'r'\n    else\n      departureDirection := 'l';\n    \n    var arrivalDirection := depToArr[departureDirection];\n    \n    if not streets[grid[r][c]].Contains(departureDirection) or not streets[grid[newRow][newCol]].Contains(arrivalDirection) then\n      continue;\n    \n    if Dfs(newRow, newCol, grid, seen) then\n    begin\n      Result := true;\n      exit;\n    end;\n  end;\n  \n  Result := false;\nend;\n\nfunction HasValidPath(grid: array of array of integer): boolean;\nbegin\n  var seen := new HashSet<integer>;\n  Result := Dfs(0, 0, grid, seen);\nend;"
  },
  {
    "instruction": "Write a function to find the maximum value that can be obtained from the given array by making at most k swaps between adjacent elements.",
    "output": "function MaxValueWithSwaps(arr: array of integer; k: integer): integer;\nbegin\n  var n := arr.Length;\n  if (n = 1) or (k = 0) then\n  begin\n    Result := arr[0];\n    exit;\n  end;\n  \n  var maxVal := new integer[n];\n  maxVal[0] := arr[0];\n  \n  for var i := 1 to n - 1 do\n    maxVal[i] := Max(arr[i], maxVal[i-1]);\n  \n  var res := arr[0];\n  for var i := 1 to n - 1 do\n  begin\n    if k > 0 then\n    begin\n      res := Max(res, maxVal[Min(i + k, n - 1)]);\n      maxVal[i] := Max(maxVal[i], res);\n    end\n    else\n      res := maxVal[i];\n  end;\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to calculate the total number of days between two dates.",
    "output": "function CalculateDateDifference(date1, date2: string): integer;\nbegin\n  var a := System.DateTime.Parse(date1);\n  var b := System.DateTime.Parse(date2);\n  var delta := b - a;\n  Result := delta.Days;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of all the prime numbers that can be expressed as the sum of two consecutive Fibonacci numbers.",
    "output": "function PrimeFibonacciSum(n: integer): integer;\n\nfunction IsPrime(num: integer): boolean;\nbegin\n  if num < 2 then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  for var i := 2 to Round(Sqrt(num)) do\n  begin\n    if num mod i = 0 then\n    begin\n      Result := false;\n      exit;\n    end;\n  end;\n  \n  Result := true;\nend;\n\nfunction Fibonacci(n: integer): integer;\nbegin\n  if n = 0 then\n    Result := 0\n  else if n = 1 then\n    Result := 1\n  else\n    Result := Fibonacci(n - 1) + Fibonacci(n - 2);\nend;\n\nbegin\n  var sumPrimes := 0;\n  var i := 1;\n  \n  while n > 0 do\n  begin\n    var fib1 := Fibonacci(i);\n    var fib2 := Fibonacci(i + 1);\n    var sumFib := fib1 + fib2;\n    \n    if IsPrime(sumFib) then\n    begin\n      sumPrimes += sumFib;\n      n -= 1;\n    end;\n    \n    i += 1;\n  end;\n  \n  Result := sumPrimes;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of non-overlapping subarrays with sum less than or equal to a given value.",
    "output": "function MaxSubarraysLeqSum(arr: array of integer; target: integer): integer;\nbegin\n  var prefixSum := new List<integer>;\n  prefixSum.Add(0);\n  \n  foreach var num in arr do\n    prefixSum.Add(prefixSum[prefixSum.Count - 1] + num);\n  \n  var maxSubarrays := 0;\n  \n  for var i := 0 to prefixSum.Count - 1 do\n  begin\n    for var j := i + 1 to prefixSum.Count - 1 do\n    begin\n      if prefixSum[j] - prefixSum[i] <= target then\n        maxSubarrays := Max(maxSubarrays, j - i)\n      else\n        break;\n    end;\n  end;\n  \n  Result := maxSubarrays;\nend;"
  },
  {
    "instruction": "Write a function to rotate a list by a certain number of steps. The function should take a list and an integer as input, and return a new list that is rotated to the right by the specified number of steps. If the rotation number is greater than the length of the list, the rotation should wrap around.",
    "output": "function RotList(lst: array of integer; num: integer): array of integer;\nbegin\n  var n := lst.Length;\n  num := num mod n;\n  Result := lst[(n - num):] + lst[:(n - num)];\nend;"
  },
  {
    "instruction": "Write a function to calculate the number of unique binary search trees (BSTs) that store values 1...n.",
    "output": "function NumTrees(n: integer): integer;\nbegin\n  if n <= 1 then\n  begin\n    Result := 1;\n    exit;\n  end;\n  \n  var dp := new List<integer>;\n  dp.Add(1);\n  dp.Add(1);\n  \n  for var i := 2 to n do\n  begin\n    dp.Add(0);\n    for var j := 0 to i - 1 do\n      dp[i] += dp[j] * dp[i - j - 1];\n  end;\n  \n  Result := dp[n];\nend;"
  },
  {
    "instruction": "Implement a function that takes a list of strings and a target string. The function should return the index of the target string in the list if it exists, and -1 otherwise. The list may contain duplicate strings.",
    "output": "function FindStringIndex(strings: array of string; target: string): integer;\nbegin\n  Result := &Array.IndexOf(strings, target);\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns a new list where each element is the product of all the elements in the original list except for the element at the current index. Do not use division in your solution.",
    "output": "function ProductExcludingSelf(nums: array of integer): array of integer;\nbegin\n  var n := nums.Length;\n  var output := new integer[n];\n  for var i := 0 to n - 1 do\n    output[i] := 1;\n  \n  var leftProduct := 1;\n  var rightProduct := 1;\n  \n  for var i := 0 to n - 1 do\n  begin\n    output[i] *= leftProduct;\n    leftProduct *= nums[i];\n  end;\n  \n  for var i := n - 1 downto 0 do\n  begin\n    output[i] *= rightProduct;\n    rightProduct *= nums[i];\n  end;\n  \n  Result := output;\nend;"
  },
  {
    "instruction": "Write a function to find a peak element in an array where an element is peak if it is NOT smaller than its neighbors. For corner elements, we need to consider only one neighbor.",
    "output": "function PeakElement(arr: array of integer): integer;\nbegin\n  var n := arr.Length;\n  if n = 1 then\n  begin\n    Result := arr[0];\n    exit;\n  end;\n  \n  if arr[0] >= arr[1] then\n  begin\n    Result := arr[0];\n    exit;\n  end;\n  \n  if arr[n-1] >= arr[n-2] then\n  begin\n    Result := arr[n-1];\n    exit;\n  end;\n  \n  for var i := 1 to n - 2 do\n  begin\n    if (arr[i] >= arr[i-1]) and (arr[i] >= arr[i+1]) then\n    begin\n      Result := arr[i];\n      exit;\n    end;\n  end;\n  \n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function that takes an integer n and returns a list of all divisors of n.",
    "output": "function GetDivisors(n: integer): List<integer>;\nbegin\n  var divisors := new List<integer>;\n  \n  for var i := 1 to n do\n  begin\n    if n mod i = 0 then\n      divisors.Add(i);\n  end;\n  \n  Result := divisors;\nend;"
  },
  {
    "instruction": "Write a function to check if a given string is a valid parentheses sequence.",
    "output": "function ValidParenthesesSequence(s: string): boolean;\nbegin\n  var count := 0;\n  \n  for var i := 1 to s.Length do\n  begin\n    if s[i] = '(' then\n      count += 1\n    else if s[i] = ')' then\n      count -= 1;\n    \n    if count < 0 then\n    begin\n      Result := false;\n      exit;\n    end;\n  end;\n  \n  Result := count = 0;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest multiple of 3 that is greater than a given number.",
    "output": "function SmallestMultipleOf3(n: integer): integer;\nbegin\n  if n mod 3 = 0 then\n    Result := n\n  else\n    Result := n + (3 - (n mod 3));\nend;"
  },
  {
    "instruction": "Write a function to find the maximum profit from stock trading given a list of daily prices. You are allowed to complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) but you must sell the stock before you buy again.",
    "output": "function StockProfit(prices: array of integer): integer;\nbegin\n  var profit := 0;\n  \n  for var i := 1 to prices.Length - 1 do\n  begin\n    if prices[i] > prices[i-1] then\n      profit += prices[i] - prices[i-1];\n  end;\n  \n  Result := profit;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of all numbers in a list that are not repeated.",
    "output": "function FindUniqueSum(lst: array of integer): integer;\nbegin\n  var sumVal := 0;\n  \n  foreach var x in lst do\n  begin\n    if lst.Count(y -> y = x) = 1 then\n      sumVal += x;\n  end;\n  \n  Result := sumVal;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum length of subarray with sum equals to k.",
    "output": "function MaxSubarrayLen(nums: array of integer; k: integer): integer;\nbegin\n  var maxLength := 0;\n  var sumDict := new Dictionary<integer, integer>;\n  sumDict[0] := -1;\n  var sumVal := 0;\n  \n  for var i := 0 to nums.Length - 1 do\n  begin\n    sumVal += nums[i];\n    \n    if not sumDict.ContainsKey(sumVal) then\n      sumDict[sumVal] := i;\n    \n    if sumDict.ContainsKey(sumVal - k) then\n      maxLength := Max(maxLength, i - sumDict[sumVal - k]);\n  end;\n  \n  Result := maxLength;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest missing positive integer from an unsorted array.",
    "output": "function FindSmallestMissingPositive(arr: array of integer): integer;\nbegin\n  var n := arr.Length;\n  \n  for var i := 0 to n - 1 do\n  begin\n    while (arr[i] >= 1) and (arr[i] <= n) and (arr[arr[i] - 1] <> arr[i]) do\n    begin\n      var temp := arr[arr[i] - 1];\n      arr[arr[i] - 1] := arr[i];\n      arr[i] := temp;\n    end;\n  end;\n  \n  for var i := 0 to n - 1 do\n  begin\n    if arr[i] <> i + 1 then\n    begin\n      Result := i + 1;\n      exit;\n    end;\n  end;\n  \n  Result := n + 1;\nend;"
  },
  {
    "instruction": "Write a function to find the index of the first occurrence of a target value in a sorted list. If the target value is not found, return -1.",
    "output": "function FindIndex(numbers: array of integer; target: integer): integer;\nbegin\n  var left := 0;\n  var right := numbers.Length - 1;\n  \n  while left <= right do\n  begin\n    var mid := left + (right - left) div 2;\n    \n    if numbers[mid] = target then\n    begin\n      if (mid = 0) or (numbers[mid - 1] < target) then\n      begin\n        Result := mid;\n        exit;\n      end;\n      right := mid - 1;\n    end\n    else if numbers[mid] < target then\n      left := mid + 1\n    else\n      right := mid - 1;\n  end;\n  \n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function that takes a string as input and returns the first character that has a repeated occurrence in the string. The function should return the character in the order of their occurrence. If no character is repeated, return -1.",
    "output": "function RepeatedCharacter(s: string): char;\nbegin\n  var seen := new HashSet<char>;\n  \n  for var i := 1 to s.Length do\n  begin\n    if seen.Contains(s[i]) then\n    begin\n      Result := s[i];\n      exit;\n    end;\n    seen.Add(s[i]);\n  end;\n  \n  Result := #0;\nend;"
  },
  {
    "instruction": "Write a function to find the number of moves required to make an array non-decreasing. A non-decreasing array is one in which the elements are either the same or increase as you move through the array. You can change any single element to any value in one move.",
    "output": "function MakeNonDecreasing(arr: array of integer): integer;\nbegin\n  var count := 0;\n  \n  for var i := 1 to arr.Length - 1 do\n  begin\n    if arr[i] < arr[i-1] then\n    begin\n      count += 1;\n      arr[i] := arr[i-1];\n    end;\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum difference between two prime numbers in a given list. The list contains positive integers only.",
    "output": "function MaxPrimeDiff(arr: array of integer): integer;\n\nfunction IsPrime(n: integer): boolean;\nbegin\n  if n <= 1 then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  for var i := 2 to Round(Sqrt(n)) do\n  begin\n    if n mod i = 0 then\n    begin\n      Result := false;\n      exit;\n    end;\n  end;\n  \n  Result := true;\nend;\n\nbegin\n  var primeNumbers := new List<integer>;\n  \n  foreach var x in arr do\n  begin\n    if IsPrime(x) then\n      primeNumbers.Add(x);\n  end;\n  \n  if primeNumbers.Count < 2 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  primeNumbers.Sort;\n  var maxDiff := primeNumbers[primeNumbers.Count - 1] - primeNumbers[0];\n  Result := maxDiff;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns a list of their square roots, rounded to 2 decimal places.",
    "output": "function SqrtRound(lst: array of integer): array of real;\nbegin\n  var res := new real[lst.Length];\n  \n  for var i := 0 to lst.Length - 1 do\n    res[i] := Round(Sqrt(lst[i]), 2);\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function that converts a list of numbers into a dictionary where the keys are the numbers from the list and the values are their squares.",
    "output": "function NumSquareDict(nums: array of integer): Dictionary<integer, integer>;\nbegin\n  var dict := new Dictionary<integer, integer>;\n  \n  foreach var num in nums do\n    dict[num] := num * num;\n  \n  Result := dict;\nend;"
  },
  {
    "instruction": "Write a function to find the two largest unique numbers in a list and return their product. If the list does not contain at least two unique numbers, return nil.",
    "output": "function ProductOfTwoLargest(numbers: array of integer): integer?;\nbegin\n  var uniqueNumbers := (new HashSet<integer>(numbers)).ToList;\n  \n  if uniqueNumbers.Count < 2 then\n  begin\n    Result := nil;\n    exit;\n  end;\n  \n  uniqueNumbers.Sort;\n  Result := uniqueNumbers[uniqueNumbers.Count - 1] * uniqueNumbers[uniqueNumbers.Count - 2];\nend;"
  },
  {
    "instruction": "Write a function to find the number of subarrays with a given range of maximum element.",
    "output": "function CountSubarraysInRange(nums: array of integer; left, right: integer): integer;\nbegin\n  var ans := 0;\n  var prev := 0;\n  var i := 0;\n  var n := nums.Length;\n  \n  for var j := 0 to n - 1 do\n  begin\n    if (nums[j] >= left) and (nums[j] <= right) then\n    begin\n      prev := j - i + 1;\n      ans += prev;\n    end\n    else if nums[j] < left then\n      ans += prev\n    else\n    begin\n      i := j + 1;\n      prev := 0;\n    end;\n  end;\n  \n  Result := ans;\nend;"
  },
  {
    "instruction": "Write a function to find the longest subarray with equal number of 0's and 1's.",
    "output": "function LongestEqualSubarray(arr: array of integer): integer;\nbegin\n  var maxLen := 0;\n  var count := 0;\n  var sumMap := new Dictionary<integer, integer>;\n  \n  for var i := 0 to arr.Length - 1 do\n  begin\n    if arr[i] = 0 then\n      count -= 1\n    else\n      count += 1;\n    \n    if count = 0 then\n      maxLen := i + 1;\n    \n    if sumMap.ContainsKey(count) then\n      maxLen := Max(maxLen, i - sumMap[count])\n    else\n      sumMap[count] := i;\n  end;\n  \n  Result := maxLen;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum value in a list of tuples based on the second element of each tuple.",
    "output": "function FindMaxInTuples(tuplesList: List<(integer, integer)>): integer;\nbegin\n  var maxVal := tuplesList[0].Item2;\n  \n  foreach var t in tuplesList do\n  begin\n    if t.Item2 > maxVal then\n      maxVal := t.Item2;\n  end;\n  \n  Result := maxVal;\nend;"
  },
  {
    "instruction": "Write a function that takes a positive integer and returns the number of positive integers less than the given number that are co-prime to it.",
    "output": "function EulerPhi(n: integer): integer;\n\nfunction Gcd(a, b: integer): integer;\nbegin\n  while b <> 0 do\n  begin\n    var temp := b;\n    b := a mod b;\n    a := temp;\n  end;\n  Result := a;\nend;\n\nbegin\n  var res := 0;\n  \n  for var i := 1 to n - 1 do\n  begin\n    if Gcd(i, n) = 1 then\n      res += 1;\n  end;\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to check if a given number is a perfect cube.",
    "output": "function CheckPerfectCube(n: integer): boolean;\nbegin\n  var root := Round(Power(n, 1/3));\n  Result := n = root * root * root;\nend;"
  },
  {
    "instruction": "Write a function to determine the minimum number of steps needed to solve a Tower of Hanoi problem with a given number of disks.",
    "output": "function Hanoi(n: integer): integer;\nbegin\n  if n = 1 then\n    Result := 1\n  else\n    Result := 2 * Hanoi(n - 1) + 1;\nend;"
  },
  {
    "instruction": "Write a function to check if a string is a palindrome, ignoring case, spaces, and punctuation.",
    "output": "function IsPalindrome(s: string): boolean;\nbegin\n  var cleaned := new StringBuilder;\n  \n  for var i := 1 to s.Length do\n  begin\n    var c := s[i];\n    if c in ['a'..'z', 'A'..'Z', '0'..'9'] then\n      cleaned.Append(c.ToLower);\n  end;\n  \n  var cleanedStr := cleaned.ToString;\n  Result := cleanedStr = new string(cleanedStr.Reverse.ToArray);\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns the count of subarrays where the median of the subarray is equal to a given integer k.",
    "output": "function CountMedianSubarrays(nums: array of integer; k: integer): integer;\nbegin\n  var n := nums.Length;\n  var delta := ArrFill(n, 0);\n  \n  for var i := 0 to n - 1 do\n  begin\n    if nums[i] > k then\n      delta[i] := 1\n    else if nums[i] < k then\n      delta[i] := -1\n    else\n      delta[i] := 0;\n  end;\n  \n  try\n    var idx := &Array.IndexOf(nums, k);\n    var l := idx;\n    var r := idx;\n    \n    var accum := new List<integer>;\n    var sum := 0;\n    for var i := 0 to n - 1 do\n    begin\n      sum += delta[i];\n      accum.Add(sum);\n    end;\n    \n    var cnt := new Dictionary<integer, integer>;\n    for var i := 0 to idx - 1 do\n    begin\n      if cnt.ContainsKey(accum[i]) then\n        cnt[accum[i]] += 1\n      else\n        cnt[accum[i]] := 1;\n    end;\n    \n    if cnt.ContainsKey(0) then\n      cnt[0] += 1\n    else\n      cnt[0] := 1;\n    \n    var res := 0;\n    for var i := idx to n - 1 do\n    begin\n      if cnt.ContainsKey(accum[i]) then\n        res += cnt[accum[i]];\n      if cnt.ContainsKey(accum[i] - 1) then\n        res += cnt[accum[i] - 1];\n    end;\n    \n    Result := res;\n  except\n    Result := 0;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to filter out the numbers from a list that are divisible by a given divisor.",
    "output": "function FilterDivisible(nums: array of integer; divisor: integer): array of integer;\nbegin\n  Result := nums.Where(x -> x mod divisor = 0).ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum spanning tree of a graph using Prim's algorithm.",
    "output": "function PrimMST(edges: array of (integer, integer, integer)): real;\nbegin\n  var vertices := edges.SelectMany(e -> [e[0], e[1]]).ToHashSet;\n  var startVertex := vertices.First;\n  var adjacentEdges := Dict(vertices.Select(v -> (v, new List<(real, integer)>)));\n  \n  foreach var edge in edges do\n  begin\n    adjacentEdges[edge[0]].Add((edge[2], edge[1]));\n    adjacentEdges[edge[1]].Add((edge[2], edge[0]));\n  end;\n  \n  var visited := new HashSet<integer>([startVertex]);\n  var edgeHeap := new List<(real, integer)>(adjacentEdges[startVertex]);\n  var totalWeight := 0.0;\n  \n  while visited.Count < vertices.Count do\n  begin\n    edgeHeap.Add((real.PositiveInfinity, 0));\n    edgeHeap.Sort((x, y) -> x[0].CompareTo(y[0]));\n    var (weight, vertex) := edgeHeap.First;\n    edgeHeap.RemoveAt(0);\n    \n    while vertex in visited do\n    begin\n      (weight, vertex) := edgeHeap.First;\n      edgeHeap.RemoveAt(0);\n    end;\n    \n    visited.Add(vertex);\n    totalWeight += weight;\n    \n    foreach var edge in adjacentEdges[vertex] do\n      edgeHeap.Add(edge);\n  end;\n  \n  Result := totalWeight;\nend;"
  },
  {
    "instruction": "Write a function to check if a given array can be divided into two subarrays of equal sum.",
    "output": "function CanSplitEqualSum(nums: array of integer): boolean;\nbegin\n  var totalSum := nums.Sum;\n  if totalSum mod 2 <> 0 then\n    Result := False\n  else\n  begin\n    var targetSum := totalSum div 2;\n    var dp := ArrFill(targetSum + 1, False);\n    dp[0] := True;\n    \n    foreach var num in nums do\n      for var i := targetSum downto num do\n        dp[i] := dp[i] or dp[i - num];\n    \n    Result := dp[targetSum];\n  end;\nend;"
  },
  {
    "instruction": "Write a function to count the number of ways to reach the top of a staircase by taking either 1 or 2 steps at a time.",
    "output": "function CountStairs(n: integer): integer;\nbegin\n  if n <= 1 then\n    Result := n\n  else\n  begin\n    var oneStepBack := 1;\n    var twoStepsBack := 0;\n    var currentStep := 0;\n    \n    for var i := 0 to n - 1 do\n    begin\n      currentStep := oneStepBack + twoStepsBack;\n      twoStepsBack := oneStepBack;\n      oneStepBack := currentStep;\n    end;\n    \n    Result := currentStep;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find out the number of occurrences of an element in a list.",
    "output": "function NumOfOccurrences(list1: array of integer; element: integer): integer;\nbegin\n  Result := list1.Count(x -> x = element);\nend;"
  },
  {
    "instruction": "Write a function that takes a string and returns the number of distinct characters in it.",
    "output": "function DistinctCharCount(s: string): integer;\nbegin\n  var charSet := new HashSet<char>;\n  foreach var ch in s do\n    charSet.Add(ch);\n  Result := charSet.Count;\nend;"
  },
  {
    "instruction": "Write a function to find the largest sum of two numbers from a list of integers. The function should take an integer N as input, which indicates the number of elements in the list, followed by N integers. The function should return the largest sum of any two numbers in the list.",
    "output": "function LargestSumOfTwoNumbers(N: integer; params numbers: array of integer): integer;\nbegin\n  var numList := numbers[:N];\n  numList.Sort;\n  Result := numList[N-1] + numList[N-2];\nend;"
  },
  {
    "instruction": "Write a function to find the third maximum number in a list. If the third maximum does not exist, return the maximum number. Note that the list may contain duplicates.",
    "output": "function ThirdMaximum(nums: array of integer): integer;\nbegin\n  var uniqueNums := nums.Distinct.ToList;\n  uniqueNums.Sort;\n  if uniqueNums.Count < 3 then\n    Result := uniqueNums.Max\n  else\n    Result := uniqueNums[uniqueNums.Count - 3];\nend;"
  },
  {
    "instruction": "Create a function that takes a list of numbers and returns the count of even numbers in the list.",
    "output": "function EvenCount(lst: array of integer): integer;\nbegin\n  var evenCount := 0;\n  foreach var num in lst do\n    if num mod 2 = 0 then\n      evenCount += 1;\n  Result := evenCount;\nend;"
  },
  {
    "instruction": "You are given a list of integers representing the scores of a game. Your task is to write a function that calculates the average score, excluding the lowest and highest score. If the list has less than three elements, return 0.",
    "output": "function CalculateAverageScore(scores: array of integer): real;\nbegin\n  if scores.Length < 3 then\n    Result := 0\n  else\n  begin\n    var sortedScores := scores.ToList;\n    sortedScores.Sort;\n    sortedScores.RemoveAt(0);\n    sortedScores.RemoveAt(sortedScores.Count - 1);\n    Result := sortedScores.Average;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the longest palindromic substring from a given string.",
    "output": "function GetLongestPalindrome(s: string): string;\nbegin\n  if s.Length = 0 then\n    Result := ''\n  else\n  begin\n    var maxLength := 1;\n    var startIndex := 0;\n    var length := s.Length;\n    \n    for var i := 1 to length - 1 do\n    begin\n      var low := i - 1;\n      var high := i;\n      while (low >= 0) and (high < length) and (s[low+1] = s[high+1]) do\n      begin\n        if (high - low + 1) > maxLength then\n        begin\n          startIndex := low;\n          maxLength := high - low + 1;\n        end;\n        low -= 1;\n        high += 1;\n      end;\n      \n      low := i - 1;\n      high := i + 1;\n      while (low >= 0) and (high < length) and (s[low+1] = s[high+1]) do\n      begin\n        if (high - low + 1) > maxLength then\n        begin\n          startIndex := low;\n          maxLength := high - low + 1;\n        end;\n        low -= 1;\n        high += 1;\n      end;\n    end;\n    \n    Result := s.Substring(startIndex, maxLength);\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the number of divisors of a given number.",
    "output": "function NumOfDivisors(n: integer): integer;\nbegin\n  var divisors := 0;\n  for var i := 1 to Round(Sqrt(n)) do\n    if n mod i = 0 then\n      if i * i = n then\n        divisors += 1\n      else\n        divisors += 2;\n  Result := divisors;\nend;"
  },
  {
    "instruction": "Write a function to find the number of items that can be bought with a given budget. The function takes a list of item prices and a budget as arguments. The function should return the maximum number of items that can be bought without exceeding the budget.",
    "output": "function MaxItems(prices: array of integer; budget: integer): integer;\nbegin\n  var sortedPrices := prices.ToList;\n  sortedPrices.Sort;\n  var total := 0;\n  for var i := 0 to sortedPrices.Count - 1 do\n  begin\n    total += sortedPrices[i];\n    if total > budget then\n    begin\n      Result := i;\n      exit;\n    end;\n  end;\n  Result := sortedPrices.Count;\nend;"
  },
  {
    "instruction": "Write a function to generate a list of prime numbers in a given range.",
    "output": "function IsPrime(n: integer): boolean;\nbegin\n  if n <= 1 then\n    Result := False\n  else if n = 2 then\n    Result := True\n  else if n mod 2 = 0 then\n    Result := False\n  else\n  begin\n    var i := 3;\n    while i * i <= n do\n    begin\n      if n mod i = 0 then\n      begin\n        Result := False;\n        exit;\n      end;\n      i += 2;\n    end;\n    Result := True;\n  end;\nend;\n\nfunction PrimesInRange(startVal, endVal: integer): array of integer;\nbegin\n  Result := Range(startVal, endVal).Where(n -> IsPrime(n)).ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of deletions required to make a string palindrome.",
    "output": "function MinimumDeletions(s: string): integer;\nbegin\n  var n := s.Length;\n  var dp := new integer[n+1, n+1];\n  \n  for var i := 0 to n - 1 do\n    for var j := 0 to n - 1 do\n      if s[i+1] = s[n - j] then\n        dp[i+1, j+1] := dp[i, j] + 1\n      else\n        dp[i+1, j+1] := Max(dp[i, j+1], dp[i+1, j]);\n  \n  Result := n - dp[n, n];\nend;"
  },
  {
    "instruction": "Write a function that takes a string and a set of characters as input and removes all characters in the string that appear in the set. Then, determine if the resulting string is a palindrome.",
    "output": "function RemoveAndCheckPalindrome(s: string; charsToRemove: HashSet<char>): boolean;\nbegin\n  var filteredS := '';\n  foreach var ch in s do\n    if not charsToRemove.Contains(ch) then\n      filteredS += ch;\n  \n  var lowerFiltered := filteredS.ToLower;\n  Result := lowerFiltered = ReverseString(lowerFiltered);\nend;"
  },
  {
    "instruction": "Write a function to find the unpaired element in an array of odd length where each element has a pair except one.",
    "output": "function FindUnpaired(A: array of integer): integer;\nbegin\n  var countDict := new Dictionary<integer, integer>;\n  \n  for var i := 0 to A.Length - 1 do\n    if countDict.ContainsKey(A[i]) then\n      countDict[A[i]] += 1\n    else\n      countDict.Add(A[i], 1);\n  \n  foreach var pair in countDict do\n    if pair.Value mod 2 <> 0 then\n    begin\n      Result := pair.Key;\n      exit;\n    end;\n  \n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to find the number of satisfied children given a list of children's greed factors and a list of cookie sizes. A child is satisfied if the cookie size is greater than or equal to their greed factor.",
    "output": "function FindContentChildren(g, s: array of integer): integer;\nbegin\n  var greedList := g.ToList;\n  var sizeList := s.ToList;\n  greedList.Sort;\n  sizeList.Sort;\n  \n  var res := 0;\n  var i := 0;\n  while (i < greedList.Count) and (res < sizeList.Count) do\n  begin\n    if greedList[i] <= sizeList[res] then\n      i += 1;\n    res += 1;\n  end;\n  Result := i;\nend;"
  },
  {
    "instruction": "Write a function to generate all possible k-length combinations of a given list of elements.",
    "output": "procedure GenerateCombinations(lst: array of integer; k: integer; start: integer; current: List<integer>; var result: List<List<integer>>);\nbegin\n  if current.Count = k then\n  begin\n    result.Add(new List<integer>(current));\n    exit;\n  end;\n  \n  for var i := start to lst.Length - 1 do\n  begin\n    current.Add(lst[i]);\n    GenerateCombinations(lst, k, i + 1, current, result);\n    current.RemoveAt(current.Count - 1);\n  end;\nend;\n\nfunction KCombinations(lst: array of integer; k: integer): List<List<integer>>;\nbegin\n  Result := new List<List<integer>>;\n  GenerateCombinations(lst, k, 0, new List<integer>, Result);\nend;"
  },
  {
    "instruction": "Write a function to find the smallest number that can be formed with the given non-negative digits.",
    "output": "function FindSmallestNum(arr: array of integer; n: integer): integer;\nbegin\n  var sortedArr := arr.ToList;\n  sortedArr.Sort;\n  var num := sortedArr[0];\n  for var i := 1 to n - 1 do\n    num := num * 10 + sortedArr[i];\n  Result := num;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of squares of first n natural numbers.",
    "output": "function FindSumOfSquare(n: integer): integer;\nbegin\n  var sum := 0;\n  for var i := 1 to n do\n    sum += i * i;\n  Result := sum;\nend;"
  },
  {
    "instruction": "Write a function to split a list into n approximately equal parts. If the list cannot be divided equally, the last parts may have fewer elements.",
    "output": "function SplitListIntoNParts(lst: array of integer; n: integer): List<List<integer>>;\nbegin\n  var length := lst.Length;\n  var partSize := length div n;\n  var remainder := length mod n;\n  Result := new List<List<integer>>;\n  var start := 0;\n  \n  for var i := 0 to n - 1 do\n  begin\n    var endIndex := start + partSize + (if i < remainder then 1 else 0);\n    var part := new List<integer>;\n    for var j := start to endIndex - 1 do\n      part.Add(lst[j]);\n    Result.Add(part);\n    start := endIndex;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to check if there exists a subarray with sum as a multiple of k.",
    "output": "function CheckSubarray(nums: array of integer; k: integer): boolean;\nbegin\n  var n := nums.Length;\n  var prefixSum := new integer[n + 1];\n  var remainderSet := new Dictionary<integer, integer>;\n  remainderSet.Add(0, -1);\n  \n  for var i := 1 to n do\n  begin\n    prefixSum[i] := prefixSum[i - 1] + nums[i - 1];\n    var remainder := prefixSum[i] mod k;\n    \n    if remainderSet.ContainsKey(remainder) then\n    begin\n      if i - remainderSet[remainder] > 1 then\n      begin\n        Result := True;\n        exit;\n      end;\n    end\n    else\n      remainderSet.Add(remainder, i);\n  end;\n  \n  Result := False;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the smallest subarray with a given sum.",
    "output": "function SmallestSubWithGivenSum(arr: array of integer; targetSum: integer): integer;\nbegin\n  var windowSum := 0;\n  var minLength := integer.MaxValue;\n  var windowStart := 0;\n  \n  for var windowEnd := 0 to arr.Length - 1 do\n  begin\n    windowSum += arr[windowEnd];\n    \n    while windowSum >= targetSum do\n    begin\n      minLength := Min(minLength, windowEnd - windowStart + 1);\n      windowSum -= arr[windowStart];\n      windowStart += 1;\n    end;\n  end;\n  \n  if minLength <> integer.MaxValue then\n    Result := minLength\n  else\n    Result := 0;\nend;"
  },
  {
    "instruction": "Write a function that takes a target integer and returns all pairs of consecutive integers that sum up to the target. The function should return a list of lists, where each inner list contains a pair of consecutive integers.",
    "output": "function FindConsecutivePairs(target: integer): List<List<integer>>;\nbegin\n  Result := new List<List<integer>>;\n  for var i := 1 to target - 1 do\n    if (target - i) = i + 1 then\n    begin\n      Result.Add(new List<integer>([i, i + 1]));\n      break;\n    end;\nend;"
  },
  {
    "instruction": "Write a function to find the deepest node in a binary tree using BFS (Breadth-First Search).",
    "output": "type\n  TreeNode = class\n    val: integer;\n    left, right: TreeNode;\n    \n    constructor Create(v: integer; l: TreeNode := nil; r: TreeNode := nil);\n    begin\n      val := v;\n      left := l;\n      right := r;\n    end;\n  end;\n\nfunction FindDeepestNode(root: TreeNode): integer;\nbegin\n  if root = nil then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var queue := new Queue<TreeNode>;\n  queue.Enqueue(root);\n  var node := root;\n  \n  while queue.Count > 0 do\n  begin\n    node := queue.Dequeue;\n    \n    if node.left <> nil then\n      queue.Enqueue(node.left);\n    if node.right <> nil then\n      queue.Enqueue(node.right);\n  end;\n  \n  Result := node.val;\nend;"
  },
  {
    "instruction": "Write a function to check if three sides can form a valid triangle.",
    "output": "function CheckTriangle(A: array of integer): integer;\nbegin\n  var n := A.Length;\n  if n < 3 then\n    Result := 0\n  else\n  begin\n    var sortedA := A.ToList;\n    sortedA.Sort;\n    for var i := 0 to n - 3 do\n      if sortedA[i] + sortedA[i+1] > sortedA[i+2] then\n      begin\n        Result := 1;\n        exit;\n      end;\n    Result := 0;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to generate all possible combinations of 0s and 1s of a given length, n.",
    "output": "procedure BacktrackBinary(n: integer; combination: List<integer>; var result: List<List<integer>>);\nbegin\n  if combination.Count = n then\n  begin\n    result.Add(new List<integer>(combination));\n    exit;\n  end;\n  \n  for var i := 0 to 1 do\n  begin\n    combination.Add(i);\n    BacktrackBinary(n, combination, result);\n    combination.RemoveAt(combination.Count - 1);\n  end;\nend;\n\nfunction GenerateBinary(n: integer): List<List<integer>>;\nbegin\n  Result := new List<List<integer>>;\n  BacktrackBinary(n, new List<integer>, Result);\nend;"
  },
  {
    "instruction": "Write a function to find the smallest repeating cycle in a given string.",
    "output": "function FindCycle(s: string): integer;\nbegin\n  if s.Length < 2 then\n    Result := -1\n  else\n  begin\n    for var i := 1 to s.Length div 2 do\n      if s.Length mod i = 0 then\n        if s.Substring(0, i) * (s.Length div i) = s then\n        begin\n          Result := s.Length div i;\n          exit;\n        end;\n    Result := -1;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the common prefix between two strings.",
    "output": "function CommonPrefix(str1, str2: string): string;\nbegin\n  var index := 0;\n  Result := '';\n  while (index < str1.Length) and (index < str2.Length) do\n  begin\n    if str1[index+1] <> str2[index+1] then\n      break;\n    Result += str1[index+1];\n    index += 1;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum product of two integers in an array.",
    "output": "function MaxProductTwoIntegers(nums: array of integer): integer;\nbegin\n  var sortedNums := nums.ToList;\n  sortedNums.Sort;\n  Result := Max(sortedNums[0] * sortedNums[1], sortedNums[sortedNums.Count-1] * sortedNums[sortedNums.Count-2]);\nend;"
  },
  {
    "instruction": "Write a function to return the number of ways to tile a 2xn rectangle with 2x1 tiles.",
    "output": "function TilingWays(n: integer): integer;\nbegin\n  if n = 1 then\n    Result := 1\n  else if n = 2 then\n    Result := 2\n  else\n  begin\n    var ways := new integer[n+1];\n    ways[1] := 1;\n    ways[2] := 2;\n    for var i := 3 to n do\n      ways[i] := ways[i-1] + ways[i-2];\n    Result := ways[n];\n  end;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of numbers as input and returns a new list where each number is replaced by its cube if it is positive, its square if it is negative, and zero if it is zero.",
    "output": "function CubeSquare(numbers: array of integer): array of integer;\nbegin\n  Result := new integer[numbers.Length];\n  for var i := 0 to numbers.Length - 1 do\n  begin\n    var num := numbers[i];\n    if num > 0 then\n      Result[i] := num * num * num\n    else if num < 0 then\n      Result[i] := num * num\n    else\n      Result[i] := 0;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the k-th smallest element in two sorted arrays.",
    "output": "function FindKthSmallestElement(arr1, arr2: array of integer; k: integer): integer;\nbegin\n  var i := 0;\n  var j := 0;\n  var count := 0;\n  var smallest := 0;\n  \n  while (i < arr1.Length) and (j < arr2.Length) do\n  begin\n    if arr1[i] < arr2[j] then\n    begin\n      smallest := arr1[i];\n      i += 1;\n    end\n    else\n    begin\n      smallest := arr2[j];\n      j += 1;\n    end;\n    count += 1;\n    if count = k then\n    begin\n      Result := smallest;\n      exit;\n    end;\n  end;\n  \n  while i < arr1.Length do\n  begin\n    smallest := arr1[i];\n    i += 1;\n    count += 1;\n    if count = k then\n    begin\n      Result := smallest;\n      exit;\n    end;\n  end;\n  \n  while j < arr2.Length do\n  begin\n    smallest := arr2[j];\n    j += 1;\n    count += 1;\n    if count = k then\n    begin\n      Result := smallest;\n      exit;\n    end;\n  end;\n  \n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to determine if two rectangles overlap. The rectangles are represented as tuples containing their top-left and bottom-right coordinates.",
    "output": "function DoRectanglesOverlap(rect1, rect2: (integer, integer, integer, integer)): boolean;\nbegin\n  var (x1, y1, x2, y2) := rect1;\n  var (x3, y3, x4, y4) := rect2;\n  \n  if (x3 > x2) or (x1 > x4) or (y3 > y2) or (y1 > y4) then\n    Result := False\n  else\n    Result := True;\nend;"
  },
  {
    "instruction": "Write a function to rotate a list of elements by a given number of steps to the right.",
    "output": "function RotateRight(lst: array of integer; steps: integer): array of integer;\nbegin\n  if (lst.Length = 0) or (steps mod lst.Length = 0) then\n    Result := lst\n  else\n  begin\n    var actualSteps := steps mod lst.Length;\n    var rotated := lst[lst.Length - actualSteps:] + lst[:lst.Length - actualSteps];\n    Result := rotated;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to calculate the total score of a game using a list of operations. The operations can be: An integer: Add an integer to the stack. \"C\": Remove the last integer from the stack. \"D\": Add 2 times the last integer in the stack to the stack. \"+\": Add the last two integers in the stack and add the result to the stack.",
    "output": "function CalculateGameScore(ops: array of string): integer;\nbegin\n  var ans := new List<integer>;\n  var total := 0;\n  \n  foreach var item in ops do\n  begin\n    if item = '+' then\n    begin\n      var sumVal := ans[ans.Count-1] + ans[ans.Count-2];\n      total += sumVal;\n      ans.Add(sumVal);\n    end\n    else if item = 'C' then\n    begin\n      total -= ans[ans.Count-1];\n      ans.RemoveAt(ans.Count-1);\n    end\n    else if item = 'D' then\n    begin\n      var doubleVal := ans[ans.Count-1] * 2;\n      total += doubleVal;\n      ans.Add(doubleVal);\n    end\n    else\n    begin\n      var num := StrToInt(item);\n      ans.Add(num);\n      total += num;\n    end;\n  end;\n  \n  Result := total;\nend;"
  },
  {
    "instruction": "Write a function to find the longest consecutive sequence in an unsorted array of integers.",
    "output": "function LongestConsecutiveSequence(nums: array of integer): integer;\nbegin\n  if nums.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var numSet := new HashSet<integer>(nums);\n  var longestStreak := 0;\n  \n  foreach var num in numSet do\n  begin\n    if not numSet.Contains(num - 1) then\n    begin\n      var currentNum := num;\n      var currentStreak := 1;\n      \n      while numSet.Contains(currentNum + 1) do\n      begin\n        currentNum += 1;\n        currentStreak += 1;\n      end;\n      \n      longestStreak := Max(longestStreak, currentStreak);\n    end;\n  end;\n  \n  Result := longestStreak;\nend;"
  },
  {
    "instruction": "Write a function to find the diameter of a binary tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree.",
    "output": "type\n  TreeNode = class\n    val: integer;\n    left, right: TreeNode;\n    \n    constructor Create(v: integer; l: TreeNode := nil; r: TreeNode := nil);\n    begin\n      val := v;\n      left := l;\n      right := r;\n    end;\n  end;\n\nfunction DiameterOfBinaryTree(root: TreeNode): integer;\n\n  function Depth(node: TreeNode; var maxDiameter: integer): integer;\n  begin\n    if node = nil then\n      Result := 0\n    else\n    begin\n      var left := Depth(node.left, maxDiameter);\n      var right := Depth(node.right, maxDiameter);\n      maxDiameter := Max(maxDiameter, left + right);\n      Result := 1 + Max(left, right);\n    end;\n  end;\n\nbegin\n  var maxDiam := -1;\n  Depth(root, maxDiam);\n  Result := maxDiam;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum length of a substring without repeating characters in a given string.",
    "output": "function NoRepeatSubstr(s: string): integer;\nbegin\n  var maxLength := 0;\n  var startIndex := 0;\n  var seenChars := new Dictionary<char, integer>;\n  \n  for var endIndex := 1 to s.Length do\n  begin\n    var ch := s[endIndex];\n    if seenChars.ContainsKey(ch) and (startIndex <= seenChars[ch]) then\n      startIndex := seenChars[ch] + 1\n    else\n      maxLength := Max(maxLength, endIndex - startIndex + 1);\n    \n    seenChars[ch] := endIndex;\n  end;\n  \n  Result := maxLength;\nend;"
  },
  {
    "instruction": "Write a function to find the most common words in a list of strings.",
    "output": "function FindCommonWords(words: array of string): array of string;\nbegin\n  var counts := new Dictionary<string, integer>;\n  \n  foreach var word in words do\n    if counts.ContainsKey(word) then\n      counts[word] += 1\n    else\n      counts.Add(word, 1);\n  \n  var maxCount := counts.Values.Max;\n  Result := counts.Where(pair -> pair.Value = maxCount).Select(pair -> pair.Key).ToArray;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings and returns the list sorted in reverse lexicographical order (Z-A).",
    "output": "function SortReverseLex(strings: array of string): array of string;\nbegin\n  var sortedList := strings.ToList;\n  sortedList.Sort;\n  sortedList.Reverse;\n  Result := sortedList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to decompress a run-length encoded string. The run-length encoding works like this: for each group of characters in the string, the first character is the number of times the following characters are repeated.",
    "output": "function Decompress(s: string): string;\nbegin\n  var stack := new Stack<object>;\n  var currString := '';\n  var currNum := 0;\n  \n  foreach var ch in s do\n  begin\n    if ch.IsDigit then\n      currNum := currNum * 10 + StrToInt(ch)\n    else if ch = '[' then\n    begin\n      stack.Push(currString);\n      stack.Push(currNum);\n      currString := '';\n      currNum := 0;\n    end\n    else if ch = ']' then\n    begin\n      var num := integer(stack.Pop);\n      var prevString := string(stack.Pop);\n      currString := prevString + currString * num;\n    end\n    else\n      currString += ch;\n  end;\n  \n  Result := currString;\nend;"
  },
  {
    "instruction": "Write a function to find the next largest number that has the same set of digits as the given number.",
    "output": "function NextLargerNumber(n: integer): integer;\nbegin\n  var numStr := n.ToString;\n  var length := numStr.Length;\n  var i := length - 2;\n  \n  while i >= 0 do\n  begin\n    if numStr[i+1] < numStr[i+2] then\n      break;\n    i -= 1;\n  end;\n  \n  if i = -1 then\n  begin\n    Result := -1;\n    exit;\n  end;\n  \n  var j := length - 1;\n  while j >= 0 do\n  begin\n    if numStr[j+1] > numStr[i+1] then\n      break;\n    j -= 1;\n  end;\n  \n  var numList := numStr.ToCharArray.ToList;\n  var temp := numList[i];\n  numList[i] := numList[j];\n  numList[j] := temp;\n  \n  var rest := numList.GetRange(i + 1, length - i - 1);\n  rest.Sort;\n  numList.RemoveRange(i + 1, length - i - 1);\n  numList.AddRange(rest);\n  \n  Result := StrToInt(string.Join('', numList));\nend;"
  },
  {
    "instruction": "Write a function to find the number complement of a given non-negative number. The number complement of a number is the result obtained by flipping all the bits in the number's binary representation.",
    "output": "function NumberComplement(num: integer): integer;\nbegin\n  var mask := 1;\n  while mask <= num do\n    mask := mask shl 1;\n  \n  if mask > 0 then\n    mask := mask - 1;\n  \n  Result := not num and mask;\nend;"
  },
  {
    "instruction": "Write a function to check if a given list of lists is a valid matrix. A valid matrix is a list of lists where each inner list has the same length.",
    "output": "function IsValidMatrix(matrix: array of array of integer): boolean;\nbegin\n  if matrix.Length = 0 then\n  begin\n    Result := True;\n    exit;\n  end;\n  \n  var rowLength := matrix[0].Length;\n  foreach var row in matrix do\n    if row.Length <> rowLength then\n    begin\n      Result := False;\n      exit;\n    end;\n  \n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum pairwise product from a list of non-negative integers.",
    "output": "function MaxPairwiseProduct(nums: array of integer): integer;\nbegin\n  var sortedNums := nums.ToList;\n  sortedNums.Sort;\n  Result := sortedNums[sortedNums.Count-1] * sortedNums[sortedNums.Count-2];\nend;"
  },
  {
    "instruction": "Write a function to find the Longest Common Subsequence (LCS) between two given sequences.",
    "output": "function LongestCommonSubsequence(X, Y: string): integer;\nbegin\n  var m := X.Length;\n  var n := Y.Length;\n  var L := new integer[m+1, n+1];\n  \n  for var i := 0 to m do\n    for var j := 0 to n do\n      if (i = 0) or (j = 0) then\n        L[i,j] := 0\n      else if X[i] = Y[j] then\n        L[i,j] := L[i-1,j-1] + 1\n      else\n        L[i,j] := Max(L[i-1,j], L[i,j-1]);\n  \n  Result := L[m,n];\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns a new list with only the odd numbers from the given list.",
    "output": "function ExtractOddNumbers(numbers: array of integer): array of integer;\nbegin\n  Result := numbers.Where(x -> x mod 2 <> 0).ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum area of water that can be contained by two lines in a histogram.",
    "output": "function MaxWaterArea(height: array of integer): integer;\nbegin\n  var left := 0;\n  var right := height.Length - 1;\n  var maxArea := 0;\n  \n  while left < right do\n  begin\n    var width := right - left;\n    if height[left] <= height[right] then\n    begin\n      maxArea := Max(maxArea, height[left] * width);\n      left += 1;\n    end\n    else\n    begin\n      maxArea := Max(maxArea, height[right] * width);\n      right -= 1;\n    end;\n  end;\n  \n  Result := maxArea;\nend;"
  },
  {
    "instruction": "Write a function to find the number of possible ways to write a given number as the sum of 1, 3, and 4.",
    "output": "function FindSumWays(n: integer): integer;\nbegin\n  if (n = 1) or (n = 2) then\n    Result := 1\n  else if n = 3 then\n    Result := 2\n  else\n  begin\n    var dp := new integer[n+1];\n    dp[1] := 1;\n    dp[2] := 1;\n    dp[3] := 2;\n    for var i := 4 to n do\n      dp[i] := dp[i-1] + dp[i-3] + dp[i-4];\n    Result := dp[n];\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the number of steps required to make two strings equal by performing the operation of inserting a character or deleting a character.",
    "output": "function OperationsToEqual(str1, str2: string): integer;\nbegin\n  var m := str1.Length;\n  var n := str2.Length;\n  var dp := new integer[m+1, n+1];\n  \n  for var i := 0 to m do\n    for var j := 0 to n do\n      if (i = 0) or (j = 0) then\n        dp[i,j] := i + j\n      else if str1[i] = str2[j] then\n        dp[i,j] := dp[i-1,j-1]\n      else\n        dp[i,j] := 1 + Min(dp[i,j-1], dp[i-1,j]);\n  \n  Result := dp[m,n];\nend;"
  },
  {
    "instruction": "Write a function to check if a binary tree is valid based on its preorder serialization.",
    "output": "function CheckBinaryTree(preorder: string): boolean;\nbegin\n  var nodes := preorder.Split(',').ToList;\n  if nodes[0] = '#' then\n  begin\n    if nodes.Count = 1 then\n      Result := True\n    else\n      Result := False;\n    exit;\n  end;\n  \n  var stack := new Stack<integer>;\n  for var i := 0 to nodes.Count - 1 do\n  begin\n    var ch := nodes[i];\n    if ch = '#' then\n    begin\n      if stack.Count = 0 then\n      begin\n        Result := False;\n        exit;\n      end;\n      stack.Push(stack.Pop - 1);\n      while (stack.Count > 0) and (stack.Peek <= 0) do\n      begin\n        stack.Pop;\n        if stack.Count > 0 then\n          stack.Push(stack.Pop - 1);\n      end;\n    end\n    else\n    begin\n      if (i <> 0) and (stack.Count = 0) then\n      begin\n        Result := False;\n        exit;\n      end;\n      stack.Push(2);\n    end;\n  end;\n  \n  Result := stack.Count = 0;\nend;"
  },
  {
    "instruction": "Write a function to convert a decimal number to its ternary (base 3) representation.",
    "output": "function DecimalToTernary(n: integer): integer;\nbegin\n  var res := '';\n  var num := n;\n  while num > 0 do\n  begin\n    res := (num mod 3).ToString + res;\n    num := num div 3;\n  end;\n  Result := StrToInt(res);\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns the integer that appears an odd number of times. There will always be only one integer that appears an odd number of times.",
    "output": "function OddInteger(seq: array of integer): integer;\nbegin\n  var counts := new Dictionary<integer, integer>;\n  foreach var num in seq do\n    if counts.ContainsKey(num) then\n      counts[num] += 1\n    else\n      counts.Add(num, 1);\n  \n  foreach var pair in counts do\n    if pair.Value mod 2 <> 0 then\n    begin\n      Result := pair.Key;\n      exit;\n    end;\n  \n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to find the number of balanced binary trees possible with a given height.",
    "output": "function BalancedBinaryTrees(n: integer): integer;\nbegin\n  if (n = 0) or (n = 1) then\n    Result := 1\n  else\n  begin\n    var C := new integer[n+1];\n    C[0] := 1;\n    C[1] := 1;\n    \n    for var i := 2 to n do\n    begin\n      C[i] := 0;\n      for var j := 0 to i - 1 do\n        C[i] := C[i] + C[j] * C[i-j-1];\n    end;\n    \n    Result := C[n];\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of non-overlapping subarrays with sum less than or equal to k.",
    "output": "function MaxSubarrays(nums: array of integer; k: integer): integer;\nbegin\n  var n := nums.Length;\n  var prefixSum := new integer[n + 1];\n  for var i := 0 to n - 1 do\n    prefixSum[i + 1] := prefixSum[i] + nums[i];\n  \n  var maxCount := 0;\n  var start := 0;\n  for var endIndex := 0 to n do\n  begin\n    while prefixSum[endIndex] - prefixSum[start] > k do\n      start += 1;\n    maxCount := Max(maxCount, endIndex - start);\n  end;\n  \n  Result := maxCount;\nend;"
  },
  {
    "instruction": "Write a function to find the most frequent number in an array.",
    "output": "function FrequentNum(arr: array of integer): integer;\nbegin\n  var numCounts := new Dictionary<integer, integer>;\n  foreach var num in arr do\n    if numCounts.ContainsKey(num) then\n      numCounts[num] += 1\n    else\n      numCounts.Add(num, 1);\n  \n  var maxCount := numCounts.Values.Max;\n  Result := numCounts.First(pair -> pair.Value = maxCount).Key;\nend;"
  },
  {
    "instruction": "Write a function to find the Longest Palindromic Subsequence (LPS) in a given string.",
    "output": "function LongestPalindromeSubsequence(s: string): integer;\nbegin\n  var n := s.Length;\n  var dp := new integer[n, n];\n  \n  for var i := n - 1 downto 0 do\n  begin\n    dp[i,i] := 1;\n    for var j := i + 1 to n - 1 do\n      if s[i+1] = s[j+1] then\n        dp[i,j] := dp[i+1,j-1] + 2\n      else\n        dp[i,j] := Max(dp[i+1,j], dp[i,j-1]);\n  end;\n  \n  Result := dp[0,n-1];\nend;"
  },
  {
    "instruction": "Write a function to check whether a number is a happy number or not.",
    "output": "function HappyNumber(n: integer): boolean;\n\n  function GetNext(number: integer): integer;\n  begin\n    var totalSum := 0;\n    var num := number;\n    while num > 0 do\n    begin\n      var digit := num mod 10;\n      totalSum += digit * digit;\n      num := num div 10;\n    end;\n    Result := totalSum;\n  end;\n\nbegin\n  var seen := new HashSet<integer>;\n  var current := n;\n  while (current <> 1) and (not seen.Contains(current)) do\n  begin\n    seen.Add(current);\n    current := GetNext(current);\n  end;\n  Result := current = 1;\nend;"
  },
  {
    "instruction": "Write a function to determine if a given string can be rearranged into a valid palindrome.",
    "output": "function CanBePalindrome(s: string): boolean;\nbegin\n  var letterCount := new Dictionary<char, integer>;\n  foreach var letter in s do\n    if char.IsLetterOrDigit(letter) then\n    begin\n      var lowerLetter := letter.ToLower;\n      if letterCount.ContainsKey(lowerLetter) then\n        letterCount[lowerLetter] += 1\n      else\n        letterCount.Add(lowerLetter, 1);\n    end;\n  \n  var oddCount := 0;\n  foreach var count in letterCount.Values do\n    if count mod 2 <> 0 then\n      oddCount += 1;\n  \n  Result := oddCount <= 1;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of the largest contiguous subarray within a one-dimensional array of numbers.",
    "output": "function SumOfLargestSubarray(nums: array of integer): integer;\nbegin\n  var maxCurrent := nums[0];\n  var maxGlobal := nums[0];\n  \n  for var i := 1 to nums.Length - 1 do\n  begin\n    maxCurrent := Max(nums[i], maxCurrent + nums[i]);\n    if maxCurrent > maxGlobal then\n      maxGlobal := maxCurrent;\n  end;\n  \n  Result := maxGlobal;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum profit from buying and selling stocks given a list of prices where the index represents the day. The function should allow for a maximum of two transactions.",
    "output": "function BuyAndSellTwoAtMost(prices: array of integer): integer;\nbegin\n  if (prices.Length = 0) or (prices.Length < 2) then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var dp := new integer[prices.Length, 4];\n  dp[0,0] := 0;\n  dp[0,1] := -prices[0];\n  dp[0,2] := 0;\n  dp[0,3] := -prices[0];\n  \n  for var i := 1 to prices.Length - 1 do\n  begin\n    dp[i,0] := dp[i-1,0];\n    dp[i,1] := Max(dp[i-1,1], dp[i-1,0] - prices[i]);\n    dp[i,2] := Max(dp[i-1,2], dp[i-1,1] + prices[i]);\n    dp[i,3] := Max(dp[i-1,3], dp[i-1,2] - prices[i]);\n  end;\n  \n  Result := Max(dp[prices.Length-1,2], dp[prices.Length-1,3] + prices[prices.Length-1]);\nend;"
  },
  {
    "instruction": "Write a function to determine if a given string can be rearranged so that no two adjacent characters are the same.",
    "output": "function IsRearrangeable(s: string): boolean;\nbegin\n  var cnt := new Dictionary<char, integer>;\n  foreach var ch in s do\n    if cnt.ContainsKey(ch) then\n      cnt[ch] += 1\n    else\n      cnt.Add(ch, 1);\n  \n  var maxCount := cnt.Values.Max;\n  \n  if (s.Length mod 2 = 1) and (maxCount > s.Length div 2 + 1) then\n    Result := False\n  else if (s.Length mod 2 = 0) and (maxCount > s.Length div 2) then\n    Result := False\n  else\n    Result := True;\nend;"
  },
  {
    "instruction": "Write a function to convert a number from decimal system to a base-3 system. Note that in base-3 system, the numbers can only be 0, 1, or 2. But in this case, instead of 0, 1, and 2, we will use '1', '2', and '4' respectively.",
    "output": "function DecToBase3(n: integer): string;\nbegin\n  if n = 0 then\n    Result := ''\n  else if n mod 3 = 0 then\n    Result := DecToBase3(n div 3 - 1) + '4'\n  else if n mod 3 = 1 then\n    Result := DecToBase3(n div 3) + '1'\n  else\n    Result := DecToBase3(n div 3) + '2';\nend;"
  },
  {
    "instruction": "Write a function to find the most frequent number in the given list. If there is a tie for the most frequent number, return the smallest number.",
    "output": "function MostFrequentNumber(numbers: array of integer): integer;\nbegin\n  var counts := new Dictionary<integer, integer>;\n  foreach var num in numbers do\n    if counts.ContainsKey(num) then\n      counts[num] += 1\n    else\n      counts.Add(num, 1);\n  \n  var maxFreq := counts.Values.Max;\n  Result := counts.Where(pair -> pair.Value = maxFreq).Min(pair -> pair.Key);\nend;"
  },
  {
    "instruction": "Write a function to calculate the number of combinations that sum up to a target value given a list of unique integers.",
    "output": "function CombinationSum4(nums: array of integer; target: integer): integer;\nbegin\n  var dp := new integer[target + 1];\n  dp[0] := 1;\n  for var j := 1 to target do\n    foreach var v in nums do\n      if j >= v then\n        dp[j] += dp[j - v];\n  Result := dp[target];\nend;"
  },
  {
    "instruction": "Write a function that takes a string as input and returns a new string where each letter is replaced by its corresponding position in the alphabet. If the character is uppercase, the position should be in uppercase too, otherwise in lowercase.",
    "output": "function LetterToPosition(s: string): string;\nbegin\n  var res := '';\n  foreach var ch in s do\n  begin\n    if char.IsLetter(ch) then\n    begin\n      var position := Ord(ch.ToLower) - Ord('a') + 1;\n      if ch.IsUpper then\n        res += position.ToString.ToUpper\n      else\n        res += position.ToString;\n    end\n    else\n      res += ch;\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the number of prime numbers less than a given number.",
    "output": "function CountPrimeNumbers(n: integer): integer;\n\n  function IsPrime(num: integer): boolean;\n  begin\n    if num <= 1 then\n      Result := False\n    else if num = 2 then\n      Result := True\n    else if num mod 2 = 0 then\n      Result := False\n    else\n    begin\n      var i := 3;\n      while i * i <= num do\n      begin\n        if num mod i = 0 then\n        begin\n          Result := False;\n          exit;\n        end;\n        i += 2;\n      end;\n      Result := True;\n    end;\n  end;\n\nbegin\n  var count := 0;\n  for var num := 2 to n - 1 do\n    if IsPrime(num) then\n      count += 1;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the minimal length of a contiguous subarray of which the sum is greater than or equal to a given number. If there isn't one, return 0 instead.",
    "output": "function MinSubArrayLength(nums: array of integer; target: integer): integer;\nbegin\n  var n := nums.Length;\n  var minLen := n + 1;\n  var left := 0;\n  var currentSum := 0;\n  \n  for var right := 0 to n - 1 do\n  begin\n    currentSum += nums[right];\n    while currentSum >= target do\n    begin\n      minLen := Min(minLen, right - left + 1);\n      currentSum -= nums[left];\n      left += 1;\n    end;\n  end;\n  \n  if minLen <= n then\n    Result := minLen\n  else\n    Result := 0;\nend;"
  },
  {
    "instruction": "Design a function to calculate the largest product of a contiguous subarray within a list of integers.",
    "output": "function MaxSubArrayProduct(nums: array of integer): integer;\nbegin\n  if nums.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var maxProduct := nums[0];\n  var minProduct := nums[0];\n  var resultVal := maxProduct;\n  \n  for var i := 1 to nums.Length - 1 do\n  begin\n    var temp := maxProduct;\n    maxProduct := Max(nums[i], Max(maxProduct * nums[i], minProduct * nums[i]));\n    minProduct := Min(nums[i], Min(temp * nums[i], minProduct * nums[i]));\n    resultVal := Max(resultVal, maxProduct);\n  end;\n  \n  Result := resultVal;\nend;"
  },
  {
    "instruction": "Write a function to check if a given number can be expressed as the sum of three consecutive integers.",
    "output": "function CanBeSumOfThreeConsecutive(num: integer): boolean;\nbegin\n  var a := (num - 3) / 3;\n  if a = Trunc(a) then\n    Result := True\n  else\n    Result := False;\nend;"
  },
  {
    "instruction": "Write a function to convert a given string to Pig Latin. In Pig Latin, words start with consonants are moved by one position to the end of the word and followed by \"ay\". If the word starts with a vowel, it just appends \"way\" at the end.",
    "output": "function ConvertToPigLatin(word: string): string;\nbegin\n  var vowels := 'aeiou';\n  if word[1].ToLower in vowels then\n    Result := word + 'way'\n  else\n    Result := word.Substring(1) + word[1] + 'ay';\nend;"
  },
  {
    "instruction": "Write a function to find the number of times a given pattern is found in a string. The pattern can overlap.",
    "output": "function CountPatternOverlap(text, pattern: string): integer;\nbegin\n  if pattern.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var count := 0;\n  var start := 0;\n  var pos := text.IndexOf(pattern, start);\n  \n  while pos <> -1 do\n  begin\n    count += 1;\n    start := pos + 1;\n    pos := text.IndexOf(pattern, start);\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns the integer that appears an odd number of times.",
    "output": "function FindOddOccurrence(arr: array of integer): integer;\nbegin\n  var res := 0;\n  foreach var i in arr do\n    res := res xor i;\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the number of occurrences of a specific digit in a number.",
    "output": "function DigitFrequency(number, digit: integer): integer;\nbegin\n  var count := 0;\n  var num := number;\n  while num > 0 do\n  begin\n    if num mod 10 = digit then\n      count += 1;\n    num := num div 10;\n  end;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to merge two strings by alternating characters from each string. If one string is longer than the other, append the remaining characters to the end of the merged string.",
    "output": "function MergeStrings(word1, word2: string): string;\nbegin\n  var outStr := '';\n  var index1 := 0;\n  var index2 := 0;\n  \n  while (index1 < word1.Length) or (index2 < word2.Length) do\n  begin\n    if index1 < word1.Length then\n      outStr += word1[index1+1];\n    if index2 < word2.Length then\n      outStr += word2[index2+1];\n    index1 += 1;\n    index2 += 1;\n  end;\n  \n  Result := outStr;\nend;"
  },
  {
    "instruction": "Write a function to check if a given string is a palindrome ignoring case and non-alphanumeric characters.",
    "output": "function IsPalindromeIgnore(s: string): boolean;\nbegin\n  var filtered := '';\n  foreach var ch in s do\n    if char.IsLetterOrDigit(ch) then\n      filtered += ch.ToLower;\n  \n  Result := filtered = ReverseString(filtered);\nend;"
  },
  {
    "instruction": "Write a function to find the least number of perfect square numbers which sum to 'n'.",
    "output": "function LeastSquares(n: integer): integer;\nbegin\n  var dp := new integer[n + 1];\n  for var i := 1 to n do\n  begin\n    dp[i] := i;\n    for var j := 1 to Trunc(Sqrt(i)) do\n      dp[i] := Min(dp[i], dp[i - j * j] + 1);\n  end;\n  Result := dp[n];\nend;"
  },
  {
    "instruction": "Write a function to find the maximum sum of K consecutive elements in an array.",
    "output": "function MaxSumKConsecutive(arr: array of integer; k: integer): integer;\nbegin\n  if arr.Length < k then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var maxSum := 0;\n  var currentSum := 0;\n  \n  for var i := 0 to k - 1 do\n    currentSum += arr[i];\n  \n  maxSum := currentSum;\n  \n  for var i := k to arr.Length - 1 do\n  begin\n    currentSum += arr[i] - arr[i - k];\n    maxSum := Max(maxSum, currentSum);\n  end;\n  \n  Result := maxSum;\nend;"
  },
  {
    "instruction": "Write a function that takes two lists of integers, `nums1` and `nums2`. Each list represents the gas and cost at each station in a circular route. The function should determine the starting gas station index that will allow you to travel around the entire circuit once without running out of gas. If such a station doesn't exist, return -1.",
    "output": "function CanCompleteCircuit(gas, cost: array of integer): integer;\nbegin\n  var gasSum := gas.Sum;\n  var costSum := cost.Sum;\n  if gasSum < costSum then\n  begin\n    Result := -1;\n    exit;\n  end;\n  \n  var n := gas.Length;\n  var tank := 0;\n  var start := 0;\n  \n  for var i := 0 to n - 1 do\n  begin\n    tank += gas[i] - cost[i];\n    if tank < 0 then\n    begin\n      tank := 0;\n      start := i + 1;\n    end;\n  end;\n  \n  Result := start;\nend;"
  },
  {
    "instruction": "Write a function that checks if it's possible to divide a list of integers into consecutive subsequences of length k. A consecutive subsequence is a sequence of integers where each integer is one more than the previous integer.",
    "output": "function IsPossibleDivide(nums: array of integer; k: integer): boolean;\nbegin\n  if nums.Length mod k <> 0 then\n  begin\n    Result := False;\n    exit;\n  end;\n  \n  var numCounts := new Dictionary<integer, integer>;\n  foreach var num in nums do\n    if numCounts.ContainsKey(num) then\n      numCounts[num] += 1\n    else\n      numCounts.Add(num, 1);\n  \n  var sortedKeys := numCounts.Keys.ToList;\n  sortedKeys.Sort;\n  \n  foreach var key in sortedKeys do\n  begin\n    if numCounts[key] > 0 then\n    begin\n      for var i := 1 to k - 1 do\n      begin\n        if (not numCounts.ContainsKey(key + i)) or (numCounts[key + i] < numCounts[key]) then\n        begin\n          Result := False;\n          exit;\n        end;\n        numCounts[key + i] -= numCounts[key];\n      end;\n    end;\n  end;\n  \n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum cost to guess a number within a range from 1 to n. The cost of guessing a number is equal to the value of that number. If the guessed number is higher or lower than the target, you have to pay the cost of the guessed number and continue guessing. Your goal is to minimize the total cost.",
    "output": "function MinGuessCost(n: integer): integer;\nbegin\n  var pay := new integer[n+1, n+1];\n  \n  for var i := n - 1 downto 0 do\n    for var j := i + 1 to n - 1 do\n    begin\n      var minVal := integer.MaxValue;\n      for var k := i to j do\n        minVal := Min(minVal, k + 1 + Max(pay[i, k-1], pay[k+1, j]));\n      pay[i,j] := minVal;\n    end;\n  \n  Result := pay[0, n-1];\nend;"
  },
  {
    "instruction": "Write a function to generate the first n ugly numbers. Ugly numbers are positive numbers whose prime factors only include 2, 3, or 5.",
    "output": "function GetUglyNumbers(n: integer): array of integer;\nbegin\n  var ugly := new integer[n];\n  ugly[0] := 1;\n  var i2 := 0;\n  var i3 := 0;\n  var i5 := 0;\n  var nextMultipleOf2 := 2;\n  var nextMultipleOf3 := 3;\n  var nextMultipleOf5 := 5;\n  \n  for var i := 1 to n - 1 do\n  begin\n    var nextUgly := Min(nextMultipleOf2, Min(nextMultipleOf3, nextMultipleOf5));\n    ugly[i] := nextUgly;\n    \n    if nextUgly = nextMultipleOf2 then\n    begin\n      i2 += 1;\n      nextMultipleOf2 := ugly[i2] * 2;\n    end;\n    \n    if nextUgly = nextMultipleOf3 then\n    begin\n      i3 += 1;\n      nextMultipleOf3 := ugly[i3] * 3;\n    end;\n    \n    if nextUgly = nextMultipleOf5 then\n    begin\n      i5 += 1;\n      nextMultipleOf5 := ugly[i5] * 5;\n    end;\n  end;\n  \n  Result := ugly;\nend;"
  },
  {
    "instruction": "Write a function to find the index of a target value in a rotated sorted array. If the target value is not found, return -1.",
    "output": "function SearchRotatedArray(nums: array of integer; target: integer): integer;\n\n  function FindRotationPoint(arr: array of integer): integer;\n  begin\n    var low := 0;\n    var high := arr.Length - 1;\n    while low < high do\n    begin\n      var mid := low + (high - low) div 2;\n      if arr[mid] > arr[high] then\n        low := mid + 1\n      else\n        high := mid;\n    end;\n    Result := low;\n  end;\n\n  function BinarySearch(low, high: integer; targetVal: integer; arr: array of integer): integer;\n  begin\n    while low <= high do\n    begin\n      var mid := low + (high - low) div 2;\n      if arr[mid] = targetVal then\n      begin\n        Result := mid;\n        exit;\n      end\n      else if arr[mid] < targetVal then\n        low := mid + 1\n      else\n        high := mid - 1;\n    end;\n    Result := -1;\n  end;\n\nbegin\n  var rotationPoint := FindRotationPoint(nums);\n  \n  if nums[rotationPoint] = target then\n  begin\n    Result := rotationPoint;\n    exit;\n  end;\n  \n  if nums[0] = target then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  if rotationPoint = 0 then\n    Result := BinarySearch(0, nums.Length - 1, target, nums)\n  else if target < nums[0] then\n    Result := BinarySearch(rotationPoint, nums.Length - 1, target, nums)\n  else\n    Result := BinarySearch(0, rotationPoint - 1, target, nums);\nend;"
  },
  {
    "instruction": "Write a function to find the smallest number that can be obtained by adding a pair of elements from an array.",
    "output": "function FindSmallestSum(arr: array of integer): integer;\nbegin\n  var sortedArr := arr.ToList;\n  sortedArr.Sort;\n  Result := sortedArr[0] + sortedArr[1];\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest substring without repeating characters.",
    "output": "function LongestSubstring(s: string): integer;\nbegin\n  var startIndex := 0;\n  var maxLength := 0;\n  var dic := new Dictionary<char, integer>;\n  \n  for var i := 1 to s.Length do\n  begin\n    var ch := s[i];\n    if dic.ContainsKey(ch) and (startIndex <= dic[ch]) then\n      startIndex := dic[ch] + 1\n    else\n      maxLength := Max(maxLength, i - startIndex + 1);\n    \n    dic[ch] := i;\n  end;\n  \n  Result := maxLength;\nend;"
  },
  {
    "instruction": "Write a function to find the factorial of a number using recursion.",
    "output": "function FindFactorialUsingRecursion(n: integer): integer;\nbegin\n  if n = 0 then\n    Result := 1\n  else\n    Result := n * FindFactorialUsingRecursion(n - 1);\nend;"
  },
  {
    "instruction": "Write a function to check if two rectangles are overlapping.",
    "output": "function IsOverlapping(A, B, C, D, E, F, G, H: integer): boolean;\nbegin\n  if (E >= C) or (G <= A) then\n    Result := False\n  else if (F >= D) or (H <= B) then\n    Result := False\n  else\n    Result := True;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest number of moves required to solve the Tower of Hanoi puzzle.",
    "output": "function Hanoi(n: integer): integer;\nbegin\n  if n = 1 then\n    Result := 1\n  else\n    Result := 2 * Hanoi(n - 1) + 1;\nend;"
  },
  {
    "instruction": "Write a function to find the missing numbers in a given array of integers. The array is supposed to contain all numbers from 1 to n (inclusive), but some numbers are missing. Your function should return the missing numbers in a list.",
    "output": "function FindMissingNumbers(nums: array of integer): array of integer;\nbegin\n  var n := nums.Length;\n  var numList := nums.ToList;\n  \n  for var i := 0 to n - 1 do\n    while (numList[i] <> i + 1) and (numList[numList[i] - 1] <> numList[i]) do\n    begin\n      var temp := numList[numList[i] - 1];\n      numList[numList[i] - 1] := numList[i];\n      numList[i] := temp;\n    end;\n  \n  Result := Range(1, n).Where(i -> numList[i - 1] <> i).ToArray;\nend;"
  },
  {
    "instruction": "Create a function that takes a list of integers and returns the maximum amount of water that can be trapped after drawing vertical lines of the specified heights. The width of each bar is 1 unit.",
    "output": "function MaxWater(height: array of integer): integer;\nbegin\n  var extendedHeight := new integer[height.Length + 2];\n  extendedHeight[0] := 0;\n  for var i := 0 to height.Length - 1 do\n    extendedHeight[i + 1] := height[i];\n  extendedHeight[extendedHeight.Length - 1] := 0;\n  \n  var leftMax := new integer[extendedHeight.Length];\n  var rightMax := new integer[extendedHeight.Length];\n  \n  for var i := 1 to extendedHeight.Length - 1 do\n    leftMax[i] := Max(extendedHeight[i], leftMax[i - 1]);\n  \n  for var i := extendedHeight.Length - 2 downto 0 do\n    rightMax[i] := Max(extendedHeight[i], rightMax[i + 1]);\n  \n  var res := 0;\n  for var i := 1 to extendedHeight.Length - 2 do\n    res += Min(leftMax[i], rightMax[i]) - extendedHeight[i];\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to decode a message with given encoding rules. A message consisting of letters from A-Z is being encoded to numbers using the following mapping: 'A' -> 1 'B' -> 2 ... 'Z' -> 26 Given an encoded message containing digits, determine the total number of ways to decode it.",
    "output": "function CountDecodeWays(s: string): integer;\nbegin\n  if (s.Length = 0) or (s[1] = '0') then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var n := s.Length;\n  var dp := new integer[n + 1];\n  dp[0] := 1;\n  dp[1] := 1;\n  \n  for var i := 2 to n do\n  begin\n    if s[i] <> '0' then\n      dp[i] := dp[i - 1];\n    \n    var twoDigit := StrToInt(s.Substring(i - 2, 2));\n    if (s[i - 1] <> '0') and (twoDigit <= 26) then\n      dp[i] += dp[i - 2];\n  end;\n  \n  Result := dp[n];\nend;"
  },
  {
    "instruction": "Write a function `generate_square_matrix(n)` that generates an n x n matrix filled with elements that are each the square of their index, starting from 0. The function should return the generated matrix.",
    "output": "function GenerateSquareMatrix(n: integer): array [,] of integer;\nbegin\n  Result := new integer[n, n];\n  for var i := 0 to n - 1 do\n    for var j := 0 to n - 1 do\n      Result[i, j] := (i * n + j) * (i * n + j);\nend;"
  },
  {
    "instruction": "Write a function to find the maximum difference between two elements in an array such that larger element appears after the smaller number.",
    "output": "function FindMaxDifference(arr: array of integer): integer;\nbegin\n  if arr.Length < 2 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var maxDiff := arr[1] - arr[0];\n  var minElement := arr[0];\n  \n  for var i := 1 to arr.Length - 1 do\n  begin\n    if arr[i] - minElement > maxDiff then\n      maxDiff := arr[i] - minElement;\n    if arr[i] < minElement then\n      minElement := arr[i];\n  end;\n  \n  Result := maxDiff;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns True if the sequence of numbers 1, 2, 3 appears in the list somewhere.",
    "output": "function SequenceCheck(nums: array of integer): boolean;\nbegin\n  for var i := 0 to nums.Length - 3 do\n    if (nums[i] = 1) and (nums[i + 1] = 2) and (nums[i + 2] = 3) then\n    begin\n      Result := True;\n      exit;\n    end;\n  Result := False;\nend;"
  },
  {
    "instruction": "Write a function to replace the last element of a given list with another list.",
    "output": "function ReplaceLast(lst: List<List<integer>>; newLst: List<integer>): List<List<integer>>;\nbegin\n  lst[lst.Count - 1] := newLst;\n  Result := lst;\nend;"
  },
  {
    "instruction": "Write a function to find the shortest repeating pattern in a given string. If no repeating pattern is found, return -1.",
    "output": "function ShortestRepeatingPattern(s: string): integer;\nbegin\n  for var i := 1 to s.Length div 2 do\n    if s.Length mod i = 0 then\n      if s.Substring(0, i) * (s.Length div i) = s then\n      begin\n        Result := i;\n        exit;\n      end;\n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function called word_counter that receives a list of sentences as input and returns a dictionary where the keys are the unique words in the sentences and the values are the counts of those words.",
    "output": "function WordCounter(sentences: array of string): Dictionary<string, integer>;\nbegin\n  var wordCount := new Dictionary<string, integer>;\n  \n  foreach var sentence in sentences do\n  begin\n    var words := sentence.Split(' ');\n    foreach var word in words do\n      if wordCount.ContainsKey(word) then\n        wordCount[word] += 1\n      else\n        wordCount.Add(word, 1);\n  end;\n  \n  Result := wordCount;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns a new list where each element is the exponentiation of the corresponding element in the input list to a given power. The function should handle negative and zero inputs gracefully by returning a list of zeros for negative inputs and a list of ones for zero inputs.",
    "output": "function PowerList(lst: array of integer; pow: integer): array of integer;\nbegin\n  var res := new integer[lst.Length];\n  for var i := 0 to lst.Length - 1 do\n  begin\n    var num := lst[i];\n    if num < 0 then\n      res[i] := 0\n    else if num = 0 then\n      res[i] := 1\n    else\n      res[i] := Round(Power(num, pow));\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum value that can be obtained from items with given values and weights, using a knapsack of given capacity. The function should return the maximum value.",
    "output": "function KnapSackSolution(values, weights: array of integer; capacity: integer): integer;\nbegin\n  var dp := new integer[values.Length + 1, capacity + 1];\n  \n  for var i := 1 to values.Length do\n    for var j := 0 to capacity do\n      if weights[i - 1] > j then\n        dp[i, j] := dp[i - 1, j]\n      else\n        dp[i, j] := Max(dp[i - 1, j], dp[i - 1, j - weights[i - 1]] + values[i - 1]);\n  \n  Result := dp[values.Length, capacity];\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number that can be obtained by flipping 6 to 9 in the given number.",
    "output": "function MaxNumByFlipping(num: integer): integer;\nbegin\n  if num = 9999 then\n  begin\n    Result := num;\n    exit;\n  end;\n  \n  var numStr := num.ToString.ToCharArray;\n  for var i := 0 to numStr.Length - 1 do\n  begin\n    if numStr[i] = '9' then\n      continue\n    else if numStr[i] = '6' then\n    begin\n      numStr[i] := '9';\n      break;\n    end;\n  end;\n  \n  Result := StrToInt(string.Join('', numStr));\nend;"
  },
  {
    "instruction": "Write a function to find the count of unique elements in a given list.",
    "output": "function UniqueElementCount(lst: array of integer): integer;\nbegin\n  Result := lst.Distinct.Count;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest repeating subsequence in a given string.",
    "output": "function FindSmallestRepeatingSubseq(s: string): string;\nbegin\n  for var i := 1 to s.Length div 2 do\n  begin\n    var subseq := s.Substring(0, i);\n    var repeated := '';\n    for var j := 1 to s.Length div i do\n      repeated += subseq;\n    if repeated + subseq.Substring(0, s.Length mod i) = s then\n    begin\n      Result := subseq;\n      exit;\n    end;\n  end;\n  Result := s;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum sum of a subarray of size k in an array.",
    "output": "function FindMaxSumSubarray(arr: array of integer; k: integer): integer;\nbegin\n  if (arr.Length = 0) or (k <= 0) or (k > arr.Length) then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var windowSum := 0;\n  for var i := 0 to k - 1 do\n    windowSum += arr[i];\n  \n  var maxSum := windowSum;\n  \n  for var i := 0 to arr.Length - k - 1 do\n  begin\n    windowSum := windowSum - arr[i] + arr[i + k];\n    maxSum := Max(maxSum, windowSum);\n  end;\n  \n  Result := maxSum;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest subarray with a given sum using the sliding window technique.",
    "output": "function FindSmallestSubarray(arr: array of integer; targetSum: integer): integer;\nbegin\n  var windowSum := 0;\n  var windowStart := 0;\n  var minLength := integer.MaxValue;\n  \n  for var windowEnd := 0 to arr.Length - 1 do\n  begin\n    windowSum += arr[windowEnd];\n    \n    while windowSum >= targetSum do\n    begin\n      minLength := Min(minLength, windowEnd - windowStart + 1);\n      windowSum -= arr[windowStart];\n      windowStart += 1;\n    end;\n  end;\n  \n  if minLength <> integer.MaxValue then\n    Result := minLength\n  else\n    Result := 0;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum and minimum numbers in a list of integers using a heap data structure.",
    "output": "function HeapMaxMin(lst: array of integer): (integer, integer);\nbegin\n  var heap := new List<integer>(lst);\n  var maxHeap := new List<integer>(lst);\n  \n  heap.Sort;\n  maxHeap.Sort((x, y) -> y.CompareTo(x));\n  \n  Result := (maxHeap[0], heap[0]);\nend;"
  },
  {
    "instruction": "Write a function to find the number of times a given number is repeated in a sorted array.",
    "output": "function FindRepetition(A: array of integer; x: integer): integer;\n\n  function FindFirstOccurrence(arr: array of integer; target: integer): integer;\n  begin\n    var left := 0;\n    var right := arr.Length - 1;\n    var resultIndex := -1;\n    \n    while left <= right do\n    begin\n      var mid := (left + right) div 2;\n      if target = arr[mid] then\n      begin\n        resultIndex := mid;\n        right := mid - 1;\n      end\n      else if target < arr[mid] then\n        right := mid - 1\n      else\n        left := mid + 1;\n    end;\n    Result := resultIndex;\n  end;\n\n  function FindLastOccurrence(arr: array of integer; target: integer): integer;\n  begin\n    var left := 0;\n    var right := arr.Length - 1;\n    var resultIndex := -1;\n    \n    while left <= right do\n    begin\n      var mid := (left + right) div 2;\n      if target = arr[mid] then\n      begin\n        resultIndex := mid;\n        left := mid + 1;\n      end\n      else if target < arr[mid] then\n        right := mid - 1\n      else\n        left := mid + 1;\n    end;\n    Result := resultIndex;\n  end;\n\nbegin\n  var first := FindFirstOccurrence(A, x);\n  if first = -1 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var last := FindLastOccurrence(A, x);\n  Result := last - first + 1;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns a new list where each element is the product of the original element and its index in the list.",
    "output": "function MultiplyIndex(lst: array of integer): array of integer;\nbegin\n  Result := new integer[lst.Length];\n  for var i := 0 to lst.Length - 1 do\n    Result[i] := i * lst[i];\nend;"
  },
  {
    "instruction": "Write a function that takes in a list of numbers and returns a new list where each element is replaced by its square if it is positive, or by its absolute value if it is negative.",
    "output": "function SquareOrAbsolute(numbers: array of integer): array of integer;\nbegin\n  Result := new integer[numbers.Length];\n  for var i := 0 to numbers.Length - 1 do\n  begin\n    var num := numbers[i];\n    if num >= 0 then\n      Result[i] := num * num\n    else\n      Result[i] := Abs(num);\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the distance between two points in a 3D space. The points are represented as tuples of three integers, where each integer represents the position along a different axis (x, y, z).",
    "output": "function Distance3D(point1, point2: (integer, integer, integer)): real;\nbegin\n  var (x1, y1, z1) := point1;\n  var (x2, y2, z2) := point2;\n  Result := Sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1));\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings and returns the strings that can be formed by rearranging the characters of one string to form another string in the list. The returned list should contain only unique strings, and the order of the strings in the returned list doesn't matter.",
    "output": "function RearrangeStrings(words: array of string): array of string;\nbegin\n  var anagrams := new Dictionary<string, List<string>>;\n  \n  foreach var word in words do\n  begin\n    var sortedWord := string.Join('', word.ToCharArray.Sorted);\n    if anagrams.ContainsKey(sortedWord) then\n      anagrams[sortedWord].Add(word)\n    else\n      anagrams.Add(sortedWord, new List<string>([word]));\n  end;\n  \n  var res := new List<string>;\n  foreach var pair in anagrams do\n    if pair.Value.Count > 1 then\n      res.AddRange(pair.Value);\n  \n  Result := res.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the largest power of a prime number p that divides a factorial number n!.",
    "output": "function LargestPowerDividingFactorial(p, n: integer): integer;\nbegin\n  var count := 0;\n  var i := p;\n  while i <= n do\n  begin\n    count += n div i;\n    i *= p;\n  end;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to express n as the sum of 1, 3, and 4.",
    "output": "function NumWays(n: integer): integer;\nbegin\n  if n < 0 then\n    Result := 0\n  else if n = 0 then\n    Result := 1\n  else\n    Result := NumWays(n - 1) + NumWays(n - 3) + NumWays(n - 4);\nend;"
  },
  {
    "instruction": "Write a function to check whether the given number is a strong number or not. A strong number is a number whose sum of the factorial of its digits is equal to the number itself.",
    "output": "function CheckStrongNumber(num: integer): boolean;\n\n  function Factorial(n: integer): integer;\n  begin\n    if (n = 0) or (n = 1) then\n      Result := 1\n    else\n      Result := n * Factorial(n - 1);\n  end;\n\nbegin\n  var temp := num;\n  var sum := 0;\n  while num > 0 do\n  begin\n    var digit := num mod 10;\n    sum += Factorial(digit);\n    num := num div 10;\n  end;\n  Result := sum = temp;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of moves required to make all elements of an array equal, where a move consists of incrementing all elements except one by 1.",
    "output": "function MinMovesEqualElements(nums: array of integer): integer;\nbegin\n  var minNum := nums.Min;\n  var moves := 0;\n  foreach var num in nums do\n    moves += num - minNum;\n  Result := moves;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum absolute value in a list of numbers.",
    "output": "function MaxAbs(numbers: array of integer): integer;\nbegin\n  Result := numbers.Max(x -> Abs(x));\nend;"
  },
  {
    "instruction": "Write a function to find the intersection of two binary search trees. The intersection is defined as the common elements between the two trees.",
    "output": "type\n  TreeNode = class\n    val: integer;\n    left, right: TreeNode;\n    \n    constructor Create(v: integer; l: TreeNode := nil; r: TreeNode := nil);\n    begin\n      val := v;\n      left := l;\n      right := r;\n    end;\n  end;\n\nprocedure InorderTraversal(root: TreeNode; var arr: List<integer>);\nbegin\n  if root <> nil then\n  begin\n    InorderTraversal(root.left, arr);\n    arr.Add(root.val);\n    InorderTraversal(root.right, arr);\n  end;\nend;\n\nfunction BuildBST(sortedArr: List<integer>; startIndex, endIndex: integer): TreeNode;\nbegin\n  if startIndex > endIndex then\n  begin\n    Result := nil;\n    exit;\n  end;\n  \n  var mid := (startIndex + endIndex) div 2;\n  Result := new TreeNode(sortedArr[mid]);\n  Result.left := BuildBST(sortedArr, startIndex, mid - 1);\n  Result.right := BuildBST(sortedArr, mid + 1, endIndex);\nend;\n\nfunction CreateBST(arr: array of integer): TreeNode;\nbegin\n  if arr.Length = 0 then\n  begin\n    Result := nil;\n    exit;\n  end;\n  \n  var sortedArr := arr.ToList;\n  sortedArr.Sort;\n  Result := BuildBST(sortedArr, 0, sortedArr.Count - 1);\nend;\n\nfunction IntersectionOfTwoBST(tree1, tree2: array of integer): array of integer;\nbegin\n  var bst1 := CreateBST(tree1);\n  var bst2 := CreateBST(tree2);\n  \n  var arr1 := new List<integer>;\n  var arr2 := new List<integer>;\n  \n  InorderTraversal(bst1, arr1);\n  InorderTraversal(bst2, arr2);\n  \n  var i := 0;\n  var j := 0;\n  var res := new List<integer>;\n  \n  while (i < arr1.Count) and (j < arr2.Count) do\n  begin\n    if arr1[i] < arr2[j] then\n      i += 1\n    else if arr1[i] > arr2[j] then\n      j += 1\n    else\n    begin\n      res.Add(arr1[i]);\n      i += 1;\n      j += 1;\n    end;\n  end;\n  \n  Result := res.ToArray;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns True if the list can be arranged in a straight flush in a game of poker. A straight flush is five cards of the same suit in sequence. The function should ignore the suit and consider only the values of the cards. The values are represented as integers from 1 to 13 for Ace to King, and 0 for a Joker. A Joker can be used as any value.",
    "output": "function IsStraight(nums: array of integer): boolean;\nbegin\n  if (nums.Length = 0) or (nums.Length <> 5) then\n  begin\n    Result := False;\n    exit;\n  end;\n\n  var sortedNums := nums.ToList;\n  sortedNums.Sort;\n  var joker := 0;\n  \n  for var i := 0 to 3 do\n  begin\n    if sortedNums[i] = 0 then\n      joker += 1\n    else\n    begin\n      if sortedNums[i] = sortedNums[i + 1] then\n      begin\n        Result := False;\n        exit;\n      end;\n    end;\n  end;\n  \n  Result := sortedNums[4] - sortedNums[joker] < 5;\nend;"
  },
  {
    "instruction": "Write a function that finds the maximum length of the sub-arrays in a 2D array. The function should return the length of the longest sub-array.",
    "output": "function MaxSubArrayLength(twoDArray: array of array of integer): integer;\nbegin\n  var maxLength := 0;\n  foreach var subArray in twoDArray do\n    if subArray.Length > maxLength then\n      maxLength := subArray.Length;\n  Result := maxLength;\nend;"
  },
  {
    "instruction": "Write a function that determines whether a given list of numbers can form a square using all the numbers as lengths of matchsticks. A matchstick can only be used once.",
    "output": "function CanFormSquareComb(a, b, c, d, i: integer; nums: array of integer; q: integer): boolean;\nbegin\n    if i = nums.Length then\n    begin\n      Result := (a = q) and (b = q) and (c = q) and (d = q);\n      exit;\n    end;\n    \n    var sides := new integer[4];\n    sides[0] := a;\n    sides[1] := b;\n    sides[2] := c;\n    sides[3] := d;\n    \n    for var j := 0 to 3 do\n    begin\n      if sides[j] + nums[i] <= q then\n      begin\n        sides[j] += nums[i];\n        if CanFormSquareComb(sides[0], sides[1], sides[2], sides[3], i + 1, nums, q) then\n        begin\n          Result := True;\n          exit;\n        end;\n        sides[j] -= nums[i];\n      end;\n    end;\n    Result := False;\nend;\n\nfunction CanFormSquare(nums: array of integer): boolean;\nbegin\n  var S := nums.Sum;\n  if S mod 4 <> 0 then\n  begin\n    Result := False;\n    exit;\n  end;\n  \n  var q := S div 4;\n  var N := nums.Length;\n  if N <= 3 then\n  begin\n    Result := False;\n    exit;\n  end;\n  \n  var sortedNums := nums.ToList;\n  sortedNums.Sort;\n  sortedNums.Reverse;\n  \n  Result := CanFormSquareComb(0, 0, 0, 0, 0, sortedNums.ToArray, q);\nend;"
  },
  {
    "instruction": "Write a function to rotate the elements of an array to the right by k steps, where k is a non-negative integer.",
    "output": "function RotateArray(nums: array of integer; k: integer): array of integer;\nbegin\n  var actualK := k mod nums.Length;\n  if actualK = 0 then\n  begin\n    Result := nums;\n    exit;\n  end;\n  \n  var rotated := nums[nums.Length - actualK:] + nums[:nums.Length - actualK];\n  Result := rotated;\nend;"
  },
  {
    "instruction": "Write a function that takes two binary strings as arguments and performs a bitwise XOR operation on them. The function should return the resulting binary string.",
    "output": "function BinaryXor(binary1, binary2: string): string;\nbegin\n  var maxLength := Max(binary1.Length, binary2.Length);\n  var res := '';\n  \n  for var i := 1 to maxLength do\n  begin\n    var bit1 := if i <= binary1.Length then StrToInt(binary1[binary1.Length - i + 1]) else 0;\n    var bit2 := if i <= binary2.Length then StrToInt(binary2[binary2.Length - i + 1]) else 0;\n    var xorBit := bit1 xor bit2;\n    res := xorBit.ToString + res;\n  end;\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to calculate the L2 norm (Euclidean norm) of a vector. The L2 norm of a vector is the square root of the sum of the squares of its components.",
    "output": "function L2Norm(vector: array of real): real;\nbegin\n  var squaredSum := 0.0;\n  foreach var x in vector do\n    squaredSum += x * x;\n  Result := Sqrt(squaredSum);\nend;"
  },
  {
    "instruction": "Write a function to find the smallest number in a list and its index.",
    "output": "function FindSmallestAndIndex(lst: array of integer): (integer, integer);\nbegin\n  var smallest := lst[0];\n  var index := 0;\n  \n  for var i := 1 to lst.Length - 1 do\n  begin\n    if lst[i] < smallest then\n    begin\n      smallest := lst[i];\n      index := i;\n    end;\n  end;\n  \n  Result := (smallest, index);\nend;"
  },
  {
    "instruction": "Write a function to simulate a game of \"Stones on a Table\". There are N stones on a table, labeled from 1 to N. The goal of the game is to remove all stones from the table. On each turn, you can remove a stone and its adjacent stones (if any) from the table. The game ends when all stones are removed. The function should return the minimum number of moves required to remove all stones.",
    "output": "function StonesOnTable(n: integer): integer;\nbegin\n  if n <= 2 then\n    Result := n\n  else\n    Result := (n + 1) div 2;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum possible sum of non-adjacent elements in the given array.",
    "output": "function MaxSumNonAdjacent(arr: array of integer): integer;\nbegin\n  if arr.Length <= 2 then\n  begin\n    Result := arr.Max;\n    exit;\n  end;\n  \n  var incl := arr[0];\n  var excl := 0;\n  \n  for var i := 1 to arr.Length - 1 do\n  begin\n    var newExcl := Max(incl, excl);\n    incl := excl + arr[i];\n    excl := newExcl;\n  end;\n  \n  Result := Max(incl, excl);\nend;"
  },
  {
    "instruction": "Write a function that generates the nth Fibonacci number using a recursive approach with memoization to optimize performance.",
    "output": "function FibMemoizedInternal(n: integer; var cache: Dictionary<integer, integer>): integer;\nbegin\n  if n = 0 then\n  begin\n    Result := 0;\n    exit;\n  end\n  else if n = 1 then\n  begin\n    Result := 1;\n    exit;\n  end;\n  \n  if cache.ContainsKey(n) then\n  begin\n    Result := cache[n];\n    exit;\n  end;\n  \n  cache[n] := FibMemoizedInternal(n - 1, cache) + FibMemoizedInternal(n - 2, cache);\n  Result := cache[n];\nend;\n\nfunction FibMemoized(n: integer): integer;\nbegin\n  var cache := new Dictionary<integer, integer>;\n  Result := FibMemoizedInternal(n, cache);\nend;"
  },
  {
    "instruction": "Write a function to find the majority elements in a list which appear more than n/3 times.",
    "output": "function FindMajority(nums: array of integer): array of integer;\nbegin\n  var counts := new Dictionary<integer, integer>;\n  foreach var num in nums do\n    if counts.ContainsKey(num) then\n      counts[num] += 1\n    else\n      counts.Add(num, 1);\n  \n  var ans := new List<integer>;\n  var threshold := nums.Length div 3;\n  \n  foreach var pair in counts do\n    if pair.Value > threshold then\n      ans.Add(pair.Key);\n  \n  Result := ans.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to validate a given credit card number using the Luhn algorithm. The function should return True if the card number is valid and False otherwise.",
    "output": "function ValidateCreditCard(cardNumber: string): boolean;\nbegin\n  var digits := cardNumber.ToCharArray.Select(ch -> StrToInt(ch)).ToArray;\n  \n  foreach var i in Range(0, digits.Length - 2, 2).Reverse() do\n  begin\n    digits[i] *= 2;\n    if digits[i] > 9 then\n      digits[i] -= 9;\n  end;\n  \n  Result := digits.Sum mod 10 = 0;\nend;"
  },
  {
    "instruction": "Write a function to determine if a given string is a valid interleaving of two other strings.",
    "output": "function IsValidInterleaving(s, t, resultStr: string): boolean;\nbegin\n  if resultStr.Length <> s.Length + t.Length then\n  begin\n    Result := False;\n    exit;\n  end;\n  \n  var dp := new boolean[s.Length + 1, t.Length + 1];\n  dp[0, 0] := True;\n  \n  for var i := 1 to s.Length do\n    dp[i, 0] := dp[i - 1, 0] and (s[i] = resultStr[i]);\n  \n  for var j := 1 to t.Length do\n    dp[0, j] := dp[0, j - 1] and (t[j] = resultStr[j]);\n  \n  for var i := 1 to s.Length do\n    for var j := 1 to t.Length do\n    begin\n      dp[i, j] := (dp[i - 1, j] and (s[i] = resultStr[i + j])) or\n                  (dp[i, j - 1] and (t[j] = resultStr[i + j]));\n    end;\n  \n  Result := dp[s.Length, t.Length];\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest subarray of a given array that contains only 1s after deleting exactly one element.",
    "output": "function LongestSubarrayWithOneDeletion(arr: array of integer): integer;\nbegin\n  var n := arr.Length;\n  var maxLen := 0;\n  var left := 0;\n  var zeroFound := False;\n  \n  for var right := 0 to n - 1 do\n  begin\n    if arr[right] = 0 then\n    begin\n      if zeroFound then\n      begin\n        while arr[left] <> 0 do\n          left += 1;\n        left += 1;\n      end\n      else\n        zeroFound := True;\n    end;\n    \n    maxLen := Max(maxLen, right - left);\n  end;\n  \n  Result := maxLen;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of deletion operations required to make a string palindrome.",
    "output": "function MinDelPalindrome(s: string): integer;\nbegin\n  var n := s.Length;\n  var dp := new integer[n, n];\n  \n  for var length := 2 to n do\n  begin\n    for var start := 0 to n - length do\n    begin\n      var endIndex := start + length - 1;\n      if s[start + 1] = s[endIndex + 1] then\n        dp[start, endIndex] := dp[start + 1, endIndex - 1]\n      else\n        dp[start, endIndex] := Min(dp[start + 1, endIndex], dp[start, endIndex - 1]) + 1;\n    end;\n  end;\n  \n  Result := dp[0, n - 1];\nend;"
  },
  {
    "instruction": "Create a function to encode and decode a list of strings using a specific algorithm. The algorithm is as follows: \nEncode: Each string in the list is prefixed with its length followed by a '#' symbol. For example, 'Hello' will be encoded as '5#Hello'. \nDecode: The encoded string is split back into the original list of strings. The length and '#' symbol are used to split the encoded string back into the original strings.",
    "output": "function Encode(strs: array of string): string;\nbegin\n  var req := '';\n  foreach var s in strs do\n    req += s.Length.ToString + '#' + s;\n  Result := req;\nend;\n\nfunction Decode(encodedStr: string): array of string;\nbegin\n  var req := new List<string>;\n  var i := 0;\n  \n  while i < encodedStr.Length do\n  begin\n    var j := i;\n    while (j < encodedStr.Length) and (encodedStr[j + 1] <> '#') do\n      j += 1;\n    \n    var length := StrToInt(encodedStr.Substring(i, j - i + 1));\n    req.Add(encodedStr.Substring(j + 2, length));\n    i := j + 2 + length;\n  end;\n  \n  Result := req.ToArray;\nend;\n\nfunction EncodeDecode(strs: array of string): array of string;\nbegin\n  var encodedStr := Encode(strs);\n  var decodedStrs := Decode(encodedStr);\n  Result := decodedStrs;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of pairs of elements in an array that can be swapped so that the array becomes lexicographically smallest. Each element can be swapped at most once.",
    "output": "function MaxPairsSwap(arr: array of integer): integer;\nbegin\n  var answer := 0;\n  var elementCounts := new Dictionary<integer, integer>;\n  \n  foreach var num in arr do\n    if elementCounts.ContainsKey(num) then\n      elementCounts[num] += 1\n    else\n      elementCounts.Add(num, 1);\n  \n  foreach var star in elementCounts.Keys do\n  begin\n    if elementCounts[star] <= answer then\n      continue;\n    \n    var cnt := 0;\n    var idx := 0;\n    while idx < arr.Length - 1 do\n    begin\n      if (arr[idx] = arr[idx + 1]) or ((arr[idx] <> star) and (arr[idx + 1] <> star)) then\n      begin\n        idx += 1;\n        continue;\n      end;\n      \n      cnt += 1;\n      idx += 2;\n    end;\n    answer := Max(answer, cnt);\n  end;\n  \n  if answer <> 0 then\n    Result := answer\n  else\n    Result := 0;\nend;"
  },
  {
    "instruction": "Write a function that takes a string as input and returns the number of times the substring \"bob\" occurs in the string. Note that overlapping occurrences should be counted separately.",
    "output": "function CountBobOccurrences(s: string): integer;\nbegin\n  var count := 0;\n  for var i := 1 to s.Length - 2 do\n    if s.Substring(i - 1, 3) = 'bob' then\n      count += 1;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function that checks if a given list contains a specific string element. If the element is found, return the index of its first occurrence. If the element is not found, return -1.",
    "output": "function FindString(lst: array of string; element: string): integer;\nbegin\n  for var i := 0 to lst.Length - 1 do\n    if lst[i] = element then\n    begin\n      Result := i;\n      exit;\n    end;\n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function that takes an integer 'n' and returns the largest power of 2 that is less than or equal to 'n'.",
    "output": "function LargestPowerOf2(n: integer): integer;\nbegin\n  var p := 1;\n  while p <= n do\n    p := p shl 1;\n  Result := p shr 1;\nend;"
  },
  {
    "instruction": "Create a function that filters out the emails from a list of strings that do not contain a specific domain. The emails are considered to be in a standard form: 'username@domain.extension'.",
    "output": "function FilterEmails(emailList: array of string; filterDomain: string): array of string;\nbegin\n  var res := new List<string>;\n  foreach var email in emailList do\n    if email.EndsWith(filterDomain) then\n      res.Add(email);\n  Result := res.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to check if all elements in a list are unique.",
    "output": "function AreElementsUnique(list: array of integer): boolean;\nbegin\n  Result := list.Length = list.Distinct.Count;\nend;"
  },
  {
    "instruction": "Write a function to return the maximum sum of non-adjacent elements in a given list of integers. This problem is commonly known as the \"Maximum Subset Sum Without Adjacent Elements\" problem.",
    "output": "function MaxSubsetSumNoAdjacent(arr: array of integer): integer;\nbegin\n  if arr.Length = 1 then\n    Result := arr[0]\n  else if arr.Length = 2 then\n    Result := Max(arr[0], arr[1])\n  else\n  begin\n    var dp := new integer[arr.Length];\n    dp[0] := arr[0];\n    dp[1] := Max(arr[0], arr[1]);\n    for var i := 2 to arr.Length - 1 do\n      dp[i] := Max(dp[i-1], dp[i-2] + arr[i]);\n    Result := dp[arr.Length - 1];\n  end;\nend;"
  },
  {
    "instruction": "Write a function to check if two strings are nearly identical. Two strings are nearly identical if rearranging some of the characters of the first string is equal to the second string. Also, the frequency of each character in both strings must be the same.",
    "output": "function NearlyIdentical(str1, str2: string): boolean;\nbegin\n  var c1 := new Dictionary<char, integer>;\n  var c2 := new Dictionary<char, integer>;\n  \n  foreach var ch in str1 do\n    if c1.ContainsKey(ch) then\n      c1[ch] += 1\n    else\n      c1.Add(ch, 1);\n  \n  foreach var ch in str2 do\n    if c2.ContainsKey(ch) then\n      c2[ch] += 1\n    else\n      c2.Add(ch, 1);\n  \n  if not c1.Keys.ToHashSet.SetEquals(c2.Keys.ToHashSet) then\n  begin\n    Result := False;\n    exit;\n  end;\n  \n  var values1 := c1.Values.ToList;\n  var values2 := c2.Values.ToList;\n  values1.Sort;\n  values2.Sort;\n  \n  if not values1.SequenceEqual(values2) then\n  begin\n    Result := False;\n    exit;\n  end;\n  \n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function to calculate the maximum possible volume of a cuboid that can be formed from a given rectangular metal sheet. The metal sheet has length L, width W, and height H. We can cut the sheet into six pieces and rearrange them to form a cuboid. The function should return the maximum possible volume of the cuboid that can be formed.",
    "output": "function MaxCuboidVolume(L, W, H: integer): integer;\nbegin\n  var sides := new integer[3];\n  sides[0] := L;\n  sides[1] := W;\n  sides[2] := H;\n  &Array.Sort(sides);\n  \n  var maxVolume := L * W * H;\n  \n  if (2 * H <= L) and (2 * H <= W) then\n    maxVolume := Max(maxVolume, 4 * H * H * H);\n  \n  if 2 * W <= L then\n    maxVolume := Max(maxVolume, W * W * (L - 2 * W));\n  \n  if 2 * L <= W then\n    maxVolume := Max(maxVolume, L * L * (W - 2 * L));\n  \n  Result := maxVolume;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum steps required to reach the end of a matrix with given start and end cells. You can move to any of its four adjacent cells in one step.",
    "output": "function MinPathSteps(matrix: array [,] of integer; start, endPos: (integer, integer)): integer;\nbegin\n  var queue := new Queue<(integer, integer, integer)>;\n  queue.Enqueue((start[0], start[1], 0));\n  var directions := |(0, 1), (1, 0), (0, -1), (-1, 0)|;\n  \n  var rows := matrix.GetLength(0);\n  var cols := matrix.GetLength(1);\n  var visited := new HashSet<(integer, integer)>;\n  \n  while queue.Count > 0 do\n  begin\n    var (x, y, steps) := queue.Dequeue;\n    if (x = endPos[0]) and (y = endPos[1]) then\n    begin\n      Result := steps;\n      exit;\n    end;\n    \n    foreach var (dx, dy) in directions do\n    begin\n      var newX := x + dx;\n      var newY := y + dy;\n      if (newX >= 0) and (newX < rows) and (newY >= 0) and (newY < cols) and \n         (not visited.Contains((newX, newY))) and (matrix[newX, newY] = 0) then\n      begin\n        queue.Enqueue((newX, newY, steps + 1));\n        visited.Add((newX, newY));\n      end;\n    end;\n  end;\n  \n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of sorted characters and a target character, then returns the smallest character in the list that is larger than the target. If no such character exists, return the first character in the list.",
    "output": "function NextGreatestLetter(letters: array of char; target: char): char;\nbegin\n  if letters.Length = 0 then\n  begin\n    Result := #0;\n    exit;\n  end;\n  \n  var low := 0;\n  var high := letters.Length - 1;\n  \n  while low <= high do\n  begin\n    var mid := low + (high - low) div 2;\n    if (mid > 0) and (letters[mid - 1] <= target) and (target < letters[mid]) then\n    begin\n      Result := letters[mid];\n      exit;\n    end\n    else if letters[mid] <= target then\n      low := mid + 1\n    else\n      high := mid - 1;\n  end;\n  \n  Result := letters[0];\nend;"
  },
  {
    "instruction": "Write a function to find the maximum difference between two consecutive elements in a list.",
    "output": "function MaxDiffConsecutiveElements(lst: array of integer): integer;\nbegin\n  if lst.Length < 2 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var maxDiff := 0;\n  for var i := 0 to lst.Length - 2 do\n  begin\n    var diff := Abs(lst[i] - lst[i + 1]);\n    maxDiff := Max(maxDiff, diff);\n  end;\n  \n  Result := maxDiff;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest power of 2 greater than or equal to given number.",
    "output": "function SmallestPowerOf2(n: integer): integer;\nbegin\n  var res := 1;\n  while res < n do\n    res := res shl 1;\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find all unique triplets in the array which gives the sum of zero.",
    "output": "function FindTriplets(nums: array of integer): List<List<integer>>;\nbegin\n  var triplets := new List<List<integer>>;\n  var sortedNums := nums.ToList;\n  sortedNums.Sort;\n  var length := sortedNums.Count;\n  \n  for var i := 0 to length - 3 do\n  begin\n    if (i > 0) and (sortedNums[i] = sortedNums[i - 1]) then\n      continue;\n    \n    var left := i + 1;\n    var right := length - 1;\n    \n    while left < right do\n    begin\n      var total := sortedNums[i] + sortedNums[left] + sortedNums[right];\n      if total < 0 then\n        left += 1\n      else if total > 0 then\n        right -= 1\n      else\n      begin\n        triplets.Add(new List<integer>([sortedNums[i], sortedNums[left], sortedNums[right]]));\n        while (left < right) and (sortedNums[left] = sortedNums[left + 1]) do\n          left += 1;\n        while (left < right) and (sortedNums[right] = sortedNums[right - 1]) do\n          right -= 1;\n        left += 1;\n        right -= 1;\n      end;\n    end;\n  end;\n  \n  Result := triplets;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of numbers as input and returns a new list where each element is the sum of its neighboring elements in the original list. If the list has an odd number of elements, ignore the last element during the sum calculation.",
    "output": "function SumOfNeighbors(nums: array of integer): array of integer;\nbegin\n  if nums.Length <= 1 then\n  begin\n    Result := new integer[0];\n    exit;\n  end;\n  \n  var res := new integer[nums.Length - 1];\n  for var i := 0 to nums.Length - 2 do\n    res[i] := nums[i] + nums[i + 1];\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the common elements between two lists.",
    "output": "function CommonElements(list1, list2: array of integer): array of integer;\nbegin\n  Result := list1.Where(x -> list2.Contains(x)).ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of all the elements in the diagonal of a matrix that runs from the top-right corner to the bottom-left corner.",
    "output": "function FindDiagonalSum(mat: array [,] of integer): integer;\nbegin\n  var sum := 0;\n  var n := mat.GetLength(0);\n  for var i := 0 to n - 1 do\n    sum += mat[i, n - i - 1];\n  Result := sum;\nend;"
  },
  {
    "instruction": "Write a function to find the largest palindrome number that is a product of two numbers of 'n' digits.",
    "output": "function LargestPalindrome(n: integer): integer;\nbegin\n  var maxNum := Round(Power(10, n)) - 1;\n  var minNum := Round(Power(10, n - 1));\n  var maxPalindrome := 0;\n  \n  for var i := maxNum downto minNum do\n  begin\n    for var j := i downto minNum do\n    begin\n      var product := i * j;\n      if product <= maxPalindrome then\n        break;\n      \n      var productStr := product.ToString;\n      if productStr = ReverseString(productStr) then\n        maxPalindrome := product;\n    end;\n  end;\n  \n  Result := maxPalindrome;\nend;"
  },
  {
    "instruction": "Write a function to find the second largest digit in a string.",
    "output": "function SecondLargestDigit(s: string): integer;\nbegin\n  var list1 := new List<integer>;\n  foreach var ch in s do\n    if ch.IsDigit then\n      list1.Add(StrToInt(ch));\n  \n  var uniqueDigits := list1.Distinct.ToList;\n  uniqueDigits.Sort;\n  \n  if uniqueDigits.Count <= 1 then\n    Result := -1\n  else\n    Result := uniqueDigits[uniqueDigits.Count - 2];\nend;"
  },
  {
    "instruction": "Write a function to find the smallest number which is evenly divisible by all numbers from 1 to n.",
    "output": "function LeastCommonDivisible(n: integer): integer;\n\n  function GCD(a, b: integer): integer;\n  begin\n    while b <> 0 do\n    begin\n      var temp := b;\n      b := a mod b;\n      a := temp;\n    end;\n    Result := a;\n  end;\n\n  function LCM(a, b: integer): integer;\n  begin\n    Result := (a * b) div GCD(a, b);\n  end;\n\nbegin\n  var res := 1;\n  for var i := 1 to n do\n    res := LCM(res, i);\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to reverse the elements of a given list of strings, and then join them into a single string with a space as a delimiter.",
    "output": "function ReverseAndJoin(lst: array of string): string;\nbegin\n  var reversedList := lst.ToList;\n  reversedList.Reverse;\n  Result := string.Join(' ', reversedList);\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of steps required to sort an array of integers in ascending order by swapping adjacent elements.",
    "output": "function MinStepsToSort(arr: array of integer): integer;\n\n  function IsSorted(a: array of integer): boolean;\n  begin\n    for var i := 0 to a.Length - 2 do\n      if a[i] > a[i + 1] then\n      begin\n        Result := False;\n        exit;\n      end;\n    Result := True;\n  end;\n\nbegin\n  var steps := 0;\n  var arrCopy := arr.ToList;\n  \n  while not IsSorted(arrCopy.ToArray) do\n  begin\n    for var i := 0 to arrCopy.Count - 2 do\n    begin\n      if arrCopy[i] > arrCopy[i + 1] then\n      begin\n        var temp := arrCopy[i];\n        arrCopy[i] := arrCopy[i + 1];\n        arrCopy[i + 1] := temp;\n        steps += 1;\n      end;\n    end;\n  end;\n  \n  Result := steps;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest number in a list and return its index.",
    "output": "function SmallestNumberIndex(nums: array of integer): integer;\nbegin\n  var smallestIndex := 0;\n  for var i := 1 to nums.Length - 1 do\n    if nums[i] < nums[smallestIndex] then\n      smallestIndex := i;\n  Result := smallestIndex;\nend;"
  },
  {
    "instruction": "Create two functions. First encodes a URL into a tiny URL and second decodes it back to the original URL. The first function should guarantee that the encoded URL is unique and can be decoded back to the original URL. The encoding should be done using a combination of letters (both uppercase and lowercase) and digits, and the encoded URL should be 6 characters long.",
    "output": "const PrefixStr = 'http://tinyurl.com/';\nconst Letters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n\nfunction GenerateUniqueCode(FullTiny : Dictionary<string, string>): string;\nbegin\n  while True do\n  begin\n    var code := '';\n    for var i := 1 to 6 do\n      code += Letters[Random(Letters.Length) + 1];\n    \n    if not FullTiny.Values.Contains(code) then\n    begin\n      Result := code;\n      exit;\n    end;\n  end;\nend;\n\nfunction EncodeUrl(FullTiny : Dictionary<string, string>; longUrl: string): string;\nbegin\n  if FullTiny.ContainsKey(longUrl) then\n    Result := PrefixStr + FullTiny[longUrl]\n  else\n  begin\n    var code := GenerateUniqueCode(FullTiny);\n    FullTiny.Add(longUrl, code);\n    Result := PrefixStr + code;\n  end;\nend;\n\nfunction DecodeUrl(FullTiny : Dictionary<string, string>; shortUrl: string): string;\nbegin\n  var shortCode := shortUrl.Split('/')[^1];\n  foreach var pair in FullTiny do\n    if pair.Value = shortCode then\n    begin\n      Result := pair.Key;\n      exit;\n    end;\n  Result := '';\nend;"
  },
  {
    "instruction": "Write a function that finds the maximum sum of two non-overlapping subarrays with given lengths L and M from a list of integers. The function should return the maximum possible sum of the two subarrays.",
    "output": "function MaxSumSubarrays(A: array of integer; L, M: integer): integer;\nbegin\n  var prefixSum := new integer[A.Length + 1];\n  for var i := 0 to A.Length - 1 do\n    prefixSum[i + 1] := prefixSum[i] + A[i];\n  \n  var res := prefixSum[L + M];\n  var lMax := prefixSum[L];\n  var mMax := prefixSum[M];\n  \n  for var i := 1 to A.Length - L - M do\n  begin\n    lMax := Max(lMax, prefixSum[L + i] - prefixSum[i]);\n    mMax := Max(mMax, prefixSum[M + i] - prefixSum[i]);\n    \n    res := Max(res, \n      lMax + prefixSum[L + M + i] - prefixSum[L + i],\n      mMax + prefixSum[L + M + i] - prefixSum[M + i]);\n  end;\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to check if a list can be divided into consecutive subsequences of length k.",
    "output": "function CanDivide(nums: array of integer; k: integer): boolean;\nbegin\n  var counts := new Dictionary<integer, integer>;\n  foreach var num in nums do\n    if counts.ContainsKey(num) then\n      counts[num] += 1\n    else\n      counts.Add(num, 1);\n  \n  var sortedKeys := counts.Keys.ToList;\n  sortedKeys.Sort;\n  \n  foreach var key in sortedKeys do\n  begin\n    var occ := counts[key];\n    if occ > 0 then\n    begin\n      for var i := key + 1 to key + k - 1 do\n      begin\n        if (not counts.ContainsKey(i)) or (counts[i] < occ) then\n        begin\n          Result := False;\n          exit;\n        end;\n        counts[i] -= occ;\n      end;\n    end;\n  end;\n  \n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function to count the number of occurrences of each character in a given string.",
    "output": "function CountCharacters(s: string): Dictionary<char, integer>;\nbegin\n  var charCount := new Dictionary<char, integer>;\n  foreach var ch in s do\n    if charCount.ContainsKey(ch) then\n      charCount[ch] += 1\n    else\n      charCount.Add(ch, 1);\n  Result := charCount;\nend;"
  },
  {
    "instruction": "Write a function to compare two strings based on their lexicographical order. However, the comparison should be done in a special way: each character in the strings is first converted to its ASCII value, then these values are compared as if they were numbers.",
    "output": "function CompareStringsLexicographically(str1, str2: string): integer;\nbegin\n  var asciiStr1 := new List<integer>;\n  var asciiStr2 := new List<integer>;\n  \n  foreach var ch in str1 do\n    asciiStr1.Add(Ord(ch));\n  \n  foreach var ch in str2 do\n    asciiStr2.Add(Ord(ch));\n  \n  var len1 := asciiStr1.Count;\n  var len2 := asciiStr2.Count;\n  \n  if len1 < len2 then\n    for var i := 1 to len2 - len1 do\n      asciiStr1.Add(0)\n  else if len1 > len2 then\n    for var i := 1 to len1 - len2 do\n      asciiStr2.Add(0);\n  \n  var i := 0;\n  while i < asciiStr1.Count do\n  begin\n    if asciiStr1[i] > asciiStr2[i] then\n    begin\n      Result := 1;\n      exit;\n    end\n    else if asciiStr1[i] < asciiStr2[i] then\n    begin\n      Result := -1;\n      exit;\n    end\n    else\n      i += 1;\n  end;\n  \n  Result := 0;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest subarray with a sum of zero.",
    "output": "function LengthLongestSubarray(arr: array of integer): integer;\nbegin\n  var maxLength := 0;\n  var sumHash := new Dictionary<integer, integer>;\n  sumHash.Add(0, -1);\n  var sumVal := 0;\n  \n  for var i := 0 to arr.Length - 1 do\n  begin\n    sumVal += arr[i];\n    if sumHash.ContainsKey(sumVal) then\n      maxLength := Max(maxLength, i - sumHash[sumVal])\n    else\n      sumHash.Add(sumVal, i);\n  end;\n  \n  Result := maxLength;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6) in a given positive integer num consisting only of digits 6 and 9.",
    "output": "function Max69Number(num: integer): integer;\nbegin\n  var s := num.ToString;\n  for var i := 1 to s.Length do\n  begin\n    if s[i] = '6' then\n    begin\n      if i = s.Length then\n        Result := StrToInt(s.Substring(0, i - 1) + '9')\n      else\n        Result := StrToInt(s.Substring(0, i - 1) + '9' + s.Substring(i));\n      exit;\n    end;\n  end;\n  Result := num;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings and returns a list of strings that contain two or more vowels.",
    "output": "function FindStringsWithVowels(strings: array of string): array of string;\nbegin\n  var vowels := 'aeiou';\n  var res := new List<string>;\n  \n  foreach var str in strings do\n  begin\n    var vowelCount := 0;\n    foreach var ch in str do\n      if ch.ToLower in vowels then\n        vowelCount += 1;\n    \n    if vowelCount >= 2 then\n      res.Add(str);\n  end;\n  \n  Result := res.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the shortest subarray that, if sorted, would result in the entire array being sorted. If the array is already sorted, return 0.",
    "output": "function ShortestUnsortedContinuousSubarray(nums: array of integer): integer;\nbegin\n  var sortedNums := nums.ToList;\n  sortedNums.Sort;\n  \n  var startIndex := -1;\n  var endIndex := -1;\n  \n  for var i := 0 to nums.Length - 1 do\n  begin\n    if nums[i] <> sortedNums[i] then\n    begin\n      if startIndex = -1 then\n        startIndex := i;\n      endIndex := i;\n    end;\n  end;\n  \n  if startIndex = -1 then\n    Result := 0\n  else\n    Result := endIndex - startIndex + 1;\nend;"
  },
  {
    "instruction": "Write a function to find the number of unique anagrams in a given list of strings.",
    "output": "function CountAnagrams(strs: array of string): integer;\nbegin\n  var tmp := new List<string>;\n  foreach var str in strs do\n  begin\n    var chars := str.ToCharArray;\n    &Array.Sort(chars);\n    tmp.Add(string.Join('', chars));\n  end;\n  \n  var hashmap := new Dictionary<string, integer>;\n  foreach var str in tmp do\n    if hashmap.ContainsKey(str) then\n      hashmap[str] += 1\n    else\n      hashmap.Add(str, 1);\n  \n  Result := hashmap.Count;\nend;"
  },
  {
    "instruction": "Write a function that takes in a list of integers and returns a new list where every element is the product of every other element in the original list. You cannot use division in your solution.",
    "output": "function ProductOfOtherElements(nums: array of integer): array of integer;\nbegin\n  var length := nums.Length;\n  var answer := new integer[length];\n  for var i := 0 to length - 1 do\n    answer[i] := 1;\n  \n  var left := 1;\n  for var i := 0 to length - 1 do\n  begin\n    answer[i] *= left;\n    left *= nums[i];\n  end;\n  \n  var right := 1;\n  for var i := length - 1 downto 0 do\n  begin\n    answer[i] *= right;\n    right *= nums[i];\n  end;\n  \n  Result := answer;\nend;"
  },
  {
    "instruction": "Write a function to determine if a string is a valid number. A valid number can be an integer, a floating-point number, or a number in scientific notation.",
    "output": "function IsValidNumber(s: string): boolean;\nbegin\n  try\n    if s.ToLower.Replace('.', '', 1).Replace('e', '', 1).All(ch -> ch.IsDigit) then\n    begin\n      var dummy := StrToFloat(s);\n      Result := True;\n    end\n    else\n      Result := False;\n  except\n    Result := False;\n  end;\nend;"
  },
  {
    "instruction": "Write a function that accepts two lists of lists (2D lists) and returns a new 2D list that is the result of adding the corresponding elements of each list. If the lists are not of equal size, the function should return nil.",
    "output": "type IntArray = array of integer;\n\nfunction Add2DLists(list1, list2: array of array of integer): array of array of integer;\nbegin\n  if list1.Length <> list2.Length then\n  begin\n    Result := nil;\n    exit;\n  end;\n  \n  var res := new IntArray[list1.Length];\n  \n  for var i := 0 to list1.Length - 1 do\n  begin\n    if list1[i].Length <> list2[i].Length then\n    begin\n      Result := nil;\n      exit;\n    end;\n    \n    res[i] := new integer[list1[i].Length];\n    for var j := 0 to list1[i].Length - 1 do\n      res[i][j] := list1[i][j] + list2[i][j];\n  end;\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to make up a certain amount (total) by adding the given coin denominations. You can assume that you have an infinite number of each kind of coin.",
    "output": "function CoinChange(total: integer; coins: array of integer): integer;\nbegin\n  var dp := new integer[total + 1];\n  dp[0] := 1;\n  \n  foreach var coin in coins do\n    for var x := coin to total do\n      dp[x] += dp[x - coin];\n  \n  Result := dp[total];\nend;"
  },
  {
    "instruction": "Write a function to find the largest number smaller than the given number n, with the same set of digits as n.",
    "output": "function PrevPermutation(n: integer): integer;\nbegin\n  var digits := n.ToString.ToCharArray.ToList;\n  var i := digits.Count - 2;\n  \n  while (i >= 0) and (digits[i] <= digits[i + 1]) do\n    i -= 1;\n  \n  if i < 0 then\n  begin\n    Result := -1;\n    exit;\n  end;\n  \n  var j := digits.Count - 1;\n  while digits[j] >= digits[i] do\n    j -= 1;\n  \n  var temp := digits[i];\n  digits[i] := digits[j];\n  digits[j] := temp;\n  \n  var rest := digits.GetRange(i + 1, digits.Count - i - 1);\n  rest.Reverse;\n  digits.RemoveRange(i + 1, digits.Count - i - 1);\n  digits.AddRange(rest);\n  \n  Result := StrToInt(string.Join('', digits));\nend;"
  },
  {
    "instruction": "Write a function to find the deepest node in a binary tree.",
    "output": "type\n  TreeNode = class\n    val: integer;\n    left, right: TreeNode;\n    \n    constructor Create(v: integer; l: TreeNode := nil; r: TreeNode := nil);\n    begin\n      val := v;\n      left := l;\n      right := r;\n    end;\n  end;\n\nfunction DeepestNode(root: TreeNode): integer;\n\n  procedure DFS(node: TreeNode; depth: integer; var deepest: (integer, integer));\n  begin\n    if node = nil then\n      exit;\n    \n    if depth > deepest[1] then\n      deepest := (node.val, depth);\n    \n    DFS(node.left, depth + 1, deepest);\n    DFS(node.right, depth + 1, deepest);\n  end;\n\nbegin\n  var deepest := (root.val, 0);\n  DFS(root, 0, deepest);\n  Result := deepest[0];\nend;"
  },
  {
    "instruction": "Write a function to find the largest rectangle containing only 1's in a binary matrix.",
    "output": "function MaxRectangle(matrix: array [,] of integer): integer;\nbegin\n  if matrix.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var m := matrix.GetLength(0);\n  var n := matrix.GetLength(1);\n  var height := new integer[n + 1];\n  var maxArea := 0;\n  \n  for var i := 0 to m - 1 do\n  begin\n    var stack := new Stack<integer>;\n    stack.Push(-1);\n    \n    for var j := 0 to n do\n    begin\n      if j < n then\n        height[j] := if matrix[i, j] = 1 then height[j] + 1 else 0;\n      \n      while (stack.Count > 1) and (height[j] < height[stack.Peek]) do\n      begin\n        var h := height[stack.Pop];\n        var w := j - 1 - stack.Peek;\n        maxArea := Max(maxArea, h * w);\n      end;\n      stack.Push(j);\n    end;\n  end;\n  \n  Result := maxArea;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to split a string into two parts so that each part contains the same number of distinct characters.",
    "output": "function NumSplits(s: string): integer;\nbegin\n  var counts := new Dictionary<char, integer>;\n  foreach var c in s do\n    if counts.ContainsKey(c) then\n      counts[c] += 1\n    else\n      counts.Add(c, 1);\n  \n  var n := counts.Count;\n  var total := 0;\n  var m := 0;\n  var st := new HashSet<char>;\n  \n  foreach var c in s do\n  begin\n    counts[c] -= 1;\n    if counts[c] = 0 then\n      n -= 1;\n    \n    if not st.Contains(c) then\n    begin\n      m += 1;\n      st.Add(c);\n    end;\n    \n    if n = m then\n      total += 1;\n  end;\n  \n  Result := total;\nend;"
  },
  {
    "instruction": "Write a function that counts the number of palindrome substrings in a given string.",
    "output": "function CountPalindromeSub(s: string): integer;\nbegin\n  var n := s.Length;\n  var palindromeCount := 0;\n  \n  for var center := 0 to 2 * n - 2 do\n  begin\n    var left := center div 2;\n    var right := left + center mod 2;\n    \n    while (left >= 0) and (right < n) and (s[left + 1] = s[right + 1]) do\n    begin\n      palindromeCount += 1;\n      left -= 1;\n      right += 1;\n    end;\n  end;\n  \n  Result := palindromeCount;\nend;"
  },
  {
    "instruction": "Write a function to generate the nth number in the Smooth Number sequence, also known as Hamming numbers. A Hamming number is a positive integer of the form 2^i * 3^j * 5^k, where i, j, and k are non-negative integers.",
    "output": "function Hamming(n: integer): integer;\nbegin\n  var seq := new List<integer>;\n  seq.Add(1);\n  \n  var ptr2 := 0;\n  var ptr3 := 0;\n  var ptr5 := 0;\n  \n  for var i := 1 to n - 1 do\n  begin\n    var next2 := 2 * seq[ptr2];\n    var next3 := 3 * seq[ptr3];\n    var next5 := 5 * seq[ptr5];\n    var nextHamming := Min(next2, Min(next3, next5));\n    \n    seq.Add(nextHamming);\n    \n    if nextHamming = next2 then\n      ptr2 += 1;\n    if nextHamming = next3 then\n      ptr3 += 1;\n    if nextHamming = next5 then\n      ptr5 += 1;\n  end;\n  \n  Result := seq[n - 1];\nend;"
  },
  {
    "instruction": "Write a function to calculate the total number of vowels in a given string.",
    "output": "function TotalVowels(str: string): integer;\nbegin\n  var vowels := 'aeiouAEIOU';\n  var count := 0;\n  foreach var ch in str do\n    if ch in vowels then\n      count += 1;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the number of connected servers in a network. A server is considered connected if there are other servers in the same row or column. You are given a grid representing the network where 1 represents a server and 0 represents an empty space.",
    "output": "function CountServers(grid: array [,] of integer): integer;\nbegin\n  var rows := new Dictionary<integer, HashSet<integer>>;\n  var cols := new Dictionary<integer, HashSet<integer>>;\n  var m := grid.GetLength(0);\n  var n := grid.GetLength(1);\n  \n  for var i := 0 to m - 1 do\n    for var j := 0 to n - 1 do\n      if grid[i, j] = 1 then\n      begin\n        if not rows.ContainsKey(i) then\n          rows.Add(i, new HashSet<integer>);\n        rows[i].Add(j);\n        \n        if not cols.ContainsKey(j) then\n          cols.Add(j, new HashSet<integer>);\n        cols[j].Add(i);\n      end;\n  \n  var ans := 0;\n  for var i := 0 to m - 1 do\n    for var j := 0 to n - 1 do\n      if grid[i, j] = 1 then\n        if (rows[i].Count >= 2) or (cols[j].Count >= 2) then\n          ans += 1;\n  \n  Result := ans;\nend;"
  },
  {
    "instruction": "Write a function to count the number of ways to place N queens on an N\u00d7N chessboard so that they are all in different rows and columns.",
    "output": "function CountNQueens(n: integer): integer;\n\n  function Backtracking(row: integer; columns: array of integer; var counts: integer): boolean;\n  \n    function Check(row, col: integer; columns: array of integer): boolean;\n    begin\n      for var r := 0 to row - 1 do\n        if (columns[r] = col) or (row - r = Abs(columns[r] - col)) then\n        begin\n          Result := False;\n          exit;\n        end;\n      Result := True;\n    end;\n\n  begin\n    if row = n then\n    begin\n      counts += 1;\n      Result := True;\n      exit;\n    end;\n    \n    for var col := 0 to n - 1 do\n    begin\n      columns[row] := col;\n      if Check(row, col, columns) then\n        Backtracking(row + 1, columns, counts)\n      else\n        columns[row] := -1;\n    end;\n    Result := False;\n  end;\n\nbegin\n  var counts := 0;\n  var columns := new integer[n];\n  for var i := 0 to n - 1 do\n    columns[i] := -1;\n  \n  Backtracking(0, columns, counts);\n  Result := counts;\nend;"
  },
  {
    "instruction": "Write a function to find the lexicographical order of permutation for a given string.",
    "output": "function PermutationLexico(s: string): array of string;\n\n  procedure GeneratePermutations(chars: array of char; start: integer; var res: List<string>);\n  begin\n    if start = chars.Length then\n    begin\n      res.Add(string.Join('', chars));\n      exit;\n    end;\n    \n    for var i := start to chars.Length - 1 do\n    begin\n      var temp := chars[start];\n      chars[start] := chars[i];\n      chars[i] := temp;\n      \n      GeneratePermutations(chars, start + 1, res);\n      \n      temp := chars[start];\n      chars[start] := chars[i];\n      chars[i] := temp;\n    end;\n  end;\n\nbegin\n  var res := new List<string>;\n  var chars := s.ToCharArray;\n  GeneratePermutations(chars, 0, res);\n  res.Sort;\n  Result := res.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number by swapping two digits of the given integer.",
    "output": "function MaxNumberBySwap(num: integer): integer;\nbegin\n  var numList := num.ToString.ToCharArray.ToList;\n  var maxNum := num;\n  \n  for var i := 0 to numList.Count - 1 do\n  begin\n    for var j := i + 1 to numList.Count - 1 do\n    begin\n      var temp := numList[i];\n      numList[i] := numList[j];\n      numList[j] := temp;\n      \n      var currentNum := StrToInt(string.Join('', numList));\n      maxNum := Max(maxNum, currentNum);\n      \n      temp := numList[i];\n      numList[i] := numList[j];\n      numList[j] := temp;\n    end;\n  end;\n  \n  Result := maxNum;\nend;"
  },
  {
    "instruction": "Create a function to find the number of distinct integers in a given list. The function should return the count of unique integers in the list.",
    "output": "function CountUniqueIntegers(nums: array of integer): integer;\nbegin\n  var uniqueIntegers := new HashSet<integer>(nums);\n  Result := uniqueIntegers.Count;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest string chain that can be built from the given list of words. A string chain is a sequence of words [word_1, word_2, ..., word_k] with k >= 1, where word_1 is a predecessor of word_2, word_2 is a predecessor of word_3, and so on. A word A is a predecessor of B if and only if we can insert exactly one letter anywhere in A without changing the order of the other characters to make it equal to B.",
    "output": "function IsPredecessor(w1, w2: string): boolean;\nbegin\n  for var i := 1 to w2.Length do\n    if w1 = (w2.Substring(0, i - 1) + w2.Substring(i)) then\n    begin\n      Result := True;\n      exit;\n    end;\n  Result := False;\nend;\n\nfunction LongestChain(words: array of string): integer;\nbegin\n  if words.Length = 1 then\n  begin\n    Result := 1;\n    exit;\n  end;\n  \n  var wordList := words.ToList;\n  wordList.Sort((x, y) -> x.Length.CompareTo(y.Length));\n  \n  var dp := new integer[wordList.Count];\n  for var i := 0 to wordList.Count - 1 do\n    dp[i] := 1;\n  \n  for var i := 1 to wordList.Count - 1 do\n    for var j := 0 to i - 1 do\n      if IsPredecessor(wordList[j], wordList[i]) then\n        dp[i] := Max(dp[i], dp[j] + 1);\n  \n  Result := dp.Max;\nend;"
  },
  {
    "instruction": "Write a function to find the number of consecutive characters in a string that are the same.",
    "output": "function ConsecutiveCharacters(s: string): List<(integer, char)>;\nbegin\n  var res := new List<(integer, char)>;\n  if s.Length = 0 then\n  begin\n    Result := res;\n    exit;\n  end;\n  \n  var count := 1;\n  for var i := 1 to s.Length - 1 do\n  begin\n    if s[i + 1] = s[i] then\n      count += 1\n    else\n    begin\n      res.Add((count, s[i]));\n      count := 1;\n    end;\n  end;\n  res.Add((count, s[s.Length]));\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function that finds the smallest index of a unique character in a given string. If there are no unique characters, return -1.",
    "output": "function SmallestUniqueIndex(s: string): integer;\nbegin\n  var charCount := new Dictionary<char, integer>;\n  foreach var c in s do\n    if charCount.ContainsKey(c) then\n      charCount[c] += 1\n    else\n      charCount.Add(c, 1);\n  \n  for var i := 1 to s.Length do\n    if charCount[s[i]] = 1 then\n    begin\n      Result := i - 1;\n      exit;\n    end;\n  \n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function that finds the longest valid parentheses in a given string. The function should return the length of the longest valid parentheses substring.",
    "output": "function LongestValidParentheses(s: string): integer;\nbegin\n  var maxLen := 0;\n  var stack := new Stack<integer>;\n  stack.Push(-1);\n  \n  for var i := 1 to s.Length do\n  begin\n    if s[i] = '(' then\n      stack.Push(i - 1)\n    else\n    begin\n      stack.Pop;\n      if stack.Count = 0 then\n        stack.Push(i - 1)\n      else\n        maxLen := Max(maxLen, i - 1 - stack.Peek);\n    end;\n  end;\n  \n  Result := maxLen;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to reach the top row of a checkerboard. The checkerboard is a 2 x N board with N columns and 2 rows.",
    "output": "function CheckerboardWays(n: integer): integer;\nbegin\n  if n = 1 then\n    Result := 1\n  else if n = 2 then\n    Result := 2\n  else\n  begin\n    var a := 1;\n    var b := 2;\n    for var i := 3 to n do\n    begin\n      var temp := a + b;\n      a := b;\n      b := temp;\n    end;\n    Result := b;\n  end;\nend;"
  },
  {
    "instruction": "Write a function that takes a string as an input and returns a list of words in that string, sorted in descending order by length. If two words have the same length, they should be sorted alphabetically.",
    "output": "function SortWords(sentence: string): array of string;\nbegin\n  var words := sentence.Split(' ').ToList;\n  words.Sort((x, y) -> \n    begin\n      if x.Length <> y.Length then\n        Result := y.Length.CompareTo(x.Length)\n      else\n        Result := x.CompareTo(y);\n    end);\n  Result := words.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to convert a list of integers into a single integer by concatenating the digits they represent.",
    "output": "function ListToInt(lst: array of integer): integer;\nbegin\n  var str := '';\n  foreach var num in lst do\n    str += num.ToString;\n  Result := StrToInt(str);\nend;"
  },
  {
    "instruction": "Write a function to find the smallest repeating pattern within a string and return the number of times the pattern is repeated to form the original string. If no repeating pattern exists, return 1.",
    "output": "function FindRepeatingPattern(s: string): integer;\nbegin\n  for var i := 1 to s.Length div 2 do\n    if s.Length mod i = 0 then\n      if s.Substring(0, i) * (s.Length div i) = s then\n      begin\n        Result := s.Length div i;\n        exit;\n      end;\n  Result := 1;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum size of a square sub-matrix with all 1s.",
    "output": "function MaxSizeSquareSubmatrix(matrix: array [,] of integer): integer;\nbegin\n  var rows := matrix.GetLength(0);\n  var cols := matrix.GetLength(1);\n  var dp := new integer[rows, cols];\n  var maxSize := 0;\n  \n  for var i := 0 to rows - 1 do\n    for var j := 0 to cols - 1 do\n      if matrix[i, j] = 1 then\n      begin\n        dp[i, j] := 1;\n        if (i > 0) and (j > 0) then\n          dp[i, j] := Min(dp[i-1, j], Min(dp[i, j-1], dp[i-1, j-1])) + 1;\n        maxSize := Max(maxSize, dp[i, j]);\n      end;\n  \n  Result := maxSize;\nend;"
  },
  {
    "instruction": "Write a function to find the largest range of consecutive integers in a list of numbers. The range should be returned as a list with two elements, where the first element is the starting number of the range and the second is the ending number. If there are multiple ranges of the same length, return the one with the smallest starting number.",
    "output": "function FindLargestConsecutiveRange(nums: array of integer): array of integer;\nbegin\n  if nums.Length = 0 then\n  begin\n    Result := new integer[0];\n    exit;\n  end;\n  \n  var numSet := new HashSet<integer>(nums);\n  var longestRange := new integer[2];\n  var longestLength := 0;\n  \n  foreach var num in numSet do\n  begin\n    if not numSet.Contains(num - 1) then\n    begin\n      var currentLength := 1;\n      var currentNum := num;\n      \n      while numSet.Contains(currentNum + 1) do\n      begin\n        currentNum += 1;\n        currentLength += 1;\n      end;\n      \n      if currentLength > longestLength then\n      begin\n        longestLength := currentLength;\n        longestRange[0] := num;\n        longestRange[1] := currentNum;\n      end;\n    end;\n  end;\n  \n  Result := longestRange;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns a list of indices where the corresponding elements are prime numbers.",
    "output": "function PrimeIndices(nums: array of integer): array of integer;\n\n  function IsPrime(n: integer): boolean;\n  begin\n    if n <= 1 then\n      Result := False\n    else if n = 2 then\n      Result := True\n    else if n mod 2 = 0 then\n      Result := False\n    else\n    begin\n      var i := 3;\n      while i * i <= n do\n      begin\n        if n mod i = 0 then\n        begin\n          Result := False;\n          exit;\n        end;\n        i += 2;\n      end;\n      Result := True;\n    end;\n  end;\n\nbegin\n  var res := new List<integer>;\n  for var i := 0 to nums.Length - 1 do\n    if IsPrime(nums[i]) then\n      res.Add(i);\n  Result := res.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum area of a rectangle formed by vertical lines with given widths.",
    "output": "function MaxArea(height: array of integer): integer;\nbegin\n  var maxArea := 0;\n  var left := 0;\n  var right := height.Length - 1;\n  \n  while left < right do\n  begin\n    maxArea := Max(maxArea, Min(height[left], height[right]) * (right - left));\n    if height[left] > height[right] then\n      right -= 1\n    else\n      left += 1;\n  end;\n  \n  Result := maxArea;\nend;"
  },
  {
    "instruction": "Write a function to count the number of pairs (i, j) in a given list such that list[i] == list[j] and i < j.",
    "output": "function CountEqualPairs(arr: array of integer): integer;\nbegin\n  var count := 0;\n  for var i := 0 to arr.Length - 1 do\n    for var j := i + 1 to arr.Length - 1 do\n      if arr[i] = arr[j] then\n        count += 1;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the number that appears only once in an array where every other number appears exactly three times.",
    "output": "function SingleNumberThreeTimes(nums: array of integer): integer;\nbegin\n  var ones := 0;\n  var twos := 0;\n  \n  foreach var n in nums do\n  begin\n    ones := (ones xor n) and not twos;\n    twos := (twos xor n) and not ones;\n  end;\n  \n  Result := ones;\nend;"
  },
  {
    "instruction": "Write a function to find the n-th Fibonacci number that is also prime.",
    "output": "function PrimeFib(n: integer): integer;\n\n  function CheckPrime(num: integer): boolean;\n  begin\n    if num <= 1 then\n      Result := False\n    else if num = 2 then\n      Result := True\n    else if num mod 2 = 0 then\n      Result := False\n    else\n    begin\n      var i := 3;\n      while i * i <= num do\n      begin\n        if num mod i = 0 then\n        begin\n          Result := False;\n          exit;\n        end;\n        i += 2;\n      end;\n      Result := True;\n    end;\n  end;\n\n  function Fib(k: integer): integer;\n  begin\n    if k <= 1 then\n      Result := k\n    else\n    begin\n      var a := 0;\n      var b := 1;\n      for var i := 2 to k do\n      begin\n        var temp := a + b;\n        a := b;\n        b := temp;\n      end;\n      Result := b;\n    end;\n  end;\n\nbegin\n  var i := 0;\n  var count := 0;\n  while True do\n  begin\n    var fib_i := Fib(i);\n    if CheckPrime(fib_i) then\n    begin\n      count += 1;\n      if count = n then\n      begin\n        Result := fib_i;\n        exit;\n      end;\n    end;\n    i += 1;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to count the number of occurrences of a given key in a nested dictionary.",
    "output": "procedure CountInDict(dict: Dictionary<object, object>; key: string; var count: integer);\nbegin\n  foreach var pair in dict do\n  begin\n    if pair.Key.ToString = key then\n      count += 1;\n    \n    if pair.Value is Dictionary<object, object> then\n      CountInDict(Dictionary&<object, object>(pair.Value), key, count);\n  end;\nend;\n\nfunction CountKeyOccurrences(key: string; dictionary: Dictionary<object, object>): integer;\nbegin\n  var count := 0;\n  CountInDict(dictionary, key, count);\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to determine if a string is a valid IPv6 address.",
    "output": "function IsValidIPv6(ip: string): boolean;\nbegin\n  var groups := ip.Split(':');\n  if groups.Length <> 8 then\n  begin\n    Result := False;\n    exit;\n  end;\n  \n  var hexDigits := '0123456789abcdefABCDEF';\n  \n  foreach var group in groups do\n  begin\n    if (group.Length = 0) or (group.Length > 4) then\n    begin\n      Result := False;\n      exit;\n    end;\n    \n    foreach var ch in group do\n      if not hexDigits.Contains(ch) then\n      begin\n        Result := False;\n        exit;\n      end;\n  end;\n  \n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function `fruit_distribution` that takes a list of tuples, where each tuple represents the quantity of a specific type of fruit in a basket, and returns a dictionary with the total quantity of each fruit type.",
    "output": "function FruitDistribution(fruits: array of (integer, string)): Dictionary<string, integer>;\nbegin\n  var fruitDict := new Dictionary<string, integer>;\n  \n  foreach var (quantity, fruit) in fruits do\n    if fruitDict.ContainsKey(fruit) then\n      fruitDict[fruit] += quantity\n    else\n      fruitDict.Add(fruit, quantity);\n  \n  Result := fruitDict;\nend;"
  },
  {
    "instruction": "Write a function to check if a given list of numbers is a strictly increasing arithmetic sequence.",
    "output": "function IsStrictlyIncreasingArithmetic(arr: array of integer): boolean;\nbegin\n  if arr.Length <= 1 then\n  begin\n    Result := True;\n    exit;\n  end;\n  \n  var diff := arr[1] - arr[0];\n  for var i := 2 to arr.Length - 1 do\n    if arr[i] - arr[i - 1] <> diff then\n    begin\n      Result := False;\n      exit;\n    end;\n  \n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function to find the second largest and second smallest number in an array.",
    "output": "function SecondLargestSmallest(arr: array of integer): (integer, integer);\nbegin\n  var uniqueArr := arr.Distinct.ToList;\n  if uniqueArr.Count < 2 then\n  begin\n    Result := (-1, -1);\n    exit;\n  end;\n  \n  uniqueArr.Sort;\n  Result := (uniqueArr[uniqueArr.Count - 2], uniqueArr[1]);\nend;"
  },
  {
    "instruction": "Write a function to find the first and last index of a given number in a sorted list.",
    "output": "function Indexes(nums: array of integer; target: integer): (integer, integer);\n\n  function FindLeft(arr: array of integer; t: integer): integer;\n  begin\n    var left := 0;\n    var right := arr.Length - 1;\n    while left <= right do\n    begin\n      var mid := (left + right) div 2;\n      if arr[mid] < t then\n        left := mid + 1\n      else\n        right := mid - 1;\n    end;\n    if (left < arr.Length) and (arr[left] = t) then\n      Result := left\n    else\n      Result := -1;\n  end;\n\n  function FindRight(arr: array of integer; t: integer): integer;\n  begin\n    var left := 0;\n    var right := arr.Length - 1;\n    while left <= right do\n    begin\n      var mid := (left + right) div 2;\n      if arr[mid] <= t then\n        left := mid + 1\n      else\n        right := mid - 1;\n    end;\n    if (right >= 0) and (arr[right] = t) then\n      Result := right\n    else\n      Result := -1;\n  end;\n\nbegin\n  var leftIndex := FindLeft(nums, target);\n  var rightIndex := FindRight(nums, target);\n  Result := (leftIndex, rightIndex);\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings and returns a list of tuples. Each tuple should contain the string from the input list and the length of that string.",
    "output": "function StrLength(strings: array of string): array of (string, integer);\nbegin\n  var res := new List<(string, integer)>();\n  for var i := 0 to strings.Length - 1 do\n    res.Add((strings[i], strings[i].Length));\n  Result := res.ToArray();\nend;"
  },
  {
    "instruction": "Write a function to check if the given list of integers has unique occurrences of each integer.",
    "output": "function UniqueOccurrences(arr: array of integer): boolean;\nbegin\n  var counts := new Dictionary<integer, integer>;\n  foreach var a in arr do\n    if counts.ContainsKey(a) then\n      counts[a] += 1\n    else\n      counts.Add(a, 1);\n  \n  var valueSet := new HashSet<integer>(counts.Values);\n  Result := valueSet.Count = counts.Count;\nend;"
  },
  {
    "instruction": "Write a function to split a given string into a list of substrings, alternatingly taking characters from the first and the second string. If one string is longer than the other, append the remaining characters of the longer string to the result.",
    "output": "function SplitAlternately(word1, word2: string): array of string;\nbegin\n  var m := word1.Length;\n  var n := word2.Length;\n  var i := 0;\n  var j := 0;\n  var split := new List<string>;\n  \n  while (i < m) and (j < n) do\n  begin\n    split.Add(word1[i + 1].ToString);\n    split.Add(word2[j + 1].ToString);\n    i += 1;\n    j += 1;\n  end;\n  \n  if i = m then\n    for var k := j to n - 1 do\n      split.Add(word2[k + 1].ToString)\n  else\n    for var k := i to m - 1 do\n      split.Add(word1[k + 1].ToString);\n  \n  Result := split.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the common characters among a list of strings.",
    "output": "function CommonChars(words: array of string): array of char;\nbegin\n  if words.Length = 0 then\n  begin\n    Result := new char[0];\n    exit;\n  end;\n  \n  var counter := new List<Dictionary<char, integer>>;\n  foreach var word in words do\n  begin\n    var dict := new Dictionary<char, integer>;\n    foreach var ch in word do\n      if dict.ContainsKey(ch) then\n        dict[ch] += 1\n      else\n        dict.Add(ch, 1);\n    counter.Add(dict);\n  end;\n  \n  var common := counter[0];\n  for var i := 1 to counter.Count - 1 do\n  begin\n    var newCommon := new Dictionary<char, integer>;\n    foreach var pair in common do\n      if counter[i].ContainsKey(pair.Key) then\n        newCommon.Add(pair.Key, Min(pair.Value, counter[i][pair.Key]));\n    common := newCommon;\n  end;\n  \n  var res := new List<char>;\n  foreach var pair in common do\n    for var i := 1 to pair.Value do\n      res.Add(pair.Key);\n  \n  Result := res.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest repeating cycle in a given string. The function should return the length of the smallest repeating cycle, if the cycle does not exist, return -1.",
    "output": "function SmallestRepeatingCycle(s: string): integer;\nbegin\n  for var i := 1 to s.Length div 2 do\n    if s.Length mod i = 0 then\n      if s.Substring(0, i) * (s.Length div i) = s then\n      begin\n        Result := i;\n        exit;\n      end;\n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of words and returns a list of words that can be typed using letters of only one row of the American keyboard layout.",
    "output": "function IsOneRow(word: string): boolean;\nbegin\n  var row1 := 'qwertyuiop';\n  var row2 := 'asdfghjkl';\n  var row3 := 'zxcvbnm';\n  \n  var lowerWord := word.ToLower;\n  if lowerWord.All(ch -> row1.Contains(ch)) then\n    Result := True\n  else if lowerWord.All(ch -> row2.Contains(ch)) then\n    Result := True\n  else if lowerWord.All(ch -> row3.Contains(ch)) then\n    Result := True\n  else\n    Result := False;\nend;\n\nfunction FindOneRowWords(words: array of string): array of string;\nbegin\n  var res := new List<string>;\n  foreach var word in words do\n    if IsOneRow(word) then\n      res.Add(word);\n  Result := res.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the number of permutations of a given string.",
    "output": "function FindPermutation(s: string): integer;\nbegin\n  var charCounts := new Dictionary<char, integer>;\n  foreach var ch in s do\n    if charCounts.ContainsKey(ch) then\n      charCounts[ch] += 1\n    else\n      charCounts.Add(ch, 1);\n  \n  var denom := 1;\n  foreach var count in charCounts.Values do\n  begin\n    var fact := 1;\n    for var i := 2 to count do\n      fact *= i;\n    denom *= fact;\n  end;\n  \n  var numerator := 1;\n  for var i := 2 to s.Length do\n    numerator *= i;\n  \n  Result := numerator div denom;\nend;"
  },
  {
    "instruction": "Write a function that checks if the occurrences of each character in a string are equal.",
    "output": "function AreOccurrencesEqual(s: string): boolean;\nbegin\n  var sortedS := s.ToCharArray.ToList;\n  sortedS.Sort;\n  \n  var length := -1;\n  var currentChar := sortedS[0];\n  var currentCount := 1;\n  \n  for var i := 1 to sortedS.Count - 1 do\n  begin\n    if sortedS[i] = currentChar then\n      currentCount += 1\n    else\n    begin\n      if length = -1 then\n        length := currentCount\n      else if currentCount <> length then\n      begin\n        Result := False;\n        exit;\n      end;\n      \n      currentChar := sortedS[i];\n      currentCount := 1;\n    end;\n  end;\n  \n  Result := (currentCount = length) or (length = -1);\nend;"
  },
  {
    "instruction": "Write a function that takes a list of numbers as input and returns the integer that appears an odd number of times in the list. It is guaranteed that there is exactly one such integer.",
    "output": "function FindOddInteger(lst: array of integer): integer;\nbegin\n  var numDict := new Dictionary<integer, integer>;\n  foreach var num in lst do\n    if numDict.ContainsKey(num) then\n      numDict[num] += 1\n    else\n      numDict.Add(num, 1);\n  \n  foreach var pair in numDict do\n    if pair.Value mod 2 <> 0 then\n    begin\n      Result := pair.Key;\n      exit;\n    end;\n  \n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to make change for a target amount using a given set of coin denominations. You may assume that you have an infinite number of coins of each denomination.",
    "output": "function Change(amount: integer; coins: array of integer): integer;\nbegin\n  var rows := coins.Length + 1;\n  var cols := amount + 1;\n  var cache := new integer[rows, cols];\n  \n  for var i := 0 to cols - 1 do\n    cache[0, i] := 0;\n  \n  for var i := 0 to rows - 1 do\n    cache[i, 0] := 1;\n  \n  for var i := 1 to rows - 1 do\n  begin\n    var coin := coins[i - 1];\n    for var target := 1 to amount do\n    begin\n      cache[i, target] := cache[i - 1, target];\n      var residual := target - coin;\n      if residual >= 0 then\n        cache[i, target] += cache[i, residual];\n    end;\n  end;\n  \n  Result := cache[rows - 1, cols - 1];\nend;"
  },
  {
    "instruction": "Write a function to find the longest word in a list of words, where every word in the list is a prefix of the next word. If there are multiple words with the same length, return the one that appears first in the list.",
    "output": "function LongestPrefixWord(words: array of string): string;\nbegin\n  if words.Length = 0 then\n  begin\n    Result := '';\n    exit;\n  end;\n  \n  var wordList := words.ToList;\n  wordList.Sort;\n  \n  var longestWord := wordList[0];\n  var hold := wordList[0];\n  \n  for var i := 1 to wordList.Count - 1 do\n  begin\n    if wordList[i].StartsWith(hold) then\n    begin\n      if wordList[i].Length >= longestWord.Length then\n        longestWord := wordList[i];\n      hold := wordList[i];\n    end\n    else\n      hold := wordList[i];\n  end;\n  \n  Result := longestWord;\nend;"
  },
  {
    "instruction": "Write a function to find the largest continuous sum in a list of integers.",
    "output": "function FindLargestContinuousSum(arr: array of integer): integer;\nbegin\n  if arr.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var maxSum := arr[0];\n  var currentSum := arr[0];\n  \n  for var i := 1 to arr.Length - 1 do\n  begin\n    currentSum := Max(currentSum + arr[i], arr[i]);\n    maxSum := Max(maxSum, currentSum);\n  end;\n  \n  Result := maxSum;\nend;"
  },
  {
    "instruction": "Write a function to calculate the shortest path from a source node to a destination node in a graph, given a list of flights with their respective prices, within a certain number of stops.",
    "output": "function FindCheapestPrice(n: integer; flights: array of (integer, integer, integer); src, dst, K: integer): integer;\nbegin\n  var dic := new Dictionary<integer, List<(integer, integer)>>;\n  foreach var (s, d, p) in flights do\n  begin\n    if not dic.ContainsKey(s) then\n      dic.Add(s, new List<(integer, integer)>);\n    dic[s].Add((d, p));\n  end;\n  \n  var visited := new Dictionary<integer, Dictionary<integer, integer>>;\n  var h := new List<(integer, integer, integer)>;\n  h.Add((0, src, 0));\n  \n  while h.Count > 0 do\n  begin\n    h.Sort((x, y) -> x[0].CompareTo(y[0]));\n    var (time, cur, count) := h[0];\n    h.RemoveAt(0);\n    \n    if cur = dst then\n    begin\n      Result := time;\n      exit;\n    end;\n    \n    if count = K + 1 then\n      continue;\n    \n    if dic.ContainsKey(cur) then\n    begin\n      foreach var (nei, t) in dic[cur] do\n      begin\n        var newTime := time + t;\n        var newCount := count + 1;\n        \n        if (not visited.ContainsKey(nei)) or (not visited[nei].ContainsKey(newCount)) or (visited[nei][newCount] > newTime) then\n        begin\n          if not visited.ContainsKey(nei) then\n            visited.Add(nei, new Dictionary<integer, integer>);\n          visited[nei][newCount] := newTime;\n          h.Add((newTime, nei, newCount));\n        end;\n      end;\n    end;\n  end;\n  \n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to perform the calculation of the difference between the maximum and minimum elements in a given list of integers.",
    "output": "function CalculateDifference(testList: array of integer): integer;\nbegin\n  Result := testList.Max - testList.Min;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns a dictionary where the keys are the integers and the values are the number of times each integer appears in the list.",
    "output": "function CountElements(nums: array of integer): Dictionary<integer, integer>;\nbegin\n  var countDict := new Dictionary<integer, integer>;\n  foreach var num in nums do\n    if countDict.ContainsKey(num) then\n      countDict[num] += 1\n    else\n      countDict.Add(num, 1);\n  Result := countDict;\nend;"
  },
  {
    "instruction": "Write a function that finds the smallest common boss of two employees in a company structure. The company structure is represented as a tree where each node represents an employee and its parent represents the boss.",
    "output": "type\n  TreeNode = class\n    val: string;\n    parent: TreeNode;\n    \n    constructor Create(v: string; p: TreeNode := nil);\n    begin\n      val := v;\n      parent := p;\n    end;\n  end;\n\nfunction FindSmallestBoss(employees: array of TreeNode; employee1, employee2: string): string;\nbegin\n  var m := new Dictionary<string, TreeNode>;\n  foreach var e in employees do\n    m.Add(e.val, e.parent);\n  \n  var path1 := new List<string>;\n  var current1 := employee1;\n  while m.ContainsKey(current1) and (m[current1] <> nil) do\n  begin\n    path1.Add(current1);\n    current1 := m[current1].val;\n  end;\n  path1.Add(current1);\n  \n  var path2 := new List<string>;\n  var current2 := employee2;\n  while m.ContainsKey(current2) and (m[current2] <> nil) do\n  begin\n    path2.Add(current2);\n    current2 := m[current2].val;\n  end;\n  path2.Add(current2);\n  \n  path1.Reverse;\n  path2.Reverse;\n  \n  var prev := '';\n  for var i := 0 to Min(path1.Count, path2.Count) - 1 do\n  begin\n    if path1[i] <> path2[i] then\n      break;\n    prev := path1[i];\n  end;\n  \n  Result := prev;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the last word in a string.",
    "output": "function LengthOfLastWord(s: string): integer;\nbegin\n  var i := s.Length;\n  var length := 0;\n  \n  while (i >= 1) and (s[i] = ' ') do\n    i -= 1;\n  \n  while (i >= 1) and (s[i] <> ' ') do\n  begin\n    length += 1;\n    i -= 1;\n  end;\n  \n  Result := length;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to reach the last cell of a matrix from the first cell using only right and down moves.",
    "output": "function NumWaysReachLastCell(m, n: integer): integer;\nbegin\n  if (m = 1) or (n = 1) then\n    Result := 1\n  else\n    Result := NumWaysReachLastCell(m - 1, n) + NumWaysReachLastCell(m, n - 1);\nend;"
  },
  {
    "instruction": "Write a function that takes a list of positive integers and returns the number of pairs (i, j) such that i < j and nums[i] divides nums[j].",
    "output": "function CountDivisiblePairs(nums: array of integer): integer;\nbegin\n  var count := 0;\n  for var i := 0 to nums.Length - 1 do\n    for var j := i + 1 to nums.Length - 1 do\n      if nums[j] mod nums[i] = 0 then\n        count += 1;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to convert a given string to uppercase and remove all the whitespace.",
    "output": "function ConvertUppercaseAndRemoveWhitespace(inputString: string): string;\nbegin\n  Result := inputString.Replace(' ', '').ToUpper;\nend;"
  },
  {
    "instruction": "Write a function to check if there exists a cycle in a directed graph represented by a list of edges.",
    "output": "function HasCycle(edges: array of (integer, integer)): boolean;\n\n  function DFS(node: integer; visited: HashSet<integer>; recursionStack: HashSet<integer>; adjacencyList: Dictionary<integer, List<integer>>): boolean;\n  begin\n    visited.Add(node);\n    recursionStack.Add(node);\n    \n    if adjacencyList.ContainsKey(node) then\n    begin\n      foreach var neighbor in adjacencyList[node] do\n      begin\n        if not visited.Contains(neighbor) then\n        begin\n          if DFS(neighbor, visited, recursionStack, adjacencyList) then\n          begin\n            Result := True;\n            exit;\n          end;\n        end\n        else if recursionStack.Contains(neighbor) then\n        begin\n          Result := True;\n          exit;\n        end;\n      end;\n    end;\n    \n    recursionStack.Remove(node);\n    Result := False;\n  end;\n\nbegin\n  var nodes := new HashSet<integer>;\n  foreach var edge in edges do\n  begin\n    nodes.Add(edge[0]);\n    nodes.Add(edge[1]);\n  end;\n  \n  var adjacencyList := new Dictionary<integer, List<integer>>;\n  foreach var node in nodes do\n    adjacencyList.Add(node, new List<integer>);\n  \n  foreach var (src, dest) in edges do\n    adjacencyList[src].Add(dest);\n  \n  var visited := new HashSet<integer>;\n  foreach var node in nodes do\n  begin\n    if not visited.Contains(node) then\n    begin\n      var recursionStack := new HashSet<integer>;\n      if DFS(node, visited, recursionStack, adjacencyList) then\n      begin\n        Result := True;\n        exit;\n      end;\n    end;\n  end;\n  \n  Result := False;\nend;"
  },
  {
    "instruction": "Write a function to find the number of days a stock price is strictly greater than its moving average in a given list of stock prices.",
    "output": "function MovingAverageDays(prices: array of integer; n: integer): integer;\nbegin\n  var count := 0;\n  for var i := n to prices.Length - 1 do\n  begin\n    var movingAverage := 0.0;\n    for var j := i - n to i do\n      movingAverage += prices[j];\n    movingAverage /= (n + 1);\n    \n    if prices[i] > movingAverage then\n      count += 1;\n  end;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of numbers and returns a new list with each element's sign (positive, negative, or zero) as an integer. A positive number should return 1, a negative number should return -1, and zero should return 0.",
    "output": "function SignOfElements(L: array of integer): array of integer;\nbegin\n  Result := L.Select(x -> \n  if x > 0 then Result := 1 \n  else if x < 0 then Result := -1 \n  else Result := 0).ToArray;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of sentences as input and returns a dictionary where the keys are the unique words in the sentences and the values are lists of sentences where the corresponding word appears.",
    "output": "function WordSentences(sentences: array of string; words: array of string): Dictionary<string, List<string>>;\nbegin\n  var wordDict := new Dictionary<string, List<string>>;\n  \n  foreach var sentence in sentences do\n  begin\n    var wordsInSentence := sentence.Split(' ').ToHashSet;\n    foreach var word in words do\n    begin\n      if wordsInSentence.Contains(word) then\n      begin\n        if not wordDict.ContainsKey(word) then\n          wordDict.Add(word, new List<string>);\n        wordDict[word].Add(sentence);\n      end;\n    end;\n  end;\n  \n  Result := wordDict;\nend;"
  },
  {
    "instruction": "Write a function that takes a string as input, where each word is followed by a number indicating its position in the sentence. The function should reorder the words according to their positions and return the sorted sentence.",
    "output": "function SortSentence(s: string): string;\nbegin\n  var temp := s.Split(' ').ToList;\n  var index := new List<integer>;\n  var count := 0;\n  var answer := '';\n  \n  for var i := 0 to temp.Count - 1 do\n  begin\n    var ele := temp[i];\n    index.Add(StrToInt(ele[ele.Length]));\n    temp[i] := ele.Substring(0, ele.Length - 1);\n    count += 1;\n  end;\n  \n  var dec := new Dictionary<integer, string>;\n  for var i := 0 to temp.Count - 1 do\n    dec.Add(index[i], temp[i]);\n  \n  for var i := 0 to index.Count - 1 do\n  begin\n    var least := i;\n    for var k := i + 1 to index.Count - 1 do\n      if index[k] < index[least] then\n        least := k;\n    \n    var tempIndex := index[i];\n    index[i] := index[least];\n    index[least] := tempIndex;\n  end;\n  \n  foreach var ele in index do\n    answer += dec[ele] + ' ';\n  \n  Result := answer.Trim;\nend;"
  },
  {
    "instruction": "Write a function to find the missing number in a given integer array of 1 to n with one number missing using bitwise XOR operation.",
    "output": "function MissingNumberXor(arr: array of integer): integer;\nbegin\n  var n := arr.Length + 1;\n  var x1 := arr[0];\n  var x2 := 1;\n  \n  for var i := 1 to n - 2 do\n    x1 := x1 xor arr[i];\n  \n  for var i := 2 to n do\n    x2 := x2 xor i;\n  \n  Result := x1 xor x2;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum rectangle that can be formed within a given binary matrix using '1's as part of the rectangle.",
    "output": "function MaximalRectangle(matrix: array of array of char): integer;\nbegin\n  if matrix.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var m := matrix.Length;\n  var n := matrix[0].Length;\n  var height := new integer[n + 1];\n  var maxArea := 0;\n  \n  for var i := 0 to m - 1 do\n  begin\n    for var j := 0 to n - 1 do\n      height[j] := if matrix[i][j] = '1' then height[j] + 1 else 0;\n    \n    var stack := new Stack<integer>;\n    stack.Push(-1);\n    \n    for var j := 0 to n do\n    begin\n      while (stack.Count > 1) and (height[j] < height[stack.Peek]) do\n      begin\n        var h := height[stack.Pop];\n        var w := j - 1 - stack.Peek;\n        maxArea := Max(maxArea, h * w);\n      end;\n      stack.Push(j);\n    end;\n  end;\n  \n  Result := maxArea;\nend;"
  },
  {
    "instruction": "Write a function to calculate the hamming distance between two integers. The Hamming distance is the number of positions at which the corresponding bits are different.",
    "output": "function CalculateHammingDistance(x, y: integer): integer;\nbegin\n  var xorResult := x xor y;\n  var distance := 0;\n  while xorResult <> 0 do\n  begin\n    distance += 1;\n    xorResult := xorResult and (xorResult - 1);\n  end;\n  Result := distance;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to decode a message using a given mapping. A message containing letters from A-Z is being encoded to numbers using the following mapping: 'A' -> 1 'B' -> 2 ... 'Z' -> 26 Given an encoded message containing digits, determine the total number of ways to decode it.",
    "output": "function DecodeMessage(s: string): integer;\nbegin\n  var dp := new integer[s.Length + 1];\n  dp[0] := 1;\n  dp[1] := if (s.Length > 0) and (StrToInt(s[1]) > 0) and (StrToInt(s[1]) <= 9) then 1 else 0;\n  \n  for var i := 2 to s.Length do\n  begin\n    var oneDigit := StrToInt(s[i]);\n    var twoDigit := StrToInt(s.Substring(i - 1, 2));\n    \n    if (oneDigit > 0) and (oneDigit <= 9) then\n      dp[i] += dp[i - 1];\n    \n    if (twoDigit >= 10) and (twoDigit <= 26) then\n      dp[i] += dp[i - 2];\n  end;\n  \n  Result := dp[s.Length];\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of jumps required to reach the end of an array from the first position.",
    "output": "function FindMinJumps(arr: array of integer): integer;\nbegin\n  var n := arr.Length;\n  if n <= 1 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  if arr[0] = 0 then\n  begin\n    Result := integer.MaxValue;\n    exit;\n  end;\n  \n  var maxReach := arr[0];\n  var step := arr[0];\n  var jump := 1;\n  \n  for var i := 1 to n - 1 do\n  begin\n    if i = n - 1 then\n    begin\n      Result := jump;\n      exit;\n    end;\n    \n    maxReach := Max(maxReach, i + arr[i]);\n    step -= 1;\n    \n    if step = 0 then\n    begin\n      jump += 1;\n      if i >= maxReach then\n      begin\n        Result := integer.MaxValue;\n        exit;\n      end;\n      step := maxReach - i;\n    end;\n  end;\n  \n  Result := jump;\nend;"
  },
  {
    "instruction": "Write a function that takes in a string of numbers separated by commas and returns the sum of all the numbers.",
    "output": "function SumOfNumbers(testStr: string): integer;\nbegin\n  var numbers := testStr.Split(',').Select(x -> StrToInt(x.Trim));\n  Result := numbers.Sum;\nend;"
  },
  {
    "instruction": "Write a function that takes two strings as input and checks if the second string is a rotated version of the first string. A rotated version means that the second string can be obtained by rotating the first string in a circular manner.",
    "output": "function IsRotatedString(s, t: string): boolean;\nbegin\n  if s.Length <> t.Length then\n  begin\n    Result := False;\n    exit;\n  end;\n  \n  Result := (s + s).Contains(t);\nend;"
  },
  {
    "instruction": "Write a function to find the number of valid triangle combinations that can be formed from a given list of side lengths. A valid triangle combination is a set of three side lengths that can form a triangle, satisfying the triangle inequality theorem.",
    "output": "function TriangleCombinations(sides: array of integer): integer;\nbegin\n  var sortedSides := sides.ToList;\n  sortedSides.Sort;\n  var count := 0;\n  \n  for var i := 0 to sortedSides.Count - 3 do\n  begin\n    var k := i + 2;\n    for var j := i + 1 to sortedSides.Count - 2 do\n    begin\n      while (k < sortedSides.Count) and (sortedSides[i] + sortedSides[j] > sortedSides[k]) do\n        k += 1;\n      count += k - j - 1;\n    end;\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to rotate a matrix by 90 degrees in the clockwise direction. The function should take a square matrix as input and return the rotated matrix.",
    "output": "function RotateMatrix(matrix: array [,] of integer): array [,] of integer;\nbegin\n  var n := matrix.GetLength(0);\n  var res := new integer[n, n];\n  \n  for var i := 0 to n - 1 do\n    for var j := 0 to n - 1 do\n      res[j, n - 1 - i] := matrix[i, j];\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to create a list of N Fibonacci numbers (where N is the input to the function) starting from 0. The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1.",
    "output": "function CreateFibonacci(n: integer): array of integer;\nbegin\n  if n = 0 then\n  begin\n    Result := new integer[0];\n    exit;\n  end\n  else if n = 1 then\n  begin\n    Result := new integer[1];\n    Result[0] := 0;\n    exit;\n  end;\n  \n  var fib := new integer[n];\n  fib[0] := 0;\n  fib[1] := 1;\n  \n  for var i := 2 to n - 1 do\n    fib[i] := fib[i - 1] + fib[i - 2];\n  \n  Result := fib;\nend;"
  },
  {
    "instruction": "Write a function to find the number of times a given value appears in a linked list.",
    "output": "type\n  ListNode = class\n    val: integer;\n    next: ListNode;\n    \n    constructor Create(v: integer; n: ListNode := nil);\n    begin\n      val := v;\n      next := n;\n    end;\n  end;\n\nfunction CountValueInList(head: ListNode; value: integer): integer;\nbegin\n  var count := 0;\n  var current := head;\n  \n  while current <> nil do\n  begin\n    if current.val = value then\n      count += 1;\n    current := current.next;\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the last even number in a given list of numbers.",
    "output": "function LastEven(nums: array of integer): integer;\nbegin\n  for var i := nums.Length - 1 downto 0 do\n    if nums[i] mod 2 = 0 then\n    begin\n      Result := nums[i];\n      exit;\n    end;\n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to check whether two lists contain the same unique elements in any order.",
    "output": "function SameUniqueElements(list1, list2: array of integer): boolean;\nbegin\n  var set1 := new HashSet<integer>(list1);\n  var set2 := new HashSet<integer>(list2);\n  Result := set1.SetEquals(set2);\nend;"
  },
  {
    "instruction": "Write a function that takes two lists of integers as parameters and returns a new list. This new list should contain all unique elements from both input lists, sorted in ascending order. The function should handle both positive and negative integers.",
    "output": "function MergeUniqueSortedLists(list1, list2: array of integer): array of integer;\nbegin\n  var mergedList := list1.Concat(list2).ToArray;\n  var uniqueList := mergedList.Distinct.ToList;\n  uniqueList.Sort;\n  Result := uniqueList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to express the number 'n' as a sum of 1, 3, and 4.",
    "output": "function NumberWays(n: integer): integer;\nbegin\n  if n = 0 then\n    Result := 1\n  else if n = 1 then\n    Result := 1\n  else if n = 2 then\n    Result := 2\n  else if n = 3 then\n    Result := 4\n  else\n  begin\n    var dp := new integer[n + 1];\n    dp[0] := 1;\n    dp[1] := 1;\n    dp[2] := 2;\n    dp[3] := 4;\n    \n    for var i := 4 to n do\n      dp[i] := dp[i - 1] + dp[i - 3] + dp[i - 4];\n    \n    Result := dp[n];\n  end;\nend;"
  },
  {
    "instruction": "Write a function in to find the number of full days that have passed since the beginning of the year for a given date.",
    "output": "function FindDayOfYear(year, month, day: integer): integer;\nbegin\n  var date := System.DateTime.Create(year, month, day);\n  Result := date.DayOfYear;\nend;"
  },
  {
    "instruction": "Write a function to check if a string contains only alphanumeric characters (letters and numbers) and no special characters. The function should return True if the string only contains alphanumeric characters and False otherwise.",
    "output": "function IsAlphanumeric(s: string): boolean;\nbegin\n  foreach var ch in s do\n    if not char.IsLetterOrDigit(ch) then\n      exit(false);\n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function to check if a number is a Fibonacci number or not. A Fibonacci number is a number that appears in the Fibonacci sequence, where each number is the sum of the two preceding ones, starting from 0 and 1.",
    "output": "function IsFibonacci(n: integer): boolean;\nbegin\n  if (n = 0) or (n = 1) then\n  begin\n    Result := True;\n    exit;\n  end;\n  \n  var a := 0;\n  var b := 1;\n  while b < n do\n  begin\n    var temp := a + b;\n    a := b;\n    b := temp;\n  end;\n  Result := b = n;\nend;"
  },
  {
    "instruction": "Write a function to calculate the number of ways to reach the nth stair using either 1 or 2 steps at a time.",
    "output": "function WaysToReachStair(n: integer): integer;\nbegin\n  if n <= 1 then\n    Result := n\n  else\n  begin\n    var first := 0;\n    var second := 1;\n    for var i := 0 to n - 1 do\n    begin\n      var currentStep := first + second;\n      first := second;\n      second := currentStep;\n    end;\n    Result := second;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the number of 'good' numbers less than or equal to a given number n. A 'good' number is a number that after rotating each digit individually by 180 degrees, we get a valid number that is different from the original number.",
    "output": "function CountGoodNumbers(n: integer): integer;\n\n  function IsGoodNumber(num: integer): boolean;\n  begin\n    var rotateMap := new Dictionary<char, char>;\n    rotateMap.Add('0', '0');\n    rotateMap.Add('1', '1');\n    rotateMap.Add('8', '8');\n    rotateMap.Add('2', '5');\n    rotateMap.Add('5', '2');\n    rotateMap.Add('6', '9');\n    rotateMap.Add('9', '6');\n    \n    var original := num.ToString;\n    var rotated := '';\n    \n    foreach var digit in original do\n    begin\n      if not rotateMap.ContainsKey(digit) then\n      begin\n        Result := False;\n        exit;\n      end;\n      rotated += rotateMap[digit];\n    end;\n    \n    Result := original <> rotated;\n  end;\n\nbegin\n  var count := 0;\n  for var i := 1 to n do\n    if IsGoodNumber(i) then\n      count += 1;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of numbers and returns the mean of the numbers.",
    "output": "function Mean(numbers: array of integer): real;\nbegin\n  Result := numbers.Average;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns a new list with the integers sorted in descending order without using built-in sort functions.",
    "output": "function DescendingSort(lst: array of integer): array of integer;\nbegin\n  var n := lst.Length;\n  for var i := 0 to n - 1 do\n    for var j := 0 to n - i - 2 do\n      if lst[j] < lst[j + 1] then\n      begin\n        var temp := lst[j];\n        lst[j] := lst[j + 1];\n        lst[j + 1] := temp;\n      end;\n  Result := lst;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of nested sublists within a given list.",
    "output": "procedure DFS(sublist: System.Collections.IList; var currentDepth : integer; var maxDepth : integer);\nbegin\n  currentDepth += 1;\n  for var i := 0 to sublist.Count - 1 do\n    if sublist[i] is System.Collections.IList then\n      DFS(System.Collections.IList(sublist[i]), currentDepth, maxDepth);\n  maxDepth := Max(maxDepth, currentDepth);\n  currentDepth -= 1;\nend;\n\nfunction FindMaxNestedSublists(lst: System.Collections.IList): integer;\nbegin\n  var maxDepth := 0;\n  var currentDepth := 0;\n  DFS(lst, currentDepth, maxDepth);\n  Result := maxDepth;\nend;"
  },
  {
    "instruction": "Write a function to compute the number of inverse pairs in an array. An inverse pair is a pair of elements (i, j) such that i < j and arr[i] > arr[j].",
    "output": "function MergeSort(var arr: array of integer; start, &end: integer): integer;\nbegin\n  if start >= &end then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var mid := (start + &end) div 2;\n  var count := MergeSort(arr, start, mid) + MergeSort(arr, mid + 1, &end);\n  \n  var i := start;\n  var j := mid + 1;\n  var temp := new List<integer>;\n  \n  while (i <= mid) and (j <= &end) do\n  begin\n    if arr[i] <= arr[j] then\n    begin\n      temp.Add(arr[i]);\n      i += 1;\n    end\n    else\n    begin\n      temp.Add(arr[j]);\n      count += mid - i + 1;\n      j += 1;\n    end;\n  end;\n  \n  while i <= mid do\n  begin\n    temp.Add(arr[i]);\n    i += 1;\n  end;\n  \n  while j <= &end do\n  begin\n    temp.Add(arr[j]);\n    j += 1;\n  end;\n  \n  for var k := 0 to temp.Count - 1 do\n    arr[start + k] := temp[k];\n  \n  Result := count;\nend;\n\nfunction CountInversePairs(arr: array of integer): integer;\nbegin\n  Result := MergeSort(arr, 0, arr.Length - 1);\nend;"
  },
  {
    "instruction": "Create a function that will sort each row of a given matrix in ascending order, then sort each column in ascending order, and finally return the resulting matrix.",
    "output": "function SortMatrix(matrix: array of array of integer): array of array of integer;\nbegin\n  var rowCount := matrix.Length;\n  var colCount := matrix[0].Length;\n  \n  for var i := 0 to rowCount - 1 do\n    &Array.Sort(matrix[i]);\n  \n  for var j := 0 to colCount - 1 do\n  begin\n    var column := new List<integer>;\n    for var i := 0 to rowCount - 1 do\n      column.Add(matrix[i][j]);\n    \n    column.Sort();\n    \n    for var i := 0 to rowCount - 1 do\n      matrix[i][j] := column[i];\n  end;\n  \n  Result := matrix;\nend;"
  },
  {
    "instruction": "Write a function to find the number of unique paths in a grid from the top-left corner to the bottom-right corner, considering an obstacle grid where some cells are blocked.",
    "output": "function CountUniquePathsObstacles(obstacleGrid: array [,] of integer): integer;\nbegin\n  var m := obstacleGrid.GetLength(0);\n  var n := obstacleGrid.GetLength(1);\n  var dp := new integer[m, n];\n  \n  if obstacleGrid[0, 0] = 0 then\n    dp[0, 0] := 1;\n  \n  for var i := 0 to m - 1 do\n    for var j := 0 to n - 1 do\n      if (obstacleGrid[i, j] = 0) and ((i > 0) or (j > 0)) then\n      begin\n        if (i > 0) and (j > 0) then\n          dp[i, j] := dp[i - 1, j] + dp[i, j - 1]\n        else if i > 0 then\n          dp[i, j] := dp[i - 1, j]\n        else\n          dp[i, j] := dp[i, j - 1];\n      end;\n  \n  Result := dp[m - 1, n - 1];\nend;"
  },
  {
    "instruction": "Write a function to find the n-th Fibonacci number using dynamic programming.",
    "output": "function FibNumber(n: integer): integer;\nbegin\n  if n <= 1 then\n  begin\n    Result := n;\n    exit;\n  end;\n  \n  var fib := new integer[n + 1];\n  fib[0] := 0;\n  fib[1] := 1;\n  \n  for var i := 2 to n do\n    fib[i] := fib[i - 1] + fib[i - 2];\n  \n  Result := fib[n];\nend;"
  },
  {
    "instruction": "Implement a function that checks if a number can be rearranged to form a power of 2. The function should take an integer N as input and return True if it's possible to rearrange the digits of N to form a power of 2, and False otherwise.",
    "output": "function CanRearrangeToPowerOf2(N: integer): boolean;\nbegin\n  var powersOf2 := new HashSet<string>;\n  \n  for var i := 0 to 30 do\n  begin\n    var power := BigInteger(1) shl i;\n    if power <= BigInteger(1000000000) then\n    begin\n      var powerStr := power.ToString;\n      var sortedPower := new string(powerStr.OrderBy(c -> c).ToArray);\n      powersOf2.Add(sortedPower);\n    end;\n  end;\n  \n  var sortedN := new string(N.ToString.OrderBy(c -> c).ToArray);\n  Result := powersOf2.Contains(sortedN);\nend;"
  },
  {
    "instruction": "Write a function to find the area of the projection of a 3D shape onto the coordinate planes. The shape is represented by a grid of non-negative integers, where each value represents the height of a unit cube at that position. The projection area is the total area of the shape's shadow when projected onto the xy, yz, and zx planes.",
    "output": "function ProjectionArea(grid: array of array of integer): integer;\nbegin\n  var xy := 0;\n  for var i := 0 to grid.Length - 1 do\n    for var j := 0 to grid[i].Length - 1 do\n      if grid[i][j] > 0 then\n        xy += 1;\n  \n  var yz := 0;\n  for var j := 0 to grid[0].Length - 1 do\n  begin\n    var maxVal := 0;\n    for var i := 0 to grid.Length - 1 do\n      maxVal := Max(maxVal, grid[i][j]);\n    yz += maxVal;\n  end;\n  \n  var zx := 0;\n  for var i := 0 to grid.Length - 1 do\n  begin\n    var maxVal := 0;\n    for var j := 0 to grid[i].Length - 1 do\n      maxVal := Max(maxVal, grid[i][j]);\n    zx += maxVal;\n  end;\n  \n  Result := xy + yz + zx;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings and returns a new list with the strings sorted in reverse alphabetical order, but ignoring case sensitivity.",
    "output": "function ReverseAlphaSort(strings: array of string): array of string;\nbegin\n  Result := strings.OrderByDescending(s -> s.ToLower).ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the N-th Catalan number. The Catalan numbers are a sequence of natural numbers that have many applications in combinatorial mathematics. The N-th catalan number can be expressed as:\nC(n) = (2n)! / ((n + 1)! * n!)",
    "output": "function CatalanNumber(n: integer): integer;\nbegin\n  var res: real := 1;\n  for var i := 2 to n do\n    res := res * (n + i) / i;\n  Result := Round(res);\nend;"
  },
  {
    "instruction": "Write a function to find the highest power of two less than or equal to a given number.",
    "output": "function HighestPowerOfTwo(n: integer): integer;\nbegin\n  var power := 0;\n  while (1 shl power) <= n do\n    power += 1;\n  Result := power - 1;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of the largest contiguous subarray within a one-dimensional array of numbers.",
    "output": "function SumLargestSubarray(arr: array of integer): integer;\nbegin\n  var maxSoFar := arr[0];\n  var currMax := arr[0];\n  \n  for var i := 1 to arr.Length - 1 do\n  begin\n    currMax := Max(arr[i], currMax + arr[i]);\n    maxSoFar := Max(maxSoFar, currMax);\n  end;\n  \n  Result := maxSoFar;\nend;"
  },
  {
    "instruction": "Write a function to find the total number of ways to reach the top of a staircase. You can climb either 1 or 2 steps at a time.",
    "output": "function CountWaysToClimbStaircase(n: integer): integer;\nbegin\n  if n <= 2 then\n  begin\n    Result := n;\n    exit;\n  end;\n  \n  var a := 1;\n  var b := 2;\n  \n  for var i := 3 to n do\n  begin\n    var temp := a + b;\n    a := b;\n    b := temp;\n  end;\n  \n  Result := b;\nend;"
  },
  {
    "instruction": "Write a function to check if a given string contains any vowels.",
    "output": "function ContainsVowels(s: string): boolean;\nbegin\n  var vowels := Arr('a', 'e', 'i', 'o', 'u');\n  \n  for var i := 0 to s.Length - 1 do\n    if vowels.Contains(s[i]) then\n    begin\n      Result := true;\n      exit;\n    end;\n  \n  Result := false;\nend;"
  },
  {
    "instruction": "Write a function to sort the list of tuples based on the second element of each tuple in descending order.",
    "output": "function SortBySecondElement(tuplesList: List<(string, integer)>): List<(string, integer)>;\nbegin\n  Result := tuplesList.OrderByDescending(t -> t[1]).ToList;\nend;"
  },
  {
    "instruction": "Write a function that takes a matrix and returns a new matrix with the rows and columns indices swapped.",
    "output": "function SwapIndices(matrix: array [,] of integer): array [,] of integer;\nbegin\n  var resultMatrix := new integer[matrix.GetLength(1), matrix.GetLength(0)];\n  \n  for var i := 0 to matrix.GetLength(0) - 1 do\n    for var j := 0 to matrix.GetLength(1) - 1 do\n      resultMatrix[j, i] := matrix[i, j];\n  \n  Result := resultMatrix;\nend;"
  },
  {
    "instruction": "Write a function to determine if two rectangles intersect with each other. The rectangles are represented by their bottom-left and top-right coordinates.",
    "output": "function CheckIntersection(rect1, rect2: (integer, integer, integer, integer)): boolean;\nbegin\n  var (x1, y1, x2, y2) := rect1;\n  var (x3, y3, x4, y4) := rect2;\n  \n  if (x1 > x4) or (x3 > x2) then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  if (y1 > y4) or (y3 > y2) then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  Result := true;\nend;"
  },
  {
    "instruction": "Write a function to detect if two rectangles overlap with each other. Each rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) is the top-left corner and (x2, y2) is the bottom-right corner.",
    "output": "function DoRectanglesOverlap(rect1, rect2: array of integer): boolean;\nbegin\n  var x1 := rect1[0];\n  var y1 := rect1[1];\n  var x2 := rect1[2];\n  var y2 := rect1[3];\n  var x3 := rect2[0];\n  var y3 := rect2[1];\n  var x4 := rect2[2];\n  var y4 := rect2[3];\n  \n  if (x3 > x2) or (x4 < x1) or (y3 > y2) or (y4 < y1) then\n    Result := false\n  else\n    Result := true;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns the length of the longest subarray that contains only even numbers.",
    "output": "function LongestEvenSubarray(nums: array of integer): integer;\nbegin\n  var maxLen := 0;\n  var currLen := 0;\n  \n  for var i := 0 to nums.Length - 1 do\n  begin\n    if nums[i] mod 2 = 0 then\n    begin\n      currLen += 1;\n      maxLen := Max(maxLen, currLen);\n    end\n    else\n      currLen := 0;\n  end;\n  \n  Result := maxLen;\nend;"
  },
  {
    "instruction": "Write a function to find the number of unique substrings in a given string.",
    "output": "function FindUniqueSubstrings(s: string): integer;\nbegin\n  var substrings := new HashSet<string>;\n  \n  for var i := 0 to s.Length - 1 do\n    for var j := i + 1 to s.Length do\n      substrings.Add(s.Substring(i, j - i));\n  \n  Result := substrings.Count;\nend;"
  },
  {
    "instruction": "Write a function that checks if a given string can be constructed by repeating a substring. If it's possible, return True, otherwise return False.",
    "output": "function RepeatedSubstring(s: string): boolean;\nbegin\n  for var i := 1 to s.Length div 2 do\n  begin\n    if s.Length mod i = 0 then\n    begin\n      var substr := s.Substring(0, i);\n      var repeated := '';\n      \n      for var j := 1 to s.Length div i do\n        repeated += substr;\n      \n      if repeated = s then\n      begin\n        Result := true;\n        exit;\n      end;\n    end;\n  end;\n  \n  Result := false;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of lists where each list represents a row of a matrix. The function should return the matrix transposed.",
    "output": "function TransposedMatrix(matrix: array [,] of integer): array [,] of integer;\nbegin\n  var resultMatrix := new integer[matrix.GetLength(1), matrix.GetLength(0)];\n  \n  for var i := 0 to matrix.GetLength(0) - 1 do\n    for var j := 0 to matrix.GetLength(1) - 1 do\n      resultMatrix[j, i] := matrix[i, j];\n  \n  Result := resultMatrix;\nend;"
  },
  {
    "instruction": "Write a function to find the nth number in the Tribonacci sequence. The Tribonacci sequence is a generalization of the Fibonacci sequence where each term is the sum of the three preceding ones, starting from 0, 1, 1.",
    "output": "function NthTribonacci(n: integer): integer;\nbegin\n  if n = 1 then\n  begin\n    Result := 1;\n    exit;\n  end;\n  \n  if n = 2 then\n  begin\n    Result := 1;\n    exit;\n  end;\n  \n  if n = 3 then\n  begin\n    Result := 2;\n    exit;\n  end;\n  \n  var trib := new integer[n + 1];\n  trib[1] := 1;\n  trib[2] := 1;\n  trib[3] := 2;\n  var modVal := 1000000007;\n  \n  for var i := 4 to n do\n    trib[i] := (trib[i - 1] mod modVal + trib[i - 2] mod modVal + trib[i - 3] mod modVal) mod modVal;\n  \n  Result := trib[n];\nend;"
  },
  {
    "instruction": "Write a function to convert a list of numbers into a list of binary strings.",
    "output": "function NumToBin(nums: array of integer): array of string;\nbegin\n  Result := nums.Select(num -> Convert.ToString(num, 2)).ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to tile a 2xn board using 2x1 tiles. Each tile can either be placed horizontally or vertically in a 2x1 space. The function should return the number of different ways the board can be completely covered by the tiles.\n\nThe function should take an integer n as input, which represents the length of the board, and return the number of ways to tile the board.",
    "output": "function NumWaysToTile(n: integer): integer;\nbegin\n  if n = 0 then\n  begin\n    Result := 1;\n    exit;\n  end;\n  \n  if n = 1 then\n  begin\n    Result := 1;\n    exit;\n  end;\n  \n  var dp := new integer[n + 1];\n  dp[0] := 1;\n  dp[1] := 1;\n  \n  for var i := 2 to n do\n    dp[i] := dp[i - 1] + dp[i - 2];\n  \n  Result := dp[n];\nend;"
  },
  {
    "instruction": "Write a function that checks if a string is a pangram. A pangram is a sentence that contains all the letters of the English alphabet at least once.",
    "output": "function IsPangram(sentence: string): boolean;\nbegin\n  var alphabet := 'abcdefghijklmnopqrstuvwxyz';\n  \n  for var i := 0 to alphabet.Length - 1 do\n    if not sentence.ToLower.Contains(alphabet[i]) then\n    begin\n      Result := false;\n      exit;\n    end;\n  \n  Result := true;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of numbers and returns the index of the smallest number in the list.",
    "output": "function SmallestNumberIndex(list1: array of integer): integer;\nbegin\n  var minIndex := 0;\n  \n  for var i := 1 to list1.Length - 1 do\n    if list1[i] < list1[minIndex] then\n      minIndex := i;\n  \n  Result := minIndex;\nend;"
  },
  {
    "instruction": "Create a function to calculate the sum of all the elements in a list of integers. Then, create another function that calculates the average of the elements in the list using the sum. Finally, create a third function to determine if the average is an integer or a float.",
    "output": "function CalculateSum(numbers: array of integer): integer;\nbegin\n  Result := numbers.Sum;\nend;\n\nfunction CalculateAverage(numbers: array of integer): real;\nbegin\n  Result := CalculateSum(numbers) / numbers.Length;\nend;\n\nfunction IsAverageInteger(numbers: array of integer): boolean;\nbegin\n  var avg := CalculateAverage(numbers);\n  Result := Frac(avg) = 0;\nend;"
  },
  {
    "instruction": "Write a function that checks if a given string is a palindrome, but ignore case sensitivity and non-alphanumeric characters.",
    "output": "function IsEnhancedPalindrome(s: string): boolean;\nbegin\n  var cleaned := '';\n  \n  for var i := 0 to s.Length - 1 do\n    if char.IsLetterOrDigit(s[i]) then\n      cleaned += s[i].ToLower;\n  \n  Result := cleaned = new string(cleaned.Reverse.ToArray);\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of sessions required to finish all tasks given a list of tasks and the maximum time for each session. Each task must be completed in one session and cannot be split into multiple sessions. Tasks in the same session can be completed in any order. The function should return the minimum number of sessions needed to finish all tasks.",
    "output": "function MinSessions(tasks: array of integer; sessionTime: integer): integer;\nbegin\n  var n := tasks.Length;\n  var status := 1 shl n;\n  \n  var nums := new integer[status];\n  var lasts := new integer[status];\n  \n  for var i := 0 to status - 1 do\n  begin\n    nums[i] := n;\n    lasts[i] := sessionTime;\n  end;\n  \n  nums[0] := 1;\n  lasts[0] := 0;\n  \n  for var i := 1 to status - 1 do\n  begin\n    for var j := 0 to n - 1 do\n    begin\n      var todo := i and (1 shl (n - 1 - j));\n      if todo <> 0 then\n      begin\n        var pre := i - (1 shl (n - 1 - j));\n        var lastVal := lasts[pre] + tasks[j];\n        var numVal := nums[pre];\n        \n        if lastVal > sessionTime then\n        begin\n          numVal += 1;\n          lastVal := tasks[j];\n        end;\n        \n        if (numVal < nums[i]) or ((numVal = nums[i]) and (lastVal < lasts[i])) then\n        begin\n          nums[i] := numVal;\n          lasts[i] := lastVal;\n        end;\n      end;\n    end;\n  end;\n  \n  Result := nums[status - 1];\nend;"
  },
  {
    "instruction": "Write a function that takes in a list of binary numbers (as strings) and converts them to decimal numbers. Then, find the maximum value among these decimal numbers.",
    "output": "function MaxBinaryToDecimal(binaryList: array of string): integer;\nbegin\n  var decimalList := binaryList.Select(bin -> Convert.ToInt32(bin, 2)).ToArray;\n  Result := decimalList.Max;\nend;"
  },
  {
    "instruction": "Create a function named 'find_word_in_string'. This function should take two parameters, a string 'sentence' and a string 'word', and return True if the word is present in the sentence, False otherwise. Note: The function should be case insensitive.",
    "output": "function FindWordInString(sentence, word: string): boolean;\nbegin\n  Result := sentence.ToLower.Contains(word.ToLower);\nend;"
  },
  {
    "instruction": "Write a function to find the unique single number in the array where every other number appears twice.",
    "output": "function FindUniqueNumber(nums: array of integer): integer;\nbegin\n  var uniqueNumber := 0;\n  for var i := 0 to nums.Length - 1 do\n    uniqueNumber := uniqueNumber xor nums[i];\n  Result := uniqueNumber;\nend;"
  },
  {
    "instruction": "Write a function to find the number of possible binary search trees with n nodes.",
    "output": "function NumOfBST(n: integer): integer;\nbegin\n  if (n = 0) or (n = 1) then\n  begin\n    Result := 1;\n    exit;\n  end;\n  \n  var num := 0;\n  for var i := 1 to n do\n    num += NumOfBST(i - 1) * NumOfBST(n - i);\n  \n  Result := num;\nend;"
  },
  {
    "instruction": "Write a function that returns the median of two sorted lists. The lists can have different lengths.",
    "output": "function FindMedianSortedLists(nums1, nums2: array of integer): real;\nbegin\n  var nums := nums1.Concat(nums2).ToArray;\n  &Array.Sort(nums);\n  var length := nums.Length;\n  \n  if length mod 2 = 0 then\n    Result := (nums[length div 2] + nums[length div 2 - 1]) / 2\n  else\n    Result := nums[length div 2];\nend;"
  },
  {
    "instruction": "Write a function to remove all the words with k length in the given string.",
    "output": "function RemoveLength(testStr: string; k: integer): string;\nbegin\n  var temp := testStr.Split(' ');\n  var res := temp.Where(ele -> ele.Length <> k).ToArray;\n  Result := string.Join(' ', res);\nend;"
  },
  {
    "instruction": "Write a function that takes a list of lists as input and returns a single list that is the concatenation of all the lists in the input.",
    "output": "function ConcatenateLists(lists: List<List<integer>>): List<integer>;\nbegin\n  Result := new List<integer>;\n  foreach var lst in lists do\n    Result.AddRange(lst);\nend;"
  },
  {
    "instruction": "Write a function that retrieves the original number when given a list of its divisors. This function should work on the principle that if the number of divisors is one, the result will be the square of the divisor. If there are more divisors, then the original number is the product of the smallest and largest divisor.",
    "output": "function GetOriginalNumber(arr: array of integer): integer;\nbegin\n  var N := arr.Length;\n  if N = 1 then\n    Result := arr[0] * arr[0]\n  else\n  begin\n    &Array.Sort(arr);\n    Result := arr[0] * arr[N - 1];\n  end;\nend;"
  },
  {
    "instruction": "Write a function to generate all possible substrings of a given string.",
    "output": "function PossibleSubstrings(s: string): List<string>;\nbegin\n  Result := new List<string>;\n  for var i := 0 to s.Length - 1 do\n    for var j := i + 1 to s.Length do\n      Result.Add(s.Substring(i, j - i));\nend;"
  },
  {
    "instruction": "Write a function to check if a given number is a power of two.",
    "output": "function CheckPowerOfTwo(n: integer): boolean;\nbegin\n  if n <= 0 then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  while n mod 2 = 0 do\n    n := n div 2;\n  \n  Result := n = 1;\nend;"
  },
  {
    "instruction": "Write a function that calculates the factorial of a number iteratively.",
    "output": "function FactorialIterative(n: integer): integer;\nbegin\n  if n = 0 then\n  begin\n    Result := 1;\n    exit;\n  end;\n  \n  Result := 1;\n  for var i := 1 to n do\n    Result := Result * i;\nend;"
  },
  {
    "instruction": "Write a function to reverse the key-value pairs in a given dictionary. If multiple keys have the same value, the values in the new dictionary should be a list of these keys.",
    "output": "function ReverseDict(testDict: Dictionary<string, integer>): Dictionary<integer, object>;\nbegin\n  var reverse := new Dictionary<integer, List<string>>;\n  \n  foreach var pair in testDict do\n  begin\n    if not reverse.ContainsKey(pair.Value) then\n      reverse[pair.Value] := new List<string>;\n    reverse[pair.Value].Add(pair.Key);\n  end;\n  \n  var res := new Dictionary<integer, object>;\n  foreach var pair in reverse do\n  begin\n    if pair.Value.Count = 1 then\n      res[pair.Key] := pair.Value[0]\n    else\n      res[pair.Key] := pair.Value;\n  end;\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to compute the sum of the digits of a number raised to a power.",
    "output": "function DigitSumPower(number, pow: integer): integer;\nbegin\n  var sumPower := 0;\n  var numStr := number.ToString;\n  \n  for var i := 0 to numStr.Length - 1 do\n    sumPower += Round(Power(StrToInt(numStr[i]), pow));\n  \n  Result := sumPower;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum product of a subarray within a given list of integers.",
    "output": "function MaxProductSubarray(nums: array of integer): integer;\nbegin\n  if nums.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var minVal := nums[0];\n  var maxVal := nums[0];\n  var resultVal := nums[0];\n  \n  for var i := 1 to nums.Length - 1 do\n  begin\n    if nums[i] < 0 then\n    begin\n      var temp := minVal;\n      minVal := maxVal;\n      maxVal := temp;\n    end;\n    \n    maxVal := Max(nums[i], maxVal * nums[i]);\n    minVal := Min(nums[i], minVal * nums[i]);\n    resultVal := Max(resultVal, maxVal);\n  end;\n  \n  Result := resultVal;\nend;"
  },
  {
    "instruction": "Write a function to check if an array can be divided into two subarrays with equal sum.",
    "output": "function DivideArray(arr: array of integer): boolean;\nbegin\n  var total := arr.Sum;\n  if total mod 2 <> 0 then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  var target := total div 2;\n  var dp := new boolean[target + 1];\n  dp[0] := true;\n  \n  for var i := 0 to arr.Length - 1 do\n    for var j := target downto arr[i] do\n      dp[j] := dp[j] or dp[j - arr[i]];\n  \n  Result := dp[target];\nend;"
  },
  {
    "instruction": "Write a function to find the longest subsequence in a given string where the vowels are in alphabetical order.",
    "output": "function LongestBeautifulSubstring(word: string): integer;\nbegin\n  var ret := 0;\n  var res := 0;\n  var kind := new HashSet<char>;\n  \n  for var i := 0 to word.Length - 1 do\n  begin\n    if i = 0 then\n    begin\n      res := 1;\n      kind.Add(word[i]);\n    end\n    else\n    begin\n      if word[i] >= word[i - 1] then\n      begin\n        res += 1;\n        kind.Add(word[i]);\n        if kind.Count = 5 then\n          ret := Max(ret, res);\n      end\n      else\n      begin\n        res := 1;\n        kind.Clear;\n        kind.Add(word[i]);\n      end;\n    end;\n  end;\n  \n  Result := ret;\nend;"
  },
  {
    "instruction": "Write a function that takes two strings as input and returns a new string formed by concatenating the characters of the two strings in an alternating fashion. If one string is longer than the other, append the remaining characters of the longer string to the result.",
    "output": "function AlternateMerge(str1, str2: string): string;\nbegin\n  var mergedStr := '';\n  var i := 0;\n  var j := 0;\n  \n  while (i < str1.Length) and (j < str2.Length) do\n  begin\n    mergedStr += str1[i] + str2[j];\n    i += 1;\n    j += 1;\n  end;\n  \n  if i < str1.Length then\n    mergedStr += str1.Substring(i);\n  \n  if j < str2.Length then\n    mergedStr += str2.Substring(j);\n  \n  Result := mergedStr;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum value in record list as tuple attribute in the given tuple list.",
    "output": "function MinimumValue(testList: List<(string, List<integer>)>): List<(string, integer)>;\nbegin\n  Result := testList.Select(t -> (t[0], t[1].Min)).ToList;\nend;"
  },
  {
    "instruction": "Create a function that takes a string and returns a new string with the first character of each word in uppercase and the rest of the characters in lowercase.",
    "output": "function FormatString(inputString: string): string;\nbegin\n  var words := inputString.Split(' ');\n  var newWords := words.Select(word -> word.Substring(0, 1).ToUpper + word.Substring(1).ToLower).ToArray;\n  Result := string.Join(' ', newWords);\nend;"
  },
  {
    "instruction": "Write a function to find the longest subarray with equal number of 0's and 1's.",
    "output": "function FindLongestSubarray(arr: array of integer): integer;\nbegin\n  var n := arr.Length;\n  var sumVal := 0;\n  var maxLen := 0;\n  var m := new Dictionary<integer, integer>;\n  \n  for var i := 0 to n - 1 do\n  begin\n    if arr[i] = 0 then\n      sumVal += -1\n    else\n      sumVal += 1;\n    \n    if sumVal = 0 then\n      maxLen := i + 1;\n    \n    if m.ContainsKey(sumVal) then\n      maxLen := Max(maxLen, i - m[sumVal])\n    else\n      m[sumVal] := i;\n  end;\n  \n  Result := maxLen;\nend;"
  },
  {
    "instruction": "Write a function to find the longest common prefix string amongst a list of strings.\nIf there is no common prefix, return an empty string \"\".",
    "output": "function LongestCommonPrefix(strs: array of string): string;\nbegin\n  if strs.Length = 0 then\n  begin\n    Result := '';\n    exit;\n  end;\n  \n  var shortest := strs.MinBy(s -> s.Length);\n  \n  for var i := 0 to shortest.Length - 1 do\n    for var j := 0 to strs.Length - 1 do\n      if strs[j][i] <> shortest[i] then\n      begin\n        Result := shortest.Substring(0, i);\n        exit;\n      end;\n  \n  Result := shortest;\nend;"
  },
  {
    "instruction": "Write a function that accepts a list of strings and returns the number of strings that have at least two characters and have the same first and last character.",
    "output": "function CountStringsWithSameFirstLast(words: array of string): integer;\nbegin\n  var count := 0;\n  for var i := 0 to words.Length - 1 do\n    if (words[i].Length > 1) and (words[i][0] = words[i][words[i].Length - 1]) then\n      count += 1;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to calculate the minimum number of jumps required to reach the end of an array from the first position. Each element in the array represents the maximum jump length at that position.",
    "output": "function MinJumps(nums: array of integer): integer;\nbegin\n  if nums.Length <= 1 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var jumps := 0;\n  var currentEnd := 0;\n  var farthest := 0;\n  \n  for var i := 0 to nums.Length - 2 do\n  begin\n    farthest := Max(farthest, i + nums[i]);\n    if i = currentEnd then\n    begin\n      jumps += 1;\n      currentEnd := farthest;\n    end;\n  end;\n  \n  Result := jumps;\nend;"
  },
  {
    "instruction": "Write a function that takes two lists as parameters, and returns the list that has the greatest number of occurrences of the number 7. If both lists have the same number of occurrences of 7, return the first list.",
    "output": "function FindSevens(list1, list2: array of integer): array of integer;\nbegin\n  var count1 := list1.Count(x -> x = 7);\n  var count2 := list2.Count(x -> x = 7);\n  \n  if count1 >= count2 then\n    Result := list1\n  else\n    Result := list2;\nend;"
  },
  {
    "instruction": "Write a function that takes a string and returns a new string with the first and last characters removed.",
    "output": "function RemoveFirstLast(s: string): string;\nbegin\n  if s.Length <= 2 then\n    Result := ''\n  else\n    Result := s.Substring(1, s.Length - 2);\nend;"
  },
  {
    "instruction": "Write a function that takes a 2D list (matrix) and reshapes it into a new 2D list with specified number of rows and columns. If it's not possible to reshape the matrix, the function should return the original matrix.",
    "output": "function MatrixReshape(mat: array [,] of integer; r, c: integer): array [,] of integer;\nbegin\n  var m := mat.GetLength(0);\n  var n := mat.GetLength(1);\n  \n  if m * n <> r * c then\n  begin\n    Result := mat;\n    exit;\n  end;\n  \n  var output := new integer[r, c];\n  var x := 0;\n  \n  for var i := 0 to m - 1 do\n    for var j := 0 to n - 1 do\n    begin\n      output[x div c, x mod c] := mat[i, j];\n      x += 1;\n    end;\n  \n  Result := output;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to choose k items from n items without repetition and without order.",
    "output": "function NChooseK(n, k: integer): integer;\nbegin\n  if k > n then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  if (k = 0) or (k = n) then\n  begin\n    Result := 1;\n    exit;\n  end;\n  \n  k := Min(k, n - k);\n  var numerator := 1;\n  \n  for var i := n downto n - k + 1 do\n    numerator := numerator * i;\n  \n  var denominator := 1;\n  for var i := 1 to k do\n    denominator := denominator * i;\n  \n  Result := numerator div denominator;\nend;"
  },
  {
    "instruction": "Write a function that finds the length of the longest contiguous subarray that is common between two arrays.",
    "output": "function FindLongestCommonSubarray(nums1, nums2: array of integer): integer;\nbegin\n  var answer := 0;\n  \n  if nums1.Length < nums2.Length then\n  begin\n    var temp := nums1;\n    nums1 := nums2;\n    nums2 := temp;\n  end;\n  \n  var deque1 := new Queue<integer>(nums1);\n  var deque2 := new Queue<integer>(nums2);\n  \n  for var i := 1 to nums2.Length - 1 do\n  begin\n    deque1.Enqueue(-1);\n    deque1.Enqueue(-1);\n  end;\n  deque1.Enqueue(-1);\n  \n  for var i := 0 to deque1.Count - nums2.Length do\n  begin\n    deque1.Dequeue;\n    var count := 0;\n    var flag := false;\n    \n    for var j := 0 to nums2.Length - 1 do\n    begin\n      if deque1.ElementAt(j) = deque2.ElementAt(j) then\n      begin\n        if not flag then\n          flag := true;\n        count += 1;\n      end\n      else\n      begin\n        count := 0;\n        flag := false;\n      end;\n      answer := Max(answer, count);\n    end;\n  end;\n  \n  Result := answer;\nend;"
  },
  {
    "instruction": "Write a function to find the closest three sum to the target in the given array of integers.",
    "output": "function ClosestThreeSum(nums: array of integer; target: integer): integer;\nbegin\n  &Array.Sort(nums);\n  var closest := 1000000;\n  \n  for var idx := 0 to nums.Length - 3 do\n  begin\n    if (idx = 0) or (nums[idx] <> nums[idx - 1]) then\n    begin\n      var left := idx + 1;\n      var right := nums.Length - 1;\n      \n      while left < right do\n      begin\n        var total := nums[idx] + nums[left] + nums[right];\n        if Abs(closest - target) > Abs(total - target) then\n          closest := total;\n        \n        if total > target then\n          right -= 1\n        else if total < target then\n          left += 1\n        else\n        begin\n          Result := target;\n          exit;\n        end;\n      end;\n    end;\n  end;\n  \n  Result := closest;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings as an argument and returns a list of unique strings sorted in ascending order.",
    "output": "function UniqueAndSort(list1: array of string): array of string;\nbegin\n  var uniqueList := list1.Distinct.ToArray;\n  &Array.Sort(uniqueList);\n  Result := uniqueList;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of characters to be deleted to make the two strings anagrams.",
    "output": "function MinDelToMakeAnagrams(s1, s2: string): integer;\nbegin\n  var count1 := new integer[26];\n  var count2 := new integer[26];\n  var res := 0;\n  \n  for var i := 0 to s1.Length - 1 do\n    count1[Ord(s1[i]) - Ord('a')] += 1;\n  \n  for var i := 0 to s2.Length - 1 do\n    count2[Ord(s2[i]) - Ord('a')] += 1;\n  \n  for var i := 0 to 25 do\n    res += Abs(count1[i] - count2[i]);\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the number of three-element subsets of the given list that sum up to zero.",
    "output": "function ThreeSumCount(nums: array of integer): integer;\nbegin\n  &Array.Sort(nums);\n  var count := 0;\n  \n  for var i := 0 to nums.Length - 3 do\n  begin\n    if (i > 0) and (nums[i] = nums[i - 1]) then\n      continue;\n    \n    var left := i + 1;\n    var right := nums.Length - 1;\n    \n    while left < right do\n    begin\n      var s := nums[i] + nums[left] + nums[right];\n      if s < 0 then\n        left += 1\n      else if s > 0 then\n        right -= 1\n      else\n      begin\n        count += 1;\n        while (left < right) and (nums[left] = nums[left + 1]) do\n          left += 1;\n        while (left < right) and (nums[right] = nums[right - 1]) do\n          right -= 1;\n        left += 1;\n        right -= 1;\n      end;\n    end;\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the missing number in a given list of numbers ranging from 0 to n.",
    "output": "function MissingNumber(nums: array of integer): integer;\nbegin\n  var n := nums.Length;\n  var totalSum := n * (n + 1) div 2;\n  var listSum := nums.Sum;\n  Result := totalSum - listSum;\nend;"
  },
  {
    "instruction": "Write a function to check if a given graph (represented as an adjacency list) is acyclic. A graph is acyclic if it doesn't contain any cycles. For this problem, the graph is directed, and the nodes are labeled from 0 to N-1, where N is the number of nodes.\n\nThe function should take two parameters: the number of nodes `numNodes` and a list of directed edges `edgesList`, where each edge is represented as a list of two integers `[fromNode, toNode]`. The function should return `True` if the graph is acyclic, and `False` otherwise.",
    "output": "uses System.Collections.Generic;\n\nfunction IsAcyclic(numNodes: integer; edgesList: List<(integer, integer)>): boolean;\nbegin\n  var graph := new Dictionary<integer, List<integer>>;\n  var indegree := new integer[numNodes];\n  \n  for var i := 0 to numNodes - 1 do\n    graph[i] := new List<integer>;\n  \n  foreach var edge in edgesList do\n  begin\n    graph[edge[0]].Add(edge[1]);\n    indegree[edge[1]] += 1;\n  end;\n  \n  var queue := new Queue<integer>;\n  for var node := 0 to numNodes - 1 do\n    if indegree[node] = 0 then\n      queue.Enqueue(node);\n  \n  var visited := 0;\n  \n  while queue.Count > 0 do\n  begin\n    var node := queue.Dequeue;\n    visited += 1;\n    \n    foreach var neighbor in graph[node] do\n    begin\n      indegree[neighbor] -= 1;\n      if indegree[neighbor] = 0 then\n        queue.Enqueue(neighbor);\n    end;\n  end;\n  \n  Result := visited = numNodes;\nend;"
  },
  {
    "instruction": "Write a function that returns the minimum number of times a line must be drawn through a wall to cross the minimum number of bricks. The wall is represented by a list of lists, where each inner list represents a row of bricks in the wall. Each brick's length is represented by an integer in the list. The line starts at the left side of the wall (x position 0) and moves through the wall until it reaches the right side.",
    "output": "function LeastBricks(wall: List<List<integer>>): integer;\nbegin\n  var numRows := wall.Count;\n  var minBricks := numRows;\n  var edgesAt := new Dictionary<integer, integer>;\n  var wallWidth := 0;\n  \n  if (wall[0].Count = 1) and (wall[0][0] = 1) then\n  begin\n    Result := numRows;\n    exit;\n  end;\n  \n  foreach var row in wall do\n  begin\n    var position := 0;\n    for var i := 0 to row.Count - 2 do\n    begin\n      position += row[i];\n      if not edgesAt.ContainsKey(position) then\n        edgesAt[position] := 0;\n      edgesAt[position] += 1;\n    end;\n    if wallWidth = 0 then\n      wallWidth := position + row[row.Count - 1];\n  end;\n  \n  foreach var position in edgesAt.Keys do\n  begin\n    if (position > 0) and (position < wallWidth) then\n    begin\n      var bricksCrossed := numRows - edgesAt[position];\n      minBricks := Min(minBricks, bricksCrossed);\n    end;\n  end;\n  \n  Result := minBricks;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of characters that need to be deleted to make two strings equal.",
    "output": "function MinDelToMakeEqual(str1, str2: string): integer;\nbegin\n  var m := str1.Length;\n  var n := str2.Length;\n  var dp := new integer[m + 1, n + 1];\n  \n  for var i := 0 to m - 1 do\n    for var j := 0 to n - 1 do\n    begin\n      if str1[i] = str2[j] then\n        dp[i + 1, j + 1] := dp[i, j] + 1\n      else\n        dp[i + 1, j + 1] := Max(dp[i + 1, j], dp[i, j + 1]);\n    end;\n  \n  Result := m - dp[m, n] + n - dp[m, n];\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of times a given target string can be formed by rearranging the characters of a source string.",
    "output": "function RearrangeCharacters(s, target: string): integer;\nbegin\n  var ans := integer.MaxValue;\n  var cnt := new Dictionary<char, integer>;\n  var targetCnt := new Dictionary<char, integer>;\n  \n  for var i := 0 to s.Length - 1 do\n  begin\n    if not cnt.ContainsKey(s[i]) then\n      cnt[s[i]] := 0;\n    cnt[s[i]] += 1;\n  end;\n  \n  for var i := 0 to target.Length - 1 do\n  begin\n    if not targetCnt.ContainsKey(target[i]) then\n      targetCnt[target[i]] := 0;\n    targetCnt[target[i]] += 1;\n  end;\n  \n  foreach var pair in targetCnt do\n  begin\n    if not cnt.ContainsKey(pair.Key) then\n    begin\n      Result := 0;\n      exit;\n    end;\n    ans := Min(ans, cnt[pair.Key] div pair.Value);\n  end;\n  \n  Result := ans;\nend;"
  },
  {
    "instruction": "Write a function that takes a string and returns a new string with the characters in reverse order. If the input string is a palindrome, the function should return the original string instead of the reversed one.",
    "output": "function ReverseOrPalindrome(s: string): string;\nbegin\n  var reversedS := new string(s.Reverse.ToArray);\n  if s = reversedS then\n    Result := s\n  else\n    Result := reversedS;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings and an integer k, and returns the kth lexicographically smallest string obtained by removing exactly k characters from the original strings.",
    "output": "function KthSmallestString(nums: array of string; k: integer): string;\nbegin\n  var trimmedStrings := nums.Select(s -> s.Substring(k)).ToArray;\n  &Array.Sort(trimmedStrings);\n  \n  if trimmedStrings.Length > 0 then\n    Result := trimmedStrings[0]\n  else\n    Result := '';\nend;"
  },
  {
    "instruction": "Write a function to find the number of times a target value appears in a sorted array using binary search.",
    "output": "function FindFirstOccurrence(nums: array of integer; target: integer; startIdx, endIdx: integer): integer;\nbegin\n  var left := startIdx;\n  var right := endIdx;\n  while left < right do\n  begin\n    var mid := left + (right - left) div 2;\n    if nums[mid] < target then\n      left := mid + 1\n    else\n      right := mid;\n  end;\n  if nums[left] = target then\n    Result := left\n  else\n    Result := -1;\nend;\n\nfunction FindLastOccurrence(nums: array of integer; target: integer; startIdx, endIdx: integer): integer;\nbegin\n  var left := startIdx;\n  var right := endIdx;\n  while left < right do\n  begin\n    var mid := left + (right - left + 1) div 2;\n    if nums[mid] > target then\n      right := mid - 1\n    else\n      left := mid;\n  end;\n  if nums[right] = target then\n    Result := right\n  else\n    Result := -1;\nend;\n\nfunction CountTargetOccurrences(nums: array of integer; target: integer): integer;\nbegin\n  var firstOccurrence := FindFirstOccurrence(nums, target, 0, nums.Length - 1);\n  if firstOccurrence = -1 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var lastOccurrence := FindLastOccurrence(nums, target, firstOccurrence, nums.Length - 1);\n  Result := lastOccurrence - firstOccurrence + 1;\nend;"
  },
  {
    "instruction": "Write a function to find the number of valid parentheses sequences of length n. A valid parentheses sequence is defined as any sequence of parentheses where for each opening parenthesis there is a corresponding closing parenthesis in the correct order.",
    "output": "function ValidParenthesesSequences(n: integer): integer;\nbegin\n  var catalan := new integer[n + 1];\n  catalan[0] := 1;\n  catalan[1] := 1;\n  \n  for var i := 2 to n do\n    for var j := 0 to i - 1 do\n      catalan[i] += catalan[j] * catalan[i - j - 1];\n  \n  Result := catalan[n];\nend;"
  },
  {
    "instruction": "Write a function in to find the smallest positive integer that cannot be represented as the sum of a subset of a given list of positive integers. This is known as the Coin Problem or the Frobenius Coin Problem when dealing with two denominations.",
    "output": "function SmallestMissingCoin(coins: array of integer): integer;\nbegin\n  &Array.Sort(coins);\n  var maxReachable := 0;\n  \n  for var i := 0 to coins.Length - 1 do\n  begin\n    if coins[i] > maxReachable + 1 then\n      break;\n    maxReachable += coins[i];\n  end;\n  \n  Result := maxReachable + 1;\nend;"
  },
  {
    "instruction": "Write a function that checks whether a given list of integers represents a valid parenthesis string. A valid parenthesis string is one where every opening parenthesis '(' has a corresponding closing parenthesis ')', and they are correctly nested.",
    "output": "uses System.Collections.Generic;\n\nfunction ValidParenthesis(parenthesisList: array of string): boolean;\nbegin\n  var stack := new Stack<string>;\n  \n  for var i := 0 to parenthesisList.Length - 1 do\n  begin\n    if parenthesisList[i] = '(' then\n      stack.Push('(')\n    else if parenthesisList[i] = ')' then\n    begin\n      if stack.Count > 0 then\n        stack.Pop\n      else\n      begin\n        Result := false;\n        exit;\n      end;\n    end;\n  end;\n  \n  Result := stack.Count = 0;\nend;"
  },
  {
    "instruction": "Write a function to find the factorial of a number using memoization.",
    "output": "function Factorial(memo: Dictionary<integer, integer>; n: integer): integer;\nbegin\n  if n = 0 then\n  begin\n    Result := 1;\n    exit;\n  end;\n  \n  if memo.ContainsKey(n) then\n    Result := memo[n]\n    else\n  begin\n    var num := n * Factorial(memo, n - 1);\n    memo[n] := num;\n    Result := num;\n  end;\nend;\n\nfunction FactorialMemo(n: integer): integer;\nbegin\n  var memo := new Dictionary<integer, integer>;\n  Result := Factorial(memo, n);\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest subarray that contains only 1's after deleting exactly one element.",
    "output": "function LongestSubarray(nums: array of integer): integer;\nbegin\n  var left := 0;\n  var zeroCount := 0;\n  var maxLen := 0;\n  \n  for var right := 0 to nums.Length - 1 do\n  begin\n    if nums[right] = 0 then\n      zeroCount += 1;\n    \n    while zeroCount > 1 do\n    begin\n      if nums[left] = 0 then\n        zeroCount -= 1;\n      left += 1;\n    end;\n    \n    maxLen := Max(maxLen, right - left);\n  end;\n  \n  Result := maxLen;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum length of a common subarray between two given arrays.",
    "output": "function HasSubstrMatch(A, B: array of integer; k: integer): boolean;\nbegin\n  if k = 0 then\n  begin\n    Result := true;\n    exit;\n  end;\n  \n  var hash2inds := new Dictionary<integer, List<integer>>;\n  \n  for var i := 0 to A.Length - k do\n  begin\n    var subA := A[i:i + k];\n    var hash := subA.GetHashCode;\n    \n    if not hash2inds.ContainsKey(hash) then\n      hash2inds[hash] := new List<integer>;\n    hash2inds[hash].Add(i);\n  end;\n  \n  for var j := 0 to B.Length - k do\n  begin\n    var subB := B[j:j + k];\n    var hash := subB.GetHashCode;\n    \n    if hash2inds.ContainsKey(hash) then\n    begin\n      foreach var i in hash2inds[hash] do\n        if A[i:i + k].SequenceEqual(subB) then\n        begin\n          Result := true;\n          exit;\n        end;\n    end;\n  end;\n  \n  Result := false;\nend;\n\nfunction FindMaxSubarrayLength(A, B: array of integer): integer;\nbegin\n  var lo := 0;\n  var hi := Min(A.Length, B.Length) + 1;\n  \n  while lo < hi do\n  begin\n    var k := (lo + hi) div 2;\n    if HasSubstrMatch(A, B, k) then\n      lo := k + 1\n    else\n      hi := k;\n  end;\n  \n  Result := lo - 1;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as an input and returns the length of the longest zigzag subsequence in the list. A zigzag sequence is defined as a sequence where the differences between successive numbers strictly alternate between positive and negative.",
    "output": "function LongestZigzag(nums: array of integer): integer;\nbegin\n  if nums.Length < 2 then\n  begin\n    Result := nums.Length;\n    exit;\n  end;\n  \n  var up := new integer[nums.Length];\n  var down := new integer[nums.Length];\n  \n  for var i := 0 to nums.Length - 1 do\n  begin\n    up[i] := 1;\n    down[i] := 1;\n  end;\n  \n  for var i := 1 to nums.Length - 1 do\n  begin\n    if nums[i] > nums[i - 1] then\n      up[i] := down[i - 1] + 1\n    else if nums[i] < nums[i - 1] then\n      down[i] := up[i - 1] + 1;\n  end;\n  \n  Result := Max(up.Max, down.Max);\nend;"
  },
  {
    "instruction": "Write a function to find the diagonal elements of a matrix.",
    "output": "function GetDiagonal(matrix: array of array of integer): array of integer;\nbegin\n  Result := new integer[matrix.Length];\n  for var i := 0 to matrix.Length - 1 do\n    Result[i] := matrix[i, i];\nend;"
  },
  {
    "instruction": "Write a function to perform arithmetic operations on two integers based on a given operator.",
    "output": "function PerformOperation(num1, num2: integer; &operator: string): real;\nbegin\n  case &operator of\n    '+': Result := num1 + num2;\n    '-': Result := num1 - num2;\n    '*': Result := num1 * num2;\n    '/': \n      if num2 <> 0 then\n        Result := num1 / num2\n      else\n        raise new System.DivideByZeroException('Error: Division by zero');\n    else\n      raise new System.ArgumentException('Error: Invalid operator');\n  end;\nend;"
  },
  {
    "instruction": "Write a function that takes in a list of numbers and returns the list sorted in descending order.",
    "output": "function DescSort(numbers: array of integer): array of integer;\nbegin\n  Result := numbers.OrderByDescending(x -> x).ToArray;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of numbers and returns a new list where each number is rounded up to the nearest whole number using the ceil function.",
    "output": "function RoundUpToNearest(numbers: array of real): array of integer;\nbegin\n  Result := numbers.Select(num -> Ceil(num)).ToArray;\nend;"
  },
  {
    "instruction": "Create a function to convert a string representation of a number in words to an integer. The input string will contain words for digits from zero to nine separated by spaces. The function should map these words to their numerical equivalents and return the resulting number.",
    "output": "function ConvertWordNumber(s: string): integer;\nbegin\n  var wordToNum := new Dictionary<string, integer>;\n  wordToNum['zero'] := 0;\n  wordToNum['one'] := 1;\n  wordToNum['two'] := 2;\n  wordToNum['three'] := 3;\n  wordToNum['four'] := 4;\n  wordToNum['five'] := 5;\n  wordToNum['six'] := 6;\n  wordToNum['seven'] := 7;\n  wordToNum['eight'] := 8;\n  wordToNum['nine'] := 9;\n  \n  var res := '';\n  var words := s.Split(' ');\n  \n  for var i := 0 to words.Length - 1 do\n    res += wordToNum[words[i]].ToString;\n  \n  Result := StrToInt(res);\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest palindrome subsequence in a given string.\n\nA palindrome is a string that reads the same backward as forward, e.g., 'radar' or 'level'.\nA subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\nExample:\nInput: \"bbbab\"\nOutput: 4\nExplanation: One possible longest palindromic subsequence is \"bbbb\".",
    "output": "function PalindromicSubseqLength(s: string): integer;\nbegin\n  var N := s.Length;\n  var dp := new integer[N, N];\n  \n  for var i := N - 1 downto 0 do\n  begin\n    dp[i, i] := 1;\n    for var j := i + 1 to N - 1 do\n    begin\n      if s[i] = s[j] then\n        dp[i, j] := dp[i + 1, j - 1] + 2\n      else\n        dp[i, j] := Max(dp[i + 1, j], dp[i, j - 1]);\n    end;\n  end;\n  \n  Result := dp[0, N - 1];\nend;"
  },
  {
    "instruction": "Write a function to generate the URLs for a given base URL and a list of paths. The function should take the base URL and a list of paths as arguments and return a list of full URLs.",
    "output": "function GenerateUrls(baseUrl: string; paths: array of string): array of string;\nbegin\n  var urls := new List<string>;\n  \n  for var i := 0 to paths.Length - 1 do\n    urls.Add(baseUrl + '/' + paths[i]);\n  \n  Result := urls.ToArray;\nend;"
  },
  {
    "instruction": "Create a function to determine if a given string is an anagram of a palindrome. A palindrome is a word that reads the same backward as forward, e.g., 'radar'. An anagram is a word formed by rearranging the letters of a different word, using all the original letters exactly once. A string can form a palindrome anagram if it has at most one character with an odd count.",
    "output": "function IsPalindromeAnagram(s: string): boolean;\nbegin\n  var charCounts := new Dictionary<char, integer>;\n  \n  for var i := 0 to s.Length - 1 do\n  begin\n    if not charCounts.ContainsKey(s[i]) then\n      charCounts[s[i]] := 0;\n    charCounts[s[i]] += 1;\n  end;\n  \n  var oddCount := 0;\n  foreach var count in charCounts.Values do\n  begin\n    if count mod 2 <> 0 then\n      oddCount += 1;\n    if oddCount > 1 then\n    begin\n      Result := false;\n      exit;\n    end;\n  end;\n  \n  Result := true;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest substring without repeating characters.",
    "output": "function LongestSubstringWithoutRepeat(s: string): integer;\nbegin\n  var charMap := new Dictionary<char, integer>;\n  var left := 0;\n  var resultVal := 0;\n  \n  for var right := 0 to s.Length - 1 do\n  begin\n    if charMap.ContainsKey(s[right]) then\n      left := Max(left, charMap[s[right]] + 1);\n    \n    charMap[s[right]] := right;\n    resultVal := Max(resultVal, right - left + 1);\n  end;\n  \n  Result := resultVal;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as an input and returns a new list with the integers sorted in descending order. However, your function should not use any built-in sort methods or libraries, but implement your own sorting algorithm instead.",
    "output": "function SortedDescending(list1: array of integer): array of integer;\nbegin\n  for var i := 0 to list1.Length - 1 do\n    for var j := i + 1 to list1.Length - 1 do\n      if list1[i] < list1[j] then\n      begin\n        var temp := list1[i];\n        list1[i] := list1[j];\n        list1[j] := temp;\n      end;\n  \n  Result := list1;\nend;"
  },
  {
    "instruction": "Write a function that takes an integer and returns a list of its digits.",
    "output": "function DigitsList(n: integer): array of integer;\nbegin\n  var numStr := n.ToString;\n  var res := new integer[numStr.Length];\n  \n  for var i := 0 to numStr.Length - 1 do\n    res[i] := StrToInt(numStr[i]);\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum difference between any two elements in a given list of integers.",
    "output": "function MinDifference(arr: array of integer): integer;\nbegin\n  &Array.Sort(arr);\n  var minDiff := integer.MaxValue;\n  \n  for var i := 1 to arr.Length - 1 do\n  begin\n    var diff := arr[i] - arr[i - 1];\n    if diff < minDiff then\n      minDiff := diff;\n  end;\n  \n  Result := minDiff;\nend;"
  },
  {
    "instruction": "Write a function to reverse the elements of a given list in groups of size K.",
    "output": "function ReverseListInGroups(inputList: array of integer; k: integer): array of integer;\nbegin\n  var output := new List<integer>;\n  \n  for var i := 0 to inputList.Length - 1 step k do\n  begin\n    var group := inputList[i:Min(i + k, inputList.Length)];\n    &Array.Reverse(group);\n    output.AddRange(group);\n  end;\n  \n  Result := output.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the number of closed islands in a given grid. A closed island is an area of 0s that is completely surrounded by 1s and is not connected to the borders of the grid. Grids are represented as a list of lists, where each sub-list represents a row of the grid and each element in the sub-list represents the value of the grid at that position (0 or 1).",
    "output": "function IsValid(row, col, R, C: integer): boolean;\nbegin\n  Result := (row >= 0) and (row < R) and (col >= 0) and (col < C);\nend;\n\nfunction IsBorder(row, col, R, C: integer): boolean;\nbegin\n  Result := (row = 0) or (row = R - 1) or (col = 0) or (col = C - 1);\nend;\n\nprocedure BFS(grid: array of array of integer; row, col, R, C: integer; directions: array of (integer, integer));\nbegin\n  grid[row, col] := 1;\n  var queue := new Queue<(integer, integer)>;\n  queue.Enqueue((row, col));\n  \n  while queue.Count > 0 do\n  begin\n    var (currR, currC) := queue.Dequeue;\n    \n    for var i := 0 to directions.Length - 1 do\n    begin\n      var (dr, dc) := directions[i];\n      var nr := currR + dr;\n      var nc := currC + dc;\n      \n      if IsValid(nr, nc, R, C) and (grid[nr, nc] = 0) then\n      begin\n        grid[nr, nc] := 1;\n        queue.Enqueue((nr, nc));\n      end;\n    end;\n  end;\nend;\n\nfunction ClosedIsland(grid: array of array of integer): integer;\nbegin\n  var R := grid.Length;\n  var C := grid[0].Length;\n  var directions := Arr((1, 0), (0, 1), (-1, 0), (0, -1));\n  \n  for var row := 0 to R - 1 do\n    for var col := 0 to C - 1 do\n      if IsBorder(row, col, R, C) and (grid[row, col] = 0) then\n        BFS(grid, row, col, R, C, directions);\n  \n  var res := 0;\n  for var row := 0 to R - 1 do\n    for var col := 0 to C - 1 do\n      if grid[row, col] = 0 then\n      begin\n        BFS(grid, row, col, R, C, directions);\n        res += 1;\n      end;\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function that determines if a given list of words is a valid word square. A word square is a set of words that can be arranged in a grid where the n-th row and column are the same for all n. Additionally, the function should check if the word square is a magic square, meaning the sum of the values of the letters in each row and column are equal (a=1, b=2, ..., z=26).",
    "output": "function IsValidWordSquare(words: array of string): boolean;\nbegin\n  if words.Length = 0 then\n  begin\n    Result := true;\n    exit;\n  end;\n  \n  var n := words.Length;\n  for var i := 0 to n - 1 do\n    for var j := 0 to words[i].Length - 1 do\n      if (j >= n) or (i >= words[j].Length) or (words[i][j] <> words[j][i]) then\n      begin\n        Result := false;\n        exit;\n      end;\n  \n  Result := true;\nend;\n\nfunction IsMagicWordSquare(words: array of string): boolean;\nbegin\n  if not IsValidWordSquare(words) then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  var n := words.Length;\n  var rowSum := 0;\n  for var i := 0 to words[0].Length - 1 do\n    rowSum += Ord(words[0][i]) - Ord('a') + 1;\n  \n  for var i := 1 to n - 1 do\n  begin\n    var currentRowSum := 0;\n    for var j := 0 to words[i].Length - 1 do\n      currentRowSum += Ord(words[i][j]) - Ord('a') + 1;\n    if currentRowSum <> rowSum then\n    begin\n      Result := false;\n      exit;\n    end;\n  end;\n  \n  for var j := 0 to n - 1 do\n  begin\n    var colSum := 0;\n    for var i := 0 to n - 1 do\n      colSum += Ord(words[i][j]) - Ord('a') + 1;\n    if colSum <> rowSum then\n    begin\n      Result := false;\n      exit;\n    end;\n  end;\n  \n  Result := true;\nend;"
  },
  {
    "instruction": "Write a function to find the number of distinct subsequences of a given string.\n\nA subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters.\n\nFor example, \"ace\" is a subsequence of \"abcde\".",
    "output": "function NumDistinctSubsequences(s, t: string): integer;\nbegin\n  var dp := new integer[t.Length + 1];\n  dp[0] := 1;\n  var sPtr := 0;\n  \n  while sPtr < s.Length do\n  begin\n    for var tPtr := t.Length - 1 downto 0 do\n    begin\n      if s[sPtr] = t[tPtr] then\n        dp[tPtr + 1] += dp[tPtr];\n    end;\n    sPtr += 1;\n  end;\n  \n  Result := dp[t.Length];\nend;"
  },
  {
    "instruction": "Write a function to find the most frequent word in a given list of strings.",
    "output": "function ModeNumber(listNums: array of string): string;\nbegin\n  var occurrenceCount := new Dictionary<string, integer>;\n  \n  for var i := 0 to listNums.Length - 1 do\n  begin\n    if not occurrenceCount.ContainsKey(listNums[i]) then\n      occurrenceCount[listNums[i]] := 0;\n    occurrenceCount[listNums[i]] += 1;\n  end;\n  \n  var maxCount := occurrenceCount.Values.Max;\n  var mostCommon := occurrenceCount.First(pair -> pair.Value = maxCount).Key;\n  \n  Result := mostCommon;\nend;"
  },
  {
    "instruction": "Write a function that checks if there is a valid \"234\" pattern in a given list of integers. A valid \"234\" pattern is defined as a triplet (i, j, k) such that i < j < k and nums[i] < nums[k] < nums[j].",
    "output": "function Check234Pattern(nums: array of integer): boolean;\nbegin\n  var deq := new Stack<integer>;\n  var num2 := -1;\n  \n  for var i := nums.Length - 1 downto 0 do\n  begin\n    if (num2 <> -1) and (nums[i] < num2) then\n    begin\n      Result := true;\n      exit;\n    end;\n    \n    while (deq.Count > 0) and (deq.Peek < nums[i]) do\n      num2 := deq.Pop;\n    \n    deq.Push(nums[i]);\n  end;\n  \n  Result := false;\nend;"
  },
  {
    "instruction": "Write a function that takes a positive integer and returns the product of all the digits in the number.",
    "output": "function ProductOfDigits(n: integer): integer;\nbegin\n  var product := 1;\n  while n > 0 do\n  begin\n    product := product * (n mod 10);\n    n := n div 10;\n    if product = 0 then\n    begin\n      Result := 0;\n      exit;\n    end;\n  end;\n  Result := product;\nend;"
  },
  {
    "instruction": "Write a function to check if a given string is a rotation of a palindrome. A rotation of a string is a rearrangement of its characters where the characters are shifted to the left or right by a certain number of positions. A palindrome is a string that reads the same forwards and backwards.",
    "output": "function IsRotationPalindrome(s: string): boolean;\nbegin\n  for var i := 0 to s.Length - 1 do\n  begin\n    var rotated := s.Substring(i) + s.Substring(0, i);\n    if rotated = new string(rotated.Reverse.ToArray) then\n    begin\n      Result := true;\n      exit;\n    end;\n  end;\n  Result := false;\nend;"
  },
  {
    "instruction": "Write a function that generates a random number within a given range and checks if the number is prime. If the number is not prime, generate another random number until a prime number is found.",
    "output": "function IsPrime(n: integer): boolean;\nbegin\n  if n <= 1 then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  if n = 2 then\n  begin\n    Result := true;\n    exit;\n  end;\n  \n  if n mod 2 = 0 then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  var i := 3;\n  while i * i <= n do\n  begin\n    if n mod i = 0 then\n    begin\n      Result := false;\n      exit;\n    end;\n    i += 2;\n  end;\n  \n  Result := true;\nend;\n\nfunction IsPrimeRandom(minVal, maxVal: integer): integer;\nbegin\n  while true do\n  begin\n    var num := Random(minVal, maxVal);\n    if IsPrime(num) then\n    begin\n      Result := num;\n      exit;\n    end;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to check if a given string is a rotation of a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same backward or forward. A rotation of a string is a rearrangement of its characters by moving the first character to the end.",
    "output": "function IsPalindrome(s: string): boolean;\nbegin\n  Result := s = new string(s.Reverse.ToArray);\nend;\n\nfunction IsRotatedPalindrome(s: string): boolean;\nbegin\n  for var i := 0 to s.Length - 1 do\n  begin\n    var rotated := s.Substring(i) + s.Substring(0, i);\n    if IsPalindrome(rotated) then\n    begin\n      Result := true;\n      exit;\n    end;\n  end;\n  Result := false;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum value from a list of tuples based on the second element of each tuple.",
    "output": "function FindMaxBySecondElement(tuplesList: List<(string, integer)>): integer;\nbegin\n  Result := tuplesList.Max(t -> t[1]);\nend;"
  },
  {
    "instruction": "Write a function to find the length of the maximum subarray that is in \"turbulence\". An array is in turbulence if for each index i between 1 and len(A) - 1, either A[i-1] < A[i] > A[i+1] or A[i-1] > A[i] < A[i+1].",
    "output": "function IsCurrIndexTurbulent(arr: array of integer; k: integer): boolean;\nbegin\n  Result := ((arr[k] > arr[k - 1]) and (arr[k] > arr[k + 1])) or\n            ((arr[k] < arr[k - 1]) and (arr[k] < arr[k + 1]));\nend;\n\nfunction MaxTurbulenceSize(arr: array of integer): integer;\nbegin\n  if arr.Length < 2 then\n  begin\n    Result := arr.Length;\n    exit;\n  end;\n  \n  var maximum := 1;\n  var startIdx := 0;\n  var &end := 0;\n  var N := arr.Length;\n  \n  while startIdx + 1 < N do\n  begin\n    if arr[startIdx] = arr[startIdx + 1] then\n    begin\n      startIdx += 1;\n      continue;\n    end;\n    \n    &end := startIdx + 1;\n    while (&end + 1 < N) and IsCurrIndexTurbulent(arr, &end) do\n      &end += 1;\n    \n    maximum := Max(maximum, &end - startIdx + 1);\n    startIdx := &end;\n  end;\n  \n  Result := maximum;\nend;"
  },
  {
    "instruction": "Write a function to search for a pattern in a given text using the Boyer-Moore algorithm. The function should return the index of the first occurrence of the pattern in the text, or -1 if the pattern is not found.",
    "output": "function GetBadCharacterShift(pattern: string): Dictionary<char, integer>;\nbegin\n  var badCharShift := new Dictionary<char, integer>;\n  for var i := 0 to pattern.Length - 2 do\n    badCharShift[pattern[i]] := pattern.Length - i - 1;\n  Result := badCharShift;\nend;\n\nfunction BoyerMooreSearch(text, pattern: string): integer;\nbegin\n  var textLength := text.Length;\n  var patternLength := pattern.Length;\n\n  if patternLength > textLength then\n  begin\n    Result := -1;\n    exit;\n  end;\n\n  var badCharShift := GetBadCharacterShift(pattern);\n  var i := patternLength - 1;\n\n  while i < textLength do\n  begin\n    var j := patternLength - 1;\n    var k := i;\n\n    while (j >= 0) and (text[k] = pattern[j]) do\n    begin\n      k -= 1;\n      j -= 1;\n    end;\n\n    if j = -1 then\n    begin\n      Result := k + 1;\n      exit;\n    end\n    else\n    begin\n      var offset := patternLength;\n      if badCharShift.ContainsKey(text[i]) then\n        offset := badCharShift[text[i]];\n      i += offset;\n    end;\n  end;\n\n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns the length of the longest harmonious subsequence. A harmonious subsequence is a subsequence where the difference between the maximum and minimum elements is exactly 1.",
    "output": "function FindLongestHarmoniousSubsequence(nums: array of integer): integer;\nbegin\n  var counts := new Dictionary<integer, integer>;\n  \n  for var i := 0 to nums.Length - 1 do\n  begin\n    if not counts.ContainsKey(nums[i]) then\n      counts[nums[i]] := 0;\n    counts[nums[i]] += 1;\n  end;\n\n  var lengthVal := 0;\n  foreach var c in counts.Keys do\n  begin\n    if counts.ContainsKey(c + 1) then\n      lengthVal := Max(lengthVal, counts[c] + counts[c + 1]);\n  end;\n  \n  Result := lengthVal;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of repetitions of a second string within the first string, considering the first string is repeated a given number of times. This problem is inspired by the 3rd solution algorithm provided above.\n\nThe function should take four parameters:\n- `s1`: The first string.\n- `n1`: The number of times the first string is repeated.\n- `s2`: The second string.\n- `n2`: The number of times to count the repetitions of the second string within the first.\n\nThe function should return the maximum number of repetitions of `s2` within `s1` repeated `n1` times, divided by `n2`.",
    "output": "function GetMaxRepetitions(s1: string; n1: integer; s2: string; n2: integer): integer;\nbegin\n  var countS1 := new Dictionary<char, integer>;\n  var countS2 := new Dictionary<char, integer>;\n  \n  for var i := 0 to s1.Length - 1 do\n  begin\n    if not countS1.ContainsKey(s1[i]) then\n      countS1[s1[i]] := 0;\n    countS1[s1[i]] += 1;\n  end;\n  \n  for var i := 0 to s2.Length - 1 do\n  begin\n    if not countS2.ContainsKey(s2[i]) then\n      countS2[s2[i]] := 0;\n    countS2[s2[i]] += 1;\n  end;\n  \n  foreach var ch in countS2.Keys do\n    if not countS1.ContainsKey(ch) then\n    begin\n      Result := 0;\n      exit;\n    end;\n  \n  var l1 := s1.Length;\n  var l2 := s2.Length;\n  var i1 := 0;\n  var i2 := 0;\n  var total := l1 * n1;\n  var dic := new Dictionary<(integer, integer), (integer, integer)>;\n  \n  while i1 < total do\n  begin\n    if s1[i1 mod l1] = s2[i2 mod l2] then\n    begin\n      var key := (i1 mod l1, i2 mod l2);\n      if dic.ContainsKey(key) then\n      begin\n        var (prev1, prev2) := dic[key];\n        var cir1 := i1 - prev1;\n        var cir2 := i2 - prev2;\n        var countCir1 := (total - i1) div cir1;\n        i1 += countCir1 * cir1;\n        i2 += countCir1 * cir2;\n        if i1 >= total then break;\n      end\n      else\n        dic[key] := (i1, i2);\n      i2 += 1;\n    end;\n    i1 += 1;\n  end;\n  \n  Result := i2 div (l2 * n2);\nend;"
  },
  {
    "instruction": "Write a function to check if a string is a valid parentheses sequence. A valid parentheses sequence is defined as any combination of \"()\", \"[]\" and \"{}\" where each opening bracket has a corresponding closing bracket of the same type.",
    "output": "uses System.Collections.Generic;\n\nfunction ValidParenthesesSequence(s: string): boolean;\nbegin\n  var mapping := new Dictionary<char, char>;\n  mapping[')'] := '(';\n  mapping[']'] := '[';\n  mapping['}'] := '{';\n  \n  var stack := new Stack<char>;\n  \n  for var i := 0 to s.Length - 1 do\n  begin\n    if mapping.ContainsValue(s[i]) then\n      stack.Push(s[i])\n    else if mapping.ContainsKey(s[i]) then\n    begin\n      if (stack.Count = 0) or (mapping[s[i]] <> stack.Pop) then\n      begin\n        Result := false;\n        exit;\n      end;\n    end\n    else\n    begin\n      Result := false;\n      exit;\n    end;\n  end;\n  \n  Result := stack.Count = 0;\nend;"
  },
  {
    "instruction": "Write a function to count the number of pairs in an array that sum up to a given value.",
    "output": "function CountPairsSum(arr: array of integer; targetSum: integer): integer;\nbegin\n  var count := 0;\n  var freq := new Dictionary<integer, integer>;\n  \n  for var i := 0 to arr.Length - 1 do\n  begin\n    var complement := targetSum - arr[i];\n    if freq.ContainsKey(complement) then\n      count += freq[complement];\n    \n    if freq.ContainsKey(arr[i]) then\n      freq[arr[i]] += 1\n    else\n      freq[arr[i]] := 1;\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to rotate a 2D array clockwise by 90 degrees.",
    "output": "function Rotate2DArray(matrix: array [,] of integer): array [,] of integer;\nbegin\n  if matrix.GetLength(0) = 0 then\n  begin\n    Result := new integer[0, 0];\n    exit;\n  end;\n  \n  var rotated := new integer[matrix.GetLength(1), matrix.GetLength(0)];\n  \n  for var i := 0 to matrix.GetLength(0) - 1 do\n    for var j := 0 to matrix.GetLength(1) - 1 do\n      rotated[j, matrix.GetLength(0) - 1 - i] := matrix[i, j];\n  \n  Result := rotated;\nend;"
  },
  {
    "instruction": "Write a function to determine if a given list of numbers is a valid permutation.\n\nA valid permutation is defined as a list that contains all the numbers from 1 to N, where N is the length of the list.",
    "output": "function ValidPermutation(A: array of integer): boolean;\nbegin\n  var size := A.Length;\n  if size < 1 then\n  begin\n    Result := false;\n    exit;\n  end;\n\n  for var i := 1 to size do\n    if not A.Contains(i) then\n    begin\n      Result := false;\n      exit;\n    end;\n  \n  Result := true;\nend;"
  },
  {
    "instruction": "Write a function to calculate the weighted average of a list of numbers. The weights are provided in a separate list that has the same length as the list of numbers.",
    "output": "function WeightedAverage(numbers, weights: array of real): real;\nbegin\n  if numbers.Length <> weights.Length then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var weightedSum := 0.0;\n  var weightSum := 0.0;\n  \n  for var i := 0 to numbers.Length - 1 do\n  begin\n    weightedSum += numbers[i] * weights[i];\n    weightSum += weights[i];\n  end;\n  \n  Result := weightedSum / weightSum;\nend;"
  },
  {
    "instruction": "Write a function to calculate the maximum number of words found in a list of sentences.",
    "output": "function MostWordsFound(sentences: array of string): integer;\nbegin\n  var count1 := new List<integer>;\n  \n  for var i := 0 to sentences.Length - 1 do\n  begin\n    var a := sentences[i].Split(' ');\n    var b := a.Length;\n    count1.Add(b);\n  end;\n  \n  Result := count1.Max;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of words and returns the longest word that contains only unique characters. If there are multiple longest words with the same length, return the one that appears first in the list.",
    "output": "function LongestUniqueWord(words: array of string): string;\nbegin\n  var longestWord := '';\n  \n  for var i := 0 to words.Length - 1 do\n  begin\n    var uniqueChars := new HashSet<char>(words[i]);\n    if (uniqueChars.Count = words[i].Length) and (words[i].Length > longestWord.Length) then\n      longestWord := words[i];\n  end;\n  \n  Result := longestWord;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of perfect square numbers which sum to 'n'.",
    "output": "function FindMinSquares(n: integer): integer;\nbegin\n  var dp := new integer[n + 1];\n  \n  for var i := 1 to n do\n  begin\n    var minVal := integer.MaxValue;\n    var j := 1;\n    while j * j <= i do\n    begin\n      minVal := Min(minVal, dp[i - j * j] + 1);\n      j += 1;\n    end;\n    dp[i] := minVal;\n  end;\n  \n  Result := dp[n];\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of operations required to maximize the profit of a Ferris wheel. The Ferris wheel can only accommodate 4 people at a time, and each operation is to either add a new customer or run the Ferris wheel once. The input is a list of customers, the boarding cost, and the running cost. The function should return the minimum number of operations to maximize the profit, or -1 if no profit can be made.",
    "output": "function MinOperationsMaxProfit(customers: array of integer; boardingCost, runningCost: integer): integer;\nbegin\n  var remainingCustomers := 0;\n  var customersServed := 0;\n  var rotation := 0;\n  var maxProfit := -1;\n  var resultVal := 0;\n  var i := 0;\n  \n  while (remainingCustomers > 0) or (i < customers.Length) do\n  begin\n    rotation += 1;\n    if i < customers.Length then\n      remainingCustomers += customers[i];\n    \n    if remainingCustomers < 4 then\n    begin\n      customersServed += remainingCustomers;\n      remainingCustomers := 0;\n    end\n    else\n    begin\n      customersServed += 4;\n      remainingCustomers -= 4;\n    end;\n    \n    var profit := customersServed * boardingCost - rotation * runningCost;\n    if maxProfit < profit then\n    begin\n      maxProfit := profit;\n      resultVal := rotation;\n    end;\n    i += 1;\n  end;\n  \n  if maxProfit <= 0 then\n    Result := -1\n  else\n    Result := resultVal;\nend;"
  },
  {
    "instruction": "Write a function that generates a dictionary with keys as the integers from 1 to n, and values as the square of the keys.",
    "output": "function GenerateSquares(n: integer): Dictionary<integer, integer>;\nbegin\n  var resultDict := new Dictionary<integer, integer>;\n  \n  for var i := 1 to n do\n    resultDict[i] := i * i;\n  \n  Result := resultDict;\nend;"
  },
  {
    "instruction": "Write a function to find the longest subarray with equal number of 0's and 1's in a given binary array.",
    "output": "function LongestEqualBinary(arr: array of integer): integer;\nbegin\n  var maxLen := 0;\n  var count := 0;\n  var countMap := new Dictionary<integer, integer>;\n  countMap[0] := -1;\n  \n  for var i := 0 to arr.Length - 1 do\n  begin\n    if arr[i] = 0 then\n      count -= 1\n    else\n      count += 1;\n\n    if countMap.ContainsKey(count) then\n      maxLen := Max(maxLen, i - countMap[count])\n    else\n      countMap[count] := i;\n  end;\n\n  Result := maxLen;\nend;"
  },
  {
    "instruction": "Write a function to create a linked list from a list. Then, create a partition function that will partition the linked list based on a given value 'x'. This partition function should rearrange the list so that all nodes with values less than 'x' come before all nodes with values greater than or equal to 'x'. The original relative order of the nodes in each partition should be preserved.",
    "output": "type\n  ListNode = class\n    val: integer;\n    next: ListNode;\n    \n    constructor Create(x: integer);\n    begin\n      val := x;\n      next := nil;\n    end;\n  end;\n\nfunction CreateLinkedList(lst: array of integer): ListNode;\nbegin\n  if lst.Length = 0 then\n  begin\n    Result := nil;\n    exit;\n  end;\n  \n  var head := new ListNode(lst[0]);\n  var current := head;\n  \n  for var i := 1 to lst.Length - 1 do\n  begin\n    current.next := new ListNode(lst[i]);\n    current := current.next;\n  end;\n  \n  Result := head;\nend;\n\nfunction PartitionList(head: ListNode; x: integer): ListNode;\nbegin\n  var leftHead := new ListNode(0);\n  var left := leftHead;\n  var rightHead := new ListNode(0);\n  var right := rightHead;\n  var current := head;\n  \n  while current <> nil do\n  begin\n    if current.val < x then\n    begin\n      left.next := current;\n      left := left.next;\n    end\n    else\n    begin\n      right.next := current;\n      right := right.next;\n    end;\n    current := current.next;\n  end;\n  \n  left.next := rightHead.next;\n  right.next := nil;\n  Result := leftHead.next;\nend;\n\nfunction LinkedListToList(head: ListNode): array of integer;\nbegin\n  var lst := new List<integer>;\n  var current := head;\n  \n  while current <> nil do\n  begin\n    lst.Add(current.val);\n    current := current.next;\n  end;\n  \n  Result := lst.ToArray;\nend;\n\nfunction PartitionLinkedList(lst: array of integer; x: integer): array of integer;\nbegin\n  var head := CreateLinkedList(lst);\n  var partitionedHead := PartitionList(head, x);\n  Result := LinkedListToList(partitionedHead);\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of unique integers after removing 'k' elements from the given list.",
    "output": "function FindMinUniqueInts(arr: array of integer; k: integer): integer;\nbegin\n  var counts := new Dictionary<integer, integer>;\n  \n  for var i := 0 to arr.Length - 1 do\n  begin\n    if not counts.ContainsKey(arr[i]) then\n      counts[arr[i]] := 0;\n    counts[arr[i]] += 1;\n  end;\n  \n  var freqs := new List<(integer, integer)>;\n  foreach var pair in counts do\n    freqs.Add((pair.Value, pair.Key));\n  \n  freqs.Sort((x, y) -> x[0].CompareTo(y[0]));\n  var uniqueInts := freqs.Count;\n  \n  for var i := 0 to freqs.Count - 1 do\n  begin\n    if freqs[i][0] <= k then\n    begin\n      k -= freqs[i][0];\n      uniqueInts -= 1;\n    end\n    else\n      break;\n  end;\n  \n  Result := uniqueInts;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns a new list with all the odd numbers removed.",
    "output": "function RemoveOddNumbers(nums: array of integer): array of integer;\nbegin\n  Result := nums.Where(x -> x mod 2 = 0).ToArray;\nend;"
  },
  {
    "instruction": "Write a function to simulate the game of \"Rock, Paper, Scissors\". The function should take two inputs representing the choices of two players and return the result of the game.",
    "output": "function RockPaperScissors(player1, player2: string): string;\nbegin\n  if player1 = player2 then\n    Result := 'It is a tie!'\n  else if ((player1 = 'rock') and (player2 = 'scissors')) or\n          ((player1 = 'scissors') and (player2 = 'paper')) or\n          ((player1 = 'paper') and (player2 = 'rock')) then\n    Result := 'Player 1 wins!'\n  else\n    Result := 'Player 2 wins!';\nend;"
  },
  {
    "instruction": "Write a function to check if a given string has a symmetry point. A string has a symmetry point if it can be split into two halves that are mirror images of each other. The function should return the index of the symmetry point, or -1 if the string does not have a symmetry point.",
    "output": "function SymmetryPoint(S: string): integer;\nbegin\n  var N := S.Length;\n  \n  if (N = 0) or (N mod 2 = 0) then\n  begin\n    Result := -1;\n    exit;\n  end;\n  \n  for var i := 0 to N - 1 do\n  begin\n    if S[i] <> S[N - 1 - i] then\n    begin\n      Result := -1;\n      exit;\n    end\n    else if i = N - 1 - i then\n    begin\n      Result := i;\n      exit;\n    end;\n  end;\n  \n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function that takes in a target integer, a list of integers, and a maximum number of operations. The function should determine if it's possible to reach the target integer by adding and/or subtracting the integers in the list, up to the specified number of operations. The integers in the list can be used multiple times.",
    "output": "function IsTargetReachable(target: integer; nums: array of integer; maxOps: integer): boolean;\n\n  function DFS(remaining, ops: integer): boolean;\n  begin\n    if remaining = 0 then\n    begin\n      Result := true;\n      exit;\n    end;\n    \n    if ops = 0 then\n    begin\n      Result := false;\n      exit;\n    end;\n    \n    for var i := 0 to nums.Length - 1 do\n    begin\n      if DFS(remaining + nums[i], ops - 1) or DFS(remaining - nums[i], ops - 1) then\n      begin\n        Result := true;\n        exit;\n      end;\n    end;\n    \n    Result := false;\n  end;\n\nbegin\n  Result := DFS(target, maxOps);\nend;"
  },
  {
    "instruction": "Write a function `count_prime_hex_digits(hex_string: str) -> int` that takes a hexadecimal string as input and returns the count of characters in the string that represent prime numbers in the hexadecimal system. In the hexadecimal system, the digits range from 0-9 and A-F. The prime digits in hexadecimal are 2, 3, 5, 7, B, and D.",
    "output": "function CountPrimeHexDigits(hexString: string): integer;\nbegin\n  var primeHexDigits := new HashSet<char>(Arr('2', '3', '5', '7', 'B', 'D'));\n  var count := 0;\n  \n  for var i := 0 to hexString.Length - 1 do\n    if primeHexDigits.Contains(hexString[i]) then\n      count += 1;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function that finds the smallest possible integer value for x, such that (x * 2) + 1 equals the given odd number n.",
    "output": "function FindSmallestX(n: integer): integer;\nbegin\n  Result := (n - 1) div 2;\nend;"
  },
  {
    "instruction": "Write a function to find the index of the first occurrence of the given character in a string. If the character is not found, return -1.",
    "output": "function FindCharIndex(s: string; c: char): integer;\nbegin\n  for var i := 0 to s.Length - 1 do\n    if s[i] = c then\n    begin\n      Result := i;\n      exit;\n    end;\n  \n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to sort a list of integers based on the number of ones in their binary representation. If two numbers have the same number of ones, they should be sorted based on their decimal value.",
    "output": "function Ones(n: integer): integer;\nbegin\n  var count := 0;\n  while n > 0 do\n  begin\n    count += n and 1;\n    n := n shr 1;\n  end;\n  Result := count;\nend;\n\nfunction SortByBits(arr: array of integer): array of integer;\nbegin\n  Result := arr.OrderBy(x -> (Ones(x), x)).ToArray;\nend;"
  },
  {
    "instruction": "Write a function to check if a number is a Mersenne prime. A Mersenne number is a number that is one less than a power of two (2^n - 1). A Mersenne prime is a Mersenne number that is also a prime number.",
    "output": "function IsPrime(n: integer): boolean;\nbegin\n  if n <= 1 then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  if n <= 3 then\n  begin\n    Result := true;\n    exit;\n  end;\n  \n  if (n mod 2 = 0) or (n mod 3 = 0) then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  var i := 5;\n  while i * i <= n do\n  begin\n    if (n mod i = 0) or (n mod (i + 2) = 0) then\n    begin\n      Result := false;\n      exit;\n    end;\n    i += 6;\n  end;\n  \n  Result := true;\nend;\n\nfunction IsMersennePrime(n: integer): boolean;\nbegin\n  if IsPrime(n) then\n  begin\n    var m := (BigInteger(1) shl n) - 1;\n    Result := IsPrime(integer(m));\n  end\n  else\n    Result := false;\nend;"
  },
  {
    "instruction": "Write a function that calculates the number of bits in an integer. This function should take an integer as input and return the number of bits in its binary representation.",
    "output": "function BitsInInt(n: integer): integer;\nbegin\n  Result := System.Convert.ToString(n, 2).Length;\nend;"
  },
  {
    "instruction": "Write a function that takes in two lists of equal length and returns a new list where each element is the product of the elements at the same index in the original lists.",
    "output": "function ProductLists(list1, list2: array of integer): array of integer;\nbegin\n  var resultList := new List<integer>;\n  \n  for var i := 0 to list1.Length - 1 do\n    resultList.Add(list1[i] * list2[i]);\n  \n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the number of unique pairs in a given array that sum up to a specific target.",
    "output": "function FindUniquePairs(arr: array of integer; target: integer): integer;\nbegin\n  &Array.Sort(arr);\n  var res := new HashSet<(integer, integer)>;\n  var lo := 0;\n  var hi := arr.Length - 1;\n\n  while lo < hi do\n  begin\n    if arr[lo] + arr[hi] < target then\n      lo += 1\n    else if arr[lo] + arr[hi] > target then\n      hi -= 1\n    else\n    begin\n      res.Add((arr[lo], arr[hi]));\n      lo += 1;\n      hi -= 1;\n    end;\n  end;\n  \n  Result := res.Count;\nend;"
  },
  {
    "instruction": "Write a function to determine the minimum number of operations required to convert the arr array into a permutation of the target array. In one operation, you can insert any integer at any position in arr.",
    "output": "function MinOperationsToPermutation(target, arr: array of integer): integer;\nbegin\n  var targetIndex := new Dictionary<integer, integer>;\n  \n  for var i := 0 to target.Length - 1 do\n    targetIndex[target[i]] := i;\n  \n  var seq := new List<integer>;\n  for var i := 0 to arr.Length - 1 do\n    if targetIndex.ContainsKey(arr[i]) then\n      seq.Add(targetIndex[arr[i]]);\n  \n  var lis := new List<integer>;\n  for var i := 0 to seq.Count - 1 do\n  begin\n    var num := seq[i];\n    var pos := lis.BinarySearch(num);\n    if pos < 0 then\n      pos := not pos;\n    \n    if pos = lis.Count then\n      lis.Add(num)\n    else\n      lis[pos] := num;\n  end;\n  \n  Result := target.Length - lis.Count;\nend;"
  },
  {
    "instruction": "Write a function to find the day of the week for a given date in the format of year, month and day.",
    "output": "function FindDay(year, month, day: integer): string;\nbegin\n  var date := new DateTime(year, month, day);\n  Result := date.DayOfWeek.ToString;\nend;"
  },
  {
    "instruction": "Write a function that checks whether a given matrix is a diagonal matrix or not. A matrix is considered diagonal if all its non-diagonal elements are zero.",
    "output": "function IsDiagonal(matrix: array of array of integer): boolean;\nbegin\n  for var i := 0 to matrix.Length - 1 do\n    for var j := 0 to matrix[i].Length - 1 do\n      if (i <> j) and (matrix[i, j] <> 0) then\n      begin\n        Result := false;\n        exit;\n      end;\n  \n  Result := true;\nend;"
  },
  {
    "instruction": "Write a function to calculate the total number of valid parentheses combinations that can be formed with a given number of pairs of parentheses.",
    "output": "function CountParenthesesCombinations(n: integer): integer;\nbegin\n  if n = 0 then\n  begin\n    Result := 1;\n    exit;\n  end;\n  \n  if n = 1 then\n  begin\n    Result := 1;\n    exit;\n  end;\n  \n  var resultVal := 0;\n  for var i := 0 to n - 1 do\n    resultVal += CountParenthesesCombinations(i) * CountParenthesesCombinations(n - 1 - i);\n  \n  Result := resultVal;\nend;"
  },
  {
    "instruction": "Write a function to find if a directed graph contains a cycle using Depth-First Search (DFS). The graph is represented as a list of edges in the form of [u, v] where u is a predecessor of v.",
    "output": "procedure DFS(node: integer; var visited, onPath: array of boolean; edges: array of array of integer; var hasCycle: boolean);\nbegin\n  if onPath[node] then\n  begin\n    hasCycle := true;\n    exit;\n  end;\n  \n  if visited[node] or hasCycle then\n    exit;\n  \n  visited[node] := true;\n  onPath[node] := true;\n  \n  for var i := 0 to edges.Length - 1 do\n  begin\n    if edges[i][0] = node then\n      DFS(edges[i][1], visited, onPath, edges, hasCycle);\n  end;\n  \n  onPath[node] := false;\nend;\n\nfunction DetectCycleDFS(edges: array of array of integer; numCourses: integer): boolean;\nbegin\n  var visited := new boolean[numCourses];\n  var onPath := new boolean[numCourses];\n  var hasCycle := false;\n  \n  for var i := 0 to numCourses - 1 do\n  begin\n    if not visited[i] then\n      DFS(i, visited, onPath, edges, hasCycle);\n  end;\n  \n  Result := hasCycle;\nend;"
  },
  {
    "instruction": "Write a function to find the unique longest substring without repeating characters in a given string.",
    "output": "function UniqueLongestSubstring(s: string): string;\nbegin\n  var charSet := new HashSet<char>;\n  var left := 0;\n  var res := '';\n  \n  for var right := 0 to s.Length - 1 do\n  begin\n    while charSet.Contains(s[right]) do\n    begin\n      charSet.Remove(s[left]);\n      left += 1;\n    end;\n    \n    charSet.Add(s[right]);\n    \n    if res.Length < right - left + 1 then\n      res := s.Substring(left, right - left + 1);\n  end;\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function that takes a positive integer n and returns the list of all positive integers that are less than n and relatively prime to n. Two numbers are relatively prime if their greatest common divisor (GCD) is 1.",
    "output": "function GCD(a, b: integer): integer;\nbegin\n  while b <> 0 do\n  begin\n    var temp := b;\n    b := a mod b;\n    a := temp;\n  end;\n  Result := a;\nend;\n\nfunction RelativePrimes(n: integer): array of integer;\nbegin\n  var resultList := new List<integer>;\n  \n  for var i := 1 to n - 1 do\n    if GCD(i, n) = 1 then\n      resultList.Add(i);\n  \n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to jump to the last step if you can jump 1, 2, or 3 steps at a time.",
    "output": "function JumpStairs(n: integer): integer;\nbegin\n  if n <= 1 then\n  begin\n    Result := n;\n    exit;\n  end;\n  \n  var first := 1;\n  var second := 2;\n  var third := 4;\n  \n  for var i := 3 to n - 1 do\n  begin\n    var total := first + second + third;\n    first := second;\n    second := third;\n    third := total;\n  end;\n  \n  Result := third;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum amount of water that can be trapped after raining using the given list of building heights. This function should calculate the maximum volume of water that can be trapped between the buildings.",
    "output": "function TrapRainwater(height: array of integer): integer;\nbegin\n  if height.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var left := 0;\n  var right := height.Length - 1;\n  var maxLeft := height[left];\n  var maxRight := height[right];\n  var trappedWater := 0;\n  \n  while left < right do\n  begin\n    if maxLeft < maxRight then\n    begin\n      left += 1;\n      maxLeft := Max(maxLeft, height[left]);\n      trappedWater += maxLeft - height[left];\n    end\n    else\n    begin\n      right -= 1;\n      maxRight := Max(maxRight, height[right]);\n      trappedWater += maxRight - height[right];\n    end;\n  end;\n  \n  Result := trappedWater;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of reorders required to make a directed graph strongly connected. A directed graph is strongly connected if there is a path from every node to every other node.",
    "output": "function MinReorder(n: integer; connections: array of (integer, integer)): integer;\nbegin\n  var edges := new Dictionary<integer, List<(integer, integer)>>;\n  \n  for var i := 0 to n - 1 do\n    edges[i] := new List<(integer, integer)>;\n  \n  foreach var (src, dest) in connections do\n  begin\n    edges[src].Add((dest, 1));\n    edges[dest].Add((src, 0));\n  end;\n  \n  var q := new Queue<integer>;\n  var visited := new HashSet<integer>;\n  var changes := 0;\n  \n  q.Enqueue(0);\n  visited.Add(0);\n  \n  while q.Count > 0 do\n  begin\n    var curr := q.Dequeue;\n    \n    foreach var (neiCity, cost) in edges[curr] do\n    begin\n      if not visited.Contains(neiCity) then\n      begin\n        visited.Add(neiCity);\n        changes += cost;\n        q.Enqueue(neiCity);\n      end;\n    end;\n  end;\n  \n  Result := changes;\nend;"
  },
  {
    "instruction": "Write a function to generate a sliding window of size 'k' over a given list and return the maximum value in each window.",
    "output": "function SlidingWindow(nums: array of integer; k: integer): array of integer;\nbegin\n  var resultList := new List<integer>;\n  \n  if nums.Length = 0 then\n  begin\n    Result := resultList.ToArray;\n    exit;\n  end;\n  \n  var window := new List<integer>(nums[0:k]);\n  var maxValue := window.Max;\n  resultList.Add(maxValue);\n  \n  for var i := k to nums.Length - 1 do\n  begin\n    window.RemoveAt(0);\n    window.Add(nums[i]);\n    maxValue := Max(maxValue, nums[i]);\n    \n    if nums[i - k] = maxValue then\n      maxValue := window.Max;\n    \n    resultList.Add(maxValue);\n  end;\n  \n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the most frequent element in a given array.",
    "output": "function MostFrequentElement(arr: array of integer): integer;\nbegin\n  var counter := new Dictionary<integer, integer>;\n  \n  for var i := 0 to arr.Length - 1 do\n  begin\n    if not counter.ContainsKey(arr[i]) then\n      counter[arr[i]] := 0;\n    counter[arr[i]] += 1;\n  end;\n  \n  var maxCount := counter.Values.Max;\n  Result := counter.First(pair -> pair.Value = maxCount).Key;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of tuples, where each tuple contains two elements (word, length). The function should return a dictionary where the keys are the unique lengths and the values are lists of words of that length. If multiple words have the same length, they should be grouped together in the list associated with that length. The words in each list should be in the order they appear in the input list.",
    "output": "function GroupByLength(wordLengthPairs: List<(string, integer)>): Dictionary<integer, List<string>>;\nbegin\n  var lengthToWords := new Dictionary<integer, List<string>>;\n  \n  for var i := 0 to wordLengthPairs.Count - 1 do\n  begin\n    var (word, length) := wordLengthPairs[i];\n    \n    if not lengthToWords.ContainsKey(length) then\n      lengthToWords[length] := new List<string>;\n    \n    lengthToWords[length].Add(word);\n  end;\n  \n  Result := lengthToWords;\nend;"
  },
  {
    "instruction": "Write a function to generate all possible permutations of a given list.",
    "output": "procedure Generate(start: integer; current: array of integer; resultList: List<array of integer>);\nbegin\n  if start = current.Length then\n  begin\n    resultList.Add(current.ToArray()); \n    exit;\n  end;\n  \n  for var i := start to current.Length - 1 do\n  begin\n    Swap(current[start], current[i]);\n    Generate(start + 1, current, resultList);\n    Swap(current[start], current[i]);\n  end;\nend;\n\nfunction GenPermutations(lst: array of integer): List<array of integer>;\nbegin\n  Result := new List<array of integer>;\n  Generate(0, lst.ToArray(), Result);\nend;"
  },
  {
    "instruction": "Write a function to check if two given sentences are similar based on a list of similar word pairs. Two sentences are considered similar if one sentence can become the other sentence by swapping some set of words in one sentence with their corresponding words in the other sentence. We may assume the sentences are of the same length, as specified by the constraint.",
    "output": "function AreSentencesSimilar(words1, words2: array of string; pairs: List<(string, string)>): boolean;\nbegin\n  var sim := new HashSet<(string, string)>;\n  \n  for var i := 0 to pairs.Count - 1 do\n  begin\n    var (x, y) := pairs[i];\n    sim.Add((x, y));\n    sim.Add((y, x));\n  end;\n  \n  if words1.Length <> words2.Length then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  for var i := 0 to words1.Length - 1 do\n  begin\n    var x := words1[i];\n    var y := words2[i];\n    \n    if (x <> y) and (not sim.Contains((x, y))) then\n    begin\n      Result := false;\n      exit;\n    end;\n  end;\n  \n  Result := true;\nend;"
  },
  {
    "instruction": "Write a function to find the number of unique paths from top-left corner to bottom-right corner of a grid. You can only move either down or right at any point in time.",
    "output": "function UniquePaths(m, n: integer): integer;\nbegin\n  if (m = 0) or (n = 0) then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var dp := new integer[m, n];\n  \n  for var i := 0 to m - 1 do\n    dp[i, 0] := 1;\n  \n  for var j := 0 to n - 1 do\n    dp[0, j] := 1;\n  \n  for var i := 1 to m - 1 do\n    for var j := 1 to n - 1 do\n      dp[i, j] := dp[i - 1, j] + dp[i, j - 1];\n  \n  Result := dp[m - 1, n - 1];\nend;"
  },
  {
    "instruction": "Write a function to find the maximum product of two integers in a given list of integers.",
    "output": "function MaxProduct(nums: array of integer): integer;\nbegin\n  &Array.Sort(nums);\n  Result := Max(nums[0] * nums[1], nums[nums.Length - 1] * nums[nums.Length - 2]);\nend;"
  },
  {
    "instruction": "Write a function that converts a given number to its corresponding day of the week.",
    "output": "function NumberToDay(num: integer): string;\nbegin\n  var days := Arr('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday');\n  \n  if (num < 1) or (num > 7) then\n    raise new System.ArgumentException('Number must be between 1 and 7');\n  \n  Result := days[num - 1];\nend;"
  },
  {
    "instruction": "Write a function to calculate the number of valid pairs in a list, where a pair (i, j) is considered valid if nums[i] == nums[j] and i < j.",
    "output": "function CountValidPairs(nums: array of integer): integer;\nbegin\n  var count := 0;\n  \n  for var i := 0 to nums.Length - 1 do\n    for var j := i + 1 to nums.Length - 1 do\n      if nums[i] = nums[j] then\n        count += 1;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function that returns the largest integer n where n^2 is less than or equal to a given number.",
    "output": "function ClosestSquare(num: integer): integer;\nbegin\n  Result := Trunc(Sqrt(num));\nend;"
  },
  {
    "instruction": "Write a function to find all the prime numbers in a given range of positive integers and return them in a list. The function should take two arguments, `start` and `end`, representing the start and end of the range, respectively. The range is inclusive, meaning both `start` and `end` are considered in the search for prime numbers.",
    "output": "function IsPrime(num: integer): boolean;\nbegin\n  if num <= 1 then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  if num <= 3 then\n  begin\n    Result := true;\n    exit;\n  end;\n  \n  if (num mod 2 = 0) or (num mod 3 = 0) then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  var i := 5;\n  while i * i <= num do\n  begin\n    if (num mod i = 0) or (num mod (i + 2) = 0) then\n    begin\n      Result := false;\n      exit;\n    end;\n    i += 6;\n  end;\n  \n  Result := true;\nend;\n\nfunction FindPrimesInRange(startVal, endVal: integer): array of integer;\nbegin\n  var primes := new List<integer>;\n  \n  for var num := startVal to endVal do\n    if IsPrime(num) then\n      primes.Add(num);\n  \n  Result := primes.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the total cost of hiring k workers from a list of candidates. The function should take in a list of integers representing the cost of each candidate, an integer k representing the number of workers to hire, and an integer representing the number of candidates to consider from the start and end of the list. The function should return the total cost of hiring the k workers with the lowest cost.",
    "output": "function TotalCost(costs: array of integer; k, candidates: integer): integer;\nbegin\n  var minHeap := new SortedSet<(integer, integer)>;\n  var seenIndex := new HashSet<integer>;\n  var left := candidates - 1;\n  var right := costs.Length - candidates;\n  var res := 0;\n  \n  for var i := 0 to costs.Length - 1 do\n  begin\n    if (i <= candidates - 1) or (i >= costs.Length - candidates) then\n    begin\n      minHeap.Add((costs[i], i));\n      seenIndex.Add(i);\n    end;\n  end;\n  \n  while k > 0 do\n  begin\n    var (cost, index) := minHeap.Min;\n    minHeap.Remove(minHeap.Min);\n    \n    if (index <= left) and (left < right) and (not seenIndex.Contains(left + 1)) then\n    begin\n      left += 1;\n      minHeap.Add((costs[left], left));\n      seenIndex.Add(left);\n    end\n    else if (index >= right) and (left < right) and (not seenIndex.Contains(right - 1)) then\n    begin\n      right -= 1;\n      minHeap.Add((costs[right], right));\n      seenIndex.Add(right);\n    end;\n    \n    res += cost;\n    k -= 1;\n  end;\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to convert a number from base 10 to base 3.",
    "output": "function ConvertToBase3(n: integer): integer;\nbegin\n  var base3 := '';\n  \n  while n > 0 do\n  begin\n    var remainder := n mod 3;\n    base3 := remainder.ToString + base3;\n    n := n div 3;\n  end;\n  \n  if base3 = '' then\n    Result := 0\n  else\n    Result := StrToInt(base3);\nend;"
  },
  {
    "instruction": "Write a function to find the longest strictly increasing subsequence of a sequence of numbers.",
    "output": "function LongestIncreasingSubsequence(nums: array of integer): integer;\nbegin\n  if nums.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var dp := new integer[nums.Length];\n  \n  for var i := 0 to nums.Length - 1 do\n    dp[i] := 1;\n  \n  for var i := 0 to nums.Length - 1 do\n    for var j := 0 to i - 1 do\n      if nums[i] > nums[j] then\n        dp[i] := Max(dp[i], dp[j] + 1);\n  \n  Result := dp.Max;\nend;"
  },
  {
    "instruction": "Write a function that converts a given 2D array into a single list by concatenating all its rows.",
    "output": "function Convert2DToList(matrix: array of array of integer): array of integer;\nbegin\n  var resultList := new List<integer>;\n  \n  for var i := 0 to matrix.Length - 1 do\n    for var j := 0 to matrix[i].Length - 1 do\n      resultList.Add(matrix[i][j]);\n  \n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function that checks if a given string is a valid HTML tag or not. A valid HTML tag starts with '<', followed by a sequence of alphabets and '-', and ends with '>'. The tag must not have any spaces. Also, the tag should be balanced i.e., if it opens with '<tag>', it should close with '</tag>'. Return True if the string is a valid HTML tag, else return False.",
    "output": "function ValidHtmlTag(s: string): boolean;\nbegin\n  var pattern := '^<([a-zA-Z0-9-]+)>(?:<[^>]*>)*</\\1>$';\n  var m := System.Text.RegularExpressions.Regex.Match(s, pattern);\n  Result := m.Success;\nend;"
  },
  {
    "instruction": "Write a function that takes two lists as input and returns a new list which is the element-wise sum of the two input lists.",
    "output": "function SumLists(list1, list2: array of integer): array of integer;\nbegin\n  if list1.Length <> list2.Length then\n    raise new System.ArgumentException('Lists must have the same length');\n  \n  var resultList := new List<integer>;\n  \n  for var i := 0 to list1.Length - 1 do\n    resultList.Add(list1[i] + list2[i]);\n  \n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function that takes a string as input and returns the length of the smallest substring that can be repeated to form the original string.\n\nFor example, the smallest repeating substring in \"abcabcabc\" is \"abc\", so the function should return 3. If there is no repeating pattern, the function should return the length of the entire string.",
    "output": "function SmallestRepeatingSubstringLength(s: string): integer;\nbegin\n  var length := s.Length;\n  \n  for var i := 1 to length div 2 do\n  begin\n    if length mod i = 0 then\n    begin\n      var substr := s.Substring(0, i);\n      var repeated := '';\n      \n      for var j := 1 to length div i do\n        repeated += substr;\n      \n      if repeated = s then\n      begin\n        Result := i;\n        exit;\n      end;\n    end;\n  end;\n  \n  Result := length;\nend;"
  },
  {
    "instruction": "Write a function to calculate the number of characters that need to be deleted to make two strings anagrams of each other.",
    "output": "function CalculateDeletions(str1, str2: string): integer;\nbegin\n  var counter1 := new Dictionary<char, integer>;\n  var counter2 := new Dictionary<char, integer>;\n  \n  for var i := 0 to str1.Length - 1 do\n  begin\n    if not counter1.ContainsKey(str1[i]) then\n      counter1[str1[i]] := 0;\n    counter1[str1[i]] += 1;\n  end;\n  \n  for var i := 0 to str2.Length - 1 do\n  begin\n    if not counter2.ContainsKey(str2[i]) then\n      counter2[str2[i]] := 0;\n    counter2[str2[i]] += 1;\n  end;\n  \n  var totalDeletions := 0;\n  \n  foreach var pair in counter1 do\n  begin\n    var char := pair.Key;\n    if counter2.ContainsKey(char) then\n      totalDeletions += Abs(pair.Value - counter2[char])\n    else\n      totalDeletions += pair.Value;\n  end;\n  \n  foreach var pair in counter2 do\n  begin\n    var char := pair.Key;\n    if not counter1.ContainsKey(char) then\n      totalDeletions += pair.Value;\n  end;\n  \n  Result := totalDeletions;\nend;"
  },
  {
    "instruction": "Write a function to find the sublist having the maximum sum of elements.",
    "output": "function FindMaxSum(lst: List<List<integer>>): List<integer>;\nbegin\n  var sums := new integer[lst.Count];\n  \n  for var i := 0 to lst.Count - 1 do\n    sums[i] := lst[i].Sum;\n  \n  var index := 0;\n  for var i := 1 to sums.Length - 1 do\n    if sums[i] > sums[index] then\n      index := i;\n  \n  Result := lst[index];\nend;"
  },
  {
    "instruction": "Write a function to count the number of balanced sub-strings in a given string. A string is considered balanced if it has an equal number of 'L' and 'R' characters.",
    "output": "function CountBalanced(s: string): integer;\nbegin\n  var countR := 0;\n  var countL := 0;\n  var countOut := 0;\n  \n  for var i := 0 to s.Length - 1 do\n  begin\n    if s[i] = 'R' then\n      countR += 1\n    else if s[i] = 'L' then\n      countL += 1;\n    \n    if countR = countL then\n      countOut += 1;\n  end;\n  \n  Result := countOut;\nend;"
  },
  {
    "instruction": "Write a function to find the nth digit of the Champernowne's constant. Champernowne's constant is a transcendental real constant constructed by concatenating the positive integers.",
    "output": "function ChampernowneDigit(n: integer): integer;\nbegin\n  if n < 10 then\n  begin\n    Result := n;\n    exit;\n  end;\n  \n  var digit := 1;\n  var total := 9;\n  \n  while n > total do\n  begin\n    n -= total;\n    digit += 1;\n    total := 9 * Round(Power(10, digit - 1)) * digit;\n  end;\n  \n  var quotient := (n - 1) div digit;\n  var remainder := (n - 1) mod digit;\n  var number := Round(Power(10, digit - 1)) + quotient;\n  \n  Result := StrToInt(number.ToString[remainder]);\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns a list of their square roots rounded to the nearest integer.",
    "output": "function SquareRoots(nList: array of integer): array of integer;\nbegin\n  var resultList := new List<integer>;\n  \n  for var i := 0 to nList.Length - 1 do\n    resultList.Add(Round(Sqrt(nList[i])));\n  \n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the total number of negative numbers in a 2D grid.",
    "output": "function CountNegatives(grid: array of array of integer): integer;\nbegin\n  var res := 0;\n  var nrows := grid.Length;\n  var ncols := grid[0].Length;\n  \n  var startL := 0;\n  var startR := nrows - 1;\n  \n  for var i := ncols - 1 downto 0 do\n  begin\n    var l := startL;\n    var r := startR;\n    \n    while l <= r do\n    begin\n      var m := l + (r - l) div 2;\n      if grid[m][i] >= 0 then\n        l := m + 1\n      else\n        r := m - 1;\n    end;\n    \n    res += nrows - l;\n    startL := l;\n  end;\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of swaps required to sort a given array.",
    "output": "function MinSwapsRequired(arr: array of integer): integer;\nbegin\n  var n := arr.Length; \n  var arrPos := new System.Tuple<integer, integer>[n];\n  \n  for var i := 0 to n - 1 do\n    arrPos[i] := (i, arr[i]);\n  \n  arrPos := arrPos.OrderBy(x -> x[1]).ToArray;\n  var vis := new boolean[n];\n  var ans := 0;\n  \n  for var i := 0 to n - 1 do\n  begin\n    if vis[i] or (arrPos[i][0] = i) then\n      continue;\n    \n    var cycleSize := 0;\n    var j := i;\n    \n    while not vis[j] do\n    begin\n      vis[j] := true;\n      j := arrPos[j][0];\n      cycleSize += 1;\n    end;\n    \n    if cycleSize > 0 then\n      ans += cycleSize - 1;\n  end;\n  \n  Result := ans;\nend;"
  },
  {
    "instruction": "Write a function called `find_longest_common_substring` that takes two strings as input and returns the longest common substring found in both strings. If no common substring is found, return an empty string.",
    "output": "function FindLongestCommonSubstring(str1, str2: string): string;\nbegin\n  var m := str1.Length;\n  var n := str2.Length;\n  var dp := new integer[m + 1, n + 1];\n  var longest := 0;\n  var endIndex := 0;\n  \n  for var i := 1 to m do\n    for var j := 1 to n do\n    begin\n      if str1[i - 1] = str2[j - 1] then\n      begin\n        dp[i, j] := dp[i - 1, j - 1] + 1;\n        if dp[i, j] > longest then\n        begin\n          longest := dp[i, j];\n          endIndex := i - 1;\n        end;\n      end\n      else\n        dp[i, j] := 0;\n    end;\n  \n  if longest > 0 then\n    Result := str1.Substring(endIndex - longest + 1, longest)\n  else\n    Result := '';\nend;"
  },
  {
    "instruction": "Write a function to check if a string is an interleaving of two other strings. A string 's3' is said to be an interleaving of 's1' and 's2' if it contains all characters of 's1' and 's2' in the same order as they appear in 's1' and 's2', but not necessarily consecutively.",
    "output": "function IsInterleave(s1, s2, s3: string): boolean;\nbegin\n  if s1.Length + s2.Length <> s3.Length then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  var dp := new boolean[s1.Length + 1, s2.Length + 1];\n  dp[0, 0] := true;\n  \n  for var i := 0 to s1.Length do\n    for var j := 0 to s2.Length do\n    begin\n      if i > 0 then\n        dp[i, j] := dp[i, j] or (dp[i - 1, j] and (s1[i - 1] = s3[i + j - 1]));\n      \n      if j > 0 then\n        dp[i, j] := dp[i, j] or (dp[i, j - 1] and (s2[j - 1] = s3[i + j - 1]));\n    end;\n  \n  Result := dp[s1.Length, s2.Length];\nend;"
  },
  {
    "instruction": "Write a function to find the sum of the digits of the largest number from a given list of positive integers.",
    "output": "function SumLargestDigits(numList: array of integer): integer;\nbegin\n  var maxNum := numList.Max;\n  var maxNumStr := maxNum.ToString;\n  Result := maxNumStr.Sum(c -> StrToInt(c.ToString));\nend;"
  },
  {
    "instruction": "Write a function to check if a number is a perfect power, i.e., it can be expressed as a power of another number.",
    "output": "function IsPerfectPower(n: integer): boolean;\nbegin\n  if n < 2 then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  for var base := 2 to Trunc(Sqrt(n)) do\n  begin\n    var pow := 2;\n    while Power(base, pow) <= n do\n    begin\n      if Power(base, pow) = n then\n      begin\n        Result := true;\n        exit;\n      end;\n      pow += 1;\n    end;\n  end;\n  \n  Result := false;\nend;"
  },
  {
    "instruction": "Write a function to find the number of times a sorted array is rotated. An array is considered to be rotated if the elements are shifted to the right from their original position. Assume there are no duplicates in the array and the rotation is in the clockwise direction.",
    "output": "function CountRotations(arr: array of integer): integer;\nbegin\n  var low := 0;\n  var high := arr.Length - 1;\n  \n  while low <= high do\n  begin\n    if arr[low] <= arr[high] then\n    begin\n      Result := low;\n      exit;\n    end;\n    \n    var mid := (low + high) div 2;\n    var next := (mid + 1) mod arr.Length;\n    var prev := (mid - 1 + arr.Length) mod arr.Length;\n    \n    if (arr[mid] <= arr[next]) and (arr[mid] <= arr[prev]) then\n    begin\n      Result := mid;\n      exit;\n    end\n    else if arr[mid] <= arr[high] then\n      high := mid - 1\n    else\n      low := mid + 1;\n  end;\n  \n  Result := 0;\nend;"
  },
  {
    "instruction": "Write a function to find the number of moves required to ensure that at least one egg breaks when dropped from the Nth floor of a building, given K eggs and N floors. This is known as the Super Egg Drop problem.",
    "output": "function Solve(k, moves: integer): integer;\nbegin\n  var dp := new integer[k + 1, moves + 1];\n  \n  for var i := 1 to k do\n    for var j := 1 to moves do\n      dp[i, j] := 1 + dp[i - 1, j - 1] + dp[i, j - 1];\n  \n  Result := dp[k, moves];\nend;\n\nfunction SuperEggDrop(K, N: integer): integer;\nbegin\n  var left := 1;\n  var right := N + 1;\n  \n  while left < right do\n  begin\n    var mid := (left + right) div 2;\n    if Solve(K, mid) >= N then\n      right := mid\n    else\n      left := mid + 1;\n  end;\n  \n  Result := left;\nend;"
  },
  {
    "instruction": "Write a function to find the number of upper-case letters in a given string.",
    "output": "function CountUpperCase(inputString: string): integer;\nbegin\n  var count := 0;\n  \n  for var i := 0 to inputString.Length - 1 do\n    if inputString[i].IsUpper then\n      count += 1;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Create a function that checks if a given word can be formed by concatenating a sequence of other words from a dictionary. A word can be formed if it matches a sequence of dictionary words exactly, without any extra characters or spaces.",
    "output": "function WordConstruct(target: string; dictionary: array of string): boolean;\nbegin\n  var dp := new boolean[target.Length + 1];\n  dp[0] := true;\n  \n  for var i := 1 to target.Length do\n    for var j := 0 to i - 1 do\n    begin\n      if dp[j] and dictionary.Contains(target.Substring(j, i - j)) then\n      begin\n        dp[i] := true;\n        break;\n      end;\n    end;\n  \n  Result := dp[target.Length];\nend;"
  },
  {
    "instruction": "Write a function to find the largest k numbers from a list.",
    "output": "function FindLargestK(nums: array of integer; k: integer): array of integer;\nbegin\n  if (nums.Length = 0) or (k <= 0) or (k > nums.Length) then\n  begin\n    Result := new integer[0];\n    exit;\n  end;\n  \n  &Array.Sort(nums);\n  &Array.Reverse(nums);\n  Result := nums[0:k];\nend;"
  },
  {
    "instruction": "Write a function to find the number of trailing zeroes in a factorial of a given number.\n\nThe number of trailing zeroes in a factorial of a number is equal to the number of times the number can be divided by 10, which is the product of 2 and 5. Since there are always more 2s than 5s in a factorial, the number of trailing zeroes is equal to the number of times the number can be divided by 5.",
    "output": "function TrailingZeroes(n: integer): integer;\nbegin\n  var count := 0;\n  \n  while n >= 5 do\n  begin\n    n := n div 5;\n    count += n;\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the k smallest numbers in a given list using a min heap.",
    "output": "function KSmallestNumbers(nums: array of integer; k: integer): array of integer;\nbegin\n  if k >= nums.Length then\n  begin\n    &Array.Sort(nums);\n    Result := nums;\n    exit;\n  end;\n  \n  var minHeap := new SortedSet<integer>(nums);\n  var resultList := new List<integer>;\n  \n  for var i := 1 to k do\n  begin\n    resultList.Add(minHeap.Min);\n    minHeap.Remove(minHeap.Min);\n  end;\n  \n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function that calculates the acceptance probability in a simulated annealing algorithm. The function should take in the current cost, the new cost, and the current temperature as parameters, and return the acceptance probability as a floating point number.",
    "output": "function AcceptanceProbability(oldCost, newCost: real; T: real): real;\nbegin\n  if newCost < oldCost then\n    Result := 1.0\n  else\n    Result := Exp(-(newCost - oldCost) / T);\nend;"
  },
  {
    "instruction": "Write a function that checks if a given number is a perfect square.",
    "output": "function IsPerfectSquare(n: integer): boolean;\nbegin\n  if n < 0 then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  var root := Trunc(Sqrt(n));\n  Result := root * root = n;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of operations to reduce a number n to 1 by performing the following operations:\n- If n is divisible by 2, divide n by 2.\n- If n is not divisible by 2, either increment or decrement n by 1.",
    "output": "function MinOperationsToReduceToOne(n: integer): integer;\nbegin\n  var operations := 0;\n  \n  while n > 1 do\n  begin\n    if n mod 2 = 0 then\n      n := n div 2\n    else\n    begin\n      if (n = 3) or (n mod 4 = 1) then\n        n := n - 1\n      else\n        n := n + 1;\n    end;\n    operations += 1;\n  end;\n  \n  Result := operations;\nend;"
  },
  {
    "instruction": "Write a function to calculate the sum of all elements in a given 2D list (list of lists). Each element in the 2D list can be either an integer or a float. The function should handle cases where the 2D list is empty or contains empty sublists.",
    "output": "function Sum2DList(matrix: array of array of real): real;\nbegin\n  var totalSum := 0.0;\n  \n  for var i := 0 to matrix.Length - 1 do\n    for var j := 0 to matrix[i].Length - 1 do\n      totalSum += matrix[i][j];\n  \n  Result := totalSum;\nend;"
  },
  {
    "instruction": "Write a function to simulate a basic vending machine. The vending machine accepts coins of 1, 2, 5, 10, 20, 50, 100, 200, 500 and 1000 units. If the inserted money is more than the product price, the machine will return the change.",
    "output": "function VendingMachine(moneyInserted, productPrice: integer): integer;\nbegin\n  if moneyInserted < productPrice then\n    raise new System.ArgumentException('Insufficient money')\n  else\n    Result := moneyInserted - productPrice;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns a new list with elements sorted based on their binary representations. The sorting should be based on the number of ones in the binary representation of each number. In case of a tie, the numbers should be sorted based on their decimal values in ascending order.",
    "output": "function CountOnes(n: integer): integer;\nbegin\n  var count := 0;\n  while n > 0 do\n  begin\n    count += n and 1;\n    n := n shr 1;\n  end;\n  Result := count;\nend;\n\nfunction BinarySort(lst: array of integer): array of integer;\nbegin\n  Result := lst.OrderBy(x -> (CountOnes(x), x)).ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum difference between two adjacent elements in a list.",
    "output": "function MaxAdjacentDiff(nums: array of integer): integer;\nbegin\n  var maxDiff := 0;\n  \n  for var i := 1 to nums.Length - 1 do\n  begin\n    var diff := Abs(nums[i] - nums[i - 1]);\n    maxDiff := Max(maxDiff, diff);\n  end;\n  \n  Result := maxDiff;\nend;"
  },
  {
    "instruction": "Write a function that takes a string and an integer as input and returns the string encoded in a zigzag pattern with the specified number of rows.\n\nFor example, the string \"PAYPALISHIRING\" encoded in a zigzag pattern with 3 rows would look like this:\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\nWhen read line by line, the encoded string would be \"PAHNAPLSIIGYIR\".",
    "output": "function ZigzagEncode(s: string; numRows: integer): string;\nbegin\n  if numRows = 1 then\n  begin\n    Result := s;\n    exit;\n  end;\n  \n  var rows := new string[numRows];\n  var incVal := 1;\n  var rowIndex := 0;\n  \n  for var i := 0 to s.Length - 1 do\n  begin\n    rows[rowIndex] += s[i];\n    \n    if (rowIndex = numRows - 1) or ((i <> 0) and (rowIndex = 0)) then\n      incVal := -incVal;\n    \n    rowIndex += incVal;\n  end;\n  \n  Result := string.Join('', rows);\nend;"
  },
  {
    "instruction": "Write a function to find the number of subarrays in a given array with a given sum.",
    "output": "function CountSubArraysWithSum(arr: array of integer; targetSum: integer): integer;\nbegin\n  var currentSum := 0;\n  var count := 0;\n  var hashMap := new Dictionary<integer, integer>;\n  \n  for var i := 0 to arr.Length - 1 do\n  begin\n    currentSum += arr[i];\n    \n    if currentSum = targetSum then\n      count += 1;\n    \n    if hashMap.ContainsKey(currentSum - targetSum) then\n      count += hashMap[currentSum - targetSum];\n    \n    if hashMap.ContainsKey(currentSum) then\n      hashMap[currentSum] += 1\n    else\n      hashMap[currentSum] := 1;\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to merge two sorted lists into one sorted list.",
    "output": "function MergeSortedLists(list1, list2: array of integer): array of integer;\nbegin\n  var mergedList := new List<integer>;\n  var i := 0;\n  var j := 0;\n  \n  while (i < list1.Length) and (j < list2.Length) do\n  begin\n    if list1[i] < list2[j] then\n    begin\n      mergedList.Add(list1[i]);\n      i += 1;\n    end\n    else\n    begin\n      mergedList.Add(list2[j]);\n      j += 1;\n    end;\n  end;\n  \n  while i < list1.Length do\n  begin\n    mergedList.Add(list1[i]);\n    i += 1;\n  end;\n  \n  while j < list2.Length do\n  begin\n    mergedList.Add(list2[j]);\n    j += 1;\n  end;\n  \n  Result := mergedList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings, each representing an integer, and returns a list where each string is now the factorial of the original integer it represented.",
    "output": "function Factorial(n: integer): BigInteger;\nbegin\n  if n <= 1 then\n    Result := 1\n  else\n    Result := n * Factorial(n - 1);\nend;\n\nfunction FactorialOfStrings(lst: array of string): array of string;\nbegin\n  var resultList := new List<string>;\n  \n  for var i := 0 to lst.Length - 1 do\n  begin\n    var num := StrToInt(lst[i]);\n    resultList.Add(Factorial(num).ToString);\n  end;\n  \n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum lucky number from a given list. A lucky number is a number which frequency in the list is equal to its value.",
    "output": "function MaxLuckyNumber(arr: array of integer): integer;\nbegin\n  var freqs := new Dictionary<integer, integer>;\n  \n  for var i := 0 to arr.Length - 1 do\n  begin\n    if not freqs.ContainsKey(arr[i]) then\n      freqs[arr[i]] := 0;\n    freqs[arr[i]] += 1;\n  end;\n  \n  var maxLucky := -1;\n  \n  foreach var pair in freqs do\n  begin\n    if pair.Key = pair.Value then\n      maxLucky := Max(maxLucky, pair.Key);\n  end;\n  \n  Result := maxLucky;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum length of the sublists within a list of lists and return the longest sublist. If there are multiple sublists of the same maximum length, return the first one.",
    "output": "function MaxLengthSublist(listOfLists: List<List<integer>>): List<integer>;\nbegin\n  var maxLength := -1;\n  var longestList := new List<integer>;\n  \n  for var i := 0 to listOfLists.Count - 1 do\n  begin\n    if listOfLists[i].Count > maxLength then\n    begin\n      maxLength := listOfLists[i].Count;\n      longestList := listOfLists[i];\n    end;\n  end;\n  \n  Result := longestList;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns a new list with all the prime numbers removed.",
    "output": "function IsPrime(n: integer): boolean;\nbegin\n  if n < 2 then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  for var i := 2 to Trunc(Sqrt(n)) do\n    if n mod i = 0 then\n    begin\n      Result := false;\n      exit;\n    end;\n  \n  Result := true;\nend;\n\nfunction NoPrimes(numbers: array of integer): array of integer;\nbegin\n  Result := numbers.Where(n -> not IsPrime(n)).ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of perfect square numbers which sum to 'n'.",
    "output": "function PerfectSquares(n: integer): integer;\nbegin\n  var dp := new integer[n + 1];\n  \n  for var i := 1 to n do\n  begin\n    dp[i] := i;\n    \n    for var j := 1 to Trunc(Sqrt(i)) do\n    begin\n      var square := j * j;\n      dp[i] := Min(dp[i], dp[i - square] + 1);\n    end;\n  end;\n  \n  Result := dp[n];\nend;"
  },
  {
    "instruction": "Write a function to find the number of times a given pattern appears in a text.",
    "output": "function FindPattern(text, pattern: string): integer;\nbegin\n  var count := 0;\n  var index := 0;\n  \n  while true do\n  begin\n    index := text.IndexOf(pattern, index);\n    if index = -1 then\n      break;\n    \n    count += 1;\n    index += pattern.Length;\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to express a given number as the sum of consecutive natural numbers.",
    "output": "function NumWaysConsecutiveSum(n: integer): integer;\nbegin\n  var count := 0;\n  \n  for var i := 1 to n do\n  begin\n    var sumVal := 0;\n    \n    for var j := i to n do\n    begin\n      sumVal += j;\n      if sumVal = n then\n      begin\n        count += 1;\n        break;\n      end\n      else if sumVal > n then\n        break;\n    end;\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of operations required to convert an array of zeros to a target array using the operation of incrementing any subarray by one.",
    "output": "function MinNumberOperations(target: array of integer): integer;\nbegin\n  var n := target.Length;\n  var dp := new integer[n];\n  dp[0] := target[0];\n  \n  for var i := 1 to n - 1 do\n  begin\n    if target[i] <= target[i - 1] then\n      dp[i] := dp[i - 1]\n    else\n      dp[i] := dp[i - 1] + (target[i] - target[i - 1]);\n  end;\n  \n  Result := dp[n - 1];\nend;"
  },
  {
    "instruction": "Write a function to find the largest power of two less than a given number n.",
    "output": "function LargestPowerOfTwo(n: integer): integer;\nbegin\n  var i := 1;\n  \n  while i * 2 < n do\n    i := i * 2;\n  \n  Result := i;\nend;"
  },
  {
    "instruction": "Write a function to find the longest harmonious subsequence length in a given list. A harmonious subsequence is defined as a subsequence where the maximum difference between any two numbers is exactly 1.",
    "output": "function FindLHS(nums: array of integer): integer;\nbegin\n  var count := new Dictionary<integer, integer>;\n  \n  for var i := 0 to nums.Length - 1 do\n  begin\n    if not count.ContainsKey(nums[i]) then\n      count[nums[i]] := 0;\n    count[nums[i]] += 1;\n  end;\n  \n  var longest := 0;\n  \n  foreach var k in count.Keys do\n  begin\n    if count.ContainsKey(k + 1) then\n      longest := Max(longest, count[k] + count[k + 1]);\n  end;\n  \n  Result := longest;\nend;"
  },
  {
    "instruction": "Write a function that takes a string and a pattern as input and returns the starting indices of all occurrences of the pattern in the string. If the pattern is not found, return an empty list.",
    "output": "function FindPatternIndices(s, pattern: string): array of integer;\nbegin\n  var indices := new List<integer>;\n  var patternLen := pattern.Length;\n  \n  for var i := 0 to s.Length - patternLen do\n  begin\n    if s.Substring(i, patternLen) = pattern then\n      indices.Add(i);\n  end;\n  \n  Result := indices.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the most frequent word in a given string that has a maximum number of unique characters and a minimum size.\n\nYou are given a string `s`, an integer `maxLetters`, an integer `minSize`, and an integer `maxSize`. Your task is to return the maximum frequency of a substring in `s` that has a maximum number of unique characters equal to `maxLetters` and a length of at least `minSize` and at most `maxSize`.",
    "output": "function MaxFreq(s: string; maxLetters, minSize, maxSize: integer): integer;\nbegin\n  var table := new Dictionary<string, integer>;\n  \n  for var i := 0 to s.Length - minSize do\n  begin\n    var word := s.Substring(i, minSize);\n    \n    if table.ContainsKey(word) then\n      table[word] += 1\n    else\n    begin\n      var count := new Dictionary<char, integer>;\n      for var j := 0 to word.Length - 1 do\n      begin\n        if not count.ContainsKey(word[j]) then\n          count[word[j]] := 0;\n        count[word[j]] += 1;\n      end;\n      \n      if count.Count <= maxLetters then\n        table[word] := 1;\n    end;\n  end;\n  \n  if table.Count > 0 then\n    Result := table.Values.Max\n  else\n    Result := 0;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns a list of all the positive integers in the input list, sorted in ascending order.",
    "output": "function PositiveSorted(inputList: array of integer): array of integer;\nbegin\n  var positiveNums := new List<integer>;\n  \n  for var i := 0 to inputList.Length - 1 do\n    if inputList[i] > 0 then\n      positiveNums.Add(inputList[i]);\n  \n  positiveNums.Sort;\n  Result := positiveNums.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to return the maximum element from each subarray of size 'k' in a given list 'arr' of size 'n'.",
    "output": "function MaxInSubarrays(arr: array of integer; k: integer): array of integer;\nbegin\n  var d := new Queue<integer>;\n  var maxList := new List<integer>;\n  \n  for var i := 0 to arr.Length - 1 do\n  begin\n    while (d.Count > 0) and (arr[i] >= arr[d.Peek]) do\n      d.Dequeue;\n    \n    d.Enqueue(i);\n    \n    if i >= k - 1 then\n    begin\n      if d.Peek = i - k then\n        d.Dequeue;\n      \n      maxList.Add(arr[d.Peek]);\n    end;\n  end;\n  \n  Result := maxList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of tuples and returns a new list of tuples where each tuple is reversed.",
    "output": "function ReverseTuples(tuplesList: List<(string, integer)>): List<(integer, string)>;\nbegin\n  var resultList := new List<(integer, string)>;\n  \n  for var i := 0 to tuplesList.Count - 1 do\n    resultList.Add((tuplesList[i][1], tuplesList[i][0]));\n  \n  Result := resultList;\nend;"
  },
  {
    "instruction": "Write a function to find the height of a binary tree.",
    "output": "type\n  Node = class\n    val: integer;\n    left, right: Node;\n    \n    constructor Create(x: integer; l: Node := nil; r: Node := nil);\n    begin\n      val := x;\n      left := l;\n      right := r;\n    end;\n  end;\n\nfunction HeightOfTree(root: Node): integer;\nbegin\n  if root = nil then\n    Result := -1\n  else\n  begin\n    var leftHeight := HeightOfTree(root.left);\n    var rightHeight := HeightOfTree(root.right);\n    Result := Max(leftHeight, rightHeight) + 1;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to determine if a string is a valid IPv4 address.\n\nA valid IPv4 address is a string of four integers separated by periods. Each integer is between 0 and 255. The first integer cannot be 0 if it is not the only integer. Leading zeros are not allowed.",
    "output": "function ValidateIPv4(ip: string): boolean;\nbegin\n  var parts := ip.Split('.');\n  \n  if parts.Length <> 4 then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  for var i := 0 to parts.Length - 1 do\n  begin\n    if not parts[i].All(c -> c.IsDigit) then\n    begin\n      Result := false;\n      exit;\n    end;\n    \n    if (parts[i].Length > 1) and (parts[i][0] = '0') then\n    begin\n      Result := false;\n      exit;\n    end;\n    \n    var num := StrToInt(parts[i]);\n    if (num < 0) or (num > 255) then\n    begin\n      Result := false;\n      exit;\n    end;\n  end;\n  \n  Result := true;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns a new list with each element squared.",
    "output": "function SquaredList(lst: array of integer): array of integer;\nbegin\n  var resultList := new List<integer>;\n  \n  for var i := 0 to lst.Length - 1 do\n    resultList.Add(lst[i] * lst[i]);\n  \n  Result := resultList.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to return the largest number from a list of integers.",
    "output": "function LargestNumInList(nums: array of integer): integer;\nbegin\n  var largestNum := nums[0];\n  \n  for var i := 1 to nums.Length - 1 do\n    if nums[i] > largestNum then\n      largestNum := nums[i];\n  \n  Result := largestNum;\nend;"
  },
  {
    "instruction": "Write a function to check if a list of numbers contains any Pythagorean triplets.\n\nA Pythagorean triplet consists of three positive integers a, b, and c, such that a^2 + b^2 = c^2. For example, (3, 4, 5) and (5, 12, 13) are Pythagorean triplets.\n\nYour function should return True if the list contains a Pythagorean triplet, and False otherwise.",
    "output": "function CheckPythagoreanTriplet(nums: array of integer): boolean;\nbegin\n  var numSet := new HashSet<integer>(nums);\n  \n  for var i := 0 to nums.Length - 1 do\n  begin\n    var a := nums[i];\n    for var j := i + 1 to nums.Length - 1 do\n    begin\n      var b := nums[j];\n      var cSquared := a * a + b * b;\n      var c := Trunc(Sqrt(cSquared));\n      \n      if (c * c = Trunc(cSquared)) and numSet.Contains(c) then\n      begin\n        Result := true;\n        exit;\n      end;\n    end;\n  end;\n  \n  Result := false;\nend;"
  },
  {
    "instruction": "Write a function to find the two smallest elements in a given list of numbers.",
    "output": "function FindTwoSmallest(nums: array of integer): (integer, integer);\nbegin\n  var sortedNums := nums.ToArray();\n  &Array.Sort(sortedNums);\n  Result := (sortedNums[0], sortedNums[1]);\nend;"
  },
  {
    "instruction": "Create a function to find the first and last position of a target value in a sorted array. If the target is not found in the array, return [-1, -1].",
    "output": "function SearchTarget(nums: array of integer; target: integer): array of integer;\nbegin\n  var first := -1;\n  var last := -1;\n  \n  for var i := 0 to nums.Length - 1 do\n  begin\n    if nums[i] = target then\n    begin\n      if first = -1 then\n        first := i;\n      last := i;\n    end;\n  end;\n  \n  Result := Arr(first, last);\nend;"
  },
  {
    "instruction": "Write a function to find the most common string in a list of strings.",
    "output": "function MostCommonString(strList: array of string): string;\nbegin\n  var strFreq := new Dictionary<string, integer>;\n  \n  for var i := 0 to strList.Length - 1 do\n  begin\n    if strFreq.ContainsKey(strList[i]) then\n      strFreq[strList[i]] += 1\n    else\n      strFreq[strList[i]] := 1;\n  end;\n  \n  var maxCount := strFreq.Values.Max;\n  var mostCommon := strFreq.First(pair -> pair.Value = maxCount).Key;\n  \n  Result := mostCommon;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum value of an array after rotating the array by a given number of steps. The rotation can be either clockwise or counterclockwise. After the rotation, find the maximum value in the array.\n\nFor example, given the array [1, 2, 3, 4, 5] and the number of steps as 2, the array will be rotated to [4, 5, 1, 2, 3] if the rotation is clockwise and to [3, 4, 5, 1, 2] if the rotation is counterclockwise. The function should return the maximum value of the rotated array.",
    "output": "function RotateAndFindMax(arr: array of integer; steps: integer; direction: string): integer;\nbegin\n  steps := steps mod arr.Length;\n  var rotatedArr: array of integer;\n  \n  if direction = 'clockwise' then\n    rotatedArr := arr[arr.Length - steps:arr.Length] + arr[0:arr.Length - steps]\n  else if direction = 'counterclockwise' then\n    rotatedArr := arr[steps:arr.Length] + arr[0:steps]\n  else\n    raise new System.ArgumentException('Direction must be \"clockwise\" or \"counterclockwise\"');\n  \n  Result := rotatedArr.Max;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to reach the nth stair by taking either 1, 2, or 3 steps at a time.",
    "output": "function FindWaysToReachStair(n: integer): integer;\nbegin\n  if n = 1 then\n  begin\n    Result := 1;\n    exit;\n  end\n  else if n = 2 then\n  begin\n    Result := 2;\n    exit;\n  end\n  else if n = 3 then\n  begin\n    Result := 4;\n    exit;\n  end\n  else\n  begin\n    var a := 1;\n    var b := 2;\n    var c := 4;\n    \n    for var i := 3 to n - 1 do\n    begin\n      var total := a + b + c;\n      a := b;\n      b := c;\n      c := total;\n    end;\n    \n    Result := c;\n  end;\nend;"
  },
  {
    "instruction": "Write a function that reverses a given string using a recursive approach.",
    "output": "function ReverseStringRecursive(s: string): string;\nbegin\n  if s.Length <= 1 then\n    Result := s\n  else\n    Result := ReverseStringRecursive(s.Substring(1)) + s[0];\nend;"
  },
  {
    "instruction": "Write a function to find the maximum product of the lengths of two words that do not share any common characters.",
    "output": "function MaxProductWordLength(words: array of string): integer;\nbegin\n  var L := words.Length;\n  var occs := new boolean[L, 26];\n  \n  for var i := 0 to L - 1 do\n    foreach var c in words[i] do\n      occs[i, Ord(c) - Ord('a')] := true;\n  \n  var sol := 0;\n  \n  for var i := 0 to L - 2 do\n    for var j := i + 1 to L - 1 do\n    begin\n      var common := false;\n      \n      for var k := 0 to 25 do\n      begin\n        if occs[i, k] and occs[j, k] then\n        begin\n          common := true;\n          break;\n        end;\n      end;\n      \n      if not common then\n        sol := Max(sol, words[i].Length * words[j].Length);\n    end;\n  \n  Result := sol;\nend;"
  },
  {
    "instruction": "Write a function to find the n-th number that is both a Fibonacci number and a prime number.",
    "output": "function IsPrime(n: integer): boolean;\nbegin\n  if n <= 1 then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  if n <= 3 then\n  begin\n    Result := true;\n    exit;\n  end;\n  \n  if (n mod 2 = 0) or (n mod 3 = 0) then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  var i := 5;\n  while i * i <= n do\n  begin\n    if (n mod i = 0) or (n mod (i + 2) = 0) then\n    begin\n      Result := false;\n      exit;\n    end;\n    i += 6;\n  end;\n  \n  Result := true;\nend;\n\nfunction NthFiboPrime(n: integer): integer;\nbegin\n  var fiboPrimes := new List<integer>;\n  var a: BigInteger := 0;\n  var b: BigInteger := 1;\n  \n  while fiboPrimes.Count < n do\n  begin\n    (a, b) := (b, a + b);\n    \n    if IsPrime(integer(b)) then\n      fiboPrimes.Add(integer(b));\n  end;\n  \n  Result := fiboPrimes[fiboPrimes.Count - 1];\nend;"
  },
  {
    "instruction": "Write a function to find the area of overlap between two rectangles. The rectangles are defined by their bottom-left and top-right coordinates.",
    "output": "function AreaOverlap(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2: integer): integer;\nbegin\n  var overlapX := Max(0, Min(ax2, bx2) - Max(ax1, bx1));\n  var overlapY := Max(0, Min(ay2, by2) - Max(ay1, by1));\n  Result := overlapX * overlapY;\nend;"
  },
  {
    "instruction": "Write a function which takes a list of integers and returns the product of the first even and first odd number in the list.",
    "output": "function ProductEvenOdd(lst: array of integer): integer;\nbegin\n  var even := 0;\n  var odd := 0;\n  var foundEven := false;\n  var foundOdd := false;\n  \n  for var i := 0 to lst.Length - 1 do\n  begin\n    if (not foundEven) and (lst[i] mod 2 = 0) then\n    begin\n      even := lst[i];\n      foundEven := true;\n    end\n    else if (not foundOdd) and (lst[i] mod 2 <> 0) then\n    begin\n      odd := lst[i];\n      foundOdd := true;\n    end;\n    \n    if foundEven and foundOdd then\n      break;\n  end;\n  \n  if foundEven and foundOdd then\n    Result := even * odd\n  else\n    Result := 0;\nend;"
  },
  {
    "instruction": "Write a function to check if a given string can be segmented into a space-separated sequence of one or more dictionary words.",
    "output": "uses System.Collections.Generic;\n\nfunction CheckMe(s: string; words: array of string): boolean;\nbegin\n  var wordSet := new HashSet<string>(words);\n  var queue := new Queue<integer>;\n  var visited := new boolean[s.Length];\n  \n  queue.Enqueue(0);\n  \n  while queue.Count > 0 do\n  begin\n    var start := queue.Dequeue;\n    \n    if visited[start] then\n      continue;\n    \n    for var &end := start + 1 to s.Length do\n    begin\n      if wordSet.Contains(s.Substring(start, &end - start)) then\n      begin\n        queue.Enqueue(&end);\n        \n        if &end = s.Length then\n        begin\n          Result := true;\n          exit;\n        end;\n      end;\n    end;\n    \n    visited[start] := true;\n  end;\n  \n  Result := false;\nend;"
  },
  {
    "instruction": "Write a function that takes an integer as input and returns the sum of all its digits in reverse order.",
    "output": "function ReverseSum(n: integer): integer;\nbegin\n  var numStr := n.ToString;\n  var sumVal := 0;\n  \n  for var i := numStr.Length - 1 downto 0 do\n    sumVal += StrToInt(numStr[i]);\n  \n  Result := sumVal;\nend;"
  },
  {
    "instruction": "Write a function to find the median of three numbers.",
    "output": "function MedianThree(a, b, c: integer): integer;\nbegin\n  if ((a <= b) and (b <= c)) or ((c <= b) and (b <= a)) then\n    Result := b\n  else if ((b <= a) and (a <= c)) or ((c <= a) and (a <= b)) then\n    Result := a\n  else\n    Result := c;\nend;"
  },
  {
    "instruction": "Write a function to check if an array contains any duplicates within a given distance 'k'.",
    "output": "function ContainsNearbyDuplicate(nums: array of integer; k: integer): boolean;\nbegin\n  if nums.Length < 2 then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  var numsDict := new Dictionary<integer, integer>;\n  \n  for var i := 0 to nums.Length - 1 do\n  begin\n    if numsDict.ContainsKey(nums[i]) then\n    begin\n      if i - numsDict[nums[i]] <= k then\n      begin\n        Result := true;\n        exit;\n      end\n      else\n        numsDict[nums[i]] := i;\n    end\n    else\n      numsDict[nums[i]] := i;\n  end;\n  \n  Result := false;\nend;"
  },
  {
    "instruction": "Write a function to find the number of times a given pattern appears in a string.",
    "output": "function FindPatternCount(text, pattern: string): integer;\nbegin\n  var count := 0;\n  var start := 0;\n  \n  while start < text.Length do\n  begin\n    var pos := text.IndexOf(pattern, start);\n    if pos <> -1 then\n    begin\n      count += 1;\n      start := pos + 1;\n    end\n    else\n      break;\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the number of unique combinations of non-overlapping subarrays with a sum equal to k.",
    "output": "function CountSubarrays(nums: array of integer; k: integer): integer;\nbegin\n  var prefixSum := 0;\n  var count := 0;\n  var subarrayCount := new Dictionary<integer, integer>;\n  subarrayCount[0] := 1;\n  \n  for var i := 0 to nums.Length - 1 do\n  begin\n    prefixSum += nums[i];\n    \n    if subarrayCount.ContainsKey(prefixSum - k) then\n      count += subarrayCount[prefixSum - k];\n    \n    if subarrayCount.ContainsKey(prefixSum) then\n      subarrayCount[prefixSum] += 1\n    else\n      subarrayCount[prefixSum] := 1;\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the nth Catalan number. Catalan numbers are a sequence of natural numbers that have many applications in combinatorial mathematics, such as counting the number of correct bracket sequences of length 2n.\n\nThe nth Catalan number can be calculated using the formula: C(n) = (2n choose n) / (n + 1)",
    "output": "function Factorial(n: integer): BigInteger;\nbegin\n  Result := 1;\n  for var i := 2 to n do\n    Result := Result * i;\nend;\n\nfunction IsCatalan(n: integer): BigInteger;\nbegin\n  var numerator := Factorial(2 * n);\n  var denominator := Factorial(n) * Factorial(n) * (n + 1);\n  Result := numerator div denominator;\nend;"
  },
  {
    "instruction": "Write a function to generate all combinations of a given list of items.",
    "output": "procedure GenerateCombinations(lst: array of integer; start: integer; current: List<integer>; n: integer; resultList: List<array of integer>);\nbegin\n  if current.Count = n then\n  begin\n    resultList.Add(current.ToArray);\n    exit;\n  end;\n  \n  for var i := start to lst.Length - 1 do\n  begin\n    current.Add(lst[i]);\n    GenerateCombinations(lst, i + 1, current, n, resultList);\n    current.RemoveAt(current.Count - 1);\n  end;\nend;\n\nfunction CombinationsGenerator(lst: array of integer; n: integer): List<array of integer>;\nbegin\n  var resultList := new List<array of integer>;\n  GenerateCombinations(lst, 0, new List<integer>, n, resultList);\n  Result := resultList;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum product of subarray within a given integer array.",
    "output": "function MaxProductSubarray(arr: array of integer): integer;\nbegin\n  if arr.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var prevMin := arr[0];\n  var prevMax := arr[0];\n  var resultVal := arr[0];\n  \n  for var i := 1 to arr.Length - 1 do\n  begin\n    if arr[i] < 0 then\n    begin\n      var temp := prevMin;\n      prevMin := prevMax;\n      prevMax := temp;\n    end;\n    \n    prevMax := Max(arr[i], prevMax * arr[i]);\n    prevMin := Min(arr[i], prevMin * arr[i]);\n    resultVal := Max(resultVal, prevMax);\n  end;\n  \n  Result := resultVal;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum of three given integers using a ternary operator.",
    "output": "function MaxOfThree(a, b, c: integer): integer;\nbegin\n  Result := a > b ? (a > c ? a : c) : (b > c ? b : c);\nend;"
  },
  {
    "instruction": "Write a function to find the number of satisfied children. Given two lists, `g` and `s`, representing the greed factor of children and the size of cookies respectively, your function should return the maximum number of children that can be satisfied. A child is satisfied if the cookie they receive is at least as large as their greed factor.",
    "output": "function FindContentChildren(g, s: array of integer): integer;\nbegin\n  &Array.Sort(g);\n  &Array.Sort(s);\n  \n  var resultVal := 0;\n  var i := 0;\n  \n  while (i < s.Length) and (resultVal < g.Length) do\n  begin\n    if s[i] >= g[resultVal] then\n      resultVal += 1;\n    i += 1;\n  end;\n  \n  Result := resultVal;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum rectangular area that can be formed by a set of rectangles where the heights are given in an array. The width of each rectangle is 1.",
    "output": "function MaxRectArea(heights: array of integer): integer;\nbegin\n  var stack := new Stack<integer>;\n  var maxArea := 0;\n  var index := 0;\n\n  while index < heights.Length do\n  begin\n    if (stack.Count = 0) or (heights[stack.Peek] <= heights[index]) then\n    begin\n      stack.Push(index);\n      index += 1;\n    end\n    else\n    begin\n      var topOfStack := stack.Pop;\n      var area := heights[topOfStack] * (if stack.Count = 0 then index else index - stack.Peek - 1);\n      maxArea := Max(maxArea, area);\n    end;\n  end;\n\n  while stack.Count > 0 do\n  begin\n    var topOfStack := stack.Pop;\n    var area := heights[topOfStack] * (if stack.Count = 0 then index else index - stack.Peek - 1);\n    maxArea := Max(maxArea, area);\n  end;\n\n  Result := maxArea;\nend;"
  },
  {
    "instruction": "Write a function to find the longest duplicated substring in a given string. The function should return the longest duplicated substring found in the string.",
    "output": "function LongestDupSubstring(S: string): string;\nbegin\n  var res := '';\n  var l := 0;\n  var r := S.Length - 1;\n  var aNum := Ord('a');\n\n  while l <= r do\n  begin\n    var tmp: string := nil;\n    var id := 0;\n    var existence := new HashSet<integer>;\n    var size := l + (r - l) div 2;\n    var tem := Round(Power(26, size - 1));\n\n    for var i := 0 to size - 1 do\n      id := id * 26 + (Ord(S[i]) - aNum);\n\n    existence.Add(id);\n\n    for var i := size to S.Length - 1 do\n    begin\n      var tail := S[i];\n      var prevHead := S[i - size];\n      id := (id - (Ord(prevHead) - aNum) * tem) * 26 + (Ord(tail) - aNum);\n\n      if existence.Contains(id) then\n      begin\n        tmp := S.Substring(i - size + 1, size);\n        break;\n      end;\n      existence.Add(id);\n    end;\n\n    if tmp <> nil then\n    begin\n      l := size + 1;\n      res := tmp;\n    end\n    else\n      r := size - 1;\n  end;\n\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of the factorial of first n natural numbers.",
    "output": "function Fact(n: integer): BigInteger;\nbegin\n  if n = 0 then\n    Result := 1\n  else\n    Result := n * Fact(n - 1);\nend;\n\nfunction FactSum(n: integer): BigInteger;\nbegin\n  var sum: BigInteger := 0;\n  for var i := 1 to n do\n    sum += Fact(i);\n  Result := sum;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum depth of a binary tree. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.",
    "output": "type\n  TreeNode = class\n    val: integer;\n    left, right: TreeNode;\n    \n    constructor(x: integer; l: TreeNode := nil; r: TreeNode := nil);\n    begin\n      val := x;\n      left := l;\n      right := r;\n    end;\n  end;\n\nfunction minDepth(root: TreeNode): integer;\nbegin\n  if root = nil then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var queue := new Queue<(TreeNode, integer)>;\n  queue.Enqueue((root, 1));\n  \n  while queue.Count > 0 do\n  begin\n    var (node, depth) := queue.Dequeue;\n    \n    if (node.left = nil) and (node.right = nil) then\n    begin\n      Result := depth;\n      exit;\n    end;\n    \n    if node.left <> nil then\n      queue.Enqueue((node.left, depth + 1));\n    \n    if node.right <> nil then\n      queue.Enqueue((node.right, depth + 1));\n  end;\n  \n  Result := 0;\nend;"
  },
  {
    "instruction": "Write a function to calculate the sum of the digits of a given (non-negative integer) number. However, if any digit in the number is repeated, return the number itself instead of the sum of its digits.",
    "output": "function SumDigitsOrNumber(n: integer): integer;\nbegin\n  if n = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n\n  var digits := new List<integer>;\n  var temp := n;\n\n  while temp > 0 do\n  begin\n    digits.Add(temp mod 10);\n    temp := temp div 10;\n  end;\n\n  if digits.Count <> digits.Distinct.Count then\n    Result := n\n  else\n    Result := digits.Sum;\nend;"
  },
  {
    "instruction": "Write a function that checks if a given array is a palindrome. An array is said to be a palindrome if it reads the same backward as forward.",
    "output": "function ArrayPalindrome(arr: array of integer): boolean;\nbegin\n  for var i := 0 to arr.Length div 2 do\n    if arr[i] <> arr[arr.Length - 1 - i] then\n    begin\n      Result := false;\n      exit;\n    end;\n\n  Result := true;\nend;"
  },
  {
    "instruction": "Write a function to find the intersection of two lists, where the intersection is a list of elements that are common in both input lists. The function should return the intersection list in sorted order without duplicates.",
    "output": "function IntersectionSorted(list1, list2: array of integer): array of integer;\nbegin\n  var set1 := new HashSet<integer>(list1);\n  var set2 := new HashSet<integer>(list2);\n  var intersectionSet := new HashSet<integer>(set1);\n  intersectionSet.IntersectWith(set2);\n  \n  var intersectionList := intersectionSet.ToArray;\n  &Array.Sort(intersectionList);\n  Result := intersectionList;\nend;"
  },
  {
    "instruction": "Write a function to find the shortest substring that contains all the characters of a given string.",
    "output": "function ShortestSubstring(s: string): string;\nbegin\n  var uniqueChars := new HashSet<char>(s);\n  var counter := new Dictionary<char, integer>;\n  var head := 0;\n  var minLen := integer.MaxValue;\n  var minStr := '';\n\n  for var tail := 0 to s.Length - 1 do\n  begin\n    if not counter.ContainsKey(s[tail]) then\n      counter[s[tail]] := 0;\n    counter[s[tail]] += 1;\n\n    while counter.Count = uniqueChars.Count do\n    begin\n      var currLen := tail - head + 1;\n      if currLen < minLen then\n      begin\n        minLen := currLen;\n        minStr := s.Substring(head, currLen);\n      end;\n\n      counter[s[head]] -= 1;\n      if counter[s[head]] = 0 then\n        counter.Remove(s[head]);\n      head += 1;\n    end;\n  end;\n\n  Result := minStr;\nend;"
  },
  {
    "instruction": "Create a function to find the kth largest unique element in a given list. If there are duplicates in the list, they should only be counted once. If the kth largest unique element does not exist, return -1.",
    "output": "function KthLargestUnique(arr: array of integer; k: integer): integer;\nbegin\n  var uniqueElements := arr.Distinct.ToArray;\n  \n  if uniqueElements.Length < k then\n  begin\n    Result := -1;\n    exit;\n  end;\n\n  &Array.Sort(uniqueElements);\n  &Array.Reverse(uniqueElements);\n  Result := uniqueElements[k - 1];\nend;"
  },
  {
    "instruction": "Write a function to find the closest number to x that is divisible by y.",
    "output": "function ClosestNumberDivisible(x, y: integer): integer;\nbegin\n  var quotient := x div y;\n  var lower := y * quotient;\n  var upper := y * (quotient + 1);\n\n  if x - lower < upper - x then\n    Result := lower\n  else\n    Result := upper;\nend;"
  },
  {
    "instruction": "Write a function to convert a given number in words to an integer. \n\nThe function should take a string input that represents a number in words and convert it to the corresponding integer. The words used will be from 'zero' to 'nine'. The words in the input string will be space-separated.\n\nFor example, if the input is \"one three two\", the output should be 132.",
    "output": "function WordToNumber(s: string): integer;\nbegin\n  var stringArr := Arr('zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine');\n  var answer := '';\n  \n  var words := s.Split(' ');\n  for var i := 0 to words.Length - 1 do\n    answer += &Array.IndexOf(stringArr, words[i]).ToString;\n  \n  Result := StrToInt(answer);\nend;"
  },
  {
    "instruction": "Write a function that implements the Boyer-Moore string search algorithm. The function should return the index of the first occurrence of the pattern in the text, or -1 if the pattern is not found.",
    "output": "function GetBadCharacterShift(pattern: string): Dictionary<char, integer>;\nbegin\n  var badCharShift := new Dictionary<char, integer>;\n  for var i := 0 to pattern.Length - 2 do\n    badCharShift[pattern[i]] := pattern.Length - i - 1;\n  Result := badCharShift;\nend;\n\nfunction BoyerMooreSearch(text, pattern: string): integer;\nbegin\n  var textLength := text.Length;\n  var patternLength := pattern.Length;\n\n  if patternLength > textLength then\n  begin\n    Result := -1;\n    exit;\n  end;\n\n  var badCharShift := GetBadCharacterShift(pattern);\n  var i := patternLength - 1;\n\n  while i < textLength do\n  begin\n    var j := patternLength - 1;\n    while (j >= 0) and (text[i] = pattern[j]) do\n    begin\n      i -= 1;\n      j -= 1;\n    end;\n\n    if j < 0 then\n    begin\n      Result := i + 1;\n      exit;\n    end;\n\n    var shift := patternLength;\n    if badCharShift.ContainsKey(text[i]) then\n      shift := badCharShift[text[i]];\n    i += shift;\n  end;\n\n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to find the largest number smaller than the given number n, with digit sum greater than the digit sum of n.",
    "output": "function LargeNumber(digitSum, n: integer): integer;\nbegin\n  while n > 0 do\n  begin\n    n -= 1;\n    var currentDigitSum := n.ToString.Sum(c -> StrToInt(c.ToString));\n    if currentDigitSum > digitSum then\n    begin\n      Result := n;\n      exit;\n    end;\n  end;\n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to convert an integer to its hexadecimal representation as a string.",
    "output": "function IntegerToHex(num: integer): string;\nbegin\n  if num = 0 then\n  begin\n    Result := '0';\n    exit;\n  end;\n\n  var hexChars := '0123456789abcdef';\n  var hexString := '';\n\n  while num > 0 do\n  begin\n    hexString := hexChars[num mod 16] + hexString;\n    num := num div 16;\n  end;\n\n  Result := hexString;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum element in a list using recursion.",
    "output": "function FindMaxRecursive(lst: array of integer): integer;\n\n  function FindMax(index: integer; maxVal: integer): integer;\n  begin\n    if index = lst.Length then\n      Result := maxVal\n    else\n    begin\n      if lst[index] > maxVal then\n        maxVal := lst[index];\n      Result := FindMax(index + 1, maxVal);\n    end;\n  end;\n\nbegin\n  if lst.Length = 0 then\n    Result := 0\n  else\n    Result := FindMax(0, lst[0]);\nend;"
  },
  {
    "instruction": "Write a function to find the largest sum of non-adjacent elements in an array.",
    "output": "function FindLargestSumNonAdjacent(arr: array of integer): integer;\nbegin\n  var incl := 0;\n  var excl := 0;\n\n  for var i := 0 to arr.Length - 1 do\n  begin\n    var newExcl := Max(incl, excl);\n    incl := excl + arr[i];\n    excl := newExcl;\n  end;\n\n  Result := Max(incl, excl);\nend;"
  },
  {
    "instruction": "Write a function that checks if it's possible to reach the end of an array of non-negative integers. Given an array `nums` of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index.",
    "output": "function CanJump(nums: array of integer): boolean;\nbegin\n  var &end := 0;\n  var n := nums.Length;\n\n  for var i := 0 to n - 1 do\n  begin\n    if i > &end then\n    begin\n      Result := false;\n      exit;\n    end;\n\n    if i = n - 1 then\n    begin\n      Result := true;\n      exit;\n    end;\n\n    &end := Max(&end, i + nums[i]);\n  end;\n\n  Result := true;\nend;"
  },
  {
    "instruction": "Write a function to find the duplicate and missing number in a given list of integers. The list is supposed to contain numbers from 1 to n (inclusive), but one number is missing and another number is duplicated. The function should return a tuple containing the duplicate number and the missing number in this order.",
    "output": "function FindDuplicateMissing(arr: array of integer): (integer, integer);\nbegin\n  var count := new Dictionary<integer, integer>;\n  var n := arr.Length;\n  var duplicate := -1;\n  var missing := -1;\n\n  for var i := 0 to arr.Length - 1 do\n  begin\n    if count.ContainsKey(arr[i]) then\n      count[arr[i]] += 1\n    else\n      count[arr[i]] := 1;\n  end;\n\n  for var i := 1 to n do\n  begin\n    if count.ContainsKey(i) then\n    begin\n      if count[i] = 2 then\n        duplicate := i;\n    end\n    else\n      missing := i;\n  end;\n\n  Result := (duplicate, missing);\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to make change for a given amount using a set of coin denominations. The function should return the count of distinct ways to make the change.",
    "output": "function WaysToChange(amount: integer; coins: array of integer): integer;\nbegin\n  var dp := new integer[amount + 1];\n  dp[0] := 1;\n\n  for var i := 0 to coins.Length - 1 do\n    for var j := coins[i] to amount do\n      dp[j] += dp[j - coins[i]];\n\n  Result := dp[amount];\nend;"
  },
  {
    "instruction": "Write a function to find the sum of diagonal elements in a square matrix.",
    "output": "function SumDiagonal(matrix: array of array of integer): integer;\nbegin\n  var sumVal := 0;\n  var n := matrix.Length;\n\n  for var i := 0 to n - 1 do\n    sumVal += matrix[i][i];\n\n  Result := sumVal;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of the numbers in a given list, excluding any numbers that are multiples of 4. If the list is empty, the function should return 0.",
    "output": "function SumExcludingMultiplesOfFour(lst: array of integer): integer;\nbegin\n  Result := 0;\n  for var i := 0 to lst.Length - 1 do\n    if lst[i] mod 4 <> 0 then\n      Result += lst[i];\nend;"
  },
  {
    "instruction": "Write a function to flatten a nested list structure where each element could be an integer or a list. The function should return a list of all the integers in the flattened structure.",
    "output": "procedure Flatten(data: List<object>; resultList: List<integer>);\nbegin\n  for var i := 0 to data.Count - 1 do\n  begin\n    if data[i] is List<object> then\n      Flatten(List&<object>(data[i]), resultList)\n    else if data[i] is integer then\n      resultList.Add(integer(data[i]));\n  end;\nend;\n\nfunction FlattenNestedList(nestedList: List<object>): List<integer>;\nbegin\n  var resultList := new List<integer>;\n  Flatten(nestedList, resultList);\n  Result := resultList;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest repeating unit in a given string. If no repeating pattern is found, return the entire string.",
    "output": "function SmallestRepeatingUnit(s: string): string;\nbegin\n  var length := s.Length;\n\n  for var i := 1 to length div 2 do\n  begin\n    if length mod i = 0 then\n    begin\n      var _unit := s.Substring(0, i);\n      var repeated := '';\n\n      for var j := 1 to length div i do\n        repeated += _unit;\n\n      if repeated = s then\n      begin\n        Result := _unit;\n        exit;\n      end;\n    end;\n  end;\n\n  Result := s;\nend;"
  },
  {
    "instruction": "Write a function to reverse the elements of a given linked list.",
    "output": "type\n  Node = class\n    data: integer;\n    next: Node;\n    \n    constructor(d: integer);\n    begin\n      data := d;\n      next := nil;\n    end;\n  end;\n\ntype\n  LinkedList = class\n    head: Node;\n    \n    constructor;\n    begin\n      head := nil;\n    end;\n    \n    procedure Reverse;\n    begin\n      var prev: Node := nil;\n      var current := head;\n      while current <> nil do\n      begin\n        var next := current.next; \n        current.next := prev;  \n        prev := current;       \n        current := next;        \n      end;\n      head := prev;  \n    end;\n  \n  \n  end;"
  },
  {
    "instruction": "Write a function that finds all possible ways to partition a given string into substrings, such that each substring is a palindrome.",
    "output": "function IsPalindrome(s: string): boolean;\nbegin\n  Result := s = s.Inverse;\nend;\n\nprocedure DFS(s: string; start: integer; path: List<string>; var res: List<List<string>>);\nbegin\n  if start = s.Length then\n  begin\n    res.Add(new List<string>(path));\n    exit;\n  end;\n  \n  for var endIndex := start to s.Length - 1 do\n  begin\n    var substr := s.Substring(start, endIndex - start + 1);\n    if IsPalindrome(substr) then\n    begin\n      path.Add(substr);\n      DFS(s, endIndex + 1, path, res);\n      path.RemoveAt(path.Count - 1);\n    end;\n  end;\nend;\n\nfunction PartitionPalindromes(s: string): List<List<string>>;\nbegin\n  var res := new List<List<string>>;\n  DFS(s, 0, new List<string>, res);\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the number of balanced parentheses expressions that can be formed using a given number of parentheses.",
    "output": "function BalancedParentheses(n: integer): integer;\nbegin\n  if n = 1 then\n    Result := 1\n  else\n  begin\n    var dp := ArrFill(n + 1, 0);\n    dp[0] := 1;\n    dp[1] := 1;\n    for var i := 2 to n do\n      for var j := 0 to i - 1 do\n        dp[i] := dp[i] + dp[j] * dp[i - j - 1];\n    Result := dp[n];\n  end;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings and returns a list of strings that have a length greater than 5.",
    "output": "function FilterLongStrings(stringList: List<string>): List<string>;\nbegin\n  Result := stringList.Where(s -> s.Length > 5).ToList;\nend;"
  },
  {
    "instruction": "Write a function to find the longest uncommon subsequence between two strings. If there is no uncommon subsequence, return -1.",
    "output": "function FindLongestUncommonSubsequence(str1, str2: string): integer;\nbegin\n  if str1 = str2 then\n    Result := -1\n  else\n    Result := Max(str1.Length, str2.Length);\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns a new list with the maximum digit in each number from the original list.",
    "output": "function MaxDigit(numbers: List<integer>): List<integer>;\nbegin\n  var res := new List<integer>;\n  foreach var number in numbers do\n  begin\n    var maxDigitValue := 0;\n    var strNum := number.ToString;\n    foreach var digitChar in strNum do\n    begin\n      var digitValue := StrToInt(digitChar);\n      if digitValue > maxDigitValue then\n        maxDigitValue := digitValue;\n    end;\n    res.Add(maxDigitValue);\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns a new list with every odd number replaced by -1, and every even number replaced by 1.",
    "output": "function OddToMinusOne(list1: List<integer>): List<integer>;\nbegin\n  var res := new List<integer>;\n  foreach var num in list1 do\n    if num mod 2 = 0 then\n      res.Add(1)\n    else\n      res.Add(-1);\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function that checks if a string's length is a prime number.",
    "output": "function IsPrime(n: integer): boolean;\nbegin\n  if n <= 1 then\n    Result := False\n  else\n  begin\n    for var i := 2 to Round(Sqrt(n)) do\n      if n mod i = 0 then\n      begin\n        Result := False;\n        exit;\n      end;\n    Result := True;\n  end;\nend;\n\nfunction IsPrimeLen(word: string): boolean;\nbegin\n  Result := IsPrime(word.Length);\nend;"
  },
  {
    "instruction": "Write a function to check whether a list of strings is sorted lexicographically or not.",
    "output": "function IsSortedLexicographically(lst: List<string>): boolean;\nbegin\n  var sortedList := lst.Order.ToList;\n  Result := lst.SequenceEqual(sortedList);\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways a given amount of money can be made using a given set of denominations of coins.",
    "output": "function CountChange(money: integer; denominations: List<integer>): integer;\nbegin\n  var dp := ArrFill(money + 1, 0);\n  dp[0] := 1;\n  foreach var coin in denominations do\n    for var i := coin to money do\n      dp[i] := dp[i] + dp[i - coin];\n  Result := dp[money];\nend;"
  },
  {
    "instruction": "Write a function to find the median of two sorted arrays.",
    "output": "function MedianTwoSortedArrays(nums1, nums2: List<integer>): real;\nbegin\n  var combined := nums1.Concat(nums2).Order.ToList;\n  var lengthValue := combined.Count;\n  if lengthValue mod 2 = 0 then\n    Result := (combined[lengthValue div 2 - 1] + combined[lengthValue div 2]) / 2\n  else\n    Result := combined[lengthValue div 2];\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest subarray that contains only 1's after deleting exactly one element from the given binary array.",
    "output": "function MaxLengthOfSubarray(arr: List<integer>): integer;\nbegin\n  var n := arr.Count;\n  var maxLen := 0;\n  var left := 0;\n  var right := 0;\n  var zeroCount := 0;\n  \n  while right < n do\n  begin\n    if arr[right] = 0 then\n      zeroCount += 1;\n    \n    while zeroCount > 1 do\n    begin\n      if arr[left] = 0 then\n        zeroCount -= 1;\n      left += 1;\n    end;\n    \n    maxLen := Max(maxLen, right - left);\n    right += 1;\n  end;\n  \n  Result := maxLen;\nend;"
  },
  {
    "instruction": "Write a function to rearrange the elements of a given list of integers so that all the even numbers come before all the odd numbers.",
    "output": "function EvenOddPartition(arr: List<integer>): List<integer>;\nbegin\n  var evenList := new List<integer>;\n  var oddList := new List<integer>;\n  \n  foreach var num in arr do\n    if num mod 2 = 0 then\n      evenList.Add(num)\n    else\n      oddList.Add(num);\n  \n  Result := evenList.Concat(oddList).ToList;\nend;"
  },
  {
    "instruction": "Write a function to count the number of times a given substring appears in a string, ignoring case sensitivity.",
    "output": "function CountSubstringIgnoreCase(s, sub: string): integer;\nbegin\n  var count := 0;\n  var pos := 0;\n  var lowerS := s.ToLower;\n  var lowerSub := sub.ToLower;\n  \n  while true do\n  begin\n    pos := lowerS.IndexOf(lowerSub, pos);\n    if pos = -1 then\n      break;\n    count := count + 1;\n    pos := pos + 1;\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of coins required to make a given amount. You have an infinite number of coins of denominations coins = [c1, c2, ..., cn].",
    "output": "function MinCoins(coins: List<integer>; amount: integer): integer;\nbegin\n  var dp := ArrFill(amount + 1, integer.MaxValue);\n  dp[0] := 0;\n  \n  foreach var coin in coins do\n    for var x := coin to amount do\n      if dp[x - coin] <> integer.MaxValue then\n        dp[x] := Min(dp[x], dp[x - coin] + 1);\n  \n  if dp[amount] = integer.MaxValue then\n    Result := -1\n  else\n    Result := dp[amount];\nend;"
  },
  {
    "instruction": "Write a function to find the number of even numbers in an array.",
    "output": "function CountEven(arr: List<integer>): integer;\nbegin\n  var count := 0;\n  foreach var num in arr do\n    if num mod 2 = 0 then\n      count += 1;\n  Result := count;\nend;"
  },
  {
    "instruction": "Create a function that takes a list of words and a single character, and returns a list of all the words that start with that character.",
    "output": "function GetWordsStartWithChar(words: List<string>; charValue: char): List<string>;\nbegin\n  Result := words.Where(word -> word.StartsWith(charValue)).ToList;\nend;"
  },
  {
    "instruction": "Write a function to find the number of connected components in an undirected graph represented by an adjacency matrix.",
    "output": "procedure BFS(isConnected: List<List<integer>>; node: integer; var visited: array of boolean);\nbegin\n  var q := new Queue<integer>;\n  q.Enqueue(node);\n  \n  while q.Count > 0 do\n  begin\n    var cur := q.Dequeue;\n    if not visited[cur] then\n    begin\n      visited[cur] := True;\n      for var neighbor := 0 to isConnected.Count - 1 do\n        if isConnected[cur][neighbor] = 1 then\n          if not visited[neighbor] then\n            q.Enqueue(neighbor);\n    end;\n  end;\nend;\n\nfunction FindCircleNum(isConnected: List<List<integer>>): integer;\nbegin\n  var n := isConnected.Count;\n  var visited := ArrFill(n, False);\n  var circles := 0;\n  \n  for var i := 0 to n - 1 do\n    if not visited[i] then\n    begin\n      BFS(isConnected, i, visited);\n      circles += 1;\n    end;\n  \n  Result := circles;\nend;"
  },
  {
    "instruction": "Write a function to find the second smallest prime number in a given list of numbers. If there is no second smallest prime number, return -1.",
    "output": "function IsPrimeNum(n: integer): boolean;\nbegin\n  if n <= 1 then\n    Result := False\n  else\n  begin\n    for var i := 2 to Round(Sqrt(n)) do\n      if n mod i = 0 then\n      begin\n        Result := False;\n        exit;\n      end;\n    Result := True;\n  end;\nend;\n\nfunction FindSecondSmallestPrime(numbers: List<integer>): integer;\nbegin\n  var primes := new List<integer>;\n  \n  foreach var num in numbers do\n    if IsPrimeNum(num) then\n      primes.Add(num);\n  \n  var uniquePrimes := primes.Distinct.ToList;\n  \n  if uniquePrimes.Count < 2 then\n    Result := -1\n  else\n  begin\n    uniquePrimes.Sort;\n    Result := uniquePrimes[1];\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the difference between the largest and smallest value in a given array.",
    "output": "function BigDiff(nums: List<integer>): integer;\nbegin\n  Result := nums.Max - nums.Min;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to reach the nth step if you can either take 1 or 2 steps at a time.",
    "output": "function StepWays(n: integer): integer;\nbegin\n  if n <= 1 then\n    Result := 1\n  else\n  begin\n    var dp := ArrFill(n + 1, 0);\n    dp[0] := 1;\n    dp[1] := 1;\n    for var i := 2 to n do\n      dp[i] := dp[i - 1] + dp[i - 2];\n    Result := dp[n];\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum absolute difference between any two elements in a given array.",
    "output": "function MinAbsDiff(arr: List<integer>): integer;\nbegin\n  arr.Sort;\n  var minDiff := integer.MaxValue;\n  \n  for var i := 0 to arr.Count - 2 do\n  begin\n    var diff := Abs(arr[i] - arr[i + 1]);\n    if diff < minDiff then\n      minDiff := diff;\n  end;\n  \n  Result := minDiff;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum subarray sum such that the subarray crosses the midpoint of the array.",
    "output": "function FindMaxCrossingSubarray(arr: List<integer>; low, mid, high: integer): integer;\nbegin\n  var leftSum := integer.MinValue;\n  var sumValue := 0;\n  var maxLeft := mid;\n  \n  for var i := mid downto low do\n  begin\n    sumValue := sumValue + arr[i];\n    if sumValue > leftSum then\n    begin\n      leftSum := sumValue;\n      maxLeft := i;\n    end;\n  end;\n  \n  var rightSum := integer.MinValue;\n  sumValue := 0;\n  var maxRight := mid + 1;\n  \n  for var j := mid + 1 to high do\n  begin\n    sumValue := sumValue + arr[j];\n    if sumValue > rightSum then\n    begin\n      rightSum := sumValue;\n      maxRight := j;\n    end;\n  end;\n  \n  Result := leftSum + rightSum;\nend;"
  },
  {
    "instruction": "Write a function to calculate the power of a number raised to another number without using the built-in power function.",
    "output": "function PowerWithoutBuiltin(base, exponent: integer): integer;\nbegin\n  var res := 1;\n  for var i := 1 to exponent do\n    res := res * base;\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum length of a subsequence where the elements are in strictly increasing order.",
    "output": "function IncreasingSubseqLength(nums: List<integer>): integer;\nbegin\n  if nums.Count = 0 then\n    Result := 0\n  else\n  begin\n    var dp := ArrFill(nums.Count, 1);\n    for var i := 1 to nums.Count - 1 do\n      for var j := 0 to i - 1 do\n        if nums[i] > nums[j] then\n          dp[i] := Max(dp[i], dp[j] + 1);\n    Result := dp.Max;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of consecutive 0's in a binary string.",
    "output": "function MaxConsecutiveZeros(binaryString: string): integer;\nbegin\n  var maxCount := 0;\n  var count := 0;\n  \n  foreach var ch in binaryString do\n    if ch = '0' then\n    begin\n      count += 1;\n      maxCount := Max(maxCount, count);\n    end\n    else\n      count := 0;\n  \n  Result := maxCount;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of the product of the first n natural numbers when paired in a sequence.",
    "output": "function ProductSum(n: integer): integer;\nbegin\n  var sumValue := 0;\n  for var i := 1 to n - 1 do\n    sumValue := sumValue + i * (i + 1);\n  Result := sumValue;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest square number which is greater than or equal to the given number.",
    "output": "function SmallestSquare(n: integer): integer;\nbegin\n  var root := Ceil(Sqrt(n));\n  Result := root * root;\nend;"
  },
  {
    "instruction": "Write a function to check if a given string is an anagram of a palindrome.",
    "output": "function IsAnagramOfPalindrome(strValue: string): boolean;\nbegin\n  var charCount := new Dictionary<char, integer>;\n  \n  foreach var ch in strValue do\n    if charCount.ContainsKey(ch) then\n      charCount[ch] := charCount[ch] + 1\n    else\n      charCount.Add(ch, 1);\n  \n  var oddCount := 0;\n  foreach var count in charCount.Values do\n    if count mod 2 <> 0 then\n      oddCount += 1;\n  \n  Result := oddCount <= 1;\nend;"
  },
  {
    "instruction": "Write a function that determines if a given integer is a narcissistic number or not. A narcissistic number is a number that is the sum of its own digits each raised to the power of the number of digits.",
    "output": "function IsNarcissistic(num: integer): boolean;\nbegin\n  var digits := num.ToString.Select(ch -> StrToInt(ch.ToString)).ToList;\n  var numDigits := digits.Count;\n  var sumValue := digits.Sum(d -> Round(Power(d, numDigits)));\n  Result := num = sumValue;\nend;"
  },
  {
    "instruction": "Write a function that will give the frequencies of each word in a given list of words.",
    "output": "function WordFrequencies(wordList: List<string>): Dictionary<string, integer>;\nbegin\n  var frequencies := new Dictionary<string, integer>;\n  \n  foreach var word in wordList do\n    if frequencies.ContainsKey(word) then\n      frequencies[word] := frequencies[word] + 1\n    else\n      frequencies.Add(word, 1);\n  \n  Result := frequencies;\nend;"
  },
  {
    "instruction": "Write a function to check whether a given string is a valid URL or not using regex.",
    "output": "function CheckURL(url: string): string;\nbegin\n  var regex := '^(http|https)://([a-zA-Z0-9]+(-?[a-zA-Z0-9])*){1,}(\\.([a-zA-Z]{1,})+)+(/[a-zA-Z0-9]*)*';\n  \n  if &System.Text.RegularExpressions.Regex.IsMatch(url, regex) then\n    Result := 'Valid URL'\n  else\n    Result := 'Invalid URL';\nend;"
  },
  {
    "instruction": "Write a function to find the number of unique binary search trees (BST) that can be made with a given number of nodes.",
    "output": "function CountUniqueBST(n: integer): integer;\nbegin\n  if (n = 0) or (n = 1) then\n    Result := 1\n  else\n  begin\n    var dp := ArrFill(n + 1, 0);\n    dp[0] := 1;\n    dp[1] := 1;\n    for var i := 2 to n do\n      for var j := 0 to i - 1 do\n        dp[i] := dp[i] + dp[j] * dp[i - j - 1];\n    Result := dp[n];\n  end;\nend;"
  },
  {
    "instruction": "Write a function to shuffle two lists by interleaving their elements.",
    "output": "function ShuffleLists(list1, list2: List<integer>): List<integer>;\nbegin\n  var shuffled := new List<integer>;\n  var maxLength := Max(list1.Count, list2.Count);\n  \n  for var i := 0 to maxLength - 1 do\n  begin\n    if i < list1.Count then\n      shuffled.Add(list1[i]);\n    if i < list2.Count then\n      shuffled.Add(list2[i]);\n  end;\n  \n  Result := shuffled;\nend;"
  },
  {
    "instruction": "Write a function to sort an array of integers using the Dutch National Flag Algorithm. The function should sort the array in-place without using extra space.",
    "output": "function SortColors(nums: List<integer>): List<integer>;\nbegin\n  var low := 0;\n  var mid := 0;\n  var high := nums.Count - 1;\n  \n  while mid <= high do\n  begin\n    if nums[mid] = 0 then\n    begin\n      var temp := nums[low];\n      nums[low] := nums[mid];\n      nums[mid] := temp;\n      low += 1;\n      mid += 1;\n    end\n    else if nums[mid] = 1 then\n      mid += 1\n    else\n    begin\n      var temp := nums[mid];\n      nums[mid] := nums[high];\n      nums[high] := temp;\n      high -= 1;\n    end;\n  end;\n  \n  Result := nums;\nend;"
  },
  {
    "instruction": "Write a function to find the largest power of 2 less than or equal to a given number.",
    "output": "function LargestPowerOf2(n: integer): integer;\nbegin\n  var power := 1;\n  while power * 2 <= n do\n    power := power * 2;\n  Result := power;\nend;"
  },
  {
    "instruction": "Write a function that takes an array of integers and returns a new array where each element is the square of the absolute value of the corresponding element in the original array. The result array should be sorted in ascending order.",
    "output": "function SortedAndSquared(arr: List<integer>): List<integer>;\nbegin\n  Result := arr.Select(num -> Abs(num) * Abs(num)).Order.ToList;\nend;"
  },
  {
    "instruction": "Write a function that takes an input string and a pattern string, and returns a boolean indicating whether or not the input string matches the pattern string. The pattern string can include the special characters '?' and '*', where '?' matches any single character and '*' matches any sequence of characters (including the empty sequence).",
    "output": "function _Match(s, pattern: string; i, j: integer; var memo: Dictionary<(integer, integer), boolean>): boolean;\nbegin\n  if memo.ContainsKey((i, j)) then\n    Result := memo[(i, j)]\n  else\n  begin\n    if j = pattern.Length then\n      Result := i = s.Length\n    else if (i < s.Length) and ((pattern[j] = '?') or (pattern[j] = s[i])) then\n      Result := _Match(s, pattern, i + 1, j + 1, memo)\n    else if (j + 1 < pattern.Length) and (pattern[j + 1] = '*') then\n      Result := _Match(s, pattern, i, j + 2, memo) or ((i < s.Length) and _Match(s, pattern, i + 1, j, memo))\n    else\n      Result := False;\n    \n    memo[(i, j)] := Result;\n  end;\nend;\n\nfunction PatternMatching(s, pattern: string): boolean;\nbegin\n  var memo := new Dictionary<(integer, integer), boolean>;\n  Result := _Match(s, pattern, 0, 0, memo);\nend;"
  },
  {
    "instruction": "Write a function to convert a string representation of a date in the format \"YYYY-MM-DD\" to the day of the year (1 through 366).",
    "output": "function DayOfYear(dateStr: string): integer;\nbegin\n  var parts := dateStr.Split('-');\n  var y := StrToInt(parts[0]);\n  var m := StrToInt(parts[1]);\n  var d := StrToInt(parts[2]);\n  \n  var dateValue := new &System.DateTime(y, m, d);\n  var startOfYear := new &System.DateTime(y, 1, 1);\n  Result := (dateValue - startOfYear).Days + 1;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns the size of the smallest set of numbers that, when removed from the list, leaves a list where the remaining numbers appear at most once. This is equivalent to finding the minimum number of elements to remove to make the list \"unique\".",
    "output": "function MinUniqueSet(arr: List<integer>): integer;\nbegin\n  var counts := new Dictionary<integer, integer>;\n  \n  foreach var num in arr do\n    if counts.ContainsKey(num) then\n      counts[num] := counts[num] + 1\n    else\n      counts.Add(num, 1);\n  \n  var sortedKeys := counts.Keys.OrderByDescending(key -> counts[key]).ToList;\n  var n := arr.Count;\n  var cnt := 0;\n  var ans := 0;\n  \n  foreach var key in sortedKeys do\n  begin\n    cnt := cnt + counts[key];\n    ans := ans + 1;\n    if cnt >= (n + 1) div 2 then\n    begin\n      Result := ans;\n      exit;\n    end;\n  end;\n  \n  Result := ans;\nend;"
  },
  {
    "instruction": "Write a function to check if a number is a perfect square and also a Fibonacci number.",
    "output": "function IsPerfectSquare(x: integer): boolean;\nbegin\n  var s := Round(Sqrt(x));\n  Result := s * s = x;\nend;\n\nfunction IsFibonacci(n: integer): boolean;\nbegin\n  Result := IsPerfectSquare(5 * n * n + 4) or IsPerfectSquare(5 * n * n - 4);\nend;\n\nfunction IsPerfectSquareFibonacci(n: integer): boolean;\nbegin\n  Result := IsPerfectSquare(n) and IsFibonacci(n);\nend;"
  },
  {
    "instruction": "Write a function to count the number of special characters in a given string.",
    "output": "function CountSpecialCharacters(s: string): integer;\nbegin\n  var specialChars := '!\"#$%&''()*+,-./:;<=>?@[\\]^_`{|}~';\n  var count := 0;\n  \n  foreach var c in s do\n    if specialChars.Contains(c) then\n      count += 1;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the number of inversions in an array. An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].",
    "output": "function Merge(var arr: array of integer; var tempArr: array of integer; left, mid, right: integer): integer;\nbegin\n  var i := left;\n  var j := mid + 1;\n  var k := left;\n  var invCount := 0;\n  \n  while (i <= mid) and (j <= right) do\n  begin\n    if arr[i] <= arr[j] then\n    begin\n      tempArr[k] := arr[i];\n      k += 1;\n      i += 1;\n    end\n    else\n    begin\n      tempArr[k] := arr[j];\n      invCount := invCount + (mid - i + 1);\n      k += 1;\n      j += 1;\n    end;\n  end;\n  \n  while i <= mid do\n  begin\n    tempArr[k] := arr[i];\n    k += 1;\n    i += 1;\n  end;\n  \n  while j <= right do\n  begin\n    tempArr[k] := arr[j];\n    k += 1;\n    j += 1;\n  end;\n  \n  for var loopVar := left to right do\n    arr[loopVar] := tempArr[loopVar];\n  \n  Result := invCount;\nend;\n\nfunction MergeSortHelper(var arr: array of integer; var tempArr: array of integer; left, right: integer): integer;\nbegin\n  var invCount := 0;\n  if left < right then\n  begin\n    var mid := (left + right) div 2;\n    invCount := invCount + MergeSortHelper(arr, tempArr, left, mid);\n    invCount := invCount + MergeSortHelper(arr, tempArr, mid + 1, right);\n    invCount := invCount + Merge(arr, tempArr, left, mid, right);\n  end;\n  Result := invCount;\nend;\n\nfunction MergeSort(arr: array of integer; n: integer): integer;\nbegin\n  var tempArr := new integer[n];\n  Result := MergeSortHelper(arr, tempArr, 0, n - 1);\nend;\n\nfunction FindInversions(arr: array of integer): integer;\nbegin\n  var n := arr.Length;\n  Result := MergeSort(arr, n);\nend;"
  },
  {
    "instruction": "Write a function to find the maximum sum of a subarray with the length of exactly k.",
    "output": "function MaxSubarraySum(arr: List<integer>; k: integer): integer;\nbegin\n  if arr.Count = 0 then\n    Result := 0\n  else\n  begin\n    var maxSum := 0;\n    var currentSum := 0;\n    \n    for var i := 0 to k - 1 do\n      currentSum := currentSum + arr[i];\n    \n    maxSum := currentSum;\n    \n    for var i := k to arr.Count - 1 do\n    begin\n      currentSum := currentSum + arr[i] - arr[i - k];\n      maxSum := Max(maxSum, currentSum);\n    end;\n    \n    Result := maxSum;\n  end;\nend;"
  },
  {
    "instruction": "Write a function that takes a string and returns a new string where the case of each character is reversed. Uppercase characters become lowercase and vice versa.",
    "output": "function CaseReverser(s: string): string;\nbegin\n  var newString := '';\n  foreach var char in s do\n    if char.IsUpper then\n      newString := newString + char.ToLower\n    else\n      newString := newString + char.ToUpper;\n  Result := newString;\nend;"
  },
  {
    "instruction": "Write a function to find all the unique combinations of k numbers that sum up to n, using numbers 1 through 9. Each number can be used at most once. Return all possible combinations in a list of lists.",
    "output": "procedure DFS(k, target, start: integer; path: List<integer>; var res: List<List<integer>>);\nbegin\n  if path.Count = k then\n  begin\n    if target = 0 then\n      res.Add(new List<integer>(path));\n    exit;\n  end;\n  \n  for var i := start to 9 do\n  begin\n    if i > target then break;\n    path.Add(i);\n    DFS(k, target - i, i + 1, path, res);\n    path.RemoveAt(path.Count - 1);\n  end;\nend;\n\nfunction CombinationSum3(k, n: integer): List<List<integer>>;\nbegin\n  var res := new List<List<integer>>;\n  DFS(k, n, 1, new List<integer>, res);\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to calculate the minimum cost of buying ice cream balls when every third ice cream ball is free. The function should take a list of integers as input representing the cost of each ice cream ball, and return the minimum cost to buy all the ice cream balls.",
    "output": "function MinimumCost(cost: List<integer>): integer;\nbegin\n  cost.Sort;\n  var res := 0;\n  for var i := 0 to cost.Count - 1 do\n    if i mod 3 <> cost.Count mod 3 then\n      res := res + cost[i];\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the number of triangles that can be formed with a given list of line segments. The length of any side of a triangle must be less than the sum of the lengths of the other two sides.",
    "output": "function FindNumTriangles(segments: List<integer>): integer;\nbegin\n  segments.Sort;\n  var count := 0;\n  var n := segments.Count;\n  \n  for var i := 0 to n - 2 do\n  begin\n    var k := i + 2;\n    for var j := i + 1 to n - 1 do\n    begin\n      while (k < n) and (segments[i] + segments[j] > segments[k]) do\n        k := k + 1;\n      count := count + k - j - 1;\n    end;\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to check if a given undirected graph is a tree or not. A tree is a connected graph with no cycles.",
    "output": "function HasCycle(graph: Dictionary<integer, List<integer>>; visited: array of boolean; parent, node: integer): boolean;\nbegin\n  visited[node] := True;\n  \n  if graph.ContainsKey(node) then\n    foreach var neighbor in graph[node] do\n    begin\n      if not visited[neighbor] then\n      begin\n        if HasCycle(graph, visited, node, neighbor) then\n        begin\n          Result := True;\n          exit;\n        end;\n      end\n      else if neighbor <> parent then\n      begin\n        Result := True;\n        exit;\n      end;\n    end;\n  \n  Result := False;\nend;\n\nfunction IsTree(numNodes: integer; edges: List<List<integer>>): boolean;\nbegin\n  var graph := new Dictionary<integer, List<integer>>;\n  \n  foreach var edge in edges do\n  begin\n    var u := edge[0];\n    var v := edge[1];\n    \n    if not graph.ContainsKey(u) then\n      graph.Add(u, new List<integer>);\n    if not graph.ContainsKey(v) then\n      graph.Add(v, new List<integer>);\n    \n    graph[u].Add(v);\n    graph[v].Add(u);\n  end;\n  \n  var visited := ArrFill(numNodes, False);\n  \n  if HasCycle(graph, visited, -1, 0) then\n    Result := False\n  else\n  begin\n    foreach var v in visited do\n      if not v then\n      begin\n        Result := False;\n        exit;\n      end;\n    Result := True;\n  end;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns a list of tuples. Each tuple should contain the original integer and its square.",
    "output": "function SquareOfNumbers(numbers: List<integer>): List<(integer, integer)>;\nbegin\n  var res := new List<(integer, integer)>;\n  foreach var num in numbers do\n    res.Add((num, num * num));\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the missing number in a given list of numbers containing 0 to n numbers with one missing. Use a lambda function to solve the problem.",
    "output": "function MissingNumberLambda(nums: List<integer>): integer;\nbegin\n  var n := nums.Count;\n  var totalSum := n * (n + 1) div 2;\n  var sumOfNums := nums.Sum;\n  var missingNumber := totalSum - sumOfNums;\n  Result := missingNumber;\nend;"
  },
  {
    "instruction": "Write a function to return top two employees with the highest salaries from a given list of tuples containing employee name and salary.",
    "output": "function TopTwoSalaries(employeeList: List<(string, integer)>): List<string>;\nbegin\n  var newList := employeeList.OrderByDescending(x -> x.Item2).ToList;\n  var topEmployees := new List<string>;\n  topEmployees.Add(newList[0].Item1);\n  topEmployees.Add(newList[1].Item1);\n  Result := topEmployees;\nend;"
  },
  {
    "instruction": "Write a function to check if a given list of integers has unique frequency of occurrence for each element.",
    "output": "function UniqueFrequency(arr: List<integer>): boolean;\nbegin\n  var frequency := new Dictionary<integer, integer>;\n  \n  foreach var num in arr do\n    if frequency.ContainsKey(num) then\n      frequency[num] := frequency[num] + 1\n    else\n      frequency.Add(num, 1);\n  \n  var frequencyValues := frequency.Values.ToList;\n  var uniqueFrequencies := frequencyValues.Distinct.ToList;\n  \n  Result := frequencyValues.Count = uniqueFrequencies.Count;\nend;"
  },
  {
    "instruction": "Write a function to check if a string has all unique characters. This function should return True if all the characters in the string are unique and False otherwise.",
    "output": "function IsUnique(s: string): boolean;\nbegin\n  var uniqueChars := s.Distinct.ToList;\n  Result := uniqueChars.Count = s.Length;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum area of water that can be contained by two lines formed by the given array of heights.",
    "output": "function MaxArea(height: List<integer>): integer;\nbegin\n  var left := 0;\n  var right := height.Count - 1;\n  var maxArea := 0;\n  \n  while left < right do\n  begin\n    maxArea := Max(maxArea, Min(height[left], height[right]) * (right - left));\n    if height[left] < height[right] then\n      left := left + 1\n    else\n      right := right - 1;\n  end;\n  \n  Result := maxArea;\nend;"
  },
  {
    "instruction": "Write a function to check if a given string is a valid IPv4 address.",
    "output": "function CheckValidIPv4(ip: string): boolean;\nbegin\n  var pattern := '^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$';\n  Result := &System.Text.RegularExpressions.Regex.IsMatch(ip, pattern);\nend;"
  },
  {
    "instruction": "Write a function to generate all permutations of a given string.",
    "output": "function GeneratePermutations(s: string): List<string>;\nbegin\n  s := s.Replace(#10, '');\n  var length := s.Length;\n\n  if length = 1 then\n  begin\n    Result := new List<string>;\n    Result.Add(s);\n    exit;\n  end;\n\n  var results := new List<string>;\n  for var i := 0 to length - 1 do\n  begin\n    var temp := s.Substring(0, i) + s.Substring(i + 1);\n    var tempPerms := GeneratePermutations(temp);\n    foreach var perm in tempPerms do\n      results.Add(s[i] + perm);\n  end;\n\n  Result := results;\nend;"
  },
  {
    "instruction": "Write a function to find the number of unique quadruplets in the array that sum up to a given target value.",
    "output": "function FindQuadruplets(nums: List<integer>; target: integer): List<List<integer>>;\nbegin\n  nums.Sort;\n  var results := new List<List<integer>>;\n  var n := nums.Count;\n  \n  for var i := 0 to n - 3 do\n  begin\n    if (i > 0) and (nums[i] = nums[i - 1]) then continue;\n    \n    for var j := i + 1 to n - 2 do\n    begin\n      if (j > i + 1) and (nums[j] = nums[j - 1]) then continue;\n      \n      var left := j + 1;\n      var right := n - 1;\n      \n      while left < right do\n      begin\n        var total := nums[i] + nums[j] + nums[left] + nums[right];\n        if total = target then\n        begin\n          results.Add(new List<integer>(|nums[i], nums[j], nums[left], nums[right]|));\n          while (left < right) and (nums[left] = nums[left + 1]) do\n            left := left + 1;\n          while (left < right) and (nums[right] = nums[right - 1]) do\n            right := right - 1;\n          left := left + 1;\n          right := right - 1;\n        end\n        else if total < target then\n          left := left + 1\n        else\n          right := right - 1;\n      end;\n    end;\n  end;\n  \n  Result := results;\nend;"
  },
  {
    "instruction": "Write a function to find the nth element of a sequence where the sequence is defined as follows: The sequence starts from 1 and each number is included in the sequence if it does not contain the digit '3' and is not divisible by 3.",
    "output": "function NthElement(n: integer): integer;\nbegin\n  var arr := new List<integer>;\n  for var i := 1 to 1002 do\n  begin\n    var temp := i.ToString;\n    if (i mod 3 = 0) or (temp[temp.Length - 1] = '3') then\n      continue\n    else\n      arr.Add(i);\n  end;\n  Result := arr[n - 1];\nend;"
  },
  {
    "instruction": "Write a function that takes a list of tuples, where each tuple represents a point on a 2D grid, and returns the tuple that is farthest from the origin (0,0). The function should return the tuple with the largest Euclidean distance from the origin.",
    "output": "function FarthestPoint(points: List<(real, real)>): (real, real);\nbegin\n  var farthest := points[0];\n  var farthestDistance := Sqrt(farthest.Item1 * farthest.Item1 + farthest.Item2 * farthest.Item2);\n  \n  foreach var point in points do\n  begin\n    var distance := Sqrt(point.Item1 * point.Item1 + point.Item2 * point.Item2);\n    if distance > farthestDistance then\n    begin\n      farthest := point;\n      farthestDistance := distance;\n    end;\n  end;\n  \n  Result := farthest;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum time required to complete all tasks given a list of tasks where each task takes 1 unit of time to complete. However, there is a cooldown period between two same tasks. Implement the function to calculate the minimum time to finish all tasks considering the cooldown period.",
    "output": "function MinimumInterval(tasks: List<integer>; n: integer): integer;\nbegin\n  var taskCounts := new Dictionary<integer, integer>;\n  \n  foreach var task in tasks do\n    if taskCounts.ContainsKey(task) then\n      taskCounts[task] := taskCounts[task] + 1\n    else\n      taskCounts.Add(task, 1);\n  \n  var maxCount := taskCounts.Values.Max;\n  var maxTask := taskCounts.Count(kv -> kv.Value = maxCount);\n  var partCount := maxCount - 1;\n  var partLength := n - (maxTask - 1);\n  var emptySlots := partCount * partLength;\n  var availableTasks := tasks.Count - maxCount * maxTask;\n  var idles := Max(0, emptySlots - availableTasks);\n  \n  Result := tasks.Count + idles;\nend;"
  },
  {
    "instruction": "Write a function to find the length of a string without using built-in Length property and Count() extension.",
    "output": "function LengthOfString(strValue: string): integer;\nbegin\n  var count := 0;\n  foreach var char in strValue do\n    count := count + 1;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to reverse the bits of an integer and return the integer obtained by reversing the bits. Assume the integer is represented in 32-bit format.",
    "output": "function ReverseBits(n: integer): integer;\nbegin\n  var res := 0;\n  for var i := 0 to 31 do\n  begin\n    res := res shl 1;\n    res := res or (n and 1);\n    n := n shr 1;\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to merge two sorted lists into a single sorted list.",
    "output": "function MergeSortedLists(list1, list2: List<integer>): List<integer>;\nbegin\n  var res := new List<integer>;\n  var i := 0;\n  var j := 0;\n  \n  while (i < list1.Count) and (j < list2.Count) do\n  begin\n    if list1[i] < list2[j] then\n    begin\n      res.Add(list1[i]);\n      i := i + 1;\n    end\n    else\n    begin\n      res.Add(list2[j]);\n      j := j + 1;\n    end;\n  end;\n  \n  while i < list1.Count do\n  begin\n    res.Add(list1[i]);\n    i := i + 1;\n  end;\n  \n  while j < list2.Count do\n  begin\n    res.Add(list2[j]);\n    j := j + 1;\n  end;\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to implement a modified quicksort algorithm. The function should take a list of numbers as input and return the sorted list. The modification in this quicksort is that the pivot is chosen randomly instead of always choosing the first element.",
    "output": "function QuicksortRandomPivot(numbers: List<integer>): List<integer>;\nbegin\n  if numbers.Count <= 1 then\n    Result := numbers\n  else\n  begin\n    var pivot := numbers[&System.Random.Create.Next(numbers.Count)];\n    var less := new List<integer>;\n    var equal := new List<integer>;\n    var greater := new List<integer>;\n    \n    foreach var i in numbers do\n      if i < pivot then\n        less.Add(i)\n      else if i = pivot then\n        equal.Add(i)\n      else\n        greater.Add(i);\n    \n    Result := QuicksortRandomPivot(less).Concat(equal).Concat(QuicksortRandomPivot(greater)).ToList;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the number of vowels and consonants in a given word.",
    "output": "function CountVowelsConsonants(word: string): (integer, integer);\nbegin\n  var vowels := 'aeiou';\n  var vowelCount := 0;\n  var consonantCount := 0;\n  \n  foreach var char in word do\n  begin\n    if vowels.Contains(char.ToLower) then\n      vowelCount := vowelCount + 1\n    else if char.IsLetter then\n      consonantCount := consonantCount + 1;\n  end;\n  \n  Result := (vowelCount, consonantCount);\nend;"
  },
  {
    "instruction": "Write a function to find the union of two sorted arrays.",
    "output": "function FindUnion(arr1, arr2: List<integer>): List<integer>;\nbegin\n  var union := new List<integer>;\n  var i := 0;\n  var j := 0;\n  \n  while (i < arr1.Count) and (j < arr2.Count) do\n  begin\n    if arr1[i] < arr2[j] then\n    begin\n      union.Add(arr1[i]);\n      i := i + 1;\n    end\n    else if arr2[j] < arr1[i] then\n    begin\n      union.Add(arr2[j]);\n      j := j + 1;\n    end\n    else\n    begin\n      union.Add(arr2[j]);\n      i := i + 1;\n      j := j + 1;\n    end;\n  end;\n  \n  while i < arr1.Count do\n  begin\n    union.Add(arr1[i]);\n    i := i + 1;\n  end;\n  \n  while j < arr2.Count do\n  begin\n    union.Add(arr2[j]);\n    j := j + 1;\n  end;\n  \n  Result := union;\nend;"
  },
  {
    "instruction": "Write a function to determine if a binary tree is a binary search tree (BST).",
    "output": "type\n  Node = class\n    value: integer;\n    left: Node;\n    right: Node;\n    \n    constructor(v: integer; l: Node := nil; r: Node := nil);\n    begin\n      value := v;\n      left := l;\n      right := r;\n    end;\n  end;\n\nfunction IsBinarySearchTree(node: Node; minValue: integer := integer.MinValue; maxValue: integer := integer.MaxValue): boolean;\nbegin\n  if node = nil then\n    Result := True\n  else if (node.value < minValue) or (node.value > maxValue) then\n    Result := False\n  else\n    Result := IsBinarySearchTree(node.left, minValue, node.value - 1) and\n              IsBinarySearchTree(node.right, node.value + 1, maxValue);\nend;"
  },
  {
    "instruction": "Write a function to merge two lists into one and sort the resulting list in descending order.",
    "output": "function MergeAndSortDesc(list1, list2: List<integer>): List<integer>;\nbegin\n  var combinedList := list1.Concat(list2).ToList;\n  combinedList.Sort;\n  combinedList.Reverse;\n  Result := combinedList;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum height trees in a graph.",
    "output": "function FindMinHeightTrees(n: integer; edges: List<List<integer>>): List<integer>;\nbegin\n  if n = 1 then\n  begin\n    Result := new List<integer>;\n    Result.Add(0);\n    exit;\n  end;\n  \n  var d := new Dictionary<integer, HashSet<integer>>;\n  \n  foreach var edge in edges do\n  begin\n    var start := edge[0];\n    var endVal := edge[1];\n    \n    if not d.ContainsKey(start) then\n      d.Add(start, new HashSet<integer>);\n    if not d.ContainsKey(endVal) then\n      d.Add(endVal, new HashSet<integer>);\n      \n    d[start].Add(endVal);\n    d[endVal].Add(start);\n  end;\n  \n  var q := new List<integer>;\n  foreach var kv in d do\n    if kv.Value.Count = 1 then\n      q.Add(kv.Key);\n  \n  while n > 2 do\n  begin\n    var t := new List<integer>;\n    foreach var i in q do\n    begin\n      var j := d[i].First;\n      d[j].Remove(i);\n      if d[j].Count = 1 then\n        t.Add(j);\n      n := n - 1;\n    end;\n    q := t;\n  end;\n  \n  Result := q;\nend;"
  },
  {
    "instruction": "Write a function to remove all elements in a list that are less than a given threshold.",
    "output": "function RemoveElementsBelowThreshold(li: List<integer>; threshold: integer): List<integer>;\nbegin\n  Result := li.Where(x -> x >= threshold).ToList;\nend;"
  },
  {
    "instruction": "Write a function to find the number of unique binary search trees (BSTs) that store values 1...n.",
    "output": "function UniqueBST(n: integer): integer;\nbegin\n  if (n = 0) or (n = 1) then\n    Result := 1\n  else\n  begin\n    var dp := ArrFill(n + 1, 0);\n    dp[0] := 1;\n    dp[1] := 1;\n    for var i := 2 to n do\n      for var j := 0 to i - 1 do\n        dp[i] := dp[i] + dp[j] * dp[i - j - 1];\n    Result := dp[n];\n  end;\nend;"
  },
  {
    "instruction": "Write a function to generate the Collatz sequence for a given starting number.",
    "output": "function CollatzSequence(n: integer): List<integer>;\nbegin\n  var seq := new List<integer>;\n  seq.Add(n);\n  \n  while n <> 1 do\n  begin\n    if n mod 2 = 0 then\n      n := n div 2\n    else\n      n := 3 * n + 1;\n    seq.Add(n);\n  end;\n  \n  Result := seq;\nend;"
  },
  {
    "instruction": "Write a function to find the number of distinct palindromic substrings in a given string.",
    "output": "function ExpandAroundCenter(s: string; left, right: integer): integer;\nbegin\n  var count := 0;\n  while (left >= 0) and (right < s.Length) and (s[left] = s[right]) do\n  begin\n    count := count + 1;\n    left := left - 1;\n    right := right + 1;\n  end;\n  Result := count;\nend;\n\nfunction DistinctPalindromicSubstrings(s: string): integer;\nbegin\n  var totalCount := 0;\n  for var i := 0 to s.Length - 1 do\n  begin\n    totalCount := totalCount + ExpandAroundCenter(s, i, i);\n    totalCount := totalCount + ExpandAroundCenter(s, i, i + 1);\n  end;\n  \n  Result := totalCount;\nend;"
  },
  {
    "instruction": "Write a function to find the common elements in two lists and return them in sorted order.",
    "output": "function SortedCommonElements(list1, list2: List<integer>): List<integer>;\nbegin\n  var commonList := list1.Where(i -> list2.Contains(i)).ToList;\n  var uniqueCommon := commonList.Distinct.ToList;\n  uniqueCommon.Sort;\n  Result := uniqueCommon;\nend;"
  },
  {
    "instruction": "Write a function to generate the next row of Pascal's triangle given the previous row.",
    "output": "function NextPascalRow(prevRow: List<integer>): List<integer>;\nbegin\n  if prevRow.Count = 0 then\n  begin\n    Result := new List<integer>;\n    Result.Add(1);\n    exit;\n  end;\n  \n  var nextRow := new List<integer>;\n  nextRow.Add(1);\n  \n  for var i := 0 to prevRow.Count - 2 do\n    nextRow.Add(prevRow[i] + prevRow[i + 1]);\n  \n  nextRow.Add(1);\n  Result := nextRow;\nend;"
  },
  {
    "instruction": "Write a function that takes in a list of integers and returns a new list containing only the distinct even numbers from the original list. Ensure the order of the numbers in the original list is maintained in the new list.",
    "output": "function DistinctEven(l: List<integer>): List<integer>;\nbegin\n  var res := new List<integer>;\n  foreach var i in l do\n    if (i mod 2 = 0) and (not res.Contains(i)) then\n      res.Add(i);\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest of three given integers.",
    "output": "function MinimumOfThree(a, b, c: integer): integer;\nbegin\n  Result := Min(a, Min(b, c));\nend;"
  },
  {
    "instruction": "Write a function to find the largest continuous sum in a given array.",
    "output": "function FindLargestContinuousSum(arr: List<integer>): integer;\nbegin\n  if arr.Count = 0 then\n    Result := 0\n  else\n  begin\n    var currentSum := arr[0];\n    var maxSum := arr[0];\n    \n    for var i := 1 to arr.Count - 1 do\n    begin\n      currentSum := Max(arr[i], currentSum + arr[i]);\n      maxSum := Max(maxSum, currentSum);\n    end;\n    \n    Result := maxSum;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to count the number of vowels in a given string.",
    "output": "function CountVowels(strValue: string): integer;\nbegin\n  var count := 0;\n  var vowels := 'aeiou';\n  foreach var char in strValue.ToLower do\n    if vowels.Contains(char) then\n      count := count + 1;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the largest subarray with an equal number of 0's and 1's.",
    "output": "function MaxSubarrayWithEqualZerosAndOnes(arr: List<integer>): integer;\nbegin\n  var count := 0;\n  var maxLength := 0;\n  var countDict := new Dictionary<integer, integer>;\n  countDict.Add(0, -1);\n  \n  for var i := 0 to arr.Count - 1 do\n  begin\n    if arr[i] = 0 then\n      count := count - 1\n    else\n      count := count + 1;\n    \n    if countDict.ContainsKey(count) then\n      maxLength := Max(maxLength, i - countDict[count])\n    else\n      countDict.Add(count, i);\n  end;\n  \n  Result := maxLength;\nend;"
  },
  {
    "instruction": "Write a function to convert a list to a string using a specific separator.",
    "output": "function ListToString(list1: List<string>; separator: string): string;\nbegin\n  Result := string.Join(separator, list1);\nend;"
  },
  {
    "instruction": "Write a function to reverse the order of words in a given sentence.",
    "output": "function ReverseOrder(sentence: string): string;\nbegin\n  var words := sentence.Split(' ').ToList;\n  words.Reverse;\n  Result := string.Join(' ', words);\nend;"
  },
  {
    "instruction": "Write a function to calculate the nth Bell number.\nBell numbers count the number of ways to partition a set of n objects into any number of subsets.",
    "output": "function GetBell(n: integer): integer;\nbegin\n  var bell := new integer[n + 1, n + 1];\n  bell[0, 0] := 1;\n  \n  for var i := 1 to n do\n  begin\n    bell[i, 0] := bell[i - 1, i - 1];\n    for var j := 1 to i do\n      bell[i, j] := bell[i - 1, j - 1] + bell[i, j - 1];\n  end;\n  \n  Result := bell[n, 0];\nend;"
  },
  {
    "instruction": "Write a function to find the maximum sum of any subarray of a given size in an array.",
    "output": "function SubarrayMaxSum(arr: List<integer>; k: integer): integer;\nbegin\n  if (arr.Count = 0) or (k <= 0) or (k > arr.Count) then\n    Result := 0\n  else\n  begin\n    var maxSum := 0;\n    var windowSum := 0;\n    var windowStart := 0;\n    \n    for var windowEnd := 0 to arr.Count - 1 do\n    begin\n      windowSum := windowSum + arr[windowEnd];\n      \n      if windowEnd >= k - 1 then\n      begin\n        maxSum := Max(maxSum, windowSum);\n        windowSum := windowSum - arr[windowStart];\n        windowStart := windowStart + 1;\n      end;\n    end;\n    \n    Result := maxSum;\n  end;\nend;"
  },
  {
    "instruction": "Write a function that finds the maximum value among a list of integers and returns it.",
    "output": "function GetMaxValue(numbers: List<integer>): integer;\nbegin\n  var maxValue := numbers[0];\n  foreach var number in numbers do\n    if number > maxValue then\n      maxValue := number;\n  Result := maxValue;\nend;"
  },
  {
    "instruction": "Write a function that takes a string as input and returns the number of unique characters in that string.",
    "output": "function UniqueCharCount(s: string): integer;\nbegin\n  var uniqueChars := s.Distinct.ToList;\n  Result := uniqueChars.Count;\nend;"
  },
  {
    "instruction": "Write a function that returns the index of the first occurrence of a substring in a string, or -1 if the substring is not found.",
    "output": "function StrStr(haystack, needle: string): integer;\nbegin\n  if haystack.Contains(needle) then\n    Result := haystack.IndexOf(needle)\n  else\n    Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest substring without repeating characters.",
    "output": "function LongestSubstring(s: string): integer;\nbegin\n  var charMap := new Dictionary<char, integer>;\n  var left := 0;\n  var resultValue := 0;\n  \n  for var right := 0 to s.Length - 1 do\n  begin\n    if charMap.ContainsKey(s[right]) then\n      left := Max(left, charMap[s[right]] + 1);\n    \n    charMap[s[right]] := right;\n    resultValue := Max(resultValue, right - left + 1);\n  end;\n  \n  Result := resultValue;\nend;"
  },
  {
    "instruction": "Write a function to find the kth smallest number in an array using a priority queue. Priority queue class should be implemented for this.",
    "output": "type\n  PriorityQueue<T> = class\n  private\n    data: List<(T, integer)>;\n    \n    procedure Swap(i, j: integer);\n    begin\n      var temp := data[i];\n      data[i] := data[j];\n      data[j] := temp;\n    end;\n    \n    procedure HeapifyUp(index: integer);\n    begin\n      if index = 0 then exit;\n      var parent := (index - 1) div 2;\n      if data[index].Item2 < data[parent].Item2 then\n      begin\n        Swap(index, parent);\n        HeapifyUp(parent);\n      end;\n    end;\n    \n    procedure HeapifyDown(index: integer);\n    begin\n      var left := 2 * index + 1;\n      var right := 2 * index + 2;\n      var smallest := index;\n      \n      if (left < data.Count) and (data[left].Item2 < data[smallest].Item2) then\n        smallest := left;\n      if (right < data.Count) and (data[right].Item2 < data[smallest].Item2) then\n        smallest := right;\n      \n      if smallest <> index then\n      begin\n        Swap(index, smallest);\n        HeapifyDown(smallest);\n      end;\n    end;\n    \n  public\n    constructor;\n    begin\n      data := new List<(T, integer)>;\n    end;\n    \n    procedure Enqueue(item: T; priority: integer);\n    begin\n      data.Add((item, priority));\n      HeapifyUp(data.Count - 1);\n    end;\n    \n    function Dequeue: T;\n    begin\n      if data.Count = 0 then\n        raise new System.InvalidOperationException('Queue is empty');\n      \n      Result := data[0].Item1;\n      data[0] := data[data.Count - 1];\n      data.RemoveAt(data.Count - 1);\n      \n      if data.Count > 0 then\n        HeapifyDown(0);\n    end;\n    \n    function Count: integer;\n    begin\n      Result := data.Count;\n    end;\n  end;\n\nfunction KthSmallestNum(arr: List<integer>; k: integer): integer;\nbegin\n  var heap := new PriorityQueue<integer>;\n  \n  foreach var num in arr do\n    heap.Enqueue(num, num);\n  \n  for var i := 1 to k - 1 do\n    heap.Dequeue;\n  \n  Result := heap.Dequeue;\nend;"
  },
  {
    "instruction": "Write a function to find the n-th Fibonacci number using dynamic programming.",
    "output": "function FibonacciDP(n: integer): integer;\nbegin\n  if n <= 1 then\n    Result := n\n  else\n  begin\n    var fib := new integer[n + 1];\n    fib[1] := 1;\n    for var i := 2 to n do\n      fib[i] := fib[i - 1] + fib[i - 2];\n    Result := fib[n];\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the diagonal order traversal of a given 2D matrix.",
    "output": "function FindDiagonalOrder(mat: List<List<integer>>): List<integer>;\nbegin\n  var sizeRow := mat.Count;\n  var sizeCol := mat[0].Count;\n  var res := new List<integer>;\n  var hashMap := new Dictionary<integer, List<integer>>;\n  \n  for var i := 0 to sizeRow - 1 do\n    for var j := 0 to sizeCol - 1 do\n    begin\n      if not hashMap.ContainsKey(i + j) then\n        hashMap.Add(i + j, new List<integer>);\n      hashMap[i + j].Add(mat[i][j]);\n    end;\n  \n  for var val := 0 to sizeRow + sizeCol - 2 do\n    if val mod 2 = 0 then\n      res.AddRange(IEnumerable&<integer>(hashMap[val]).Reverse)\n    else\n      res.AddRange(hashMap[val]);\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum score of a pair of sightseeing spots in a list. The score of a pair (i, j) is values[i] + values[j] + i - j, where i < j.",
    "output": "function MaxSightseeingScore(values: List<integer>): integer;\nbegin\n  var arr1 := new List<integer>;\n  var arr2 := new List<integer>;\n  \n  arr1.Add(values[0]);\n  \n  for var index := 1 to values.Count - 1 do\n  begin\n    arr1.Add(values[index] + index);\n    arr2.Add(values[index] - index);\n  end;\n  \n  arr1.RemoveAt(arr1.Count - 1);\n  \n  for var index := values.Count - 3 downto 0 do\n    arr2[index] := Max(arr2[index], arr2[index + 1]);\n  \n  var maxim := integer.MinValue;\n  for var index := 0 to values.Count - 2 do\n    maxim := Max(maxim, arr1[index] + arr2[index]);\n  \n  Result := maxim;\nend;"
  },
  {
    "instruction": "Write a function to find the k most frequent elements in a given list of numbers.",
    "output": "function TopKFrequent(nums: List<integer>; k: integer): List<integer>;\nbegin\n  var count := new Dictionary<integer, integer>;\n  \n  foreach var n in nums do\n    if count.ContainsKey(n) then\n      count[n] := count[n] + 1\n    else\n      count.Add(n, 1);\n  \n  var countList := count.ToList;\n  var kElems := countList.OrderByDescending(pair -> pair.Value).Take(k).ToList;\n  var res := kElems.Select(pair -> pair.Key).ToList;\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the number of good pairs in a given array. A pair (i, j) is called good if nums[i] == nums[j] and i < j.",
    "output": "function NumIdenticalPairs(nums: List<integer>): integer;\nbegin\n  var count := 0;\n  for var i := 0 to nums.Count - 1 do\n    for var j := i + 1 to nums.Count - 1 do\n      if nums[i] = nums[j] then\n        count := count + 1;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum sum of a circular subarray in a given list of integers.",
    "output": "function Kadane(arrParam: List<integer>): integer;\nbegin\n  var curSum := arrParam[0];\n  var maxSum := arrParam[0];\n  for var i := 1 to arrParam.Count - 1 do\n  begin\n    curSum := Max(arrParam[i], curSum + arrParam[i]);\n    maxSum := Max(maxSum, curSum);\n  end;\n  Result := maxSum;\nend;\n\nfunction CircularSubarraySum(arr: List<integer>): integer;\nbegin\n  var maxKadane := Kadane(arr);\n  var maxWrap := 0;\n  \n  for var i := 0 to arr.Count - 1 do\n  begin\n    maxWrap := maxWrap + arr[i];\n    arr[i] := -arr[i];\n  end;\n  \n  maxWrap := maxWrap + Kadane(arr);\n  \n  if (maxWrap > maxKadane) and (maxWrap <> 0) then\n    Result := maxWrap\n  else\n    Result := maxKadane;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of all odd numbers within a given range.",
    "output": "function OddSum(startVal, endVal: integer): integer;\nbegin\n  var sumValue := 0;\n  for var num := startVal to endVal do\n    if num mod 2 <> 0 then\n      sumValue := sumValue + num;\n  Result := sumValue;\nend;"
  },
  {
    "instruction": "Write a function to convert a given list of numbers into a linked list.",
    "output": "type\n  ListNode = class\n    val: integer;\n    next: ListNode;\n    \n    constructor(v: integer; n: ListNode := nil);\n    begin\n      val := v;\n      next := n;\n    end;\n  end;\n\nfunction ListToLinkedList(arr: List<integer>): ListNode;\nbegin\n  var head: ListNode := nil;\n  for var i := arr.Count - 1 downto 0 do\n    head := new ListNode(arr[i], head);\n  Result := head;\nend;"
  },
  {
    "instruction": "Write a function to calculate the smallest sum of any contiguous subsequence in the given sequence of numbers.",
    "output": "function MinimumSubArray(nums: List<integer>): integer;\nbegin\n  var minSum := integer.MaxValue;\n  var currentSum := 0;\n  \n  foreach var num in nums do\n  begin\n    currentSum := currentSum + num;\n    minSum := Min(minSum, currentSum);\n    if currentSum > 0 then\n      currentSum := 0;\n  end;\n  \n  Result := minSum;\nend;"
  },
  {
    "instruction": "Write a function that creates a new string by inserting a character at a specified index in the original string.",
    "output": "function InsertCharAtIndex(originalString, charValue: string; index: integer): string;\nbegin\n  Result := originalString.Substring(0, index) + charValue + originalString.Substring(index);\nend;"
  },
  {
    "instruction": "Write a function to find the nth pentagonal number.",
    "output": "function IsPentagonal(n: integer): integer;\nbegin\n  Result := n * (3 * n - 1) div 2;\nend;"
  },
  {
    "instruction": "Write a function to find the count of subarrays with sum equal to 0.",
    "output": "function CountSubarrays(arr: List<integer>): integer;\nbegin\n  var count := 0;\n  var sumValue := 0;\n  var sumMap := new Dictionary<integer, integer>;\n  \n  for var i := 0 to arr.Count - 1 do\n  begin\n    sumValue := sumValue + arr[i];\n    if sumValue = 0 then\n      count := count + 1;\n    \n    if sumMap.ContainsKey(sumValue) then\n    begin\n      count := count + sumMap[sumValue];\n      sumMap[sumValue] := sumMap[sumValue] + 1;\n    end\n    else\n      sumMap.Add(sumValue, 1);\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to count the negative numbers in a sorted matrix.",
    "output": "function Search(row: List<integer>; edge: integer): integer;\nbegin\n  var n := row.Count;\n  if edge = n then\n    Result := edge\n  else\n  begin\n    var l := edge;\n    var r := n - 1;\n    while l <= r do\n    begin\n      var m := l + (r - l) div 2;\n      if row[m] >= 0 then\n        l := m + 1\n      else\n        r := m - 1;\n    end;\n    Result := l;\n  end;\nend;\n\nfunction CountNegativeNumbers(grid: List<List<integer>>): integer;\nbegin\n  var m := grid.Count;\n  var n := grid[0].Count;\n  var edge := 0;\n  var count := 0;\n  \n  for var i := m - 1 downto 0 do\n  begin\n    edge := Search(grid[i], edge);\n    count := count + n - edge;\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find all numbers in the given list that are divisible by 5.",
    "output": "function DivisibleByFive(testList: List<integer>): List<integer>;\nbegin\n  Result := testList.Where(num -> num mod 5 = 0).ToList;\nend;"
  },
  {
    "instruction": "Write a function to find all the numbers less than the given number n that are co-prime to n. Two numbers are co-prime if their greatest common divisor (GCD) is 1.",
    "output": "function GCD(a, b: integer): integer;\nbegin\n  while b <> 0 do\n  begin\n    var temp := b;\n    b := a mod b;\n    a := temp;\n  end;\n  Result := a;\nend;\n\nfunction CoPrimeNumbers(n: integer): List<integer>;\nbegin\n  var res := new List<integer>;\n  \n  for var i := 1 to n - 1 do\n    if GCD(i, n) = 1 then\n      res.Add(i);\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the n-th number that is both a Fibonacci number and a perfect square.",
    "output": "function IsSquare(n: integer): boolean;\nbegin\n  var root := Round(Sqrt(n));\n  Result := root * root = n;\nend;\n\nfunction FindSquareFibonacci(n: integer): integer;\nbegin\n  var a := 0;\n  var b := 1;\n  var count := 0;\n  \n  while True do\n  begin\n    var temp := a;\n    a := b;\n    b := temp + b;\n    \n    if IsSquare(a) then\n    begin\n      count := count + 1;\n      if count = n then\n      begin\n        Result := a;\n        exit;\n      end;\n    end;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to calculate the number of ways to jump to the last step if you are initially at step 0 and can jump 1, 2, or 3 steps at a time.",
    "output": "function WaysToJump(n: integer): integer;\nbegin\n  if n <= 1 then\n    Result := 1\n  else\n  begin\n    var a := 1;\n    var b := 1;\n    var c := 2;\n    \n    for var i := 3 to n do\n    begin\n      var temp := a + b + c;\n      a := b;\n      b := c;\n      c := temp;\n    end;\n    \n    Result := c;\n  end;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns True if all integers in the list are consecutive numbers, otherwise return False.",
    "output": "function ConsecutiveCheck(lst: List<integer>): boolean;\nbegin\n  if lst.Count <= 1 then\n    Result := True\n  else\n  begin\n    var lstSorted := lst.Order.ToList;\n    for var i := 0 to lstSorted.Count - 2 do\n      if lstSorted[i] + 1 <> lstSorted[i + 1] then\n      begin\n        Result := False;\n        exit;\n      end;\n    Result := True;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest substring of repeated characters in a given string.",
    "output": "function LongestRepeatedSubstring(s: string): integer;\nbegin\n  if s.Length = 0 then\n    Result := 0\n  else\n  begin\n    var maxLength := 1;\n    var currentLength := 1;\n    \n    for var i := 1 to s.Length - 1 do\n    begin\n      if s[i] = s[i - 1] then\n      begin\n        currentLength := currentLength + 1;\n        maxLength := Max(maxLength, currentLength);\n      end\n      else\n        currentLength := 1;\n    end;\n    \n    Result := maxLength;\n  end;\nend;"
  },
  {
    "instruction": "Write a function that takes a positive integer and returns the number of digits counted from the right until a digit larger than the rightmost digit is encountered.",
    "output": "function FindLargerDigit(num: integer): integer;\nbegin\n  var rightmost := num mod 10;\n  var count := 0;\n  num := num div 10;\n  \n  while num > 0 do\n  begin\n    count := count + 1;\n    var currentDigit := num mod 10;\n    if currentDigit > rightmost then\n    begin\n      Result := count;\n      exit;\n    end;\n    num := num div 10;\n  end;\n  \n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function that finds the first 'k' prime numbers in an array that are missing. A prime number is a number that has only two distinct positive divisors: 1 and itself.",
    "output": "function IsPrimeNumber(n: integer): boolean;\nbegin\n  if n <= 1 then\n    Result := False\n  else\n  begin\n    for var i := 2 to Round(Sqrt(n)) do\n      if n mod i = 0 then\n      begin\n        Result := False;\n        exit;\n      end;\n    Result := True;\n  end;\nend;\n\nfunction FindFirstKMissingPrimes(nums: List<integer>; k: integer): List<integer>;\nbegin\n  var i := 2;\n  var primeCount := 0;\n  var missingPrimes := new List<integer>;\n  \n  while primeCount < k do\n  begin\n    if (not nums.Contains(i)) and IsPrimeNumber(i) then\n    begin\n      missingPrimes.Add(i);\n      primeCount := primeCount + 1;\n    end;\n    i := i + 1;\n  end;\n  \n  Result := missingPrimes;\nend;"
  },
  {
    "instruction": "Write a function to find the intersection of two given lists.",
    "output": "function IntersectionLists(list1, list2: List<integer>): List<integer>;\nbegin\n  Result := list1.Where(value -> list2.Contains(value)).ToList;\nend;"
  },
  {
    "instruction": "Write a function to find the number of occurrences of an element in a list.",
    "output": "function ElementCount(lst: List<integer>; element: integer): integer;\nbegin\n  Result := lst.Count(x -> x = element);\nend;"
  },
  {
    "instruction": "Write a function to find the character made by adding all the characters of the given string.",
    "output": "function GetChar(strr: string): char;\nbegin\n  var summ := 0;\n  for var i := 0 to strr.Length - 1 do\n    summ := summ + (integer(strr[i]) - integer('a') + 1);\n  \n  if summ mod 26 = 0 then\n    Result := 'z'\n  else\n  begin\n    summ := summ mod 26;\n    Result := char(integer('a') + summ - 1);\n  end;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of positive integers and returns a list of tuples, each tuple containing the product and sum of two consecutive elements from the input list.",
    "output": "function ProductSumTuple(lst: List<integer>): List<(integer, integer)>;\nbegin\n  var res := new List<(integer, integer)>;\n  for var i := 0 to lst.Count - 2 do\n    res.Add((lst[i] * lst[i + 1], lst[i] + lst[i + 1]));\n  Result := res;\nend;"
  },
  {
    "instruction": "Given a positive integer, write a function to find the number of ways it can be translated into letters using the mapping: 0 -> 'a', 1 -> 'b', ..., 25 -> 'z'. A number can be translated if the number formed by its two consecutive digits is less than or equal to 25.",
    "output": "function TranslateNumber(num: integer): integer;\nbegin\n  var numStr := num.ToString;\n  var dp := new integer[numStr.Length + 1];\n  dp[0] := 1;\n  dp[1] := 1;\n  \n  for var i := 2 to numStr.Length do\n  begin\n    if StrToInt(numStr[i - 1].ToString) > 0 then\n      dp[i] := dp[i - 1];\n    \n    var twoDigit := StrToInt(numStr.Substring(i - 2, 2));\n    if (10 <= twoDigit) and (twoDigit <= 25) then\n      dp[i] := dp[i] + dp[i - 2];\n  end;\n  \n  Result := dp[numStr.Length];\nend;"
  },
  {
    "instruction": "Write a function to find the closest number in a sorted list to a given target number. If there are two numbers equally close to the target, return the smaller one.",
    "output": "function FindClosest(nums: List<integer>; target: integer): integer;\nbegin\n  if nums.Count = 0 then\n    Result := 0\n  else\n  begin\n    var start := 0;\n    var endVal := nums.Count - 1;\n    \n    while start + 1 < endVal do\n    begin\n      var mid := (start + endVal) div 2;\n      if nums[mid] = target then\n      begin\n        Result := nums[mid];\n        exit;\n      end\n      else if nums[mid] < target then\n        start := mid\n      else\n        endVal := mid;\n    end;\n    \n    if Abs(nums[start] - target) <= Abs(nums[endVal] - target) then\n      Result := nums[start]\n    else\n      Result := nums[endVal];\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the second smallest unique number in a list. If there is no such number, return nil.",
    "output": "function SecondSmallest(numbers: List<integer>): integer?;\nbegin\n  var uniqueNumbers := numbers.Distinct.ToList;\n  if uniqueNumbers.Count < 2 then\n    Result := nil\n  else\n  begin\n    uniqueNumbers.Sort;\n    Result := uniqueNumbers[1];\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum wealth of an individual. The wealth of an individual is defined as the sum of the wealth in each of their bank accounts. Each individual's wealth is represented as a list of integers, where each integer represents the wealth in a bank account.",
    "output": "function MaxWealth(accounts: List<List<integer>>): integer;\nbegin\n  var maks := 0;\n  for var i := 0 to accounts.Count - 1 do\n  begin\n    var sums := accounts[i].Sum;\n    if sums > maks then\n      maks := sums;\n  end;\n  Result := maks;\nend;"
  },
  {
    "instruction": "Write a function to check if a given list of words forms a valid chain. A word chain is valid if the last character of a word is the same as the first character of the next word. The function should return False if any word breaks this rule or if any word repeats in the list.",
    "output": "function ValidWordChain(words: List<string>): boolean;\nbegin\n  var wordList := new List<string>;\n  \n  for var i := 0 to words.Count - 1 do\n  begin\n    if i = 0 then\n    begin\n      wordList.Add(words[i]);\n      continue;\n    end;\n    \n    if (words[i - 1][words[i - 1].Length - 1] <> words[i][0]) or (wordList.Contains(words[i])) then\n    begin\n      Result := False;\n      exit;\n    end\n    else\n      wordList.Add(words[i]);\n  end;\n  \n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings as input and returns a dictionary where the keys are the strings from the input list and the values are the lengths of those strings. Use list comprehension and dictionary comprehension to solve this problem.",
    "output": "function StrLen(lst: List<string>): Dictionary<string, integer>;\nbegin\n  var res := new Dictionary<string, integer>;\n  foreach var i in lst do\n    res.Add(i, i.Length);\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to check if the given list of strings is a palindrome sequence when concatenated.",
    "output": "function IsPalindromeSequence(words: List<string>): boolean;\nbegin\n  var concatenated := string.Join('', words);\n  Result := concatenated = string.Join('', concatenated.Reverse.ToArray);\nend;"
  },
  {
    "instruction": "Write a function to find the next largest number formed by the digits of the given number.",
    "output": "function NextLargest(n: integer): integer;\nbegin\n  var digits := n.ToString.ToCharArray.ToList;\n  var length := digits.Count;\n  var i := length - 2;\n  \n  while i >= 0 do\n  begin\n    if digits[i] < digits[i + 1] then\n      break;\n    i := i - 1;\n  end;\n  \n  if i < 0 then\n    Result := -1\n  else\n  begin\n    var j := length - 1;\n    while j > i do\n    begin\n      if digits[j] > digits[i] then\n        break;\n      j := j - 1;\n    end;\n    \n    var temp := digits[i];\n    digits[i] := digits[j];\n    digits[j] := temp;\n    \n    var sortedPart := digits.GetRange(i + 1, length - i - 1);\n    sortedPart.Sort;\n    var resultStr := string.Join('', digits.GetRange(0, i + 1)) + string.Join('', sortedPart);\n    Result := StrToInt(resultStr);\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the largest prime number less than a given number.",
    "output": "function IsPrime(num: integer): boolean;\nbegin\n  if num < 2 then\n    Result := False\n  else\n  begin\n    for var i := 2 to Round(Sqrt(num)) do\n      if num mod i = 0 then\n      begin\n        Result := False;\n        exit;\n      end;\n    Result := True;\n  end;\nend;\n\nfunction LargestPrimeLessThan(n: integer): integer;\nbegin\n  var prime := -1;\n  for var i := n - 1 downto 2 do\n    if IsPrime(i) then\n    begin\n      prime := i;\n      break;\n    end;\n  Result := prime;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of the even-valued terms in the Fibonacci sequence whose values do not exceed a given limit n.",
    "output": "function FibSumEven(n: integer): integer;\nbegin\n  var a := 1;\n  var b := 2;\n  var total := 0;\n  \n  while b <= n do\n  begin\n    if b mod 2 = 0 then\n      total := total + b;\n    var temp := a;\n    a := b;\n    b := temp + b;\n  end;\n  \n  Result := total;\nend;"
  },
  {
    "instruction": "Write a function to check if a given graph represented as an adjacency list is a valid tree.",
    "output": "function DFS(graph: Dictionary<integer, List<integer>>; node, parent: integer; var visited: array of boolean): boolean;\nbegin\n  visited[node] := True;\n  \n  if graph.ContainsKey(node) then\n    foreach var neighbor in graph[node] do\n    begin\n      if not visited[neighbor] then\n      begin\n        if not DFS(graph, neighbor, node, visited) then\n        begin\n          Result := False;\n          exit;\n        end;\n      end\n      else if neighbor <> parent then\n      begin\n        Result := False;\n        exit;\n      end;\n    end;\n  \n  Result := True;\nend;\n\nfunction CheckValidTree(n: integer; edges: List<List<integer>>): boolean;\nbegin\n  if (n <= 0) or (edges.Count <> n - 1) then\n    Result := False\n  else\n  begin\n    var graph := new Dictionary<integer, List<integer>>;\n    \n    foreach var edge in edges do\n    begin\n      var u := edge[0];\n      var v := edge[1];\n      \n      if not graph.ContainsKey(u) then\n        graph.Add(u, new List<integer>);\n      if not graph.ContainsKey(v) then\n        graph.Add(v, new List<integer>);\n        \n      graph[u].Add(v);\n      graph[v].Add(u);\n    end;\n    \n    var visited := ArrFill(n, False);\n    \n    if not DFS(graph, 0, -1, visited) then\n      Result := False\n    else\n    begin\n      foreach var v in visited do\n        if not v then\n        begin\n          Result := False;\n          exit;\n        end;\n      Result := True;\n    end;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of platforms required at the railway station so that no train waits.",
    "output": "function MinimumPlatforms(arrivals, departures: List<integer>): integer;\nbegin\n  arrivals.Sort;\n  departures.Sort;\n  var i := 1;\n  var j := 0;\n  var plat := 1;\n  var maxVal := 1;\n  \n  while (i < arrivals.Count) and (j < departures.Count) do\n  begin\n    if arrivals[i] <= departures[j] then\n    begin\n      plat := plat + 1;\n      i := i + 1;\n    end\n    else\n    begin\n      plat := plat - 1;\n      j := j + 1;\n    end;\n    \n    if plat > maxVal then\n      maxVal := plat;\n  end;\n  \n  Result := maxVal;\nend;"
  },
  {
    "instruction": "Write a function to group anagrams from a list of strings.",
    "output": "function GroupAna(strs: List<string>): List<List<string>>;\nbegin\n  var res := new Dictionary<string, List<string>>;\n  \n  foreach var strVal in strs do\n  begin\n    var count := new integer[26];\n    foreach var c in strVal do\n      count[integer(c) - integer('a')] := count[integer(c) - integer('a')] + 1;\n    \n    var key := string.Join(',', count);\n    \n    if res.ContainsKey(key) then\n      res[key].Add(strVal)\n    else\n    begin\n      res.Add(key, new List<string>);\n      res[key].Add(strVal);\n    end;\n  end;\n  \n  Result := res.Values.ToList;\nend;"
  },
  {
    "instruction": "Write a function to find the most frequent characters in a string and return them as a list. If there are multiple characters with the same highest frequency, return all of them in the order they appear in the string.",
    "output": "function FrequentChars(s: string): List<char>;\nbegin\n  var counter := new Dictionary<char, integer>;\n  \n  foreach var char in s do\n    if counter.ContainsKey(char) then\n      counter[char] := counter[char] + 1\n    else\n      counter.Add(char, 1);\n  \n  var maxFreq := counter.Values.Max;\n  var res := new List<char>;\n  \n  foreach var char in s do\n    if (counter[char] = maxFreq) and (not res.Contains(char)) then\n      res.Add(char);\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns a list of tuples. Each tuple should contain the original integer and the string \"Odd\" if the integer is odd, or the string \"Even\" if the integer is even.",
    "output": "function OddEven(numbers: List<integer>): List<(integer, string)>;\nbegin\n  var res := new List<(integer, string)>;\n  foreach var num in numbers do\n    if num mod 2 = 0 then\n      res.Add((num, 'Even'))\n    else\n      res.Add((num, 'Odd'));\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns a new list with each integer reversed.",
    "output": "function ReverseDigits(nums: List<integer>): List<integer>;\nbegin\n  var reversedNums := new List<integer>;\n  foreach var num in nums do\n  begin\n    var reversedNum := StrToInt(string.Join('', num.ToString.Reverse.ToArray));\n    reversedNums.Add(reversedNum);\n  end;\n  Result := reversedNums;\nend;"
  },
  {
    "instruction": "Write a function to find the square of a number.",
    "output": "function Square(n: integer): integer;\nbegin\n  Result := n * n;\nend;"
  },
  {
    "instruction": "Write a function to find the longest arithmetic subsequence in a list of integers.",
    "output": "function LongestArithSeq(nums: List<integer>): integer;\nbegin\n  var arr := new Dictionary<(integer, integer), integer>;\n  var n := nums.Count;\n  var maxLength := 0;\n\n  for var i := 0 to n - 1 do\n    for var j := i + 1 to n - 1 do\n    begin\n      var diff := nums[j] - nums[i];\n      var key := (j, diff);\n      \n      if arr.ContainsKey((i, diff)) then\n        arr[key] := arr[(i, diff)] + 1\n      else\n        arr[key] := 2;\n        \n      maxLength := Max(maxLength, arr[key]);\n    end;\n\n  Result := maxLength;\nend;"
  },
  {
    "instruction": "Write a function to check if a given string is a valid parenthesis sequence or not. A valid parenthesis sequence is one where every opening parenthesis '(' has a corresponding closing parenthesis ')' and they are properly nested.",
    "output": "function ValidParenthesisSequence(s: string): boolean;\nbegin\n  var stk := 0;\n  foreach var ss in s do\n  begin\n    if ss = '(' then\n      stk := stk + 1\n    else if (ss = ')') and (stk = 0) then\n    begin\n      Result := False;\n      exit;\n    end\n    else\n      stk := stk - 1;\n  end;\n  \n  if stk <> 0 then\n    Result := False\n  else\n    Result := True;\nend;"
  },
  {
    "instruction": "Write a function to generate all possible combinations of strings that can be formed using a given set of characters, where the length of the strings is also given.",
    "output": "procedure GenerateCombinations(lengthVal: integer; characters: string; current: string; var res: List<string>);\nbegin\n  if current.Length = lengthVal then\n  begin\n    res.Add(current);\n    exit;\n  end;\n  \n  foreach var ch in characters do\n    GenerateCombinations(lengthVal, characters, current + ch, res);\nend;\n\nfunction StringCombinations(lengthVal: integer; characters: string): List<string>;\nbegin\n  var res := new List<string>;\n  GenerateCombinations(lengthVal, characters, '', res);\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to count the number of odd numbers in a given list.",
    "output": "function CountOdd(l: List<integer>): integer;\nbegin\n  var count := 0;\n  foreach var i in l do\n    if i mod 2 <> 0 then\n      count := count + 1;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of digits and increments the number by one. The digits are stored such that the most significant digit is at the head of the list. You may assume the integer does not contain any leading zero, except the number 0 itself.",
    "output": "function IncrementNumber(digits: List<integer>): List<integer>;\nbegin\n  for var i := digits.Count - 1 downto 0 do\n  begin\n    if digits[i] = 9 then\n    begin\n      digits[i] := 0;\n      if i = 0 then\n        digits.Insert(0, 1);\n    end\n    else\n    begin\n      digits[i] := digits[i] + 1;\n      break;\n    end;\n  end;\n  Result := digits;\nend;"
  },
  {
    "instruction": "Write a function to find the index of the smallest repeating substring in a given string.",
    "output": "function SmallestRepeatingSubstringIndex(s: string): integer;\nbegin\n  var n := s.Length;\n  for var i := 1 to n div 2 do\n  begin\n    if n mod i = 0 then\n    begin\n      var pattern := s.Substring(0, i);\n      var repeated := '';\n      for var j := 1 to n div i do\n        repeated := repeated + pattern;\n      \n      if repeated = s then\n      begin\n        Result := i;\n        exit;\n      end;\n    end;\n  end;\n  Result := n;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum element in a rotated sorted array that may contain duplicates.",
    "output": "function FindMin(nums: List<integer>): integer;\nbegin\n  var l := 0;\n  var r := nums.Count - 1;\n  \n  while l < r do\n  begin\n    var mid := (l + r) div 2;\n    if nums[mid] > nums[r] then\n      l := mid + 1\n    else if nums[mid] < nums[r] then\n      r := mid\n    else\n      r := r - 1;\n  end;\n  \n  Result := nums[l];\nend;"
  },
  {
    "instruction": "Write a function to check if a set of points lie on a straight line.",
    "output": "function CheckStraightLine(coordinates: List<List<integer>>): boolean;\nbegin\n  if coordinates.Count <= 2 then\n    Result := True\n  else\n  begin\n    var (x0, y0) := (coordinates[0][0], coordinates[0][1]);\n    var (x1, y1) := (coordinates[1][0], coordinates[1][1]);\n    \n    for var i := 2 to coordinates.Count - 1 do\n    begin\n      var (x, y) := (coordinates[i][0], coordinates[i][1]);\n      if (x0 - x1) * (y1 - y) <> (x1 - x) * (y0 - y1) then\n      begin\n        Result := False;\n        exit;\n      end;\n    end;\n    Result := True;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to generate all possible strings where exactly two adjacent characters are swapped. Ensure that the function does not return any duplicate strings.",
    "output": "function GenerateSwaps(s: string): List<string>;\nbegin\n  if s.Length <= 1 then\n  begin\n    Result := new List<string>;\n    exit;\n  end;\n  \n  var swappedStrings := new List<string>;\n  for var i := 0 to s.Length - 2 do\n  begin\n    var swapped := s.ToCharArray;\n    var temp := swapped[i];\n    swapped[i] := swapped[i + 1];\n    swapped[i + 1] := temp;\n    swappedStrings.Add(string.Join('', swapped));\n  end;\n  \n  Result := swappedStrings.Distinct.ToList;\nend;"
  },
  {
    "instruction": "Write a function to calculate the minimum steps required to convert a string to palindrome by only deleting characters.",
    "output": "function LongestPalindromicSubsequence(strVal: string): integer;\nbegin\n  var n := strVal.Length;\n  var dp := new integer[n, n];\n  \n  for var i := n - 1 downto 0 do\n  begin\n    dp[i, i] := 1;\n    for var j := i + 1 to n - 1 do\n    begin\n      if strVal[i] = strVal[j] then\n        dp[i, j] := dp[i + 1, j - 1] + 2\n      else\n        dp[i, j] := Max(dp[i + 1, j], dp[i, j - 1]);\n    end;\n  end;\n  Result := dp[0, n - 1];\nend;\n\nfunction MinStepsPalindrome(s: string): integer;\nbegin\n  var lps := LongestPalindromicSubsequence(s);\n  Result := s.Length - lps;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the shortest substring that can be repeated to form the original string.",
    "output": "function FindRepeatedSubstringLength(s: string): integer;\nbegin\n  var length := s.Length;\n  for var i := 1 to length div 2 do\n  begin\n    if length mod i = 0 then\n    begin\n      var pattern := s.Substring(0, i);\n      var repeated := '';\n      for var j := 1 to length div i do\n        repeated := repeated + pattern;\n      \n      if repeated = s then\n      begin\n        Result := i;\n        exit;\n      end;\n    end;\n  end;\n  Result := length;\nend;"
  },
  {
    "instruction": "Write a function to reverse the elements of a sublist within a given list. The sublist is defined by the start and end indices provided as arguments to the function.",
    "output": "function ReverseSublist(lst: List<integer>; startIdx, endIdx: integer): List<integer>;\nbegin\n  if startIdx >= endIdx then\n    Result := lst\n  else\n  begin\n    var sublist := lst.GetRange(startIdx, endIdx - startIdx + 1);\n    sublist.Reverse;\n    \n    for var i := 0 to sublist.Count - 1 do\n      lst[startIdx + i] := sublist[i];\n    \n    Result := lst;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to check if a given string is a rotation of a palindrome.",
    "output": "function IsPalindrome(s: string): boolean;\nbegin\n  Result := s = string.Join('', s.Reverse.ToArray);\nend;\n\nfunction IsRotationOfPalindrome(s: string): boolean;\nbegin\n  for var i := 0 to s.Length - 1 do\n  begin\n    var rotated := s.Substring(i) + s.Substring(0, i);\n    if IsPalindrome(rotated) then\n    begin\n      Result := True;\n      exit;\n    end;\n  end;\n  Result := False;\nend;"
  },
  {
    "instruction": "Write a function that determines whether it's possible to make change for a given amount using a given set of coin denominations. Assume an unlimited supply of coins for each denomination.",
    "output": "function CanMakeChange(targetAmount: integer; denominations: List<integer>): boolean;\nbegin\n  var dp := ArrFill(targetAmount + 1, False);\n  dp[0] := True;\n  \n  for var amount := 1 to targetAmount do\n    foreach var coin in denominations do\n      if (coin <= amount) and dp[amount - coin] then\n      begin\n        dp[amount] := True;\n        break;\n      end;\n  \n  Result := dp[targetAmount];\nend;"
  },
  {
    "instruction": "Write a function to find the maximum profit that can be achieved from trading stocks given a list of prices. You are only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock).",
    "output": "function MaxStockProfit(prices: List<integer>): integer;\nbegin\n  if prices.Count = 0 then\n    Result := 0\n  else\n  begin\n    var minPrice := integer.MaxValue;\n    var maxProfit := 0;\n    \n    foreach var price in prices do\n    begin\n      minPrice := Min(minPrice, price);\n      var profit := price - minPrice;\n      maxProfit := Max(maxProfit, profit);\n    end;\n    \n    Result := maxProfit;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the median of three given numbers. The function should take three integer arguments and return the median value among them.",
    "output": "function FindMedianOfThree(x, y, z: integer): integer;\nbegin\n  var numbers := new List<integer>;\n  numbers.Add(x);\n  numbers.Add(y);\n  numbers.Add(z);\n  numbers.Sort;\n  Result := numbers[1];\nend;"
  },
  {
    "instruction": "Write a function to find the number of unique binary search trees (BSTs) that store values 1...n.",
    "output": "function NumBST(n: integer): integer;\nbegin\n  if (n = 0) or (n = 1) then\n    Result := 1\n  else\n  begin\n    var num := 0;\n    for var i := 1 to n do\n    begin\n      var numLeftSubtrees := NumBST(i - 1);\n      var numRightSubtrees := NumBST(n - i);\n      num := num + numLeftSubtrees * numRightSubtrees;\n    end;\n    Result := num;\n  end;\nend;"
  },
  {
    "instruction": "Write a function that converts a given number to its English word representation. The function should handle numbers from 0 to 999,999,999,999 (0 to 999 billion).",
    "output": "function Words(n: integer; to19: List<string>; tens: List<string>): string;\nbegin\n  if n < 20 then\n    Result := to19[n]\n  else if n < 100 then\n  begin\n    if n mod 10 = 0 then\n      Result := tens[n div 10 - 2]\n    else\n      Result := tens[n div 10 - 2] + ' ' + to19[n mod 10];\n  end\n  else if n < 1000 then\n  begin\n    if n mod 100 = 0 then\n      Result := to19[n div 100] + ' Hundred'\n    else\n      Result := to19[n div 100] + ' Hundred ' + Words(n mod 100, to19, tens);\n  end\n  else if n < 1000000 then\n  begin\n    if n mod 1000 = 0 then\n      Result := Words(n div 1000, to19, tens) + ' Thousand'\n    else\n      Result := Words(n div 1000, to19, tens) + ' Thousand ' + Words(n mod 1000, to19, tens);\n  end\n  else if n < 1000000000 then\n  begin\n    if n mod 1000000 = 0 then\n      Result := Words(n div 1000000, to19, tens) + ' Million'\n    else\n      Result := Words(n div 1000000, to19, tens) + ' Million ' + Words(n mod 1000000, to19, tens);\n  end\n  else\n  begin\n    if n mod 1000000000 = 0 then\n      Result := Words(n div 1000000000, to19, tens) + ' Billion'\n    else\n      Result := Words(n div 1000000000, to19, tens) + ' Billion ' + Words(n mod 1000000000, to19, tens);\n  end;\nend;\n\nfunction NumberToWords(num: integer): string;\nbegin\n  var to19 := 'Zero One Two Three Four Five Six Seven Eight Nine Ten Eleven Twelve Thirteen Fourteen Fifteen Sixteen Seventeen Eighteen Nineteen'.Split(' ').ToList;\n  var tens := 'Twenty Thirty Forty Fifty Sixty Seventy Eighty Ninety'.Split(' ').ToList;\n  Result := Words(num, to19, tens);\nend;"
  },
  {
    "instruction": "Write a function to find the number of unique anagram pairs in a given list of words.",
    "output": "function AnagramPairs(words: List<string>): integer;\nbegin\n  var anagramGroups := new Dictionary<string, List<string>>;\n  \n  foreach var word in words do\n  begin\n    var sortedWord := string.Join('', word.ToCharArray.Order.ToArray);\n    \n    if anagramGroups.ContainsKey(sortedWord) then\n      anagramGroups[sortedWord].Add(word)\n    else\n    begin\n      anagramGroups.Add(sortedWord, new List<string>);\n      anagramGroups[sortedWord].Add(word);\n    end;\n  end;\n  \n  var count := 0;\n  foreach var group in anagramGroups.Values do\n    if group.Count > 1 then\n      count := count + 1;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to return the smallest integer that is greater than a given number and is a multiple of 3.",
    "output": "function NextMultipleOfThree(n: integer): integer;\nbegin\n  Result := ((n div 3) + 1) * 3;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns True if the list contains a 0 anywhere between two 6's (inclusive).",
    "output": "function ContainsZeroBetweenSixes(lst: List<integer>): boolean;\nbegin\n  var foundSix := False;\n  foreach var num in lst do\n  begin\n    if num = 6 then\n      foundSix := True\n    else if (num = 0) and foundSix then\n    begin\n      Result := True;\n      exit;\n    end\n    else if (num <> 6) and foundSix then\n      foundSix := False;\n  end;\n  Result := False;\nend;"
  },
  {
    "instruction": "Write a function to check if a given string is a valid IPv4 address.",
    "output": "function CheckIPv4(ip: string): boolean;\nbegin\n  var parts := ip.Split('.').ToList;\n  if parts.Count <> 4 then\n    Result := False\n  else\n  begin\n    foreach var part in parts do\n    begin\n      if not part.All(ch -> ch.IsDigit) then\n      begin\n        Result := False;\n        exit;\n      end;\n      var num := StrToInt(part);\n      if (num < 0) or (num > 255) then\n      begin\n        Result := False;\n        exit;\n      end;\n    end;\n    Result := True;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the number of subarrays with sum equal to k.",
    "output": "function SubarraysWithSumK(arr: List<integer>; k: integer): integer;\nbegin\n  var count := 0;\n  var currentSum := 0;\n  var prefixSums := new Dictionary<integer, integer>;\n  prefixSums.Add(0, 1);\n  \n  foreach var num in arr do\n  begin\n    currentSum := currentSum + num;\n    if prefixSums.ContainsKey(currentSum - k) then\n      count := count + prefixSums[currentSum - k];\n    \n    if prefixSums.ContainsKey(currentSum) then\n      prefixSums[currentSum] := prefixSums[currentSum] + 1\n    else\n      prefixSums.Add(currentSum, 1);\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest non-repeated element in a given array.",
    "output": "function FindSmallestNonrepeated(arr: List<integer>): integer;\nbegin\n  var hashTable := new Dictionary<integer, integer>;\n  \n  foreach var num in arr do\n    if hashTable.ContainsKey(num) then\n      hashTable[num] := hashTable[num] + 1\n    else\n      hashTable.Add(num, 1);\n  \n  var smallest := integer.MaxValue;\n  foreach var num in arr do\n    if (hashTable[num] = 1) and (num < smallest) then\n      smallest := num;\n  \n  if smallest = integer.MaxValue then\n    Result := -1\n  else\n    Result := smallest;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns a new list where each element is replaced by its cube if it is positive or its square if it is negative.",
    "output": "function ModifyNumbers(numbers: List<integer>): List<integer>;\nbegin\n  var modifiedNumbers := new List<integer>;\n  foreach var num in numbers do\n    if num > 0 then\n      modifiedNumbers.Add(num * num * num)\n    else\n      modifiedNumbers.Add(num * num);\n  Result := modifiedNumbers;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest positive integer that cannot be represented as sum of any subset of a given list of positive integers.",
    "output": "function SmallestMissing(arr: List<integer>): integer;\nbegin\n  arr.Sort;\n  var smallestMissing := 1;\n  foreach var i in arr do\n  begin\n    if i > smallestMissing then\n    begin\n      Result := smallestMissing;\n      exit;\n    end;\n    smallestMissing := smallestMissing + i;\n  end;\n  Result := smallestMissing;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of tuples, each tuple contains two strings. The function should return a dictionary where each key is the first string from the tuples and the value is a list of the second strings from the tuples that have the same first string.",
    "output": "function GroupByFirst(tuplesList: List<(string, string)>): Dictionary<string, List<string>>;\nbegin\n  var res := new Dictionary<string, List<string>>;\n  foreach var tupleItem in tuplesList do\n  begin\n    if res.ContainsKey(tupleItem.Item1) then\n      res[tupleItem.Item1].Add(tupleItem.Item2)\n    else\n    begin\n      res.Add(tupleItem.Item1, new List<string>);\n      res[tupleItem.Item1].Add(tupleItem.Item2);\n    end;\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum product of three numbers in a given array.",
    "output": "function FindMaxProductThree(nums: List<integer>): integer;\nbegin\n  nums.Sort;\n  var product1 := nums[0] * nums[1] * nums[nums.Count - 1];\n  var product2 := nums[nums.Count - 1] * nums[nums.Count - 2] * nums[nums.Count - 3];\n  Result := Max(product1, product2);\nend;"
  },
  {
    "instruction": "Write a function to find the number of unique binary search trees that can be made with a given number of nodes.",
    "output": "function CountUniqueBST(n: integer): integer;\nbegin\n  if n = 0 then\n    Result := 1\n  else\n  begin\n    var dp := new integer[n + 1];\n    dp[0] := 1;\n    dp[1] := 1;\n    for var i := 2 to n do\n      for var j := 0 to i - 1 do\n        dp[i] := dp[i] + dp[j] * dp[i - j - 1];\n    Result := dp[n];\n  end;\nend;"
  },
  {
    "instruction": "Write a function that checks if a given string is a valid license plate. A valid license plate must satisfy the following conditions:\n- It must be at least 2 characters and at most 6 characters in length.\n- It must start with two letters.\n- It can contain numbers after the letters, but not zeros as the first digit.\n- It cannot end with a letter if it contains any numbers.\n- It cannot contain any special characters like spaces, periods, or commas.",
    "output": "function IsValidLicensePlate(licensePlate: string): boolean;\nbegin\n  if (licensePlate.Length < 2) or (licensePlate.Length > 6) then\n    Result := False\n  else if not (licensePlate[0].IsLetter and licensePlate[1].IsLetter) then\n    Result := False\n  else if licensePlate.Any(ch -> not char.IsLetterOrDigit(ch)) then\n    Result := False\n  else\n  begin\n    var hasNumbers := false;\n    for var i := 2 to licensePlate.Length - 1 do\n    begin\n      if licensePlate[i].IsDigit then\n      begin\n        hasNumbers := true;\n        if (i = 2) and (licensePlate[i] = '0') then\n        begin\n          Result := False;\n          exit;\n        end;\n      end;\n    end;\n    \n    if hasNumbers and licensePlate[licensePlate.Length - 1].IsLetter then\n      Result := False\n    else\n      Result := True;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest bitonic subsequence in a given array. A bitonic subsequence is a sequence of numbers that first increases and then decreases.",
    "output": "function FindLongestBitonicSubsequence(arr: List<integer>): integer;\nbegin\n  var n := arr.Count;\n  var inc := new integer[n];\n  var dec := new integer[n];\n  \n  for var i := 0 to n - 1 do\n  begin\n    inc[i] := 1;\n    dec[i] := 1;\n  end;\n  \n  for var i := 1 to n - 1 do\n    for var j := 0 to i - 1 do\n      if (arr[i] > arr[j]) and (inc[i] < inc[j] + 1) then\n        inc[i] := inc[j] + 1;\n  \n  for var i := n - 2 downto 0 do\n    for var j := n - 1 downto i + 1 do\n      if (arr[i] > arr[j]) and (dec[i] < dec[j] + 1) then\n        dec[i] := dec[j] + 1;\n  \n  var maxLength := 0;\n  for var i := 0 to n - 1 do\n    maxLength := Max(maxLength, inc[i] + dec[i] - 1);\n  \n  Result := maxLength;\nend;"
  },
  {
    "instruction": "Write a function to find the first index of an element in a list that is greater than a given threshold.",
    "output": "function FirstIndexGreaterThan(arr: List<integer>; threshold: integer): integer;\nbegin\n  for var i := 0 to arr.Count - 1 do\n    if arr[i] > threshold then\n    begin\n      Result := i;\n      exit;\n    end;\n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to find all unique permutations of a given list of numbers, including duplicates.",
    "output": "procedure GeneratePermutations(current: List<integer>; remaining: List<integer>; var res: List<List<integer>>);\nbegin\n  if remaining.Count = 0 then\n  begin\n    if not res.Any(lst -> lst.SequenceEqual(current)) then\n      res.Add(new List<integer>(current));\n    exit;\n  end;\n  \n  for var i := 0 to remaining.Count - 1 do\n  begin\n    var newCurrent := new List<integer>(current);\n    newCurrent.Add(remaining[i]);\n    var newRemaining := new List<integer>(remaining);\n    newRemaining.RemoveAt(i);\n    GeneratePermutations(newCurrent, newRemaining, res);\n  end;\nend;\n\nfunction FindUniquePermutations(nums: List<integer>): List<List<integer>>;\nbegin\n  var res := new List<List<integer>>;\n  GeneratePermutations(new List<integer>, nums, res);\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the length of longest common subsequence in two strings.",
    "output": "function LCS(X, Y: string): integer;\nbegin\n  var m := X.Length;\n  var n := Y.Length;\n  var L := new integer[m + 1, n + 1];\n  \n  for var i := 0 to m do\n  begin\n    for var j := 0 to n do\n    begin\n      if (i = 0) or (j = 0) then\n        L[i, j] := 0\n      else if X[i - 1] = Y[j - 1] then\n        L[i, j] := L[i - 1, j - 1] + 1\n      else\n        L[i, j] := Max(L[i - 1, j], L[i, j - 1]);\n    end;\n  end;\n  \n  Result := L[m, n];\nend;"
  },
  {
    "instruction": "Write a function to find the element that is repeated N times in an array A of size 2N, where there are N+1 unique elements.",
    "output": "function RepeatedElement(A: List<integer>): integer;\nbegin\n  var charDict := new Dictionary<integer, boolean>;\n  foreach var num in A do\n  begin\n    if charDict.ContainsKey(num) then\n    begin\n      Result := num;\n      exit;\n    end\n    else\n      charDict.Add(num, True);\n  end;\n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to find the largest continuous sum in a given array.",
    "output": "function FindLargestContinuousSum(arr: List<integer>): integer;\nbegin\n  if arr.Count = 0 then\n    Result := 0\n  else\n  begin\n    var maxSoFar := arr[0];\n    var maxEndingHere := arr[0];\n    \n    for var i := 1 to arr.Count - 1 do\n    begin\n      maxEndingHere := Max(arr[i], maxEndingHere + arr[i]);\n      maxSoFar := Max(maxSoFar, maxEndingHere);\n    end;\n    \n    Result := maxSoFar;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest subsequence of equal elements in a given list of integers.",
    "output": "function LongestEqualSubsequence(arr: List<integer>): integer;\nbegin\n  if arr.Count = 0 then\n    Result := 0\n  else\n  begin\n    var maxLength := 1;\n    var currentLength := 1;\n    \n    for var i := 1 to arr.Count - 1 do\n    begin\n      if arr[i] = arr[i - 1] then\n      begin\n        currentLength := currentLength + 1;\n        maxLength := Max(maxLength, currentLength);\n      end\n      else\n        currentLength := 1;\n    end;\n    \n    Result := maxLength;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the two numbers in the list that add up to a target number.",
    "output": "function FindTwoNumbers(nums: List<integer>; target: integer): List<integer>;\nbegin\n  var numDict := new Dictionary<integer, integer>;\n  for var i := 0 to nums.Count - 1 do\n  begin\n    var complement := target - nums[i];\n    if numDict.ContainsKey(complement) then\n    begin\n      Result := new List<integer>;\n      Result.Add(numDict[complement]);\n      Result.Add(i);\n      exit;\n    end;\n    numDict[nums[i]] := i;\n  end;\n  Result := new List<integer>;\nend;"
  },
  {
    "instruction": "Write a function to find the largest time for a given list of digits that can make hours and minutes. The time format should be HH:MM. If no valid time can be created, return an empty string.",
    "output": "function FindLargestTime(arr: List<integer>): string;\nbegin\n  var maxVal := -1;\n  var ans := '';\n  \n  for var i := 0 to arr.Count - 1 do\n    for var j := 0 to arr.Count - 1 do\n      for var k := 0 to arr.Count - 1 do\n        for var l := 0 to arr.Count - 1 do\n        begin\n          if (i = j) or (i = k) or (i = l) or (j = k) or (j = l) or (k = l) then\n            continue;\n          \n          var hour := arr[i] * 10 + arr[j];\n          var minute := arr[k] * 10 + arr[l];\n          \n          if (hour >= 0) and (hour <= 23) and (minute >= 0) and (minute <= 59) then\n          begin\n            var time := hour * 60 + minute;\n            if time > maxVal then\n            begin\n              maxVal := time;\n              ans := hour.ToString.PadLeft(2, '0') + ':' + minute.ToString.PadLeft(2, '0');\n            end;\n          end;\n        end;\n  \n  Result := ans;\nend;"
  },
  {
    "instruction": "Write a function to convert a list of characters into a string, but with a twist. The function should also reverse the order of the characters in the resulting string. Additionally, the function should ignore any non-alphabetic characters in the input list.",
    "output": "function ReverseAndConvert(charList: List<char>): string;\nbegin\n  var filteredList := charList.Where(ch -> ch.IsLetter).ToList;\n  filteredList.Reverse;\n  Result := string.Join('', filteredList);\nend;"
  },
  {
    "instruction": "Define a function `findMissingNumber` that takes a list of unique integers from 0 to n with exactly one number missing. The function should return the missing number.",
    "output": "function FindMissingNumber(nums: List<integer>): integer;\nbegin\n  var n := nums.Count;\n  var total := n * (n + 1) div 2;\n  var sumOfNums := nums.Sum;\n  Result := total - sumOfNums;\nend;"
  },
  {
    "instruction": "Write a function to find the product of the largest and smallest value in a given array.",
    "output": "function BigProduct(nums: List<integer>): integer;\nbegin\n  if nums.Count = 0 then\n    Result := 0\n  else\n  begin\n    var minnum := nums.Min;\n    var maxnum := nums.Max;\n    Result := minnum * maxnum;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to check if the given sequence of brackets is balanced or not. A sequence of brackets is called balanced if for every opening bracket there is a corresponding closing bracket and they are correctly nested.",
    "output": "function CheckBrackets(s: string): boolean;\nbegin\n  var stack := new Stack<char>;\n  var mapping := new Dictionary<char, char>;\n  mapping.Add(')', '(');\n  mapping.Add('}', '{');\n  mapping.Add(']', '[');\n\n  foreach var char in s do\n  begin\n    if mapping.ContainsValue(char) then\n      stack.Push(char)\n    else if mapping.ContainsKey(char) then\n    begin\n      if (stack.Count = 0) or (stack.Peek() <> mapping[char]) then\n      begin\n        Result := False;\n        exit;\n      end;\n      stack.Pop;\n    end;\n  end;\n\n  Result := stack.Count = 0;\nend;"
  },
  {
    "instruction": "Write a function to find the largest number in a list of lists.",
    "output": "function LargestInLists(lists: List<List<integer>>): integer;\nbegin\n  var maxVal := integer.MinValue;\n  foreach var lst in lists do\n  begin\n    var currentMax := lst.Max;\n    if currentMax > maxVal then\n      maxVal := currentMax;\n  end;\n  Result := maxVal;\nend;"
  },
  {
    "instruction": "Write a function that will return the index of the first occurrence of a character in a string. If the character is not found, return -1.",
    "output": "function FindCharIndex(strVal: string; charVal: char): integer;\nbegin\n  var index := strVal.IndexOf(charVal);\n  if index >= 0 then\n    Result := index\n  else\n    Result := -1;\nend;"
  },
  {
    "instruction": "Write a function that takes a list as input and returns the list with each element repeated twice, except for the last element which is only repeated once. If the input list is empty, return an empty list.",
    "output": "function DoubleListExceptLast(lst: List<integer>): List<integer>;\nbegin\n  if lst.Count = 0 then\n  begin\n    Result := new List<integer>;\n    exit;\n  end;\n  \n  if lst.Count = 1 then\n  begin\n    Result := new List<integer>;\n    Result.Add(lst[0]);\n    Result.Add(lst[0]);\n    exit;\n  end;\n  \n  var resultList := new List<integer>;\n  for var i := 0 to lst.Count - 2 do\n  begin\n    resultList.Add(lst[i]);\n    resultList.Add(lst[i]);\n  end;\n  resultList.Add(lst[lst.Count - 1]);\n  resultList.Add(lst[lst.Count - 1]);\n  \n  Result := resultList;\nend;"
  },
  {
    "instruction": "Write a function to find the number of substrings where all characters are the same.",
    "output": "function CountSameCharSubstrings(s: string): integer;\nbegin\n  var count := 0;\n  var i := 0;\n  \n  while i < s.Length do\n  begin\n    var j := i;\n    while (j < s.Length) and (s[j] = s[i]) do\n      j := j + 1;\n    \n    var length := j - i;\n    count := count + (length * (length + 1)) div 2;\n    i := j;\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to rotate a matrix clockwise by 90 degrees.",
    "output": "function RotateMatrix(mat: List<List<integer>>): List<List<integer>>;\nbegin\n  var n := mat.Count;\n  var res := new List<List<integer>>;\n  \n  for var i := 0 to n - 1 do\n  begin\n    res.Add(new List<integer>);\n    for var j := 0 to n - 1 do\n      res[i].Add(0);\n  end;\n  \n  for var i := 0 to n - 1 do\n    for var j := 0 to n - 1 do\n      res[j][n - 1 - i] := mat[i][j];\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function that finds the longest common prefix among a list of strings.",
    "output": "function FindLongestPrefix(strs: List<string>): string;\nbegin\n  if strs.Count = 0 then\n    Result := ''\n  else\n  begin\n    var shortest := strs.OrderBy(s -> s.Length).First;\n    \n    for var i := 0 to shortest.Length - 1 do\n    begin\n      var currentChar := shortest[i];\n      foreach var other in strs do\n        if other[i] <> currentChar then\n        begin\n          Result := shortest.Substring(0, i);\n          exit;\n        end;\n    end;\n    \n    Result := shortest;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest number that can be formed by removing exactly k digits from the given number.",
    "output": "function RemoveKDigits(num: string; k: integer): string;\nbegin\n  var res := new List<char>;\n  \n  foreach var n in num do\n  begin\n    while (res.Count > 0) and (k > 0) and (res[res.Count - 1] > n) do\n    begin\n      res.RemoveAt(res.Count - 1);\n      k := k - 1;\n    end;\n    res.Add(n);\n  end;\n  \n  while k > 0 do\n  begin\n    res.RemoveAt(res.Count - 1);\n    k := k - 1;\n  end;\n  \n  var resultStr := string.Join('', res).TrimStart('0');\n  if resultStr = '' then\n    Result := '0'\n  else\n    Result := resultStr;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest positive integer that cannot be represented as sum of any subset of a given array.",
    "output": "function SmallestMissingPositiveSum(arr: List<integer>): integer;\nbegin\n  arr.Sort;\n  var smallestMissing := 1;\n  foreach var num in arr do\n  begin\n    if num <= smallestMissing then\n      smallestMissing := smallestMissing + num\n    else\n      break;\n  end;\n  Result := smallestMissing;\nend;"
  },
  {
    "instruction": "Write a function to extract the digits from a given number and return them as a list.",
    "output": "function ExtractDigits(num: integer): List<integer>;\nbegin\n  var digits := new List<integer>;\n  var numStr := num.ToString;\n  foreach var digitChar in numStr do\n    digits.Add(StrToInt(digitChar.ToString));\n  Result := digits;\nend;"
  },
  {
    "instruction": "Write a function to find the most frequently occurring number in a given list. If multiple numbers have the same highest frequency, return them all in a list sorted in ascending order.",
    "output": "function MostFrequentNumbers(lst: List<integer>): List<integer>;\nbegin\n  var counter := new Dictionary<integer, integer>;\n  \n  foreach var num in lst do\n    if counter.ContainsKey(num) then\n      counter[num] := counter[num] + 1\n    else\n      counter.Add(num, 1);\n  \n  var maxFreq := counter.Values.Max;\n  var resultList := new List<integer>;\n  \n  foreach var pair in counter do\n    if pair.Value = maxFreq then\n      resultList.Add(pair.Key);\n  \n  resultList.Sort;\n  Result := resultList;\nend;"
  },
  {
    "instruction": "Write a function to determine if a given list of four points can form a valid rectangle.",
    "output": "function DistSq(point1, point2: (integer, integer)): integer;\nbegin\n  Result := (point1.Item1 - point2.Item1) * (point1.Item1 - point2.Item1) + \n            (point1.Item2 - point2.Item2) * (point1.Item2 - point2.Item2);\nend;\n\nfunction ValidRectangle(p1, p2, p3, p4: (integer, integer)): boolean;\nbegin\n  var points := new List<(integer, integer)>;\n  points.Add(p1);\n  points.Add(p2);\n  points.Add(p3);\n  points.Add(p4);\n  \n  var distances := new List<integer>;\n  \n  for var i := 0 to 3 do\n    for var j := i + 1 to 3 do\n      distances.Add(DistSq(points[i], points[j]));\n  \n  distances.Sort;\n  \n  if (distances[0] = distances[1]) and (distances[1] = distances[2]) and \n     (distances[2] = distances[3]) and (distances[4] = distances[5]) then\n    Result := True\n  else\n    Result := False;\nend;"
  },
  {
    "instruction": "Write a function to check if a given number can be expressed as the power of another number. The function should return True if the number can be rearranged to form the power of another number and False otherwise.",
    "output": "function CanBeExpressedAsPower(n: integer): boolean;\nbegin\n  var mydict := new Dictionary<integer, List<string>>;\n  var val := 1;\n  \n  while val <= 1000000000 do\n  begin\n    var strval := val.ToString;\n    var len := strval.Length;\n    \n    if not mydict.ContainsKey(len) then\n      mydict.Add(len, new List<string>);\n    mydict[len].Add(strval);\n    \n    val := val * 2;\n  end;\n  \n  var strn := n.ToString;\n  if mydict.ContainsKey(strn.Length) then\n    foreach var each in mydict[strn.Length] do\n    begin\n      var tmp1 := string.Join('', each.ToCharArray.Order.ToArray);\n      var tmp2 := string.Join('', strn.ToCharArray.Order.ToArray);\n      if tmp2 = tmp1 then\n      begin\n        Result := True;\n        exit;\n      end;\n    end;\n  \n  Result := False;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of the largest and smallest numbers in a list.",
    "output": "function SumLargestSmallest(numbers: List<integer>): integer;\nbegin\n  Result := numbers.Max + numbers.Min;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest substring without repeating characters.",
    "output": "function LengthOfLongstring(s: string): integer;\nbegin\n  var charMap := new Dictionary<char, integer>;\n  var left := 0;\n  var maxLength := 0;\n\n  for var right := 0 to s.Length - 1 do\n  begin\n    if charMap.ContainsKey(s[right]) then\n      left := Max(left, charMap[s[right]] + 1);\n    \n    charMap[s[right]] := right;\n    maxLength := Max(maxLength, right - left + 1);\n  end;\n\n  Result := maxLength;\nend;"
  },
  {
    "instruction": "Write a function to calculate the sum of the two lowest positive integers in a list of positive integers. No floats or non-positive integers will be passed.",
    "output": "function SumTwoSmallestNumbers(numbers: List<integer>): integer;\nbegin\n  numbers.Sort;\n  Result := numbers[0] + numbers[1];\nend;"
  },
  {
    "instruction": "Write a function to find the number of trailing zeros in the factorial of a given number.",
    "output": "function FactorialTrailingZeros(n: integer): integer;\nbegin\n  var count := 0;\n  while n >= 5 do\n  begin\n    n := n div 5;\n    count := count + n;\n  end;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to compute the minimum number of characters that need to be deleted from two given strings so that the strings become anagrams of each other. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "output": "function MinDeleteAnagram(str1, str2: string): integer;\nbegin\n  var c1 := new Dictionary<char, integer>;\n  var c2 := new Dictionary<char, integer>;\n  \n  foreach var ch in str1 do\n    if c1.ContainsKey(ch) then\n      c1[ch] := c1[ch] + 1\n    else\n      c1.Add(ch, 1);\n  \n  foreach var ch in str2 do\n    if c2.ContainsKey(ch) then\n      c2[ch] := c2[ch] + 1\n    else\n      c2.Add(ch, 1);\n  \n  var common := 0;\n  foreach var pair in c1 do\n    if c2.ContainsKey(pair.Key) then\n      common := common + Min(pair.Value, c2[pair.Key]);\n  \n  Result := (str1.Length - common) + (str2.Length - common);\nend;"
  },
  {
    "instruction": "Write a function to find the number of distinct island geometries in a given matrix.",
    "output": "procedure DFS(matrix: List<List<integer>>; i, j: integer; var path: StringBuilder; direction: char);\nbegin\n  if (i < 0) or (i >= matrix.Count) or (j < 0) or (j >= matrix[0].Count) or (matrix[i][j] <> 1) then\n    exit;\n  \n  matrix[i][j] := 0;\n  path.Append(direction);\n  \n  DFS(matrix, i + 1, j, path, 'D');\n  DFS(matrix, i - 1, j, path, 'U');\n  DFS(matrix, i, j + 1, path, 'R');\n  DFS(matrix, i, j - 1, path, 'L');\n  \n  path.Append('B');\nend;\n\nfunction CountDistinctIslands(matrix: List<List<integer>>): integer;\nbegin\n  if matrix.Count = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var distinctIslands := new HashSet<string>;\n  \n  for var i := 0 to matrix.Count - 1 do\n    for var j := 0 to matrix[0].Count - 1 do\n      if matrix[i][j] = 1 then\n      begin\n        var path := new StringBuilder;\n        DFS(matrix, i, j, path, 'O');\n        distinctIslands.Add(path.ToString);\n      end;\n  \n  Result := distinctIslands.Count;\nend;"
  },
  {
    "instruction": "Write a function to implement the fast power algorithm for calculating x^n. This algorithm reduces the number of multiplications required to calculate x^n by using the property that x^(2k) = (x^k)^2. The function should handle both positive and negative exponents, returning the reciprocal of x^n for negative exponents. Also, the function should handle the case when n is 0, returning 1 in that case.",
    "output": "function FastPower(x: real; n: integer): real;\nbegin\n  if n = 0 then\n    Result := 1\n  else if n < 0 then\n    Result := 1 / FastPower(x, -n)\n  else if n mod 2 = 0 then\n  begin\n    var halfPower := FastPower(x, n div 2);\n    Result := halfPower * halfPower;\n  end\n  else\n    Result := x * FastPower(x, n - 1);\nend;"
  },
  {
    "instruction": "Write a function to reverse the elements of a given list in-place.",
    "output": "function ReverseListInPlace(nums: List<integer>): List<integer>;\nbegin\n  var left := 0;\n  var right := nums.Count - 1;\n  \n  while left < right do\n  begin\n    var temp := nums[left];\n    nums[left] := nums[right];\n    nums[right] := temp;\n    \n    left := left + 1;\n    right := right - 1;\n  end;\n  \n  Result := nums;\nend;"
  },
  {
    "instruction": "Write a function to find the number of occurrences of a substring within a string.",
    "output": "function NumOccurrences(strVal, substring: string): integer;\nbegin\n  var count := 0;\n  var start := 0;\n  \n  while start < strVal.Length do\n  begin\n    var pos := strVal.IndexOf(substring, start);\n    if pos <> -1 then\n    begin\n      count := count + 1;\n      start := pos + 1;\n    end\n    else\n      break;\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to check if a given string is a valid parenthesis sequence.",
    "output": "function ValidParenthesisSequence(s: string): boolean;\nbegin\n  var stack := new Stack<char>;\n  \n  foreach var char in s do\n  begin\n    if char = '(' then\n      stack.Push(char)\n    else if char = ')' then\n    begin\n      if stack.Count = 0 then\n      begin\n        Result := False;\n        exit;\n      end;\n      stack.Pop;\n    end;\n  end;\n  \n  Result := stack.Count = 0;\nend;"
  },
  {
    "instruction": "Write a function to validate a given string if it contains only hexadecimal characters (0-9, a-f, A-F).",
    "output": "function ValidateHexadecimal(strVal: string): boolean;\nbegin\n  var pattern := '^[0-9a-fA-F]+$';\n  Result := &System.Text.RegularExpressions.Regex.IsMatch(strVal, pattern);\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings and returns a list of words with the length of each word appended to the end. If the word is a palindrome, append \"Palindrome\" after the length.",
    "output": "function WordLength(words: List<string>): List<string>;\nbegin\n  var res := new List<string>;\n  \n  foreach var word in words do\n  begin\n    var length := word.Length;\n    if word = string.Join('', word.Reverse.ToArray) then\n      res.Add(word + length.ToString + 'Palindrome')\n    else\n      res.Add(word + length.ToString);\n  end;\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of unique characters in a substring of a given string.",
    "output": "function MaxUniqueCharacters(s: string): integer;\nbegin\n  var charIndex := new Dictionary<char, integer>;\n  var maxLength := 0;\n  var start := 0;\n  \n  for var endIndex := 0 to s.Length - 1 do\n  begin\n    if charIndex.ContainsKey(s[endIndex]) and (charIndex[s[endIndex]] >= start) then\n      start := charIndex[s[endIndex]] + 1;\n    \n    charIndex[s[endIndex]] := endIndex;\n    maxLength := Max(maxLength, endIndex - start + 1);\n  end;\n  \n  Result := maxLength;\nend;"
  },
  {
    "instruction": "Write a function to find the intersection of two sorted lists.",
    "output": "function SortedListIntersection(list1, list2: List<integer>): List<integer>;\nbegin\n  var intersection := new List<integer>;\n  var i := 0;\n  var j := 0;\n  \n  while (i < list1.Count) and (j < list2.Count) do\n  begin\n    if list1[i] < list2[j] then\n      i := i + 1\n    else if list1[i] > list2[j] then\n      j := j + 1\n    else\n    begin\n      intersection.Add(list1[i]);\n      i := i + 1;\n      j := j + 1;\n    end;\n  end;\n  \n  Result := intersection;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings and returns a list of strings with all characters converted to lowercase.",
    "output": "function ToLowerCase(strList: List<string>): List<string>;\nbegin\n  var res := new List<string>;\n  \n  foreach var word in strList do\n  begin\n    var temp := new List<char>;\n    foreach var ch in word do\n    begin\n      if (ch >= 'A') and (ch <= 'Z') then\n        temp.Add(chr(ord(ch) + 32))\n      else\n        temp.Add(ch);\n    end;\n    res.Add(string.Join('', temp));\n  end;\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function that checks if a given string is a palindrome by ignoring case, spaces, and special characters. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward, ignoring spaces, punctuation, and capitalization.",
    "output": "function IsPalindromeIgnoringSpecial(s: string): boolean;\nbegin\n  var filteredChars := new List<char>;\n  \n  foreach var ch in s do\n    if char.IsLetterOrDigit(ch) then\n      filteredChars.Add(ch.ToLower);\n  \n  var left := 0;\n  var right := filteredChars.Count - 1;\n  \n  while left < right do\n  begin\n    if filteredChars[left] <> filteredChars[right] then\n    begin\n      Result := False;\n      exit;\n    end;\n    left := left + 1;\n    right := right - 1;\n  end;\n  \n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function to find the number of unique binary search trees (BSTs) that store values 1...n.",
    "output": "function UniqueBST(n: integer): integer;\nbegin\n  if n <= 1 then\n    Result := 1\n  else\n  begin\n    var dp := new integer[n + 1];\n    dp[0] := 1;\n    dp[1] := 1;\n    \n    for var i := 2 to n do\n      for var j := 1 to i do\n        dp[i] := dp[i] + dp[j - 1] * dp[i - j];\n    \n    Result := dp[n];\n  end;\nend;"
  },
  {
    "instruction": "Given three positive integers a, b, and c, write a function to return the minimum number of bit flips required in a and b to make the bitwise OR of a and b equal to c. A bit flip operation consists of changing any single bit 1 to 0 or changing the bit 0 to 1 in their binary representation.",
    "output": "function MinBitFlips(a, b, c: integer): integer;\nbegin\n  var flips := 0;\n  \n  for var i := 0 to 31 do\n  begin\n    var bitA := (a shr i) and 1;\n    var bitB := (b shr i) and 1;\n    var bitC := (c shr i) and 1;\n    \n    if bitC = 0 then\n      flips := flips + bitA + bitB\n    else\n      if (bitA + bitB) = 0 then\n        flips := flips + 1;\n  end;\n  \n  Result := flips;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of arrows needed to shoot all the balloons. There are some balloons arranged in a horizontal line, given as a list of intervals where each interval represents a balloon and its start and end points. An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with start and end points as (x, y) bursts by an arrow shot at x if x is in the range [start, end]. No arrow goes beyond the bounds of the intervals. Arrows can intersect, but any arrow shot must burst the balloons it intersects with.",
    "output": "function FindMinArrowShots(points: List<List<integer>>): integer;\nbegin\n  if points.Count = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  points.Sort((x, y) -> x[1].CompareTo(y[1]));\n  var arrows := 1;\n  var endVal := points[0][1];\n  \n  for var i := 1 to points.Count - 1 do\n  begin\n    if points[i][0] > endVal then\n    begin\n      arrows := arrows + 1;\n      endVal := points[i][1];\n    end;\n  end;\n  \n  Result := arrows;\nend;"
  },
  {
    "instruction": "Write a function that converts the given temperature from degrees Celsius to degrees Fahrenheit.",
    "output": "function ConvertCToF(celsius: real): real;\nbegin\n  Result := (celsius * 9 / 5) + 32;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum sum of a subarray where the subarray elements are consecutive in the original array.",
    "output": "function MaxConsecutiveSubarraySum(arr: List<integer>): integer;\nbegin\n  if arr.Count = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var maxSum := arr[0];\n  var currentSum := arr[0];\n  \n  for var i := 1 to arr.Count - 1 do\n  begin\n    currentSum := Max(arr[i], currentSum + arr[i]);\n    maxSum := Max(maxSum, currentSum);\n  end;\n  \n  Result := maxSum;\nend;"
  },
  {
    "instruction": "Write a function to find the duplicate characters in a given string and count their occurrences.",
    "output": "function FindDuplicateCharacters(strVal: string): Dictionary<char, integer>;\nbegin\n  var charCount := new Dictionary<char, integer>;\n  \n  foreach var char in strVal do\n    if charCount.ContainsKey(char) then\n      charCount[char] := charCount[char] + 1\n    else\n      charCount.Add(char, 1);\n  \n  var duplicates := new Dictionary<char, integer>;\n  foreach var pair in charCount do\n    if pair.Value > 1 then\n      duplicates.Add(pair.Key, pair.Value);\n  \n  Result := duplicates;\nend;"
  },
  {
    "instruction": "Write a function to find the longest common substring between two strings.",
    "output": "function FindLongestCommonSubstring(str1, str2: string): string;\nbegin\n  var m := str1.Length;\n  var n := str2.Length;\n  var dp := new integer[m + 1, n + 1];\n  var maxLen := 0;\n  var endIndex := 0;\n  \n  for var i := 1 to m do\n  begin\n    for var j := 1 to n do\n    begin\n      if str1[i - 1] = str2[j - 1] then\n      begin\n        dp[i, j] := dp[i - 1, j - 1] + 1;\n        if dp[i, j] > maxLen then\n        begin\n          maxLen := dp[i, j];\n          endIndex := i;\n        end;\n      end\n      else\n        dp[i, j] := 0;\n    end;\n  end;\n  \n  if maxLen = 0 then\n    Result := ''\n  else\n    Result := str1.Substring(endIndex - maxLen, maxLen);\nend;"
  },
  {
    "instruction": "Write a function to find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.",
    "output": "function FindKthLargest(nums: List<integer>; k: integer): integer;\nbegin\n  nums.Sort;\n  nums.Reverse;\n  Result := nums[k - 1];\nend;"
  },
  {
    "instruction": "Write a function that takes a list of numbers as input and returns a new list with only the unique numbers, preserving the original order of appearance.",
    "output": "function GetUniqueNumbers(numbers: List<integer>): List<integer>;\nbegin\n  var seen := new HashSet<integer>;\n  var uniqueNumbers := new List<integer>;\n  \n  foreach var number in numbers do\n  begin\n    if not seen.Contains(number) then\n    begin\n      uniqueNumbers.Add(number);\n      seen.Add(number);\n    end;\n  end;\n  \n  Result := uniqueNumbers;\nend;"
  },
  {
    "instruction": "Write a function to find the count of all possible substrings of a given string. The function should return the total number of substrings.",
    "output": "function CountSubstrings(s: string): integer;\nbegin\n  var n := s.Length;\n  Result := n * (n + 1) div 2;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest number of Fibonacci series which is larger than or equal to the given number.",
    "output": "function SmallestFibonacci(n: integer): integer;\nbegin\n  var a := 0;\n  var b := 1;\n  \n  while b < n do\n  begin\n    var temp := a;\n    a := b;\n    b := temp + b;\n  end;\n  \n  Result := b;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns a new list with only the positive numbers from the original list, preserving their original order.",
    "output": "function ExtractPositiveNumbers(numbers: List<integer>): List<integer>;\nbegin\n  Result := numbers.Where(num -> num > 0).ToList;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings and returns the string with the most unique characters. If multiple strings have the same number of unique characters, return the one that appears first in the list.",
    "output": "function MostUniqueChars(words: List<string>): string;\nbegin\n  var maxUnique := 0;\n  var resultStr := '';\n  \n  foreach var word in words do\n  begin\n    var uniqueChars := word.Distinct.ToList.Count;\n    if uniqueChars > maxUnique then\n    begin\n      maxUnique := uniqueChars;\n      resultStr := word;\n    end;\n  end;\n  \n  Result := resultStr;\nend;"
  },
  {
    "instruction": "Write a function that takes a string and a number of rows, and returns the string written in a zigzag pattern on the specified number of rows, then read line by line.",
    "output": "function ZigzagPattern(s: string; numRows: integer): string;\nbegin\n  if numRows = 1 then\n  begin\n    Result := s;\n    exit;\n  end;\n  \n  var ans := '';\n  var interval := 2 * (numRows - 1);\n  \n  for var i := 0 to s.Length - 1 step interval do\n    ans := ans + s[i];\n  \n  for var row := 1 to numRows - 2 do\n  begin\n    var inter := 2 * row;\n    var i := row;\n    while i < s.Length do\n    begin\n      ans := ans + s[i];\n      inter := interval - inter;\n      i := i + inter;\n    end;\n  end;\n  \n  for var i := numRows - 1 to s.Length - 1 step interval do\n    ans := ans + s[i];\n  \n  Result := ans;\nend;"
  },
  {
    "instruction": "Write a function to find the longest substring that can be obtained by replacing no more than k characters in the given string.",
    "output": "function LongestRepeatingCharacterReplacement(s: string; k: integer): integer;\nbegin\n  var char2count := new Dictionary<char, integer>;\n  var maxLen := 0;\n  var start := 0;\n  \n  for var endIndex := 0 to s.Length - 1 do\n  begin\n    if char2count.ContainsKey(s[endIndex]) then\n      char2count[s[endIndex]] := char2count[s[endIndex]] + 1\n    else\n      char2count.Add(s[endIndex], 1);\n    \n    while (endIndex - start + 1 - char2count.Values.Max) > k do\n    begin\n      char2count[s[start]] := char2count[s[start]] - 1;\n      start := start + 1;\n    end;\n    \n    maxLen := Max(maxLen, endIndex - start + 1);\n  end;\n  \n  Result := maxLen;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and a target sum. It should return the count of ways that the integers can be added or subtracted to reach the target sum.",
    "output": "procedure CountWays(numbers: List<integer>; i: integer; var counts: List<List<integer>>);\nbegin\n  var n := numbers.Count;\n  var plus := numbers.GetRange(0, n - i);\n  if i = 1 then\n  begin\n    foreach var count in counts.ToList do\n    begin\n      var newCount := new List<integer>(plus);\n      newCount.Add(-1 * numbers[n - i]);\n      counts.Add(newCount);\n    end;\n  end\n  else\n  begin\n    foreach var count in counts.ToList do\n    begin\n      var newCount := new List<integer>(plus);\n      newCount.Add(-1 * numbers[n - i]);\n      newCount.AddRange(count.GetRange(n - i + 1, count.Count - (n - i + 1)));\n      counts.Add(newCount);\n    end;\n  end;\nend;\n\nfunction CountTargetSums(numbers: List<integer>; target: integer): integer;\nbegin\n  var answer := 0;\n  var n := numbers.Count;\n  var counts := new List<List<integer>>;\n  counts.Add(numbers);\n  \n  for var i := 1 to n do\n    CountWays(numbers, i, counts);\n  \n  var results := counts.Select(lst -> lst.Sum).ToList;\n  answer := results.Count(val -> val = target);\n  \n  Result := answer;\nend;"
  },
  {
    "instruction": "Write a function to convert temperature between Celsius and Fahrenheit.",
    "output": "function ConvertTemperature(source: string; temp: real): real;\nbegin\n  if source = 'C' then\n    Result := (temp * 9 / 5) + 32\n  else if source = 'F' then\n    Result := (temp - 32) * 5 / 9\n  else\n    raise new System.ArgumentException('Invalid source. Please use ''C'' for Celsius or ''F'' for Fahrenheit.');\nend;"
  },
  {
    "instruction": "Write a function to find the k-th number whose sum of digits is a prime number. Start counting from 1.",
    "output": "function IsPrimeNumber(n: integer): boolean;\nbegin\n  if n <= 1 then\n    Result := False\n  else if n <= 3 then\n    Result := True\n  else if (n mod 2 = 0) or (n mod 3 = 0) then\n    Result := False\n  else\n  begin\n    var i := 5;\n    while i * i <= n do\n    begin\n      if (n mod i = 0) or (n mod (i + 2) = 0) then\n      begin\n        Result := False;\n        exit;\n      end;\n      i := i + 6;\n    end;\n    Result := True;\n  end;\nend;\n\nfunction SumOfDigits(n: integer): integer;\nbegin\n  var sumVal := 0;\n  var numStr := n.ToString;\n  foreach var digitChar in numStr do\n    sumVal := sumVal + StrToInt(digitChar.ToString);\n  Result := sumVal;\nend;\n\nfunction KthPrimeSumNumber(k: integer): integer;\nbegin\n  var count := 0;\n  var num := 1;\n  \n  while True do\n  begin\n    if IsPrimeNumber(SumOfDigits(num)) then\n    begin\n      count := count + 1;\n      if count = k then\n      begin\n        Result := num;\n        exit;\n      end;\n    end;\n    num := num + 1;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to count the number of times each letter appears in a string, excluding any digits and punctuation marks. The function should return a dictionary where the keys are the letters and the values are the counts.",
    "output": "function LetterCounts(s: string): Dictionary<char, integer>;\nbegin\n  var filteredChars := new List<char>;\n  \n  foreach var char in s do\n    if char.IsLetter then\n      filteredChars.Add(char.ToLower);\n  \n  var counts := new Dictionary<char, integer>;\n  \n  foreach var char in filteredChars do\n    if counts.ContainsKey(char) then\n      counts[char] := counts[char] + 1\n    else\n      counts.Add(char, 1);\n  \n  Result := counts;\nend;"
  },
  {
    "instruction": "Write a function to find the peak index in a mountain array. A mountain array is defined as an array where it is strictly increasing until a peak element and then strictly decreasing. The function should return the index of the peak element.",
    "output": "function SearchFun(arr: List<integer>; left, right: integer): integer;\nbegin\n  var mid := (left + right) div 2;\n  \n  if left > right then\n  begin\n    Result := -1;\n    exit;\n  end;\n  \n  if (arr[mid] > arr[mid - 1]) and (arr[mid] > arr[mid + 1]) then\n    Result := mid\n  else\n  begin\n    if (mid < arr.Count - 1) and (arr[mid] < arr[mid + 1]) then\n      Result := SearchFun(arr, mid + 1, right)\n    else if (mid < arr.Count - 1) and (arr[mid] > arr[mid + 1]) then\n      Result := SearchFun(arr, left, mid - 1)\n    else\n      Result := -1;\n  end;\nend;\n\nfunction PeakIndexInMountainArray(arr: List<integer>): integer;\nbegin\n  if arr.Count = 0 then\n  begin\n    Result := -1;\n    exit;\n  end;\n  \n  if arr.Count = 1 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  Result := SearchFun(arr, 0, arr.Count - 1);\nend;"
  },
  {
    "instruction": "Write a function to find the minimum length encoding for a list of words. The encoding should represent each word as a sequence of characters followed by a hash symbol (#). The goal is to find the shortest possible encoding that represents all words without any ambiguity.",
    "output": "type\n  TreeNode = class\n  public\n    children: Dictionary<char, TreeNode>;\n    \n    constructor;\n    begin\n      children := new Dictionary<char, TreeNode>;\n    end;\n  end;\n\nfunction MinimumLengthEncoding(words: List<string>): integer;\nbegin\n  var root := new TreeNode;\n  var leaves := new List<(TreeNode, integer)>;\n  \n  // Build tree with words in reverse order\n  foreach var word in words do\n  begin\n    var node := root;\n    for var i := word.Length - 1 downto 0 do\n    begin\n      var c := word[i];\n      if not node.children.ContainsKey(c) then\n        node.children.Add(c, new TreeNode);\n      node := node.children[c];\n    end;\n    leaves.Add((node, word.Length + 1)); // +1 for '#'\n  end;\n  \n  // Count only leaf nodes (nodes with no children)\n  var res := 0;\n  foreach var leaf in leaves do\n    if leaf[0].children.Count = 0 then\n      res := res + leaf[1];\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the kth smallest element in a given unsorted array using QuickSelect algorithm.",
    "output": "function Partition(nums: List<integer>; low, high: integer): integer;\nbegin\n  var pivot := nums[high];\n  var i := low - 1;\n  \n  for var j := low to high - 1 do\n  begin\n    if nums[j] <= pivot then\n    begin\n      i := i + 1;\n      var temp := nums[i];\n      nums[i] := nums[j];\n      nums[j] := temp;\n    end;\n  end;\n  \n  var temp := nums[i + 1];\n  nums[i + 1] := nums[high];\n  nums[high] := temp;\n  \n  Result := i + 1;\nend;\n\nfunction QuickSelect(nums: List<integer>; k, low, high: integer): integer;\nbegin\n  if low = high then\n  begin\n    Result := nums[low];\n    exit;\n  end;\n  \n  var pivotIndex := Partition(nums, low, high);\n  \n  if k = pivotIndex then\n    Result := nums[k]\n  else if k < pivotIndex then\n    Result := QuickSelect(nums, k, low, pivotIndex - 1)\n  else\n    Result := QuickSelect(nums, k, pivotIndex + 1, high);\nend;\n\nfunction KthSmallestElement(nums: List<integer>; k: integer): integer;\nbegin\n  if (k < 1) or (k > nums.Count) then\n    raise new System.ArgumentException('k is out of bounds!');\n  \n  Result := QuickSelect(nums, k - 1, 0, nums.Count - 1);\nend;"
  },
  {
    "instruction": "Create a function that flattens a given list of lists, but only includes elements that are even numbers.",
    "output": "function FlattenEven(nestedList: List<List<integer>>): List<integer>;\nbegin\n  var res := new List<integer>;\n  \n  foreach var sublist in nestedList do\n    foreach var num in sublist do\n      if num mod 2 = 0 then\n        res.Add(num);\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to check if two binary trees are identical, considering only the values of the leaf nodes. Two trees are considered identical if their leaf node values are the same, in the same order.",
    "output": "type\n  TreeNode = class\n    val: integer;\n    left: TreeNode;\n    right: TreeNode;\n    \n    constructor(v: integer; l: TreeNode := nil; r: TreeNode := nil);\n    begin\n      val := v;\n      left := l;\n      right := r;\n    end;\n  end;\n\nfunction GetLeafValues(node: TreeNode): List<integer>;\nbegin\n  if node = nil then\n  begin\n    Result := new List<integer>;\n    exit;\n  end;\n  \n  if (node.left = nil) and (node.right = nil) then\n  begin\n    Result := new List<integer>;\n    Result.Add(node.val);\n  end\n  else\n    Result := GetLeafValues(node.left).Concat(GetLeafValues(node.right)).ToList;\nend;\n\nfunction CompareLeafNodes(root1, root2: TreeNode): boolean;\nbegin\n  var leaves1 := GetLeafValues(root1);\n  var leaves2 := GetLeafValues(root2);\n  \n  Result := leaves1.SequenceEqual(leaves2);\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest consecutive elements sequence in an unsorted array of integers.",
    "output": "function LongestConsecutive(nums: List<integer>): integer;\nbegin\n  if nums.Count = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var numSet := new HashSet<integer>(nums);\n  var longestStreak := 0;\n  \n  foreach var num in numSet do\n  begin\n    if not numSet.Contains(num - 1) then\n    begin\n      var currentNum := num;\n      var currentStreak := 1;\n      \n      while numSet.Contains(currentNum + 1) do\n      begin\n        currentNum := currentNum + 1;\n        currentStreak := currentStreak + 1;\n      end;\n      \n      longestStreak := Max(longestStreak, currentStreak);\n    end;\n  end;\n  \n  Result := longestStreak;\nend;"
  },
  {
    "instruction": "Create a function that generates a list of Fibonacci numbers up to a certain limit. The limit should be an input to the function. The Fibonacci sequence is defined by the following rule: the first two numbers in the Fibonacci sequence are 0 and 1, and each subsequent number is the sum of the previous two.",
    "output": "function FibUpTo(limit: integer): List<integer>;\nbegin\n  var fibList := new List<integer>;\n  \n  if limit >= 0 then\n    fibList.Add(0);\n  \n  if limit >= 1 then\n  begin\n    fibList.Add(1);\n    var a := 0;\n    var b := 1;\n    \n    while True do\n    begin\n      var nextFib := a + b;\n      if nextFib > limit then\n        break;\n      fibList.Add(nextFib);\n      a := b;\n      b := nextFib;\n    end;\n  end;\n  \n  Result := fibList;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of jumps required for a knight to reach from one position to another on a chessboard. The chessboard size is 8x8.",
    "output": "function KnightMoves(x1, y1, x2, y2: integer): integer;\nbegin\n  var moves := new List<(integer, integer)>;\n  moves.Add((2, 1));\n  moves.Add((1, 2));\n  moves.Add((-1, -2));\n  moves.Add((-2, -1));\n  moves.Add((-2, 1));\n  moves.Add((-1, 2));\n  moves.Add((1, -2));\n  moves.Add((2, -1));\n  \n  var queue := new Queue<(integer, integer, integer)>;\n  queue.Enqueue((x1, y1, 0));\n  var visited := new HashSet<(integer, integer)>;\n  visited.Add((x1, y1));\n  \n  while queue.Count > 0 do\n  begin\n    var (x, y, c) := queue.Dequeue;\n    \n    if (x = x2) and (y = y2) then\n    begin\n      Result := c;\n      exit;\n    end;\n    \n    foreach var (dx, dy) in moves do\n    begin\n      var nx := x + dx;\n      var ny := y + dy;\n      \n      if (nx >= 0) and (nx < 8) and (ny >= 0) and (ny < 8) and (not visited.Contains((nx, ny))) then\n      begin\n        visited.Add((nx, ny));\n        queue.Enqueue((nx, ny, c + 1));\n      end;\n    end;\n  end;\n  \n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function that finds the first non-repeated character in a given string.",
    "output": "function FindFirstNonRepeated(s: string): char;\nbegin\n  var charCount := new Dictionary<char, integer>;\n  \n  foreach var char in s do\n    if charCount.ContainsKey(char) then\n      charCount[char] := charCount[char] + 1\n    else\n      charCount.Add(char, 1);\n  \n  foreach var char in s do\n    if charCount[char] = 1 then\n    begin\n      Result := char;\n      exit;\n    end;\n  \n  Result := #0;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of unique summands that add up to a given number n. The summands should be positive integers and none of them should be equal. For example, if n=8, the unique summands could be [1,2,5] because 1+2+5=8 and all numbers are unique.",
    "output": "function UniqueSummands(n: integer): List<integer>;\nbegin\n  var summands := new List<integer>;\n  var current := 1;\n  \n  while n > 0 do\n  begin\n    if n <= 2 * current then\n    begin\n      summands.Add(n);\n      break;\n    end\n    else\n    begin\n      summands.Add(current);\n      n := n - current;\n      current := current + 1;\n    end;\n  end;\n  \n  Result := summands;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum area of a histogram.",
    "output": "function MaxAreaHistogram(heights: List<integer>): integer;\nbegin\n  var stack := new Stack<integer>;\n  var maxArea := 0;\n  var index := 0;\n  \n  while index < heights.Count do\n  begin\n    if (stack.Count = 0) or (heights[stack.Peek] <= heights[index]) then\n    begin\n      stack.Push(index);\n      index := index + 1;\n    end\n    else\n    begin\n      var top := stack.Pop;\n      var area := heights[top] * (if stack.Count = 0 then index else (index - stack.Peek - 1));\n      maxArea := Max(maxArea, area);\n    end;\n  end;\n  \n  while stack.Count > 0 do\n  begin\n    var top := stack.Pop;\n    var area := heights[top] * (if stack.Count = 0 then index else (index - stack.Peek - 1));\n    maxArea := Max(maxArea, area);\n  end;\n  \n  Result := maxArea;\nend;"
  },
  {
    "instruction": "Write a function to find the number of subarrays with a given sum.",
    "output": "function FindSubArrays(arr: List<integer>; s: integer): integer;\nbegin\n  var count := 0;\n  var sumMap := new Dictionary<integer, integer>;\n  var currSum := 0;\n  \n  for var i := 0 to arr.Count - 1 do\n  begin\n    currSum := currSum + arr[i];\n    \n    if currSum = s then\n      count := count + 1;\n    \n    if sumMap.ContainsKey(currSum - s) then\n      count := count + sumMap[currSum - s];\n    \n    if sumMap.ContainsKey(currSum) then\n      sumMap[currSum] := sumMap[currSum] + 1\n    else\n      sumMap.Add(currSum, 1);\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the first negative number in a given list of numbers.",
    "output": "function FirstNegative(nums: List<integer>): integer;\nbegin\n  foreach var num in nums do\n    if num < 0 then\n    begin\n      Result := num;\n      exit;\n    end;\n  Result := 0;\nend;"
  },
  {
    "instruction": "Write a function to find the largest perfect square less than or equal to the given number.",
    "output": "function FindPerfectSquare(n: integer): integer;\nbegin\n  var root := Floor(Sqrt(n));\n  Result := root * root;\nend;"
  },
  {
    "instruction": "Create a function that will take a list of stock prices and return the maximum profit that could be made by buying and selling at the optimal times. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).",
    "output": "function OptimalStockProfit(prices: List<integer>): integer;\nbegin\n  var profit := 0;\n  \n  for var i := 1 to prices.Count - 1 do\n    if prices[i] > prices[i - 1] then\n      profit := profit + (prices[i] - prices[i - 1]);\n  \n  Result := profit;\nend;"
  },
  {
    "instruction": "Write a function to convert a Roman numeral to an integer.",
    "output": "function RomanToInt(s: string): integer;\nbegin\n  var romanValues := new Dictionary<char, integer>;\n  romanValues.Add('I', 1);\n  romanValues.Add('V', 5);\n  romanValues.Add('X', 10);\n  romanValues.Add('L', 50);\n  romanValues.Add('C', 100);\n  romanValues.Add('D', 500);\n  romanValues.Add('M', 1000);\n  \n  var total := 0;\n  var prevValue := 0;\n  \n  for var i := s.Length - 1 downto 0 do\n  begin\n    var value := romanValues[s[i]];\n    if value < prevValue then\n      total := total - value\n    else\n      total := total + value;\n    prevValue := value;\n  end;\n  \n  Result := total;\nend;"
  },
  {
    "instruction": "Write a function to find the position of the first occurrence of a given number in a sorted array.",
    "output": "function FindPositionInSortedArray(arr: List<integer>; target: integer): integer;\nbegin\n  var low := 0;\n  var high := arr.Count - 1;\n  var resultIndex := -1;\n  \n  while low <= high do\n  begin\n    var mid := (low + high) div 2;\n    \n    if arr[mid] = target then\n    begin\n      resultIndex := mid;\n      high := mid - 1;\n    end\n    else if arr[mid] > target then\n      high := mid - 1\n    else\n      low := mid + 1;\n  end;\n  \n  Result := resultIndex;\nend;"
  },
  {
    "instruction": "Write a function to convert an integer to a Roman numeral.",
    "output": "function IntToRoman(num: integer): string;\nbegin\n  var val := new integer[13];\n  val[0] := 1000;\n  val[1] := 900;\n  val[2] := 500;\n  val[3] := 400;\n  val[4] := 100;\n  val[5] := 90;\n  val[6] := 50;\n  val[7] := 40;\n  val[8] := 10;\n  val[9] := 9;\n  val[10] := 5;\n  val[11] := 4;\n  val[12] := 1;\n  \n  var syms := new string[13];\n  syms[0] := 'M';\n  syms[1] := 'CM';\n  syms[2] := 'D';\n  syms[3] := 'CD';\n  syms[4] := 'C';\n  syms[5] := 'XC';\n  syms[6] := 'L';\n  syms[7] := 'XL';\n  syms[8] := 'X';\n  syms[9] := 'IX';\n  syms[10] := 'V';\n  syms[11] := 'IV';\n  syms[12] := 'I';\n  \n  var romanNum := '';\n  var i := 0;\n  \n  while num > 0 do\n  begin\n    for var times := 1 to (num div val[i]) do\n    begin\n      romanNum := romanNum + syms[i];\n      num := num - val[i];\n    end;\n    i := i + 1;\n  end;\n  \n  Result := romanNum;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of the squares of the first n natural numbers.",
    "output": "function SquaresSum(n: integer): integer;\nbegin\n  Result := (n * (n + 1) * (2 * n + 1)) div 6;\nend;"
  },
  {
    "instruction": "Write a function to check if the target string can be formed by concatenating the elements of the dictionary.",
    "output": "function CanFormTarget(target: string; wordset: List<string>): boolean;\nbegin\n  if target = '' then\n  begin\n    Result := True;\n    exit;\n  end;\n  \n  foreach var word in wordset do\n  begin\n    if target.StartsWith(word) then\n    begin\n      var suffix := target.Substring(word.Length);\n      if CanFormTarget(suffix, wordset) then\n      begin\n        Result := True;\n        exit;\n      end;\n    end;\n  end;\n  \n  Result := False;\nend;"
  },
  {
    "instruction": "Write a function to check if a target integer exists in a given two-dimensional list(matrix). The matrix is sorted in both row and column directions.",
    "output": "function SearchMatrix(matrix: List<List<integer>>; target: integer): boolean;\nbegin\n  var m := matrix.Count;\n  if m = 0 then\n  begin\n    Result := False;\n    exit;\n  end;\n  \n  var n := matrix[0].Count;\n  var ans := False;\n  \n  for var i := 0 to m - 1 do\n  begin\n    var l := 0;\n    var r := n - 1;\n    \n    if (target >= matrix[i][l]) and (target <= matrix[i][r]) then\n    begin\n      while l <= r do\n      begin\n        var mid := (l + r) div 2;\n        if matrix[i][mid] = target then\n        begin\n          ans := True;\n          break;\n        end\n        else if matrix[i][mid] < target then\n          l := mid + 1\n        else\n          r := mid - 1;\n      end;\n      \n      if ans then\n        break;\n    end;\n  end;\n  \n  Result := ans;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and an integer k, and returns the count of contiguous subarrays whose sum equals k.",
    "output": "function SubArraySum(nums: List<integer>; k: integer): integer;\nbegin\n  var d := new Dictionary<integer, integer>;\n  d.Add(0, 1);\n  var count := 0;\n  var sumSoFar := 0;\n  \n  foreach var num in nums do\n  begin\n    sumSoFar := sumSoFar + num;\n    var diff := sumSoFar - k;\n    \n    if d.ContainsKey(diff) then\n      count := count + d[diff];\n    \n    if d.ContainsKey(sumSoFar) then\n      d[sumSoFar] := d[sumSoFar] + 1\n    else\n      d.Add(sumSoFar, 1);\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the square root of a given number using the Newton-Raphson method.",
    "output": "function SqrtNewtonRaphson(number: real; tolerance: real := 1e-10): real;\nbegin\n  if number < 0 then\n    raise new System.ArgumentException('Cannot compute square root of a negative number');\n  \n  if number = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var guess := number;\n  \n  while True do\n  begin\n    var betterGuess := (guess + number / guess) / 2.0;\n    if Abs(guess - betterGuess) < tolerance then\n    begin\n      Result := betterGuess;\n      exit;\n    end;\n    guess := betterGuess;\n  end;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings, each representing a number, and returns a list of the numbers sorted in ascending order.",
    "output": "function SortStringNumbers(numbers: List<string>): List<integer>;\nbegin\n  var intList := numbers.Select(str -> StrToInt(str)).ToList;\n  intList.Sort;\n  Result := intList;\nend;"
  },
  {
    "instruction": "Write a function to find the nth newman\u2013shanks\u2013williams prime number, but with the additional condition that the function should also check if the number is indeed a prime number. The Newman\u2013Shanks\u2013Williams (NSW) sequence is defined by the recurrence relation: a(n) = 2 * a(n-1) + a(n-2), with initial conditions a(0) = 1 and a(1) = 1. The NSW primes are the prime numbers that occur in this sequence.",
    "output": "function IsPrime(n: integer): boolean;\nbegin\n  if n <= 1 then\n    Result := False\n  else\n  begin\n    for var i := 2 to Round(Sqrt(n)) do\n      if n mod i = 0 then\n      begin\n        Result := False;\n        exit;\n      end;\n    Result := True;\n  end;\nend;\n\nfunction NewmanPrime(n: integer): integer;\nbegin\n  if (n = 0) or (n = 1) then\n    Result := 1\n  else\n  begin\n    var a := new List<integer>;\n    a.Add(1);\n    a.Add(1);\n    \n    for var i := 2 to n do\n      a.Add(2 * a[i - 1] + a[i - 2]);\n    \n    for var i := n downto 0 do\n      if IsPrime(a[i]) then\n      begin\n        Result := a[i];\n        exit;\n      end;\n    \n    Result := -1;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the leader in an array. A leader is an element that is strictly greater than all the elements to its right side.",
    "output": "function FindLeader(arr: List<integer>): List<integer>;\nbegin\n  if arr.Count = 0 then\n  begin\n    Result := new List<integer>;\n    exit;\n  end;\n  \n  var maxRight := arr[arr.Count - 1];\n  var resultList := new List<integer>;\n  resultList.Add(maxRight);\n  \n  for var i := arr.Count - 2 downto 0 do\n  begin\n    if arr[i] > maxRight then\n    begin\n      resultList.Add(arr[i]);\n      maxRight := arr[i];\n    end;\n  end;\n  \n  resultList.Reverse;\n  Result := resultList;\nend;"
  },
  {
    "instruction": "Write a function to convert a given string of digits into the corresponding number. The string can contain digits from \"zero\" to \"nine\" separated by spaces.",
    "output": "function StrToNum(strNum: string): integer;\nbegin\n  var dig := new Dictionary<string, string>;\n  dig.Add('zero', '0');\n  dig.Add('one', '1');\n  dig.Add('two', '2');\n  dig.Add('three', '3');\n  dig.Add('four', '4');\n  dig.Add('five', '5');\n  dig.Add('six', '6');\n  dig.Add('seven', '7');\n  dig.Add('eight', '8');\n  dig.Add('nine', '9');\n  \n  var res := '';\n  var words := strNum.Split(' ').ToList;\n  \n  foreach var word in words do\n    res := res + dig[word];\n  \n  Result := StrToInt(res);\nend;"
  },
  {
    "instruction": "Write a function that calculates the sum of the digits of a given non-negative integer recursively.",
    "output": "function SumDigitsRecursively(num: integer): integer;\nbegin\n  if num = 0 then\n    Result := 0\n  else\n    Result := (num mod 10) + SumDigitsRecursively(num div 10);\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings and returns a new list with the strings sorted by their length in descending order.",
    "output": "function StringSort(strings: List<string>): List<string>;\nbegin\n  var sortedList := strings.OrderByDescending(s -> s.Length).ToList;\n  Result := sortedList;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of operations to transform an array into a palindrome by flipping elements.",
    "output": "function MinFlip(arr: array of integer): integer;\nbegin\n  var n := arr.Length;\n  var l := 0;\n  var r := n - 1;\n  var flip := 0;\n  while l < r do\n  begin\n    if arr[l] <> arr[r] then\n      flip += 1;\n    l += 1;\n    r -= 1;\n  end;\n  Result := flip;\nend;"
  },
  {
    "instruction": "Given a list of tuples, each containing two numbers, write a function that calculates the product of the first elements and the second elements separately, and returns the results as a tuple.",
    "output": "function MultiplyTupleElements(tuples: List<(integer, integer)>): (integer, integer);\nbegin\n  var firstProduct := 1;\n  var secondProduct := 1;\n  foreach var t in tuples do\n  begin\n    firstProduct *= t[0];\n    secondProduct *= t[1];\n  end;\n  Result := (firstProduct, secondProduct);\nend;"
  },
  {
    "instruction": "Write a function to find the largest rectangle containing only 1's in a binary matrix.",
    "output": "function LargestRectangle(matrix: array[,] of integer): integer;\nbegin\n  if (matrix = nil) or (matrix.GetLength(0) = 0) then\n    Result := 0;\n\n  var rows := matrix.GetLength(0);\n  var cols := matrix.GetLength(1);\n  var height := ArrFill(cols + 1, 0);\n  var maxArea := 0;\n\n  for var r := 0 to rows - 1 do\n  begin\n    for var i := 0 to cols - 1 do\n      height[i] := if matrix[r, i] = 1 then height[i] + 1 else 0;\n\n    var stack := new Stack<integer>;\n    stack.Push(-1);\n    for var i := 0 to cols do\n    begin\n      while (stack.Count > 0) and (stack.Peek() <> -1) and (height[i] < height[stack.Peek()]) do\n      begin\n        var h := height[stack.Pop()];\n        var w := i - 1 - stack.Peek();\n        maxArea := Max(maxArea, h * w);\n      end;\n      stack.Push(i);\n    end;\n  end;\n\n  Result := maxArea;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings and returns the string with the highest number of vowels. If there are multiple strings with the same highest number of vowels, return the one that appears first in the list.",
    "output": "function MostVowels(strings: array of string): string;\nbegin\n  var vowels := 'aeiou';\n  var maxVowels := 0;\n  var res := '';\n  foreach var s in strings do\n  begin\n    var vowelCount := 0;\n    foreach var ch in s do\n      if ch.ToLower() in vowels then\n        vowelCount += 1;\n    if vowelCount > maxVowels then\n    begin\n      maxVowels := vowelCount;\n      res := s;\n    end;\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to return the first element from a given list. If the list is empty, return nil.",
    "output": "function FirstElement(lst: array of integer): integer?;\nbegin\n  Result := if lst.Length > 0 then lst[0] else nil; end;"
  },
  {
    "instruction": "Write a function to find the largest binary gap within a positive integer N. A binary gap within a positive integer N is any maximal sequence of consecutive zeros that is surrounded by ones at both ends in the binary representation of N.",
    "output": "function FindLargestBinaryGap(N: integer): integer;\nbegin\n  var binaryStr := Convert.ToString(N, 2);\n  var maxGap := 0;\n  var currentGap := 0;\n\n  foreach var bit in binaryStr do\n  begin\n    if bit = '1' then\n    begin\n      maxGap := Max(maxGap, currentGap);\n      currentGap := 0;\n    end\n    else\n      currentGap += 1;\n  end;\n\n  Result := maxGap;\nend;"
  },
  {
    "instruction": "Write a function to find the elements that appear only once in the given list.",
    "output": "function FindUnique(inputList: array of integer): array of integer;\nbegin\n  var uniqueElements := new List<integer>;\n  foreach var element in inputList do\n    if inputList.CountOf(element) = 1 then\n      uniqueElements.Add(element);\n  Result := uniqueElements.ToArray();\nend;"
  },
  {
    "instruction": "Write a function to find the number of palindrome substrings in a given string.",
    "output": "function PalindromeSubstringsCount(s: string): integer;\n\n  function ExpandAroundCenter(left: integer; right: integer): integer;\n  begin\n    var count := 0;\n    while (left >= 0) and (right < s.Length) and (s[left] = s[right]) do\n    begin\n      count += 1;\n      left -= 1;\n      right += 1;\n    end;\n    Result := count;\n  end;\n\nbegin\n  var totalCount := 0;\n  for var i := 0 to s.Length - 1 do\n  begin\n    totalCount += ExpandAroundCenter(i, i);\n    totalCount += ExpandAroundCenter(i, i + 1);\n  end;\n  Result := totalCount;\nend;"
  },
  {
    "instruction": "Write a function to find the number of distinct words in a given string. A word is defined as a sequence of non-space characters.",
    "output": "function DistinctWords(s: string): integer;\nbegin\n  var words := s.ToWords();\n  var distinct := words.Distinct().ToArray();\n  Result := distinct.Length;\nend;"
  },
  {
    "instruction": "Create a function that takes a paragraph and a list of banned words as input, and returns the most common word in the paragraph that is not in the list of banned words. Words in the paragraph are case-insensitive and non-alphanumeric characters are considered as spaces.",
    "output": "function FindCommonWord(paragraph: string; banned: array of string): string;\nbegin\n  var list1 := Regex.Replace(paragraph, '[\\W_]+', ' ');\n  list1 := list1.ToLower();\n  var words := list1.ToWords();\n  words := words.Where(w -> not banned.Contains(w)).ToArray();\n  var wordCount := words.GroupBy(w -> w).ToDictionary(g -> g.Key, g -> g.Count());\n  var sortedWords := wordCount.OrderByDescending(kv -> kv.Value).ToArray();\n  Result := sortedWords[0].Key;\nend;"
  },
  {
    "instruction": "Write a function to find the longest substring where the letters occur in alphabetical order.",
    "output": "function LongestOrderedSubstring(s: string): string;\nbegin\n  var subs := new List<string>;\n  subs.Add(s[1].ToString());\n  for var i := 2 to s.Length do\n  begin\n    if s[i] >= subs[subs.Count - 1][subs[subs.Count - 1].Length] then\n      subs[subs.Count - 1] += s[i]\n    else\n      subs.Add(s[i].ToString());\n  end;\n  Result := subs.OrderByDescending(x -> x.Length).First();\nend;"
  },
  {
    "instruction": "Write a function to find the maximum performance of a team. The team's performance is the sum of their speeds multiplied by the minimum efficiency in the team. The team should have exactly 'k' members.",
    "output": "function MaxPerformance(n: integer; speed: array of integer; efficiency: array of integer; k: integer): integer;\nbegin\n  var performances := ArrGen(n, i -> (efficiency[i], speed[i])).OrderByDescending(x -> x[0]).ToArray();\n  var speedSum := 0;\n  var heap := new SortedSet<integer>;\n  var performance := 0;\n\n  foreach var (e, s) in performances do\n  begin\n    if heap.Count > k - 1 then\n    begin\n      var minSpeed := heap.Min;\n      speedSum -= minSpeed;\n      heap.Remove(minSpeed);\n    end;\n\n    heap.Add(s);\n    speedSum += s;\n    performance := Max(performance, speedSum * e);\n  end;\n\n  Result := performance mod (1000000007);\nend;"
  },
  {
    "instruction": "Write a function to check if a given array is a valid peak array. A peak array is defined as an array that has at least three elements and there exists an index where the elements before this index are strictly increasing and the elements after this index are strictly decreasing. The element at this index is called the peak.",
    "output": "function ValidPeakArray(arr: array of integer): boolean;\nbegin\n  if arr.Length < 3 then\n    Result := False;\n\n  var (peakIndex, peak) := arr.Select((val, idx) -> (idx, val)).OrderByDescending(x -> x[1]).First();\n  if (peakIndex = 0) or (peakIndex = arr.Length - 1) then\n    Result := False;\n\n  for var i := 0 to peakIndex - 1 do\n    if arr[i] >= arr[i + 1] then\n      Result := False;\n\n  for var i := peakIndex to arr.Length - 2 do\n    if arr[i] <= arr[i + 1] then\n      Result := False;\n\n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function to check if a given list of numbers is an arithmetic sequence. An arithmetic sequence is a sequence of numbers such that the difference between the consecutive terms is constant.",
    "output": "function IsArithmetic(nums: array of integer): boolean;\nbegin\n  if nums.Length < 2 then\n    Result := False;\n  var difference := nums[1] - nums[0];\n  for var i := 2 to nums.Length - 1 do\n    if nums[i] - nums[i - 1] <> difference then\n      Result := False;\n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function to find the degree of a polynomial. The degree of a polynomial is the highest power of the variable in the polynomial.",
    "output": "function DegreeOfPolynomial(coefficients: array of real): integer;\nbegin\n  var degree := coefficients.Length - 1;\n  for var i := coefficients.Length - 1 downto 0 do\n    if coefficients[i] <> 0 then\n    begin\n      Result := i;\n      exit;\n    end;\n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to calculate the total number of unique substrings that can be formed from a given string where all the characters in the substring are the same.",
    "output": "function CountIdenticalCharSubstrings(s: string): integer;\nbegin\n  var totalSubstrings := 0;\n  var currentChar := s[1];\n  var currentCount := 1;\n\n  for var i := 2 to s.Length do\n  begin\n    if s[i] = currentChar then\n      currentCount += 1\n    else\n    begin\n      totalSubstrings += (currentCount * (currentCount + 1)) div 2;\n      currentChar := s[i];\n      currentCount := 1;\n    end;\n  end;\n\n  totalSubstrings += (currentCount * (currentCount + 1)) div 2;\n  Result := totalSubstrings;\nend;"
  },
  {
    "instruction": "Write a function to find the shortest sequence of city visits which will cover all the tourist attractions in a given list. The attractions are represented as integers and you can move from one attraction to another if there is a road between them.",
    "output": "function ShortestTour(attractions: array of integer; roads: array of (integer, integer)): array of integer;\nbegin\n  var roadMap := new Dictionary<integer, HashSet<integer>>;\n  foreach var road in roads do\n  begin\n    if not roadMap.ContainsKey(road[0]) then\n      roadMap[road[0]] := new HashSet<integer>;\n    if not roadMap.ContainsKey(road[1]) then\n      roadMap[road[1]] := new HashSet<integer>;\n    roadMap[road[0]].Add(road[1]);\n    roadMap[road[1]].Add(road[0]);\n  end;\n\n  var shortest: array of integer;\n  foreach var permutation in attractions.Permutations() do\n  begin\n    var valid := True;\n    for var i := 0 to permutation.Length - 2 do\n      if not roadMap[permutation[i]].Contains(permutation[i + 1]) then\n      begin\n        valid := False;\n        break;\n      end;\n    \n    if valid and ((shortest = nil) or (permutation.Length < shortest.Length)) then\n      shortest := permutation;\n  end;\n\n  Result := shortest;\nend;"
  },
  {
    "instruction": "Write a function that finds the top k frequent elements in a given list of integers using the heap queue algorithm.",
    "output": "function TopKFrequent(nums: array of integer; k: integer): array of integer;\nbegin\n  var d := nums.GroupBy(x -> x).ToDictionary(g -> g.Key, g -> g.Count());\n  var heap := new SortedSet<(integer, integer)>(\n    Comparer&<(integer, integer)>.Create(\n      (x, y) -> begin\n        if x[0] = y[0] then\n          Result := x[1].CompareTo(y[1])\n        else\n          Result := y[0].CompareTo(x[0]);\n      end));\n\n  foreach var i in d.Keys do\n    heap.Add((-d[i], i));\n\n  var res := new List<integer>;\n  for var idx := 0 to k - 1 do\n  begin\n    res.Add(heap.Min[1]);\n    heap.Remove(heap.Min);\n  end;\n\n  Result := res.ToArray();\nend;"
  },
  {
    "instruction": "Write a function to find the largest subarray with equal number of 0's and 1's.",
    "output": "function LargestSubarray(arr: array of integer): integer;\nbegin\n  var count := 0;\n  var maxLength := 0;\n  var start := 0;\n  var sumMap := new Dictionary<integer, integer>;\n  sumMap[0] := -1;\n  \n  for var i := 0 to arr.Length - 1 do\n  begin\n    if arr[i] = 0 then\n      count -= 1\n    else\n      count += 1;\n    \n    if sumMap.ContainsKey(count) then\n    begin\n      var length := i - sumMap[count];\n      if length > maxLength then\n      begin\n        maxLength := length;\n        start := sumMap[count] + 1;\n      end;\n    end\n    else\n      sumMap[count] := i;\n  end;\n  \n  Result := maxLength;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of unique characters in a given string.",
    "output": "function UniqueCharMax(s: string): integer;\nbegin\n  var charDict := new Dictionary<char, integer>;\n  var left := 0;\n  var maxLength := 0;\n  \n  for var right := 1 to s.Length do\n  begin\n    if charDict.ContainsKey(s[right]) then\n      left := Max(left, charDict[s[right]] + 1);\n    charDict[s[right]] := right;\n    maxLength := Max(maxLength, right - left + 1);\n  end;\n  \n  Result := maxLength;\nend;"
  },
  {
    "instruction": "Write a function that takes a string as input and returns the string with all repeated characters removed, keeping only the first occurrence of each character.",
    "output": "function RemoveRepeatedCharacters(s: string): string;\nbegin\n  var res := new List<char>;\n  foreach var ch in s do\n    if not res.Contains(ch) then\n      res.Add(ch);\n  Result := string.Join('', res);\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of elements between two negative numbers in a list. Return this count, or return -1 if there are no such elements.",
    "output": "function FindMaxElementsBetweenNegatives(arr: array of integer): integer;\nbegin\n  var count := 0;\n  var maxCount := 0;\n  var foundFirstNegative := False;\n  \n  foreach var num in arr do\n  begin\n    if num < 0 then\n    begin\n      if foundFirstNegative then\n      begin\n        maxCount := Max(maxCount, count);\n        count := 0;\n        foundFirstNegative := False;\n      end\n      else\n        foundFirstNegative := True;\n    end\n    else if foundFirstNegative then\n      count += 1;\n  end;\n\n  Result := if maxCount > 0 then maxCount else -1;\nend;"
  },
  {
    "instruction": "Write a function to create a new string by replacing the character with the character which is present at the next position in the alphabetical order.",
    "output": "function ReplaceNextChar(s: string): string;\nbegin\n  var res := '';\n  foreach var ch in s do\n  begin\n    if ch = 'z' then\n      res += 'a'\n    else if ch = 'Z' then\n      res += 'A'\n    else\n      res += Chr(Ord(ch) + 1);\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of steps required to make a given string palindrome by performing the following operations: delete a character or insert a character.",
    "output": "function FindMinSteps(i: integer; j: integer; s: string; dp: array[,] of integer): integer;\nbegin\n  if i >= j then\n  begin\n    Result := 0;\n    exit;\n  end;\n  if dp[i, j] <> -1 then\n  begin\n    Result := dp[i, j];\n    exit;\n  end;\n  if s[i + 1] = s[j + 1] then\n    dp[i, j] := FindMinSteps(i + 1, j - 1, s, dp)\n  else\n    dp[i, j] := 1 + Min(FindMinSteps(i + 1, j, s, dp), FindMinSteps(i, j - 1, s, dp));\n  Result := dp[i, j];\nend;\n\nfunction MinStepsPalindrome(s: string): integer;\nbegin\n  var n := s.Length;\n  var dp := new integer[n, n];\n  for var i := 0 to n - 1 do\n    for var j := 0 to n - 1 do\n      dp[i, j] := -1;\n  Result := FindMinSteps(0, n - 1, s, dp);\nend;"
  },
  {
    "instruction": "Write a function called `is_continuous` that takes a list of 5 integers representing the drawn cards in a game where the numbers can range from 0 to 13 (0 for either King or Ace, 1 for 2, ..., 12 for Queen, 13 for King, and 1 for Ace when playing with the rule that Aces can be high or low). The function should return `True` if the cards can form a straight (consecutive sequence), considering that the wild cards (0s) can take the value of any number. Return `False` otherwise.",
    "output": "function IsContinuous(cards: array of integer): boolean;\nbegin\n  if cards.Length <> 5 then\n    Result := False;\n  \n  &Array.Sort(cards);\n  var wildCards := cards.CountOf(0);\n  \n  for var i := wildCards to 4 do\n  begin\n    var gap := cards[i] - cards[i - 1] - 1;\n    if gap > 0 then\n    begin\n      wildCards -= gap;\n      if wildCards < 0 then\n      begin\n        Result := False;\n        exit;\n      end;\n    end\n    else if (cards[i] = cards[i - 1]) and (cards[i] <> 0) then\n    begin\n      Result := False;\n      exit;\n    end;\n  end;\n  \n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum health required for a knight to reach the bottom-right corner of a dungeon. The knight starts at the top-left corner of the dungeon (dungeon[0][0]) and moves to the bottom-right corner (dungeon[m-1][n-1]). The knight's health point (HP) should be always greater than 0. Any room can be dangerous to the knight, represented by a negative integer (losing health points), or be very supportive where the knight regains health points, represented by a positive integer.",
    "output": "function MinimumHealth(dungeon: array[,] of integer): integer;\nbegin\n  var m := dungeon.GetLength(0);\n  var n := dungeon.GetLength(1);\n  var dp := new integer[m + 1, n + 1];\n  \n  for var i := 0 to m do\n    for var j := 0 to n do\n      dp[i, j] := integer.MaxValue;\n      \n  dp[m, n - 1] := 1;\n  dp[m - 1, n] := 1;\n\n  for var i := m - 1 downto 0 do\n    for var j := n - 1 downto 0 do\n    begin\n      dp[i, j] := Max(1, Min(dp[i + 1, j], dp[i, j + 1]) - dungeon[i, j]);\n    end;\n    \n  Result := dp[0, 0];\nend;"
  },
  {
    "instruction": "Write a function to find the second largest number from the given list of unique integers. Assume the list always contains at least two elements.",
    "output": "function SecondLargest(lst: array of integer): integer;\nbegin\n  var maxNum := lst.Max();\n  var newLst := lst.Where(x -> x <> maxNum).ToArray();\n  Result := newLst.Max();\nend;"
  },
  {
    "instruction": "Write a function to check whether a given directed graph is acyclic or not. The graph is represented as an adjacency list where each node is an integer from 1 to A (number of nodes) and each edge is represented as a pair (u, v) in the lists B and C where B[i] is the starting node and C[i] is the ending node. Return 1 if the graph is acyclic, otherwise return 0.",
    "output": "function GraphIsAcyclic(A: integer; B: array of integer; C: array of integer): integer;\n\n  function DFS(adjLis: array of List<integer>; vis: array of boolean; se: HashSet<integer>; element: integer): integer;\n  begin\n    vis[element] := True;\n    var val := 1;\n    se.Add(element);\n    foreach var i in adjLis[element] do\n    begin\n      if se.Contains(i) then\n      begin\n        Result := 0;\n        exit;\n      end;\n      if not vis[i] then\n      begin\n        val := DFS(adjLis, vis, se, i);\n        if val = 0 then\n        begin\n          Result := 0;\n          exit;\n        end;\n      end;\n    end;\n    se.Remove(element);\n    Result := 1;\n  end;\n\nbegin\n  var vis := ArrFill(A + 1, False);\n  var lenb := B.Length;\n  var se := new HashSet<integer>;\n  var adjLis := new List<integer>[A + 1];\n  \n  for var i := 0 to A do\n    adjLis[i] := new List<integer>;\n    \n  for var i := 0 to lenb - 1 do\n    adjLis[B[i]].Add(C[i]);\n    \n  for var i := 1 to A do\n  begin\n    if not vis[i] then\n    begin\n      vis[i] := True;\n      if DFS(adjLis, vis, se, i) = 0 then\n      begin\n        Result := 0;\n        exit;\n      end;\n    end;\n  end;\n  \n  Result := 1;\nend;"
  },
  {
    "instruction": "Write a function to check if all the points in a given list of coordinates are collinear.",
    "output": "function CheckCollinear(coordinates: array of (integer, integer)): boolean;\n\n  function GetSlope(p1: (integer, integer); p2: (integer, integer)): real;\n  begin\n    var (x1, y1) := p1;\n    var (x2, y2) := p2;\n    if x2 - x1 = 0 then\n      Result := real.PositiveInfinity\n    else\n      Result := (y2 - y1) / (x2 - x1);\n  end;\n\nbegin\n  if coordinates.Length < 2 then\n    Result := False;\n\n  var (x0, y0) := coordinates[0];\n  var (x1, y1) := coordinates[1];\n  var initialSlope := GetSlope((x0, y0), (x1, y1));\n\n  for var i := 2 to coordinates.Length - 1 do\n  begin\n    var (x, y) := coordinates[i];\n    if GetSlope((x0, y0), (x, y)) <> initialSlope then\n    begin\n      Result := False;\n      exit;\n    end;\n  end;\n  \n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function that takes a string as an input and removes all the characters that are the same as the previous character but in the opposite case (uppercase vs. lowercase).",
    "output": "function RemoveOppositeCase(s: string): string;\nbegin\n  var stack := new Stack<char>;\n  foreach var c in s do\n  begin\n    if (stack.Count = 0) or (Abs(Ord(stack.Peek()) - Ord(c)) <> 32) then\n      stack.Push(c)\n    else\n      stack.Pop();\n  end;\n  Result := string.Join('', stack.Reverse());\nend;"
  },
  {
    "instruction": "Write a function to find the product of all elements in an array that are not equal to zero.",
    "output": "function ProductNonZero(arr: array of integer): integer;\nbegin\n  var res := 1;\n  foreach var num in arr do\n    if num <> 0 then\n      res *= num;\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function that generates the next lexicographic permutation of a given list of numbers. If no such permutation exists (meaning the list is in its highest possible lexicographic order), return the lowest possible order (i.e., sorted in ascending order).",
    "output": "function NextLexicographicPermutation(arr: array of integer): array of integer;\nbegin\n  var pivot: integer := -1;\n  for var i := arr.Length - 2 downto 0 do\n  begin\n    if arr[i] < arr[i + 1] then\n    begin\n      pivot := i;\n      break;\n    end;\n  end;\n  \n  if pivot = -1 then\n  begin\n    &Array.Sort(arr);\n    Result := arr;\n    exit;\n  end;\n\n  var rightmostSuccessor := 0;\n  for var i := arr.Length - 1 downto pivot + 1 do\n  begin\n    if arr[i] > arr[pivot] then\n    begin\n      rightmostSuccessor := i;\n      break;\n    end;\n  end;\n\n  Swap(arr[pivot], arr[rightmostSuccessor]);\n  \n  var left := pivot + 1;\n  var right := arr.Length - 1;\n  while left < right do\n  begin\n    Swap(arr[left], arr[right]);\n    left += 1;\n    right -= 1;\n  end;\n  \n  Result := arr;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest number in the list that can be expressed as the sum of two cubes of integers in two different ways.",
    "output": "function SumOfTwoCubes(n: integer): boolean;\nbegin\n  var cubes := new List<integer>;\n  for var i := 0 to Round(Power(n, 1/3)) + 2 do\n    cubes.Add(i * i * i);\n    \n  for var i := 0 to cubes.Count - 1 do\n    for var j := i to cubes.Count - 1 do\n      for var k := 0 to cubes.Count - 1 do\n        for var l := k to cubes.Count - 1 do\n          if (cubes[i] + cubes[j] = cubes[k] + cubes[l]) and \n             ((i <> k) or (j <> l)) and \n             ((i <> l) or (j <> k)) then\n          begin\n            Result := True;\n            exit;\n          end;\n  Result := False;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of the digits of a given number, but in base 2.",
    "output": "function SumBinaryDigits(n: integer): integer;\nbegin\n  var binary := Convert.ToString(n, 2);\n  var sum := 0;\n  foreach var digit in binary do\n    sum += StrToInt(digit.ToString());\n  Result := sum;\nend;"
  },
  {
    "instruction": "Write a function to find the character that is added to a string to make it a palindrome.",
    "output": "function FindPalindromeChar(s: string): char;\nbegin\n  var lowerS := s.ToLower();\n  for var i := 1 to s.Length div 2 do\n  begin\n    if lowerS[i] <> lowerS[s.Length - i + 1] then\n    begin\n      Result := s[i];\n      exit;\n    end;\n  end;\n  Result := #0;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of the digits of a factorial of a given number.",
    "output": "function FactorialDigitSum(n: integer): integer;\nbegin\n  var factorial := 1bi;\n  for var i := 1 to n do\n    factorial *= i;\n  \n  var sumOfDigits := 0;\n  foreach var digit in factorial.ToString() do\n    sumOfDigits += StrToInt(digit.ToString());\n  \n  Result := sumOfDigits;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of pairs in an array that sum up to a given value K.",
    "output": "function FindMaxPairs(nums: array of integer; k: integer): integer;\nbegin\n  var d := new Dictionary<integer, integer>;\n  var count := 0;\n  foreach var num in nums do\n  begin\n    var complement := k - num;\n    if d.ContainsKey(complement) and (d[complement] > 0) then\n    begin\n      count += 1;\n      d[complement] -= 1;\n    end\n    else\n    begin\n      if not d.ContainsKey(num) then\n        d[num] := 0;\n      d[num] += 1;\n    end;\n  end;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function that finds the next greatest value for each element in the array. If no such value exists, return -1 for that position.",
    "output": "function NextGreatestElement(nums: array of integer): array of integer;\nbegin\n  var stack := new Stack<integer>;\n  var res := ArrFill(nums.Length, -1);\n  \n  for var i := 0 to nums.Length - 1 do\n  begin\n    while (stack.Count > 0) and (nums[stack.Peek()] < nums[i]) do\n    begin\n      res[stack.Pop()] := nums[i];\n    end;\n    stack.Push(i);\n  end;\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function that takes a positive integer and returns the count of digits from the right until a digit larger than the rightmost digit is encountered.",
    "output": "function FindDigitCount(num: integer): integer;\nbegin\n  if num < 10 then\n  begin\n    Result := -1;\n    exit;\n  end;\n  \n  var rightmost := num mod 10;\n  var count := 0;\n  num := num div 10;\n  \n  while num > 0 do\n  begin\n    count += 1;\n    var currentDigit := num mod 10;\n    if currentDigit > rightmost then\n    begin\n      Result := count;\n      exit;\n    end;\n    num := num div 10;\n  end;\n  \n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to check if a given list contains any three consecutive even numbers.",
    "output": "function HasThreeConsecutiveEvens(arr: array of integer): boolean;\nbegin\n  if arr.Length < 3 then\n    Result := False;\n  \n  var i := 0;\n  while i < arr.Length - 2 do\n  begin\n    if (arr[i] mod 2 = 0) and (arr[i + 1] mod 2 = 0) and (arr[i + 2] mod 2 = 0) then\n    begin\n      Result := True;\n      exit;\n    end\n    else if arr[i + 1] mod 2 = 0 then\n      i += 1\n    else if arr[i + 2] mod 2 = 0 then\n      i += 2\n    else\n      i += 3;\n  end;\n  \n  Result := False;\nend;"
  },
  {
    "instruction": "Write a function to validate a given string as a valid parenthesis string. A string is a valid parenthesis string (denoted VPS) if it meets one of the following:\n1. It is an empty string \"\", or a single character not equal to \"(\" or \")\",\n2. It can be written as AB (A concatenated with B), where A and B are VPS's, or\n3. It can be written as (A), where A is a VPS.\nYou may assume the input string, s, is non-empty and contains only '(', ')', ' ', 'a' ~ 'z'.",
    "output": "function ValidParenthesis(s: string): boolean;\nbegin\n  var stack := new Stack<char>;\n  foreach var i in s do\n  begin\n    if (i = '(') or (i = ' ') or ((i >= 'a') and (i <= 'z')) then\n      stack.Push(i)\n    else if i = ')' then\n    begin\n      if (stack.Count = 0) or (stack.Peek() <> '(') then\n      begin\n        Result := False;\n        exit;\n      end;\n      stack.Pop();\n    end;\n  end;\n  Result := stack.Count = 0;\nend;"
  },
  {
    "instruction": "Write a function to count the number of times a given pattern occurs in a string. The pattern can have wildcards where any character can fit. '*' is a wildcard that matches any sequence of characters (including the empty sequence), and '?' is a wildcard that matches any single character.",
    "output": "function CountWildcardPattern(text: string; pattern: string): integer;\nbegin\n  var wildcardPattern := '^' + pattern.Replace('?', '.?').Replace('*', '.*') + '$';\n  var matches := Regex.Matches(text, wildcardPattern);\n  Result := matches.Count;\nend;"
  },
  {
    "instruction": "Write a function that will calculate the sum of numbers in a string. The function should be able to ignore non-numeric characters.",
    "output": "function SumNumbersString(str1: string): integer;\nbegin\n  var numbers := Regex.Matches(str1, '\\d+');\n  var sum := 0;\n  foreach m : &Match in numbers do\n    sum += StrToInt(m.Value);\n  Result := sum;\nend;"
  },
  {
    "instruction": "Write a function to calculate the fuel required for a journey if the distance and fuel efficiency of the vehicle is known. The function should return the fuel required rounded to the nearest litre.",
    "output": "function CalculateFuel(distance: real; fuelEfficiency: real): integer;\nbegin\n  var fuelRequired := distance / fuelEfficiency;\n  Result := Round(fuelRequired);\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of unique substrings that can be formed from a given string such that each substring contains only one distinct letter.",
    "output": "function MaxUniqueSubstrings(s: string): integer;\nbegin\n  var maxCount := 0;\n  var currentCount := 0;\n  var lastSeen := new Dictionary<char, integer>;\n\n  for var i := 1 to s.Length do\n  begin\n    var ch := s[i];\n    if lastSeen.ContainsKey(ch) then\n      currentCount := i - lastSeen[ch]\n    else\n      currentCount += 1;\n    lastSeen[ch] := i;\n    maxCount := Max(maxCount, currentCount);\n  end;\n\n  Result := maxCount;\nend;"
  },
  {
    "instruction": "Write a function to find the k most frequent elements in a list of numbers. If there are multiple elements with the same frequency, return them in the order they appear in the original list.",
    "output": "function TopFrequentElements(nums: array of integer; k: integer): array of integer;\nbegin\n  var counter := new Dictionary<integer, integer>;\n  foreach var n in nums do\n  begin\n    if counter.ContainsKey(n) then\n      counter[n] += 1\n    else\n      counter[n] := 1;\n  end;\n  \n  var topk := counter.OrderByDescending(x -> x.Value).Take(k).ToArray();\n  Result := topk.Select(x -> x.Key).ToArray();\nend;"
  },
  {
    "instruction": "Write a function to convert a list of dates from one format to another. The input list will contain dates in the format 'YYYYMMDD' and the function should return a list of dates in the format 'MM/DD/YYYY'.",
    "output": "function ConvertDateFormat(dates: array of string): array of string;\nbegin\n  var convertedDates := new List<string>;\n  foreach var date in dates do\n  begin\n    var year := date.Substring(0, 4);\n    var month := date.Substring(4, 2);\n    var day := date.Substring(6, 2);\n    convertedDates.Add($'{month}/{day}/{year}');\n  end;\n  Result := convertedDates.ToArray();\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest absolute path to a file in a simulated file system represented as a string.",
    "output": "function LongestPathLength(inputStr: string): integer;\nbegin\n  var lines := inputStr.Split(|NewLine|, System.StringSplitOptions.RemoveEmptyEntries);\n  var words := new List<string>;\n  var tabCount := new List<integer>;\n  var res := 0;\n  \n  for var i := 0 to lines.Length - 1 do\n  begin\n    var word := lines[i].TrimStart(#9);\n    var count := lines[i].Length - word.Length;\n    while (tabCount.Count > 0) and (count <= tabCount[tabCount.Count - 1]) do\n    begin\n      tabCount.RemoveAt(tabCount.Count - 1);\n      words.RemoveAt(words.Count - 1);\n    end;\n    \n    if word.Contains('.') then\n    begin\n      words.Add(word);\n      res := Max(res, string.Join('/', words).Length);\n      words.RemoveAt(words.Count - 1);\n    end\n    else\n    begin\n      words.Add(word);\n      tabCount.Add(count);\n    end;\n  end;\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the number of times a number can be evenly divided by a prime number before it becomes less than that prime number.",
    "output": "function CountDivisible(n: integer; p: integer): integer;\nbegin\n  var count := 0;\n  while (n >= p) and (n mod p = 0) do\n  begin\n    n := n div p;\n    count += 1;\n  end;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the number of unique characters in a string.",
    "output": "function UniqueCharacters(s: string): integer;\nbegin\n  var uniqueChars := new HashSet<char>(s);\n  Result := uniqueChars.Count;\nend;"
  },
  {
    "instruction": "Write a function to check if a given tree is a binary search tree (BST).",
    "output": "type\n  TreeNode = class\n    val: integer;\n    left, right: TreeNode;\n    constructor(v: integer; l: TreeNode := nil; r: TreeNode := nil);\n    begin\n      val := v;\n      left := l;\n      right := r;\n    end;\n  end;\n\nfunction IsBst(root: TreeNode): boolean;\n\n  function Dfs(node: TreeNode; minVal: integer; maxVal: integer): boolean;\n  begin\n    if node = nil then\n      Result := True\n    else if not ((minVal < node.val) and (node.val < maxVal)) then\n      Result := False\n    else\n      Result := Dfs(node.left, minVal, node.val) and Dfs(node.right, node.val, maxVal);\n  end;\n\nbegin\n  Result := Dfs(root, integer.MinValue, integer.MaxValue);\nend;"
  },
  {
    "instruction": "Write a function to return the n largest items from a dataset.",
    "output": "function LargestNNum(list1: array of integer; n: integer): array of integer;\nbegin\n  var largest := list1.OrderByDescending(x -> x).Take(n).ToArray();\n  Result := largest;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of tuples, where each tuple contains a string and a number, and returns a list of tuples with the string and the number multiplied by a given multiplier.",
    "output": "function MultiplyNumbers(lst: array of (string, integer); multiplier: integer): array of (string, integer);\nbegin\n  Result := lst.Select(x -> (x[0], x[1] * multiplier)).ToArray();\nend;"
  },
  {
    "instruction": "Write a function to calculate the number of different ways to climb n steps, given that you can take 1 step, 2 steps, or 3 steps at a time.",
    "output": "function StepClimb(n: integer): integer;\nbegin\n  if n = 1 then\n    Result := 1\n  else if n = 2 then\n    Result := 2\n  else if n = 3 then\n    Result := 4\n  else\n    Result := StepClimb(n - 1) + StepClimb(n - 2) + StepClimb(n - 3);\nend;"
  },
  {
    "instruction": "You are given a list of integers. Write a function to find the two non-overlapping subarrays with the maximum sum. Return the start and end indices of both subarrays.",
    "output": "function MaxSumSubarrays(nums: array of integer): array of (integer, integer);\nbegin\n  var maxSum := integer.MinValue;\n  var currentSum := 0;\n  var start := 0;\n  var res := new List<(integer, integer)>;\n  \n  for var endIdx := 0 to nums.Length - 1 do\n  begin\n    currentSum += nums[endIdx];\n    if currentSum > maxSum then\n    begin\n      maxSum := currentSum;\n      res.Clear();\n      res.Add((start, endIdx));\n    end\n    else if currentSum = maxSum then\n      res.Add((start, endIdx));\n    \n    if currentSum < 0 then\n    begin\n      currentSum := 0;\n      start := endIdx + 1;\n    end;\n  end;\n  \n  Result := res.ToArray();\nend;"
  },
  {
    "instruction": "Write a function that reverses a string in-place without using extra space for another string. The function should modify the input string directly.",
    "output": "function ReverseStringInplace(var s: string): string;\nbegin\n  var left := 1;\n  var right := s.Length;\n  while left < right do\n  begin\n    var temp := s[left];\n    s[left] := s[right];\n    s[right] := temp;\n    left += 1;\n    right -= 1;\n  end;\n  Result := s;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum subarray sum in a list using Kadane's algorithm.",
    "output": "function KadaneAlgorithm(arr: array of integer): integer;\nbegin\n  var maxCurrent := arr[0];\n  var maxGlobal := arr[0];\n  for var i := 1 to arr.Length - 1 do\n  begin\n    maxCurrent := Max(arr[i], maxCurrent + arr[i]);\n    if maxCurrent > maxGlobal then\n      maxGlobal := maxCurrent;\n  end;\n  Result := maxGlobal;\nend;"
  },
  {
    "instruction": "Write a function to merge two sorted lists into a single sorted list.",
    "output": "function MergeTwoLists(l1: array of integer; l2: array of integer): array of integer;\nbegin\n  var l3 := new List<integer>;\n  var i := 0;\n  var j := 0;\n  \n  while (i < l1.Length) and (j < l2.Length) do\n  begin\n    if l1[i] < l2[j] then\n    begin\n      l3.Add(l1[i]);\n      i += 1;\n    end\n    else\n    begin\n      l3.Add(l2[j]);\n      j += 1;\n    end;\n  end;\n  \n  if i = l1.Length then\n    l3.AddRange(l2[j:l2.Length])\n  else\n    l3.AddRange(l1[i:l1.Length]);\n  \n  Result := l3.ToArray();\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns a new list where each element is the result of squaring the original element and adding 1.",
    "output": "function SquareAndAddOne(nums: array of integer): array of integer;\nbegin\n  Result := nums.Select(x -> x * x + 1).ToArray();\nend;"
  },
  {
    "instruction": "Write a function to find the total number of ways to reach the Nth stair from the ground using either 1 or 2 steps at a time.",
    "output": "function WaysToReachStair(n: integer): integer;\nbegin\n  if n <= 1 then\n    Result := n\n  else\n  begin\n    var first := 1;\n    var second := 1;\n    for var i := 2 to n do\n    begin\n      var third := first + second;\n      first := second;\n      second := third;\n    end;\n    Result := second;\n  end;\nend;"
  },
  {
    "instruction": "Write a function that finds the smallest set of vertices from which all nodes in a directed graph are reachable. You are given the number of vertices in the graph (n) and a list of directed edges. A vertex is reachable from another vertex if there is a path from the first vertex to the second vertex.",
    "output": "function FindSmallestSetOfVertices(n: integer; edges: array of (integer, integer)): array of integer;\nbegin\n  var graph := new Dictionary<integer, List<integer>>;\n  foreach var (start, dest) in edges do\n  begin\n    if not graph.ContainsKey(start) then\n      graph[start] := new List<integer>;\n    graph[start].Add(dest);\n  end;\n\n  var ans := new List<integer>;\n  var values := new HashSet<integer>;\n  foreach var valList in graph.Values do\n    values.UnionWith(valList);\n\n  for var i := 0 to n - 1 do\n    if not values.Contains(i) then\n      ans.Add(i);\n\n  Result := ans.ToArray();\nend;"
  },
  {
    "instruction": "Write a function to find the score of a given parentheses string. The score of a valid parentheses string is defined as follows:\n- () has score 1,\n- AB has score A + B, where A and B are valid parentheses strings,\n- (A) has score 2 * A, where A is a valid parentheses string.",
    "output": "function ScoreOfParentheses(s: string): integer;\nbegin\n  var stackCount := 0;\n  var start := 1;\n  var score := 0;\n  for var endIdx := 1 to s.Length do\n  begin\n    if s[endIdx] = '(' then\n      stackCount += 1\n    else if stackCount > 0 then\n      stackCount -= 1;\n    \n    if stackCount = 0 then\n    begin\n      if endIdx - start = 1 then\n        score += 1\n      else\n        score += 2 * ScoreOfParentheses(s.Substring(start, endIdx - start));\n      start := endIdx + 1;\n    end;\n  end;\n  Result := score;\nend;"
  },
  {
    "instruction": "Write a function that takes in a list of integers and returns a list of tuples, where each tuple contains the index and the value of the integer in the original list if the integer is larger than 10.",
    "output": "function FindLargeNumbers(l: array of integer): array of (integer, integer);\nbegin\n  Result := l.Select((v, i) -> (i, v)).Where(x -> x[1] > 10).ToArray();\nend;"
  },
  {
    "instruction": "Write a function that takes an array of integers and returns a new array with each element squared.",
    "output": "function SquareArray(nums: array of integer): array of integer;\nbegin\n  Result := nums.Select(num -> num * num).ToArray();\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to split a string into substrings where the number of distinct characters in each substring is equal to the number of substrings.",
    "output": "function NumSplits(s: string): integer;\nbegin\n  var left := new HashSet<char>;\n  var right := new Dictionary<char, integer>;\n  foreach var ch in s do\n  begin\n    if right.ContainsKey(ch) then\n      right[ch] += 1\n    else\n      right[ch] := 1;\n  end;\n  \n  var res := 0;\n  foreach var ch in s do\n  begin\n    left.Add(ch);\n    right[ch] -= 1;\n    if right[ch] = 0 then\n      right.Remove(ch);\n\n    if left.Count = right.Count then\n      res += 1;\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to sort a list of numbers based on another list. The numbers in the first list should be sorted in the order of their occurrence in the second list. If a number is not present in the second list, it should be placed at the end of the sorted list in ascending order.",
    "output": "function RelativeSort(arr1: array of integer; arr2: array of integer): array of integer;\nbegin\n  var countMap := new Dictionary<integer, integer>;\n  foreach var num in arr1 do\n  begin\n    if countMap.ContainsKey(num) then\n      countMap[num] += 1\n    else\n      countMap[num] := 1;\n  end;\n  \n  var sortedArr := new List<integer>;\n  var remaining := new List<integer>;\n  \n  foreach var num in arr2 do\n  begin\n    while countMap.ContainsKey(num) and (countMap[num] > 0) do\n    begin\n      sortedArr.Add(num);\n      countMap[num] -= 1;\n    end;\n  end;\n\n  foreach var num in arr1 do\n  begin\n    if (not arr2.Contains(num)) and (countMap.ContainsKey(num)) and (countMap[num] > 0) then\n    begin\n      remaining.Add(num);\n      countMap[num] -= 1;\n    end;\n  end;\n\n  remaining.Sort();\n  Result := sortedArr.Concat(remaining).ToArray();\nend;"
  },
  {
    "instruction": "Write a function to reverse the order of words in a given sentence and invert the case of each character.",
    "output": "function ReverseInvertSentence(sentence: string): string;\nbegin\n  var words := sentence.ToWords();\n  var reversedWords := words.Reverse().Select(word -> \n  begin\n    var newWord := '';\n    foreach var ch in word do\n      if ch.IsUpper then\n        newWord += ch.ToLower()\n      else\n        newWord += ch.ToUpper();\n    Result := newWord;\n  end).ToArray();\n  Result := string.Join(' ', reversedWords);\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest valid parentheses substring.",
    "output": "function LongestValidParentheses(s: string): integer;\nbegin\n  var maxLen := 0;\n  var stack := new Stack<integer>;\n  stack.Push(-1);\n  for var i := 1 to s.Length do\n  begin\n    var ch := s[i];\n    if ch = '(' then\n      stack.Push(i)\n    else\n    begin\n      stack.Pop();\n      if stack.Count = 0 then\n        stack.Push(i)\n      else\n        maxLen := Max(maxLen, i - stack.Peek());\n    end;\n  end;\n  Result := maxLen;\nend;"
  },
  {
    "instruction": "Write a function that takes a string and an integer as input and returns the string in a zigzag pattern with the specified number of rows.",
    "output": "function ConvertStringToZigzag(s: string; numRows: integer): string;\nbegin\n  if (numRows = 1) or (numRows >= s.Length) then\n  begin\n    Result := s;\n    exit;\n  end;\n\n  var res := ArrFill(numRows, '');\n  var p := 2 * (numRows - 1);\n\n  for var i := 1 to s.Length do\n  begin\n    var floor := (i - 1) mod p;\n    if floor >= p div 2 then\n      floor := p - floor;\n    res[floor] += s[i];\n  end;\n\n  Result := string.Join('', res);\nend;"
  },
  {
    "instruction": "Write a function that takes a string and a character as input and returns the number of occurrences of that character in the string, ignoring case.",
    "output": "function IgnoreCaseCount(text: string; ch: char): integer;\nbegin\n  var cnt := 0;\n  var lower := ch.ToLower();\n  var upper := ch.ToUpper();\n\n  foreach var c in text do\n    if (c = lower) or (c = upper) then\n      cnt += 1;\n  Result := cnt;\nend;"
  },
  {
    "instruction": "Write a function to detect if any three points in a given list form a right-angled triangle. The function should return True if there is at least one set of three points that form a right-angled triangle, and False otherwise.",
    "output": "function RightAngleTriangle(points: array of (real, real)): boolean;\n\n  function IsRightAngleTriangle(p1: (real, real); p2: (real, real); p3: (real, real)): boolean;\n  begin\n    var (x1, y1) := p1;\n    var (x2, y2) := p2;\n    var (x3, y3) := p3;\n    \n    var dx1 := x2 - x1;\n    var dy1 := y2 - y1;\n    var dx2 := x3 - x1;\n    var dy2 := y3 - y1;\n    var dx3 := x3 - x2;\n    var dy3 := y3 - y2;\n\n    if (dx1 * dx2 + dy1 * dy2 = 0) or \n       (dx1 * dx3 + dy1 * dy3 = 0) or \n       (dx2 * dx3 + dy2 * dy3 = 0) then\n      Result := True\n    else\n      Result := False;\n  end;\n\nbegin\n  for var i := 0 to points.Length - 1 do\n    for var j := i + 1 to points.Length - 1 do\n      for var k := j + 1 to points.Length - 1 do\n        if IsRightAngleTriangle(points[i], points[j], points[k]) then\n        begin\n          Result := True;\n          exit;\n        end;\n  Result := False;\nend;"
  },
  {
    "instruction": "Write a function to find the number of connected components in an undirected graph represented as an adjacency matrix.",
    "output": "function FindConnectedComponents(matrix: array[,] of integer): integer;\n\n  procedure Dfs(node: integer; var visited: array of boolean);\n  begin\n    visited[node] := True;\n    for var neighbor := 0 to matrix.GetLength(0) - 1 do\n      if (matrix[node, neighbor] = 1) and (not visited[neighbor]) then\n        Dfs(neighbor, visited);\n  end;\n\nbegin\n  var n := matrix.GetLength(0);\n  var visited := ArrFill(n, False);\n  var components := 0;\n\n  for var i := 0 to n - 1 do\n    if not visited[i] then\n    begin\n      Dfs(i, visited);\n      components += 1;\n    end;\n\n  Result := components;\nend;"
  },
  {
    "instruction": "Write a function to check whether a string is a valid pin code or not. The valid pin code should be numeric and either 4 or 6 digits long.",
    "output": "function CheckPin(s: string): boolean;\nbegin\n  Result := ((s.Length = 4) or (s.Length = 6)) and s.All(ch -> ch in ['0'..'9']);\nend;"
  },
  {
    "instruction": "Write a function to check if a string is a rotation of a pattern. A rotation of a string is a rearrangement of the string by moving the characters from the beginning to the end.",
    "output": "function IsRotation(str1: string; str2: string): boolean;\nbegin\n  if str1.Length <> str2.Length then\n    Result := False\n  else\n  begin\n    var temp := str1 + str1;\n    Result := temp.Contains(str2);\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the largest number of consecutive zeros in a binary string.",
    "output": "function MaxZero(s: string): integer;\nbegin\n  var count := 0;\n  var maxCount := 0;\n  foreach var ch in s do\n  begin\n    if ch = '0' then\n    begin\n      count += 1;\n      if count > maxCount then\n        maxCount := count;\n    end\n    else\n      count := 0;\n  end;\n  Result := maxCount;\nend;"
  },
  {
    "instruction": "Create a function that takes a list and a number k, and returns all the possible subsets of length k from the list.",
    "output": "function KSizedSubsets(arr: array of integer; k: integer): array of array of integer;\n\n  procedure Backtrack(start: integer; path: List<integer>; var res: List<array of integer>);\n  begin\n    if path.Count = k then\n    begin\n      res.Add(path.ToArray());\n      exit;\n    end;\n    \n    for var i := start to arr.Length - 1 do\n    begin\n      path.Add(arr[i]);\n      Backtrack(i + 1, path, res);\n      path.RemoveAt(path.Count - 1);\n    end;\n  end;\n\nbegin\n  var res := new List<array of integer>;\n  Backtrack(0, new List<integer>, res);\n  Result := res.ToArray();\nend;"
  },
  {
    "instruction": "Write a function that checks if all elements in a list of lists are the same length.",
    "output": "function IsListsSameLength(listOfLists: array of array of integer): boolean;\nbegin\n  var lengths := listOfLists.Select(lst -> lst.Length).Distinct().ToArray();\n  Result := lengths.Length = 1;\nend;"
  },
  {
    "instruction": "Write a function to encode a given string using a simple substitution cipher. The cipher works by shifting each letter in the string by a specified number of places in the alphabet. If the shift number is greater than the length of the alphabet, it should wrap around to the beginning of the alphabet.",
    "output": "function EncodeCipher(str1: string; shift: integer): string;\nbegin\n  var encodedStr := '';\n  foreach var ch in str1 do\n  begin\n    if ch.IsLetter then\n    begin\n      var shiftAmount := shift mod 26;\n      if ch.IsLower then\n      begin\n        var newChar := Chr(((Ord(ch) - Ord('a') + shiftAmount) mod 26) + Ord('a'));\n        encodedStr += newChar;\n      end\n      else\n      begin\n        var newChar := Chr(((Ord(ch) - Ord('A') + shiftAmount) mod 26) + Ord('A'));\n        encodedStr += newChar;\n      end;\n    end\n    else\n      encodedStr += ch;\n  end;\n  Result := encodedStr;\nend;"
  },
  {
    "instruction": "Write a function that accepts a string and a character. The function should return the index of the first occurrence of the character in the string. If the character is not found, the function should return -1.",
    "output": "function FindCharIndex(s: string; c: char): integer;\nbegin\n  for var i := 1 to s.Length do\n    if s[i] = c then\n    begin\n      Result := i;\n      exit;\n    end;\n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to find the intersection of two sorted lists.",
    "output": "function SortedListIntersection(list1: array of integer; list2: array of integer): array of integer;\nbegin\n  var intersection := new List<integer>;\n  var i := 0;\n  var j := 0;\n  \n  while (i < list1.Length) and (j < list2.Length) do\n  begin\n    if list1[i] = list2[j] then\n    begin\n      intersection.Add(list1[i]);\n      i += 1;\n      j += 1;\n    end\n    else if list1[i] < list2[j] then\n      i += 1\n    else\n      j += 1;\n  end;\n  \n  Result := intersection.ToArray();\nend;"
  },
  {
    "instruction": "Write a function to convert a string of digits into the integer it represents. However, the function should handle string representations of both positive and negative numbers, where the negative numbers are represented with a '-' sign at the beginning of the string.",
    "output": "function StringToInteger(s: string): integer;\nbegin\n  if s[1] = '-' then\n    Result := -StrToInt(s.Substring(2))\n  else\n    Result := StrToInt(s);\nend;"
  },
  {
    "instruction": "Write a function to return the maximum profit you can achieve from trading stocks given the stock prices. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the condition that you must sell the stock before you buy again.",
    "output": "function StockTrading(prices: array of integer): integer;\nbegin\n  var maxProfit := 0;\n  for var i := 1 to prices.Length - 1 do\n    if prices[i] > prices[i - 1] then\n      maxProfit += prices[i] - prices[i - 1];\n  Result := maxProfit;\nend;"
  },
  {
    "instruction": "Write a function to generate all possible n-pairs of a given list of numbers. An n-pair is a subset of the list with exactly n elements.",
    "output": "procedure GenerateCombination(start: integer; current: List<integer>; n: integer; nums: array of integer; combinations: List<array of integer>);\nbegin\n  if current.Count = n then\n  begin\n    combinations.Add(current.ToArray());\n    exit;\n  end;\n  \n  for var i := start to nums.Length - 1 do\n  begin\n    current.Add(nums[i]);\n    GenerateCombination(i + 1, current, n, nums, combinations);\n    current.RemoveAt(current.Count - 1);\n  end;\nend;\n\nfunction GenerateNPairs(nums: array of integer; n: integer): array of array of integer;\nbegin\n  var combinations := new List<array of integer>;\n  GenerateCombination(0, new List<integer>, n, nums, combinations);\n  Result := combinations.ToArray();\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of Fibonacci numbers whose sum is equal to the given number. The same Fibonacci number can be used multiple times.",
    "output": "function FindFibonacciNumbers(n: integer): integer;\nbegin\n  var fib := new List<integer>;\n  fib.Add(1);\n  fib.Add(1);\n  while fib[fib.Count - 1] < n do\n    fib.Add(fib[fib.Count - 1] + fib[fib.Count - 2]);\n  \n  var count := 0;\n  var i := fib.Count - 1;\n  var tempN := n;\n  \n  while (tempN > 0) and (i >= 0) do\n  begin\n    while tempN >= fib[i] do\n    begin\n      tempN -= fib[i];\n      count += 1;\n    end;\n    i -= 1;\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to calculate the number of matches that can be played in a round robin tournament given the number of participating teams. In a round robin tournament, each team plays every other team exactly once.",
    "output": "function MatchesInTournament(teams: integer): integer;\nbegin\n  Result := teams * (teams - 1) div 2;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum height trees in a given undirected graph represented as a list of edges.",
    "output": "function FindMinHeightTrees(n: integer; edges: array of (integer, integer)): array of integer;\nbegin\n  if n = 0 then\n  begin\n    Result := new integer[0];\n    exit;\n  end;\n\n  var res := new List<integer>;\n  if n <= 2 then\n  begin\n    for var i := 0 to n - 1 do\n      res.Add(i);\n    Result := res.ToArray();\n    exit;\n  end;\n\n  var adjList := new Dictionary<integer, List<integer>>;\n  for var i := 0 to n - 1 do\n    adjList[i] := new List<integer>;\n\n  var degree := ArrFill(n, 0);\n  \n  foreach var (u, v) in edges do\n  begin\n    adjList[u].Add(v);\n    adjList[v].Add(u);\n    degree[u] += 1;\n    degree[v] += 1;\n  end;\n\n  var nodeQueue := new Queue<integer>;\n  for var i := 0 to n - 1 do\n    if degree[i] = 1 then\n      nodeQueue.Enqueue(i);\n\n  var remainingNodes := n;\n  while remainingNodes > 2 do\n  begin\n    var length := nodeQueue.Count;\n    remainingNodes -= length;\n    \n    for var x := 0 to length - 1 do\n    begin\n      var a := nodeQueue.Dequeue();\n      foreach var neighbor in adjList[a] do\n      begin\n        degree[neighbor] -= 1;\n        if degree[neighbor] = 1 then\n          nodeQueue.Enqueue(neighbor);\n      end;\n    end;\n  end;\n\n  while nodeQueue.Count > 0 do\n    res.Add(nodeQueue.Dequeue());\n  \n  Result := res.ToArray();\nend;"
  },
  {
    "instruction": "Write a function to check if the given list of integers is a valid permutation of the first N natural numbers.",
    "output": "function ValidPermutation(list1: array of integer): boolean;\nbegin\n  var sortedList := list1.OrderBy(x -> x).ToArray();\n  for var i := 0 to sortedList.Length - 1 do\n    if sortedList[i] <> i + 1 then\n    begin\n      Result := False;\n      exit;\n    end;\n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function named `get_longest_palindrome` that takes a string as input and returns the longest palindromic substring in the string. A palindrome is a word, phrase, number, or other sequence of characters that reads the same backward or forward. Examples of palindromes are \"racecar\", \"madam\", and \"12321\".",
    "output": "function GetLongestPalindrome(s: string): string;\nbegin\n  if s.Length = 0 then\n  begin\n    Result := '';\n    exit;\n  end;\n  \n  var maxLength := 1;\n  var start := 1;\n  \n  for var i := 1 to s.Length do\n  begin\n    if (i - maxLength >= 1) and \n       (s.Substring(i - maxLength - 1, maxLength + 1) = \n        string.Create(s.Substring(i - maxLength - 1, maxLength + 1).Reverse().ToArray())) then\n    begin\n      start := i - maxLength - 1;\n      maxLength += 2;\n      continue;\n    end;\n    \n    if (i - maxLength >= 0) and \n       (s.Substring(i - maxLength, maxLength + 1) = \n        string.Create(s.Substring(i - maxLength, maxLength + 1).Reverse().ToArray())) then\n    begin\n      start := i - maxLength;\n      maxLength += 1;\n    end;\n  end;\n  \n  Result := s.Substring(start, maxLength);\nend;"
  },
  {
    "instruction": "Write a function to find the largest number in a list of integers using a heap data structure.",
    "output": "function MaxHeapLargest(nums: array of integer): integer;\nbegin\n  var heap := new SortedSet<integer>(Comparer&<integer>.Create((x, y) -> y.CompareTo(x)));\n  foreach var num in nums do\n    heap.Add(num);\n  Result := heap.Max;\nend;"
  },
  {
    "instruction": "Write a function to check whether it is possible to make the given string a valid parentheses string by adding the minimum number of parentheses. The function should return the minimum number of parentheses that need to be added.",
    "output": "function MinAddToMakeValid(S: string): integer;\nbegin\n  var stack := new Stack<char>;\n  var cnt := 0;\n  foreach var ch in S do\n  begin\n    if ch = '(' then\n      stack.Push(ch)\n    else if stack.Count = 0 then\n      cnt += 1\n    else\n      stack.Pop();\n  end;\n  Result := stack.Count + cnt;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of unique elements in a list.",
    "output": "function MaxUniqueElements(nums: array of integer): integer;\nbegin\n  var uniqueElements := new HashSet<integer>(nums);\n  Result := uniqueElements.Count;\nend;"
  },
  {
    "instruction": "Write a function to check if a given string is a valid parenthesis sequence.",
    "output": "function IsValidParenthesis(s: string): boolean;\nbegin\n  var stack := new Stack<char>;\n  var mapping := new Dictionary<char, char>;\n  mapping[')'] := '(';\n  mapping['}'] := '{';\n  mapping[']'] := '[';\n\n  foreach var ch in s do\n  begin\n    if mapping.ContainsKey(ch) then\n    begin\n      var topElement := if stack.Count > 0 then stack.Pop() else '#';\n      if mapping[ch] <> topElement then\n      begin\n        Result := False;\n        exit;\n      end;\n    end\n    else\n      stack.Push(ch);\n  end;\n\n  Result := stack.Count = 0;\nend;"
  },
  {
    "instruction": "Write a function to find the number of unique characters in a string.",
    "output": "function UniqueChars(s: string): integer;\nbegin\n  var uniqueChars := new HashSet<char>;\n  foreach var ch in s do\n    uniqueChars.Add(ch);\n  Result := uniqueChars.Count;\nend;"
  },
  {
    "instruction": "Write a function to find the number of unique binary search trees (BSTs) that store values 1...n.",
    "output": "function CountUniqueBsts(n: integer): integer;\nbegin\n  var dp := ArrFill(n + 1, 0);\n  dp[0] := 1;\n  dp[1] := 1;\n\n  for var i := 2 to n do\n    for var j := 0 to i - 1 do\n      dp[i] += dp[j] * dp[i - j - 1];\n\n  Result := dp[n];\nend;"
  },
  {
    "instruction": "Write a function to determine if a given string is a valid URL or not using regex.",
    "output": "function CheckURL(url: string): string;\nbegin\n  var regex := new Regex('^(?:http|ftp)s?://' +\n    '(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|' +\n    'localhost|' +\n    '\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})' +\n    '(?::\\d+)?' +\n    '(?:/?|[/?]\\S+)$', RegexOptions.IgnoreCase);\n\n  if regex.IsMatch(url) then\n    Result := 'Valid URL'\n  else\n    Result := 'Invalid URL';\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest common subarray between two given arrays.",
    "output": "function LongestCommonSubarray(nums1: array of integer; nums2: array of integer): integer;\nbegin\n  var subArray1 := new List<string>;\n  var subArray2 := new List<string>;\n  var temp := '';\n  \n  for var i := 0 to nums1.Length - 1 do\n  begin\n    temp := nums1[i].ToString();\n    subArray1.Add(temp);\n\n    for var j := i + 1 to nums1.Length - 1 do\n    begin\n      temp += '->' + nums1[j].ToString();\n      subArray1.Add(temp);\n    end;\n    temp := '';\n  end;\n\n  for var i := 0 to nums2.Length - 1 do\n  begin\n    temp := nums2[i].ToString();\n    subArray2.Add(temp);\n\n    for var j := i + 1 to nums2.Length - 1 do\n    begin\n      temp += '->' + nums2[j].ToString();\n      subArray2.Add(temp);\n    end;\n    temp := '';\n  end;\n\n  var ans := new List<string>;\n  foreach var i in subArray1 do\n    if subArray2.Contains(i) then\n      ans.Add(i);\n\n  if ans.Count = 0 then\n    Result := 0\n  else\n  begin\n    var newLis := ans.OrderByDescending(k -> k.Length).ToArray();\n    var actualAns := newLis[0].Split(|'->'|, System.StringSplitOptions.RemoveEmptyEntries)\n      .Select(x -> StrToInt(x)).ToArray();\n    Result := actualAns.Length;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the balanced index in a list. The balanced index is an index where the sum of the elements at lower indexes is equal to the sum of the elements at higher indexes.",
    "output": "function BalancedIndex(arr: array of integer): integer;\nbegin\n  for var i := 0 to arr.Length - 1 do\n  begin\n    var leftSum := arr[0:i].Sum();\n    var rightSum := arr[i+1:arr.Length].Sum();\n    if leftSum = rightSum then\n    begin\n      Result := i;\n      exit;\n    end;\n  end;\n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of numbers and returns a list with the sum of adjacent numbers.",
    "output": "function SumAdjacent(numbers: array of integer): array of integer;\nbegin\n  var res := new List<integer>;\n  for var i := 0 to numbers.Length - 2 do\n    res.Add(numbers[i] + numbers[i + 1]);\n  Result := res.ToArray();\nend;"
  },
  {
    "instruction": "Write a function to find a pair of numbers from the given list that adds up to a specific target sum.",
    "output": "function FindPair(arr: array of integer; targetSum: integer): array of integer;\nbegin\n  var hashSet := new HashSet<integer>;\n  foreach var num in arr do\n  begin\n    var complement := targetSum - num;\n    if hashSet.Contains(complement) then\n    begin\n      Result := [complement, num];\n      exit;\n    end;\n    hashSet.Add(num);\n  end;\n  Result := new integer[0];\nend;"
  },
  {
    "instruction": "Write a function to calculate the total number of uppercase letters in a string.",
    "output": "function UppercaseCount(inputString: string): integer;\nbegin\n  var count := 0;\n  foreach var ch in inputString do\n    if ch.IsUpper then\n      count += 1;\n  Result := count;\nend;"
  },
  {
    "instruction": "Create a function to check if a given list of integers contains a subarray with a sum of zero.",
    "output": "function ZeroSumSubarray(arr: array of integer): boolean;\nbegin\n  var s := new HashSet<integer>;\n  s.Add(0);\n  var sum := 0;\n  for var i := 0 to arr.Length - 1 do\n  begin\n    sum += arr[i];\n    if s.Contains(sum) then\n    begin\n      Result := True;\n      exit;\n    end;\n    s.Add(sum);\n  end;\n  Result := False;\nend;"
  },
  {
    "instruction": "Write a function to calculate the probability of two boxes having the same number of distinct balls given a list of balls of different colors. The balls are distributed between the two boxes in all possible ways, and the probability is calculated based on the number of valid distributions.",
    "output": "function Factorial(n: integer): integer;\nbegin\n  Result := 1;\n  for var i := 2 to n do\n    Result *= i;\nend;\n\nfunction Comb(n: integer; m: integer): integer;\nbegin\n  Result := Factorial(n) div (Factorial(m) * Factorial(n - m));\nend;\n\nprocedure F(i: integer; n1: integer; n2: integer; c1: integer; c2: integer; j: integer; balls: array of integer; var res: integer);\nbegin\n  if (n1 > balls.Sum() div 2) or ((i - n1) > balls.Sum() div 2) then\n    exit;\n  if i = balls.Length then\n  begin\n    if (n1 = n2) and (c1 = c2) then\n      res += j;\n    exit;\n  end;\n  var x := balls[i];\n  for var k := 0 to x do\n    F(i + 1, n1 + k, n2 + (x - k), c1 + Ord(k <> 0), c2 + Ord(k <> x), j * Comb(x, k), balls, res);\nend;\n\nfunction GetProbability(balls: array of integer): real;\nbegin\n  var n := balls.Sum();\n  var total := Factorial(n) div (Factorial(n div 2) * Factorial(n div 2));\n  var res := 0;\n  F(0, 0, 0, 0, 0, 1, balls, res);\n  Result := res / total;\nend;"
  },
  {
    "instruction": "Write a function to find the second highest number in a given list of integers.",
    "output": "function SecondHighest(numbers: array of integer): integer;\nbegin\n  var uniqueNumbers := numbers.Distinct().ToArray();\n  if uniqueNumbers.Length < 2 then\n    Result := 0\n  else\n  begin\n    &Array.Sort(uniqueNumbers);\n    Result := uniqueNumbers[uniqueNumbers.Length - 2];\n  end;\nend;"
  },
  {
    "instruction": "Write a function to check if a given triplet of numbers forms a Pythagorean triplet. A Pythagorean triplet consists of three positive integers a, b, and c, such that a^2 + b^2 = c^2.",
    "output": "function IsPythagoreanTriplet(a: integer; b: integer; c: integer): boolean;\nbegin\n  Result := a * a + b * b = c * c;\nend;"
  },
  {
    "instruction": "Write a function to find the largest overlap between two binary matrices. A binary matrix is a matrix where all elements are 0 or 1. The overlap is the largest number of ones shared by the two matrices when one matrix is shifted in any direction (up, down, left, right) relative to the other matrix.",
    "output": "function LargestOverlap(img1: array[,] of integer; img2: array[,] of integer): integer;\nbegin\n  var bestMax := 0;\n  var img1Ones := new List<(integer, integer)>;\n  var img2Ones := new List<(integer, integer)>;\n  var shiftCount := new Dictionary<(integer, integer), integer>;\n\n  for var i := 0 to img1.GetLength(0) - 1 do\n    for var j := 0 to img1.GetLength(1) - 1 do\n    begin\n      if img1[i, j] = 1 then\n        img1Ones.Add((i, j));\n      if img2[i, j] = 1 then\n        img2Ones.Add((i, j));\n    end;\n\n  foreach var (r1, c1) in img1Ones do\n    foreach var (r2, c2) in img2Ones do\n    begin\n      var rowShift := r1 - r2;\n      var colShift := c1 - c2;\n      var key := (rowShift, colShift);\n      if shiftCount.ContainsKey(key) then\n        shiftCount[key] += 1\n      else\n        shiftCount[key] := 1;\n      bestMax := Max(bestMax, shiftCount[key]);\n    end;\n\n  Result := bestMax;\nend;"
  },
  {
    "instruction": "Write a function that takes a string as an argument and returns the string with all spaces removed.",
    "output": "function RemoveSpaces(inputString: string): string;\nbegin\n  Result := inputString.Replace(' ', '');\nend;"
  },
  {
    "instruction": "Write a function to find the maximum consecutive repetition of a character in a given string.",
    "output": "function MaxConsecutiveRepetition(s: string): integer;\nbegin\n  if s.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  var maxRepeat := 1;\n  var currentRepeat := 1;\n  for var i := 2 to s.Length do\n  begin\n    if s[i] = s[i - 1] then\n    begin\n      currentRepeat += 1;\n      maxRepeat := Max(maxRepeat, currentRepeat);\n    end\n    else\n      currentRepeat := 1;\n  end;\n  Result := maxRepeat;\nend;"
  },
  {
    "instruction": "Write a function to find the nth Catalan number. Catalan numbers are a sequence of natural numbers that have many applications in combinatorial mathematics, including the number of correct bracket sequences of length 2n, the number of rooted binary trees with n+1 leaves, and the number of ways a convex polygon with n+2 sides can be cut into triangles by connecting vertices with straight lines.",
    "output": "function CatalanNumber(n: integer): integer;\nbegin\n  var catalan := ArrFill(n + 1, 0);\n  catalan[0] := 1;\n  if n > 0 then\n    catalan[1] := 1;\n  for var i := 2 to n do\n  begin\n    catalan[i] := 0;\n    for var j := 0 to i - 1 do\n      catalan[i] := catalan[i] + catalan[j] * catalan[i - j - 1];\n  end;\n  Result := catalan[n];\nend;"
  },
  {
    "instruction": "Write a function to find the symmetric difference between two sets.",
    "output": "function SymmetricDiff(set1: HashSet<integer>; set2: HashSet<integer>): HashSet<integer>;\nbegin\n  Result := new HashSet<integer>(set1);\n  Result.SymmetricExceptWith(set2);\nend;"
  },
  {
    "instruction": "Write a function that checks if it's possible to divide a list of integers into two groups such that the sum of the first group is equal to the sum of the second group.",
    "output": "function CanDivideIntoTwoEqualGroups(nums: array of integer): boolean;\nbegin\n  var total := nums.Sum();\n  if total mod 2 <> 0 then\n  begin\n    Result := False;\n    exit;\n  end;\n  var target := total div 2;\n  var n := nums.Length;\n  var dp := new boolean[target + 1];\n  dp[0] := True;\n  \n  for var i := 0 to n - 1 do\n    for var j := target downto nums[i] do\n      if dp[j - nums[i]] then\n        dp[j] := True;\n  \n  Result := dp[target];\nend;"
  },
  {
    "instruction": "Write a function to determine if a string is a palindrome ignoring case, spaces, and punctuation.",
    "output": "function IsPalindromeIgnoreCaseSpacePunctuation(s: string): boolean;\nbegin\n  var cleaned := Regex.Replace(s, '\\W+', '').ToLower();\n  var reversed := string.Create(cleaned.Reverse().ToArray());\n  Result := cleaned = reversed;\nend;"
  },
  {
    "instruction": "Write a function to find the number of times a given pattern appears in a string. The pattern can have wildcards represented by the '*' character, which can match any sequence of characters (including an empty sequence).",
    "output": "function CountPatternOccurrences(text: string; pattern: string): integer;\nbegin\n  pattern := pattern.Replace('*', '.*');\n  var regex := new Regex(pattern);\n  var matches := regex.Matches(text);\n  Result := matches.Count;\nend;"
  },
  {
    "instruction": "Write a function to find the largest number in a binary tree.",
    "output": "type\n  TreeNode = class\n    val: integer;\n    left, right: TreeNode;\n    constructor(v: integer; l: TreeNode := nil; r: TreeNode := nil);\n    begin\n      val := v;\n      left := l;\n      right := r;\n    end;\n  end;\n\nfunction LargestInTree(root: TreeNode): integer;\nbegin\n  if root = nil then\n  begin\n    Result := integer.MinValue;\n    exit;\n  end;\n  var maxValue := root.val;\n  var leftMax := LargestInTree(root.left);\n  var rightMax := LargestInTree(root.right);\n  if leftMax > maxValue then\n    maxValue := leftMax;\n  if rightMax > maxValue then\n    maxValue := rightMax;\n  Result := maxValue;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum product of lengths of two words that do not share any common letters.",
    "output": "function MaxWordProduct(words: array of string): integer;\nbegin\n  var sortedWords := words.OrderByDescending(w -> w.Length).ToArray();\n  var ans := 0;\n  for var i := 0 to sortedWords.Length - 1 do\n    for var j := i + 1 to sortedWords.Length - 1 do\n    begin\n      var set1 := new HashSet<char>(sortedWords[i]);\n      var set2 := new HashSet<char>(sortedWords[j]);\n      set1.IntersectWith(set2);\n      if set1.Count = 0 then\n        ans := Max(ans, sortedWords[i].Length * sortedWords[j].Length);\n    end;\n  Result := ans;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest sub-array length with a sum at least as large as the given target value from the given array of positive integers.",
    "output": "function SmallestSubArray(nums: array of integer; target: integer): integer;\nbegin\n  var n := nums.Length;\n  var minLen := n + 1;\n  var left := 0;\n  var currentSum := 0;\n\n  for var right := 0 to n - 1 do\n  begin\n    currentSum += nums[right];\n    while currentSum >= target do\n    begin\n      minLen := Min(minLen, right - left + 1);\n      currentSum -= nums[left];\n      left += 1;\n    end;\n  end;\n\n  Result := if minLen <= n then minLen else 0;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum difference between any item from one array and any item from another array.",
    "output": "function MinDifference(arr1: array of integer; arr2: array of integer): integer;\nbegin\n  &Array.Sort(arr1);\n  &Array.Sort(arr2);\n  var i := 0;\n  var j := 0;\n  var minDiff := integer.MaxValue;\n  while (i < arr1.Length) and (j < arr2.Length) do\n  begin\n    minDiff := Min(minDiff, Abs(arr1[i] - arr2[j]));\n    if arr1[i] < arr2[j] then\n      i += 1\n    else\n      j += 1;\n  end;\n  Result := minDiff;\nend;"
  },
  {
    "instruction": "Write a function to calculate the sum of all the elements in a given list of integers using a lambda function.",
    "output": "function SumOfElements(inputList: array of integer): integer;\nbegin\n  Result := inputList.Sum();\nend;"
  },
  {
    "instruction": "Write a function to find the largest and second largest numbers in a given list of integers.",
    "output": "function FindLargestAndSecondLargest(arr: array of integer): (integer, integer);\nbegin\n  var uniqueArr := arr.Distinct().ToArray();\n  if uniqueArr.Length < 2 then\n    Result := (0, 0)\n  else\n  begin\n    &Array.Sort(uniqueArr);\n    Result := (uniqueArr[uniqueArr.Length - 1], uniqueArr[uniqueArr.Length - 2]);\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum profit that can be obtained by buying and selling stocks given a list of daily prices. The function should return the maximum profit that can be achieved, assuming you can only make one transaction (i.e., buy one and sell one share of the stock), and you must buy before you sell.",
    "output": "function CalculateMaxProfit(prices: array of integer): integer;\nbegin\n  if prices.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  var minPrice := prices[0];\n  var maxProfit := 0;\n  foreach var price in prices do\n  begin\n    minPrice := Min(minPrice, price);\n    var profit := price - minPrice;\n    maxProfit := Max(maxProfit, profit);\n  end;\n  Result := maxProfit;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of points that can be made collinear from a given list of points.",
    "output": "function MaxCollinearPoints(points: array of (real, real)): integer;\n\n  function CalcSlope(x1: real; x2: real; y1: real; y2: real): real;\n  begin\n    if x1 = x2 then\n      Result := real.PositiveInfinity\n    else\n      Result := (y2 - y1) / (x2 - x1);\n  end;\n\nbegin\n  var res := 1;\n  for var index1 := 0 to points.Length - 1 do\n  begin\n    var slopes := new Dictionary<real, integer>;\n    var maxPoints := 1;\n    var (x1, y1) := points[index1];\n    for var index2 := index1 + 1 to points.Length - 1 do\n    begin\n      var (x2, y2) := points[index2];\n      var slope := CalcSlope(x1, x2, y1, y2);\n      if slopes.ContainsKey(slope) then\n        slopes[slope] += 1\n      else\n        slopes[slope] := 1;\n      maxPoints := Max(maxPoints, 1 + slopes[slope]);\n    end;\n    res := Max(res, maxPoints);\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function that converts a given number from base 10 to base 8 (octal) without using the built-in functions.",
    "output": "function ConvertToOctal(num: integer): string;\nbegin\n  if num = 0 then\n  begin\n    Result := '0';\n    exit;\n  end;\n  var octal := '';\n  var tempNum := num;\n  while tempNum > 0 do\n  begin\n    octal := (tempNum mod 8).ToString() + octal;\n    tempNum := tempNum div 8;\n  end;\n  Result := octal;\nend;"
  },
  {
    "instruction": "Write a function to find the highest product of three numbers from a list of integers.",
    "output": "function HighestProduct(arr: array of integer): integer;\nbegin\n  if arr.Length < 3 then\n    raise new Exception('Input array must have at least 3 elements');\n  \n  &Array.Sort(arr);\n  var n := arr.Length;\n  Result := Max(arr[n-1] * arr[n-2] * arr[n-3], arr[0] * arr[1] * arr[n-1]);\nend;"
  },
  {
    "instruction": "Write a function to find the sum of the cubes of the first n natural numbers.",
    "output": "function CubeSum(n: integer): integer;\nbegin\n  var sum := 0;\n  for var i := 1 to n do\n    sum += i * i * i;\n  Result := sum;\nend;"
  },
  {
    "instruction": "Implement a function that takes an array of integers and returns the first pair of integers that add up to a given sum. If no such pair exists, return an empty array.",
    "output": "function FindPair(arr: array of integer; target: integer): array of integer;\nbegin\n  var seen := new HashSet<integer>;\n  foreach var num in arr do\n  begin\n    var complement := target - num;\n    if seen.Contains(complement) then\n    begin\n      Result := [complement, num];\n      exit;\n    end;\n    seen.Add(num);\n  end;\n  Result := new integer[0];\nend;"
  },
  {
    "instruction": "Write a function that converts a number into a list of its digits, plus the count of digits it contains. It also reverses the order of digits.",
    "output": "function NumberToList(n: integer): (array of integer, integer);\nbegin\n  if n = 0 then\n  begin\n    Result := ([0], 1);\n    exit;\n  end;\n  var tempN := Abs(n);\n  var digits := new List<integer>;\n  while tempN > 0 do\n  begin\n    digits.Add(tempN mod 10);\n    tempN := tempN div 10;\n  end;\n  Result := (digits.ToArray(), digits.Count);\nend;"
  },
  {
    "instruction": "Write a function to merge k sorted lists into a single sorted list. Each list is sorted in ascending order. The function should merge these lists and return the merged list which should also be in ascending order.",
    "output": "function MergeKLists(arrays: array of array of integer): array of integer;\nbegin\n  var heap := new SortedSet<integer>;\n  foreach var arr in arrays do\n    foreach var i in arr do\n      heap.Add(i);\n  Result := heap.ToArray();\nend;"
  },
  {
    "instruction": "Write a function to find the second largest element in an array of integers.",
    "output": "function FindSecondLargest(arr: array of integer): integer;\nbegin\n  var uniqueArr := arr.Distinct().ToArray();\n  if uniqueArr.Length = 1 then\n    Result := uniqueArr[0]\n  else\n  begin\n    &Array.Sort(uniqueArr);\n    Result := uniqueArr[uniqueArr.Length - 2];\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the number of pairs in an array that have a given sum.",
    "output": "function FindPairsWithSum(arr: array of integer; targetSum: integer): integer;\nbegin\n  var count := 0;\n  var numDict := new Dictionary<integer, integer>;\n  foreach var num in arr do\n  begin\n    if numDict.ContainsKey(targetSum - num) then\n      count += numDict[targetSum - num];\n    if numDict.ContainsKey(num) then\n      numDict[num] += 1\n    else\n      numDict[num] := 1;\n  end;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the first non-repeating character in a given string.",
    "output": "function NonRepeating(s: string): char;\nbegin\n  var charCount := new Dictionary<char, integer>;\n  foreach var c in s do\n  begin\n    if charCount.ContainsKey(c) then\n      charCount[c] += 1\n    else\n      charCount[c] := 1;\n  end;\n  foreach var c in s do\n    if charCount[c] = 1 then\n    begin\n      Result := c;\n      exit;\n    end;\n  Result := #0;\nend;"
  },
  {
    "instruction": "Write a function to find the largest number in the list of integers using a heap data structure.",
    "output": "function HeapMax(lst: array of integer): integer;\nbegin\n  var heap := new SortedSet<integer>(Comparer&<integer>.Create((x, y) -> y.CompareTo(x)));\n  foreach var i in lst do\n    heap.Add(i);\n  Result := heap.Max;\nend;"
  },
  {
    "instruction": "Write a function to find out if a given string is a permutation of a palindrome.",
    "output": "function IsPalindromePermutation(s: string): boolean;\nbegin\n  var cleaned := s.Replace(' ', '').ToLower();\n  var d := new Dictionary<char, integer>;\n  foreach var i in cleaned do\n  begin\n    if d.ContainsKey(i) then\n      d[i] += 1\n    else\n      d[i] := 1;\n  end;\n  var oddCount := 0;\n  foreach var (k, v) in d do\n  begin\n    if v mod 2 <> 0 then\n    begin\n      if oddCount = 0 then\n        oddCount += 1\n      else\n      begin\n        Result := False;\n        exit;\n      end;\n    end;\n  end;\n  Result := True;\nend;"
  },
  {
    "instruction": "Write a function to perform index wise addition of tuple elements in the given two tuples.",
    "output": "function IndexAddition(testTup1: array of (integer, integer); testTup2: array of (integer, integer)): array of (integer, integer);\nbegin\n  var res := new List<(integer, integer)>;\n  for var i := 0 to Min(testTup1.Length, testTup2.Length) - 1 do\n  begin\n    var (a1, b1) := testTup1[i];\n    var (a2, b2) := testTup2[i];\n    res.Add((a1 + a2, b1 + b2));\n  end;\n  Result := res.ToArray();\nend;"
  },
  {
    "instruction": "Write a function to find all possible combinations of numbers from given list which sums up to given target.",
    "output": "function AllCombinationSum(candidates: array of integer; target: integer): array of array of integer;\n\n  procedure Dfs(i: integer; cur: List<integer>; total: integer; var res: List<array of integer>);\n  begin\n    if total = target then\n    begin\n      res.Add(cur.ToArray());\n      exit;\n    end;\n    if (i >= candidates.Length) or (total > target) then\n      exit;\n    cur.Add(candidates[i]);\n    Dfs(i, cur, total + candidates[i], res);\n    cur.RemoveAt(cur.Count - 1);\n    Dfs(i + 1, cur, total, res);\n  end;\n\nbegin\n  var res := new List<array of integer>;\n  Dfs(0, new List<integer>, 0, res);\n  Result := res.ToArray();\nend;"
  },
  {
    "instruction": "Write a function to check if a tic-tac-toe game has a winner. The function should return 1 if 'O' has won, 2 if 'X' has won, 0 if the game is a draw, and -1 if the game is still in progress.",
    "output": "function CheckWinner(board: array of array of char): integer;\nbegin\n  var oCnt := 0;\n  var xCnt := 0;\n  var oFlag := False;\n  var xFlag := False;\n  \n  foreach var line in board do\n  begin\n    var oLine := line.CountOf('O');\n    var xLine := line.CountOf('X');\n    oCnt += oLine;\n    xCnt += xLine;\n    if oLine = 3 then\n      oFlag := True;\n    if xLine = 3 then\n      xFlag := True;\n  end;\n  \n  for var idx := 0 to 2 do\n  begin\n    if (board[0][idx] = 'O') and (board[1][idx] = 'O') and (board[2][idx] = 'O') then\n      oFlag := True\n    else if (board[0][idx] = 'X') and (board[1][idx] = 'X') and (board[2][idx] = 'X') then\n      xFlag := True;\n  end;\n  \n  if ((board[0][0] = 'O') and (board[1][1] = 'O') and (board[2][2] = 'O')) or\n     ((board[0][2] = 'O') and (board[1][1] = 'O') and (board[2][0] = 'O')) then\n    oFlag := True\n  else if ((board[0][0] = 'X') and (board[1][1] = 'X') and (board[2][2] = 'X')) or\n          ((board[0][2] = 'X') and (board[1][1] = 'X') and (board[2][0] = 'X')) then\n    xFlag := True;\n  \n  if oFlag and not xFlag then\n    Result := 1\n  else if xFlag and not oFlag then\n    Result := 2\n  else if oCnt + xCnt = 9 then\n    Result := 0\n  else\n    Result := -1;\nend;"
  },
  {
    "instruction": "Write a function that returns the last element of the longest palindrome subsequence in a given string.",
    "output": "function LastElementOfLongestPalindrome(s: string): char;\nbegin\n  var n := s.Length;\n  var dp := new integer[n, n];\n  for var i := n - 1 downto 0 do\n  begin\n    dp[i, i] := 1;\n    for var j := i + 1 to n - 1 do\n    begin\n      if s[i + 1] = s[j + 1] then\n        dp[i, j] := dp[i + 1, j - 1] + 2\n      else\n        dp[i, j] := Max(dp[i + 1, j], dp[i, j - 1]);\n    end;\n  end;\n  var lastElement := s[1];\n  for var i := 0 to n - 1 do\n    for var j := 0 to n - 1 do\n      if dp[i, j] > dp[0, 0] - 1 then\n        lastElement := s[j + 1];\n  Result := lastElement;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum length of subarray with sum equals to the given value.",
    "output": "function MaxLength(nums: array of integer; k: integer): integer;\nbegin\n  var maxLen := 0;\n  var sumMap := new Dictionary<integer, integer>;\n  sumMap[0] := -1;\n  var currentSum := 0;\n  for var i := 0 to nums.Length - 1 do\n  begin\n    currentSum += nums[i];\n    if not sumMap.ContainsKey(currentSum) then\n      sumMap[currentSum] := i;\n    if sumMap.ContainsKey(currentSum - k) then\n      maxLen := Max(maxLen, i - sumMap[currentSum - k]);\n  end;\n  Result := maxLen;\nend;"
  },
  {
    "instruction": "Write a function to convert infix expression to postfix expression.",
    "output": "function InfixToPostfix(expression: string): string;\nbegin\n  var prec := new Dictionary<char, integer>;\n  prec['*'] := 3;\n  prec['/'] := 3;\n  prec['+'] := 2;\n  prec['-'] := 2;\n  prec['('] := 1;\n  \n  var opStack := new Stack<char>;\n  var postfixList := new List<string>;\n  var tokenList := expression.ToWords();\n\n  foreach var token in tokenList do\n  begin\n    if (token[1] in ['A'..'Z']) or (token[1] in ['0'..'9']) then\n      postfixList.Add(token)\n    else if token = '(' then\n      opStack.Push('(')\n    else if token = ')' then\n    begin\n      var topToken := opStack.Pop();\n      while topToken <> '(' do\n      begin\n        postfixList.Add(topToken.ToString());\n        topToken := opStack.Pop();\n      end;\n    end\n    else\n    begin\n      while (opStack.Count <> 0) and (prec[opStack.Peek()] >= prec[token[1]]) do\n        postfixList.Add(opStack.Pop().ToString());\n      opStack.Push(token[1]);\n    end;\n  end;\n\n  while opStack.Count <> 0 do\n    postfixList.Add(opStack.Pop().ToString());\n  \n  Result := string.Join(' ', postfixList);\nend;"
  },
  {
    "instruction": "Write a function to find the number of occurrences of each character in a string.",
    "output": "function CharCount(s: string): Dictionary<char, integer>;\nbegin\n  var res := new Dictionary<char, integer>;\n  foreach var ch in s do\n  begin\n    if res.ContainsKey(ch) then\n      res[ch] += 1\n    else\n      res[ch] := 1;\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function that calculates the cube root of a non-negative integer using binary search. The function should return the largest integer part of the cube root.",
    "output": "function CubeRoot(x: integer): integer;\nbegin\n  if x < 2 then\n  begin\n    Result := x;\n    exit;\n  end;\n\n  var left := 0;\n  var right := x;\n  while left < right do\n  begin\n    var mid := (left + right) div 2;\n    if mid * mid * mid < x then\n      left := mid + 1\n    else\n      right := mid;\n  end;\n  Result := if left * left * left > x then left - 1 else left;\nend;"
  },
  {
    "instruction": "Write a function that takes a string as input and returns a new string where each character's case is swapped. Lowercase characters become uppercase and uppercase characters become lowercase.",
    "output": "function CaseSwap(inputString: string): string;\nbegin\n  var res := new StringBuilder;\n  foreach var ch in inputString do\n  begin\n    if ch.IsLower then\n      res.Append(ch.ToUpper)\n    else if ch.IsUpper then\n      res.Append(ch.ToLower)\n    else\n      res.Append(ch);\n  end;\n  Result := res.ToString;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the last word in a given string.",
    "output": "function LengthOfLastWord(s: string): integer;\nbegin\n  var length := s.Length;\n  if ' ' not in s then\n  begin\n    Result := length;\n    exit;\n  end;\n  for var i := length downto 1 do\n  begin\n    if s[i] <> ' ' then\n    begin\n      for var x := i downto 1 do\n      begin\n        if s[x] = ' ' then\n        begin\n          Result := i - x;\n          exit;\n        end;\n      end;\n      Result := i;\n      exit;\n    end;\n  end;\n  Result := 0;\nend;"
  },
  {
    "instruction": "Write a function that takes a string and returns a new string with the characters in reverse order. However, the function should not reverse the order of the words within the string.",
    "output": "function ReverseCharOrder(text: string): string;\nbegin\n  var words := text.ToWords();\n  var reversedText := '';\n  foreach var word in words do\n  begin\n    var reversedWord := string.Create(word.Reverse().ToArray());\n    reversedText += reversedWord + ' ';\n  end;\n  Result := reversedText.Trim();\nend;"
  },
  {
    "instruction": "Write a function to check if a given number is a Disarium number or not.\nA number is said to be a Disarium number if the sum of its digits raised to the power of their respective positions is equal to the number itself. For example, 135 is a Disarium number because 1^1 + 3^2 + 5^3 = 1 + 9 + 125 = 135.",
    "output": "function IsDisarium(number: integer): boolean;\nbegin\n  var numStr := number.ToString();\n  var sum := 0;\n  for var i := 1 to numStr.Length do\n  begin\n    var digit := StrToInt(numStr[i]);\n    sum += Round(Power(digit, i));\n  end;\n  Result := sum = number;\nend;"
  },
  {
    "instruction": "Write a function that takes a positive integer and returns the count of digits from the right until a digit larger than the rightmost digit is encountered.",
    "output": "function FindDigitCount(num: integer): integer;\nbegin\n  if num < 10 then\n  begin\n    Result := -1;\n    exit;\n  end;\n  var rightmost := num mod 10;\n  var count := 0;\n  num := num div 10;\n  while num > 0 do\n  begin\n    count += 1;\n    var currentDigit := num mod 10;\n    if currentDigit > rightmost then\n    begin\n      Result := count;\n      exit;\n    end;\n    num := num div 10;\n  end;\n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function that determines if a given string can be decoded into a valid sequence of letters using a standard phone keypad mapping. In the standard phone keypad, each digit maps to a set of letters as follows:\n- 2: ABC\n- 3: DEF\n- 4: GHI\n- 5: JKL\n- 6: MNO\n- 7: PQRS\n- 8: TUV\n- 9: WXYZ\nA string can be decoded if it can be split into a sequence of non-overlapping substrings, each of which can be mapped to a single letter using the phone keypad mapping. The function should return True if the string can be decoded, and False otherwise.",
    "output": "function CanDecode(s: string): boolean;\nbegin\n  var keypad := new Dictionary<integer, integer>;\n  keypad[2] := 3;\n  keypad[3] := 3;\n  keypad[4] := 3;\n  keypad[5] := 3;\n  keypad[6] := 3;\n  keypad[7] := 4;\n  keypad[8] := 3;\n  keypad[9] := 4;\n  \n  var n := s.Length;\n  var dp := ArrFill(n + 1, False);\n  dp[0] := True;\n  \n  for var i := 1 to n do\n  begin\n    for var j := 1 to Min(4, i) do\n    begin\n      if (i - j >= 0) and dp[i - j] then\n      begin\n        var substr := s.Substring(i - j, j);\n        if substr.All(ch -> ch = substr[1]) and \n           (substr[1] in ['2'..'9']) and \n           (j <= keypad[StrToInt(substr[1])]) then\n        begin\n          dp[i] := True;\n          break;\n        end;\n      end;\n    end;\n  end;\n  \n  Result := dp[n];\nend;"
  },
  {
    "instruction": "Write a function to find the minimum length of a subarray such that all the types of gems are present in that subarray. Gems are represented by strings.",
    "output": "function FindMinLength(gems: array of string): integer;\nbegin\n  var gemTypes := new HashSet<string>(gems);\n  var gemCount := new Dictionary<string, integer>;\n  var start := 0;\n  var minLength := integer.MaxValue;\n  for var endIdx := 0 to gems.Length - 1 do\n  begin\n    if gemCount.ContainsKey(gems[endIdx]) then\n      gemCount[gems[endIdx]] += 1\n    else\n      gemCount[gems[endIdx]] := 1;\n    while gemCount.Count = gemTypes.Count do\n    begin\n      minLength := Min(minLength, endIdx - start + 1);\n      gemCount[gems[start]] -= 1;\n      if gemCount[gems[start]] = 0 then\n        gemCount.Remove(gems[start]);\n      start += 1;\n    end;\n  end;\n  Result := if minLength <> integer.MaxValue then minLength else 0;\nend;"
  },
  {
    "instruction": "Write a function that converts a number from a given base to base 10. The function should support bases up to 36 (i.e., 0-9 and A-Z as digits).",
    "output": "function ConvertToDecimal(number: string; base: integer): integer;\nbegin\n  var digits := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  var answer := 0;\n  for var i := 1 to number.Length do\n  begin\n    var pos := number.Length - i;\n    var num := digits.IndexOf(number[i]);\n    answer += num * Round(Power(base, pos));\n  end;\n  Result := answer;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest substring containing all unique characters from a given string.",
    "output": "function FindSmallestUniqueSubstring(s: string): string;\nbegin\n  var uniqueChars := new HashSet<char>(s);\n  var types := uniqueChars.Count;\n  var length := s.Length;\n  var l := 1;\n  var r := 1;\n  var ansl := 1;\n  var ansr := length;\n  var current := new Dictionary<char, integer>;\n  current[s[1]] := 1;\n  \n  while (l < length) and (r < length) do\n  begin\n    if current.Count < types then\n    begin\n      r += 1;\n      if r > length then\n        break;\n      if current.ContainsKey(s[r]) then\n        current[s[r]] += 1\n      else\n        current[s[r]] := 1;\n    end\n    else\n    begin\n      if (r - l) < (ansr - ansl) then\n      begin\n        ansl := l;\n        ansr := r;\n      end;\n      current[s[l]] -= 1;\n      if current[s[l]] = 0 then\n        current.Remove(s[l]);\n      l += 1;\n    end;\n  end;\n  \n  Result := s.Substring(ansl, ansr - ansl + 1);\nend;"
  },
  {
    "instruction": "Write a function that takes a list of tuples, each tuple containing a person's name and their scores in three subjects, and returns a list of tuples containing the name and total score of each person.",
    "output": "function CalculateScores(scores: array of (string, integer, integer, integer)): array of (string, integer);\nbegin\n  var totalScores := new List<(string, integer)>;\n  foreach var score in scores do\n  begin\n    var total := score[1] + score[2] + score[3];\n    totalScores.Add((score[0], total));\n  end;\n  Result := totalScores.ToArray();\nend;"
  },
  {
    "instruction": "Write a function to generate a list that contains the elements of the given list twice.",
    "output": "function DuplicateList(nums: array of integer): array of integer;\nbegin\n  Result := nums + nums;\nend;"
  },
  {
    "instruction": "Write a function to check if the given list of strings are anagrams or not.",
    "output": "function AreAnagrams(strList: array of string): boolean;\nbegin\n  var sortedList := strList.Select(s -> string.Create(s.ToLower().OrderBy(ch -> ch).ToArray())).ToArray();\n  Result := sortedList.Distinct().Count() = 1;\nend;"
  },
  {
    "instruction": "Write a function to find the number of continuous subarrays whose sum equals to k.",
    "output": "function FindContinuousSubarrays(nums: array of integer; k: integer): integer;\nbegin\n  var length := nums.Length;\n  var ans := 0;\n  var dic := new Dictionary<integer, integer>;\n  dic[0] := 1;\n\n  var currentSum := 0;\n  for var i := 0 to length - 1 do\n  begin\n    currentSum += nums[i];\n    var reminder := currentSum - k;\n    if dic.ContainsKey(reminder) then\n      ans += dic[reminder];\n\n    if dic.ContainsKey(currentSum) then\n      dic[currentSum] += 1\n    else\n      dic[currentSum] := 1;\n  end;\n  \n  Result := ans;\nend;"
  },
  {
    "instruction": "Write a function to check if the given string is a valid parentheses string. A valid parentheses string is a string that starts and ends with parentheses and each parentheses is properly closed.",
    "output": "function CheckValidParentheses(s: string): boolean;\nbegin\n  if s.Length mod 2 <> 0 then\n    Result := false\n  else\n  begin\n    var stack := new Stack<char>;\n    for var i := 1 to s.Length do\n    begin\n      var ch := s[i];\n      if ch = '(' then\n        stack.Push(ch)\n      else if ch = ')' then\n      begin\n        if stack.Count = 0 then\n        begin\n          Result := false;\n          exit;\n        end\n        else\n          stack.Pop;\n      end;\n    end;\n    Result := stack.Count = 0;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the second minimum number in a list.",
    "output": "function SecondMin(nums: array of integer): integer;\nbegin\n  var uniqueList := new List<integer>;\n  for var i := 0 to nums.Length - 1 do\n  begin\n    if not uniqueList.Contains(nums[i]) then\n      uniqueList.Add(nums[i]);\n  end;\n  \n  if uniqueList.Count < 2 then\n    Result := -1\n  else\n  begin\n    uniqueList.Sort;\n    Result := uniqueList[1];\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the number of unique words in a given string. A word is considered unique if it does not repeat in the string. Words are separated by spaces.",
    "output": "function NumUniqueWords(s: string): integer;\nbegin\n  var words := s.ToWords;\n  var uniqueWords := new HashSet<string>(words);\n  var repeatWords := new HashSet<string>;\n  \n  for var i := 0 to words.Length - 1 do\n  begin\n    var count := 0;\n    for var j := 0 to words.Length - 1 do\n    begin\n      if words[i] = words[j] then\n        count += 1;\n    end;\n    if count > 1 then\n      repeatWords.Add(words[i]);\n  end;\n  \n  uniqueWords.ExceptWith(repeatWords);\n  Result := uniqueWords.Count;\nend;"
  },
  {
    "instruction": "Write a function in that checks if a given stack sequence is valid based on a set of operations. The operations include 'push' and 'pop' on a stack, and the function should return True if the sequence of operations is valid, and False otherwise. A stack sequence is valid if every 'pop' operation happens after a corresponding 'push' operation for the same element.",
    "output": "function IsValidStackSequence(operations: array of string): boolean;\nbegin\n  var stack := new Stack<integer>;\n  for var i := 0 to operations.Length - 1 do\n  begin\n    if operations[i].StartsWith('push') then\n    begin\n      var elementStr := operations[i].Substring(5, operations[i].Length - 6);\n      var element := StrToInt(elementStr);\n      stack.Push(element);\n    end\n    else if operations[i].StartsWith('pop') then\n    begin\n      if stack.Count = 0 then\n      begin\n        Result := false;\n        exit;\n      end;\n      stack.Pop;\n    end;\n  end;\n  Result := stack.Count = 0;\nend;"
  },
  {
    "instruction": "Write a function to count the number of ways to partition a positive integer n using positive integers up to m.",
    "output": "function CountPartitions(n, m: integer): integer;\nbegin\n  if n = 0 then\n    Result := 1\n  else if (n < 0) or (m = 0) then\n    Result := 0\n  else\n    Result := CountPartitions(n - m, m) + CountPartitions(n, m - 1);\nend;"
  },
  {
    "instruction": "Write a function to find the largest product of two adjacent elements in a list of integers.",
    "output": "function AdjProduct(nums: array of integer): integer;\nbegin\n  var maxProduct := nums[0] * nums[1];\n  for var i := 1 to nums.Length - 2 do\n  begin\n    maxProduct := Max(maxProduct, nums[i] * nums[i + 1]);\n  end;\n  Result := maxProduct;\nend;"
  },
  {
    "instruction": "Write a function that checks if a given string is a palindrome (reads the same backward as forward) using recursion.",
    "output": "function IsPalindromeRecursive(s: string): boolean;\nbegin\n  if s.Length <= 1 then\n    Result := true\n  else if s[1] <> s[s.Length] then\n    Result := false\n  else\n    Result := IsPalindromeRecursive(s.Substring(2, s.Length - 2));\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of vowels in any substring of the given length.",
    "output": "function MaxVowels(s: string; k: integer): integer;\nbegin\n  var vowels := HSet('a', 'e', 'i', 'o', 'u');\n  var currentVowels := 0;\n  \n  for var i := 1 to k do\n  begin\n    if vowels.Contains(s[i]) then\n      currentVowels += 1;\n  end;\n  \n  var maxVowels := currentVowels;\n  \n  for var i := k + 1 to s.Length do\n  begin\n    if vowels.Contains(s[i]) then\n      currentVowels += 1;\n    if vowels.Contains(s[i - k]) then\n      currentVowels -= 1;\n    maxVowels := Max(maxVowels, currentVowels);\n  end;\n  \n  Result := maxVowels;\nend;"
  },
  {
    "instruction": "Write a function that returns the index of the first occurrence of a substring within a string. If the substring is not found, return -1. Implement this function without using the built-in string methods like IndexOf().",
    "output": "function FindSubstring(haystack, needle: string): integer;\nbegin\n  if needle = '' then\n    Result := 0\n  else\n  begin\n    for var i := 1 to haystack.Length - needle.Length + 1 do\n    begin\n      var found := true;\n      for var j := 1 to needle.Length do\n      begin\n        if haystack[i + j - 1] <> needle[j] then\n        begin\n          found := false;\n          break;\n        end;\n      end;\n      if found then\n      begin\n        Result := i - 1;\n        exit;\n      end;\n    end;\n    Result := -1;\n  end;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns the maximum product that can be obtained by multiplying any three integers from the list.",
    "output": "function MaxProductOfThree(nums: array of integer): integer;\nbegin\n  &Array.Sort(nums);\n  Result := Max(nums[0] * nums[1] * nums[nums.Length - 1], \n               nums[nums.Length - 1] * nums[nums.Length - 2] * nums[nums.Length - 3]);\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to express n as a sum of 1, 3, and 4.",
    "output": "function WaysToExpressNAsSum(n: integer): integer;\nbegin\n  if n = 0 then\n    Result := 1\n  else if n < 0 then\n    Result := 0\n  else\n    Result := WaysToExpressNAsSum(n - 1) + WaysToExpressNAsSum(n - 3) + WaysToExpressNAsSum(n - 4);\nend;\n\nfunction WaysToExpressNAsSumDP(n: integer): integer;\nbegin\n  var dp := new integer[n + 1];\n  dp[0] := 1;\n  for var i := 1 to n do\n  begin\n    if i - 1 >= 0 then\n      dp[i] += dp[i - 1];\n    if i - 3 >= 0 then\n      dp[i] += dp[i - 3];\n    if i - 4 >= 0 then\n      dp[i] += dp[i - 4];\n  end;\n  Result := dp[n];\nend;"
  },
  {
    "instruction": "Write a function to find the maximum length of a subsequence of consecutive 1's in a binary array that can be obtained by flipping at most k 0's to 1's.",
    "output": "function MaxOnesSubsequence(A: array of integer; k: integer): integer;\nbegin\n  var left := 0;\n  var zeros := 0;\n  var maxLength := 0;\n  \n  for var right := 0 to A.Length - 1 do\n  begin\n    if A[right] = 0 then\n      zeros += 1;\n    \n    while zeros > k do\n    begin\n      if A[left] = 0 then\n        zeros -= 1;\n      left += 1;\n    end;\n    \n    maxLength := Max(maxLength, right - left + 1);\n  end;\n  \n  Result := maxLength;\nend;"
  },
  {
    "instruction": "Write a function to find the median of two sorted arrays.",
    "output": "function MedianArrays(nums1, nums2: array of integer): real;\nbegin\n  var combined := new List<integer>;\n  combined.AddRange(nums1);\n  combined.AddRange(nums2);\n  combined.Sort;\n  \n  var length := combined.Count;\n  if length mod 2 = 0 then\n    Result := (combined[length div 2 - 1] + combined[length div 2]) / 2\n  else\n    Result := combined[length div 2];\nend;"
  },
  {
    "instruction": "Write a function to convert a given decimal number to its equivalent in base 8 (octal).",
    "output": "function DecToOct(num: integer): string;\nbegin\n  var isNeg := num < 0;\n  num := Abs(num);\n  var ans := '';\n  \n  if num = 0 then\n  begin\n    Result := '0';\n    exit;\n  end;\n  \n  while num > 0 do\n  begin\n    var remainder := num mod 8;\n    ans := remainder.ToString + ans;\n    num := num div 8;\n  end;\n  \n  if isNeg then\n    Result := '-' + ans\n  else\n    Result := ans;\nend;"
  },
  {
    "instruction": "Write a function to find the largest power of 2 less than or equal to a given number.",
    "output": "function LargestPowerOf2(n: integer): integer;\nbegin\n  var power := 1;\n  while power * 2 <= n do\n    power *= 2;\n  Result := power;\nend;"
  },
  {
    "instruction": "Write a function to find the number of times a number can be divided by 2 before it becomes odd.",
    "output": "function DivideBy2(num: integer): integer;\nbegin\n  var count := 0;\n  while num mod 2 = 0 do\n  begin\n    num := num div 2;\n    count += 1;\n  end;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum absolute difference between the sum of two parts of an array after splitting it at any index.",
    "output": "function MinDiffSplit(A: array of integer): integer;\nbegin\n  var first := A[0];\n  var second := 0;\n  for var i := 1 to A.Length - 1 do\n    second += A[i];\n  \n  var best := Abs(first - second);\n  var p := 2;\n  \n  while p < A.Length do\n  begin\n    first += A[p - 1];\n    second -= A[p - 1];\n    best := Min(best, Abs(first - second));\n    p += 1;\n  end;\n  \n  Result := best;\nend;"
  },
  {
    "instruction": "Write a function to check if a number is a Harshad number. A Harshad number is an integer that is divisible by the sum of its digits.",
    "output": "function CheckHarshadNumber(num: integer): boolean;\nbegin\n  if num <= 0 then\n    Result := false\n  else\n  begin\n    var sumOfDigits := 0;\n    var numStr := num.ToString;\n    for var i := 1 to numStr.Length do\n      sumOfDigits += StrToInt(numStr[i]);\n    \n    Result := num mod sumOfDigits = 0;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the number of unique pairs in a sorted array that sum up to a given target value.",
    "output": "function FindUniquePairs(nums: array of integer; target: integer): integer;\nbegin\n  var left := 0;\n  var right := nums.Length - 1;\n  var pairs := new HashSet<(integer, integer)>;\n  \n  while left < right do\n  begin\n    var currentSum := nums[left] + nums[right];\n    \n    if currentSum = target then\n    begin\n      pairs.Add((nums[left], nums[right]));\n      left += 1;\n      right -= 1;\n    end\n    else if currentSum < target then\n      left += 1\n    else\n      right -= 1;\n  end;\n  \n  Result := pairs.Count;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum subarray sum from a given list of integers.\n\nThe function should take a list of integers as input and return the maximum sum of any contiguous subarray within the list.",
    "output": "function MaxSubarraySum(nums: array of integer): integer;\nbegin\n  var maxSum := integer.MinValue;\n  var currSum := 0;\n  \n  for var i := 0 to nums.Length - 1 do\n  begin\n    currSum := Max(nums[i], currSum + nums[i]);\n    maxSum := Max(maxSum, currSum);\n  end;\n  \n  Result := maxSum;\nend;"
  },
  {
    "instruction": "Write a function to find the largest prime factor from a list of numbers.",
    "output": "function LargestPrimeFactor(numbers: array of integer): integer;\nbegin\n  var primeNumbers := new List<integer>;\n  for var i := 0 to numbers.Length - 1 do\n  begin\n    var num := numbers[i];\n    if num > 1 then\n    begin\n      var isPrime := true;\n      for var j := 2 to num - 1 do\n      begin\n        if num mod j = 0 then\n        begin\n          isPrime := false;\n          break;\n        end;\n      end;\n      if isPrime then\n        primeNumbers.Add(num);\n    end;\n  end;\n  \n  if primeNumbers.Count > 0 then\n    Result := primeNumbers.Max\n  else\n    Result := -1;\nend;"
  },
  {
    "instruction": "Write a function that takes a string and a number of rows as input and returns the string in a zigzag pattern. The zigzag pattern is formed by writing the string in a zigzag pattern across a number of rows, then reading the string row by row.",
    "output": "function NumToSkip(rowNum, numRows: integer): (integer, integer);\nbegin\n  var down := (numRows - rowNum - 1) * 2 - 1;\n  var up := rowNum * 2 - 1;\n  Result := (up + 1, down + 1);\nend;\n\nfunction ZigzagConversion(s: string; numRows: integer): string;\nbegin\n  if numRows = 1 then\n  begin\n    Result := s;\n    exit;\n  end;\n  \n  var resultStr := '';\n  \n  for var firstLetterIndex := 0 to numRows - 1 do\n  begin\n    var (upSkip, downSkip) := NumToSkip(firstLetterIndex, numRows);\n    var goingDown := true;\n    var doNotAppend := false;\n    var cursor := firstLetterIndex;\n    \n    while cursor < s.Length do\n    begin\n      if not doNotAppend then\n        resultStr += s[cursor + 1];\n      doNotAppend := false;\n      \n      if goingDown then\n      begin\n        goingDown := false;\n        if downSkip <= 0 then\n        begin\n          doNotAppend := true;\n          continue;\n        end;\n        cursor += downSkip;\n      end\n      else\n      begin\n        goingDown := true;\n        if upSkip <= 0 then\n        begin\n          doNotAppend := true;\n          continue;\n        end;\n        cursor += upSkip;\n      end;\n    end;\n  end;\n  \n  Result := resultStr;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum and minimum elements in a given array using divide and conquer approach.",
    "output": "function FindMaxMin(arr: array of integer): (integer, integer);\nbegin\n  if arr.Length = 1 then\n    Result := (arr[0], arr[0])\n  else if arr.Length = 2 then\n    Result := (Max(arr[0], arr[1]), Min(arr[0], arr[1]))\n  else\n  begin\n    var mid := arr.Length div 2;\n    var (leftMax, leftMin) := FindMaxMin(arr[:mid]);\n    var (rightMax, rightMin) := FindMaxMin(arr[mid:]);\n    Result := (Max(leftMax, rightMax), Min(leftMin, rightMin));\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the n-th pentagonal number.",
    "output": "function FindPentNum(n: integer): integer;\nbegin\n  Result := n * (3 * n - 1) div 2;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of numbers as input and returns the sum of all the numbers in the list that are not multiples of 3.",
    "output": "function SumNotMultipleOfThree(numbers: array of integer): integer;\nbegin\n  var total := 0;\n  for var i := 0 to numbers.Length - 1 do\n  begin\n    if numbers[i] mod 3 <> 0 then\n      total += numbers[i];\n  end;\n  Result := total;\nend;"
  },
  {
    "instruction": "Create a function to find the kth smallest divisor of a given number. If the kth smallest divisor does not exist, return -1.",
    "output": "function KthSmallestDivisor(n, k: integer): integer;\nbegin\n  var factors := new List<integer>;\n  for var x := 1 to Trunc(Sqrt(n)) do\n  begin\n    if n mod x = 0 then\n    begin\n      k -= 1;\n      if k = 0 then\n      begin\n        Result := x;\n        exit;\n      end\n      else\n        factors.Add(x);\n    end;\n  end;\n  \n  if (factors.Count > 0) and (factors[factors.Count - 1] * factors[factors.Count - 1] = n) then\n    k += 1;\n  \n  var f := factors.Count;\n  if k <= f then\n    Result := n div factors[f - k]\n  else\n    Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest subarray with a sum of zero.",
    "output": "function LongestSubarraySumZero(arr: array of integer): integer;\nbegin\n  var maxLen := 0;\n  var sumMap := new Dictionary<integer, integer>;\n  var currSum := 0;\n  \n  for var i := 0 to arr.Length - 1 do\n  begin\n    currSum += arr[i];\n    \n    if (arr[i] = 0) and (maxLen = 0) then\n      maxLen := 1;\n    \n    if currSum = 0 then\n      maxLen := i + 1;\n    \n    if sumMap.ContainsKey(currSum) then\n      maxLen := Max(maxLen, i - sumMap[currSum])\n    else\n      sumMap[currSum] := i;\n  end;\n  \n  Result := maxLen;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest and second smallest elements in a list.",
    "output": "function SmallestPair(lst: array of integer): (integer, integer);\nbegin\n  var sortedList := lst.ToArray;\n  &Array.Sort(sortedList);\n  Result := (sortedList[0], sortedList[1]);\nend;"
  },
  {
    "instruction": "Create a function that converts a given number to its base 8 representation as a string.",
    "output": "function ConvertToBase8(num: integer): string;\nbegin\n  if num = 0 then\n  begin\n    Result := '0';\n    exit;\n  end;\n  \n  var res := '';\n  var tempNum := Abs(num);\n  \n  while tempNum <> 0 do\n  begin\n    var r := tempNum mod 8;\n    res := r.ToString + res;\n    tempNum := tempNum div 8;\n  end;\n  \n  if num < 0 then\n    Result := '-' + res\n  else\n    Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the number of buses required to reach a destination from a source given the bus routes. Each bus route is represented as a list of stops. The function should return the minimum number of buses required to reach the destination or -1 if it's not possible.",
    "output": "function NumBusesToDestination(routes: array of array of integer; source, target: integer): integer;\nbegin\n  if source = target then\n  begin\n    Result := 0;\n    exit;\n  end;\n\n  var stopToRoutes := new Dictionary<integer, HashSet<integer>>;\n  for var i := 0 to routes.Length - 1 do\n  begin\n    for var j := 0 to routes[i].Length - 1 do\n    begin\n      var stop := routes[i][j];\n      if not stopToRoutes.ContainsKey(stop) then\n        stopToRoutes[stop] := new HashSet<integer>;\n      stopToRoutes[stop].Add(i);\n    end;\n  end;\n\n  var queue := new Queue<(integer, integer)>;\n  queue.Enqueue((source, 0));\n  var visitedStops := new HashSet<integer>;\n  visitedStops.Add(source);\n  var visitedRoutes := new HashSet<integer>;\n\n  while queue.Count > 0 do\n  begin\n    var (currStop, buses) := queue.Dequeue;\n    \n    if stopToRoutes.ContainsKey(currStop) then\n    begin\n      foreach var route in stopToRoutes[currStop] do\n      begin\n        if visitedRoutes.Contains(route) then\n          continue;\n        \n        visitedRoutes.Add(route);\n        \n        for var k := 0 to routes[route].Length - 1 do\n        begin\n          var stop := routes[route][k];\n          if stop = target then\n          begin\n            Result := buses + 1;\n            exit;\n          end;\n          \n          if not visitedStops.Contains(stop) then\n          begin\n            visitedStops.Add(stop);\n            queue.Enqueue((stop, buses + 1));\n          end;\n        end;\n      end;\n    end;\n  end;\n  \n  Result := -1;\nend;"
  },
  {
    "instruction": "Write a function to generate the nth Gray Code.\n\nThe gray code is a binary numeral system where two successive values differ in only one bit.\n\nAs a sequence, the gray code for a given number of bits begins at \"0\" and proceeds through the sequence of integers to \"2^n - 1\", where n is the number of bits.\n\nFor example, the gray code for 2-bit numbers is [\"00\", \"01\", \"11\", \"10\"].",
    "output": "function GenerateGrayCode(n: integer): array of string;\nbegin\n  var res := new List<string>;\n  for var i := 0 to (1 shl n) - 1 do\n  begin\n    var gray := i xor (i shr 1);\n    var binaryStr := '';\n    \n    for var bit := n - 1 downto 0 do\n    begin\n      if (gray and (1 shl bit)) <> 0 then\n        binaryStr += '1'\n      else\n        binaryStr += '0';\n    end;\n    \n    res.Add(binaryStr);\n  end;\n  \n  Result := res.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to generate all possible combinations of a given list with a specific length.",
    "output": "procedure GenerateCombinations(start: integer; current: List<integer>; length: integer; myList: array of integer; res: List<array of integer>);\nbegin\n  if current.Count = length then\n  begin\n    res.Add(current.ToArray);\n    exit;\n  end;\n  \n  for var i := start to myList.Length - 1 do\n  begin\n    current.Add(myList[i]);\n    GenerateCombinations(i + 1, current, length, myList, res);\n    current.RemoveAt(current.Count - 1);\n  end;\nend;\n\nfunction CombinationsList(myList: array of integer; length: integer): array of array of integer;\nbegin\n  var res := new List<array of integer>;\n  GenerateCombinations(0, new List<integer>, length, myList, res);\n  Result := res.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the repeated elements in a given list and return them as a list.",
    "output": "function FindRepeatedElements(lst: array of integer): array of integer;\nbegin\n  var elementCount := new Dictionary<integer, integer>;\n  var repeatedElements := new List<integer>;\n  \n  for var i := 0 to lst.Length - 1 do\n  begin\n    var element := lst[i];\n    if elementCount.ContainsKey(element) then\n      elementCount[element] += 1\n    else\n      elementCount[element] := 1;\n  end;\n  \n  foreach var pair in elementCount do\n  begin\n    if pair.Value > 1 then\n      repeatedElements.Add(pair.Key);\n  end;\n  \n  Result := repeatedElements.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest subsequence that is strictly increasing in a given list of integers.",
    "output": "function FindLongestIncreasingSubsequence(nums: array of integer): integer;\nbegin\n  if nums.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var dp := new integer[nums.Length];\n  for var i := 0 to nums.Length - 1 do\n    dp[i] := 1;\n  \n  for var i := 1 to nums.Length - 1 do\n  begin\n    var maxLength := 0;\n    for var j := 0 to i - 1 do\n    begin\n      if nums[i] > nums[j] then\n        maxLength := Max(maxLength, dp[j]);\n    end;\n    dp[i] := maxLength + 1;\n  end;\n  \n  Result := dp.Max;\nend;"
  },
  {
    "instruction": "Write a function that takes in a string and returns all possible partitions of the string where each partition is a palindrome. A palindrome is a string that reads the same backward as forward.",
    "output": "function IsPal(str: string): boolean;\nbegin\n  var left := 1;\n  var right := str.Length;\n  while left < right do\n  begin\n    if str[left] <> str[right] then\n    begin\n      Result := false;\n      exit;\n    end;\n    left += 1;\n    right -= 1;\n  end;\n  Result := true;\nend;\n\nprocedure Dfs(remaining: string; path: List<string>; res: List<array of string>);\nbegin\n  if remaining = '' then\n  begin\n    res.Add(path.ToArray);\n    exit;\n  end;\n  \n  for var i := 1 to remaining.Length do\n  begin\n    var substr := remaining.Substring(1, i);\n    if IsPal(substr) then\n    begin\n      var newPath := new List<string>(path);\n      newPath.Add(substr);\n      Dfs(remaining.Substring(i + 1), newPath, res);\n    end;\n  end;\nend;\n\nfunction PalindromePartitions(s: string): array of array of string;\nbegin\n  var res := new List<array of string>;\n  Dfs(s, new List<string>, res);\n  Result := res.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to check if a given string is a valid HTML tag or not. A valid HTML tag starts with '<', followed by a valid tag name, and ends with '>'. The tag name must consist of only lowercase letters, digits, and one or more of the following characters: '-', '_'. The tag name must start with a letter.",
    "output": "function IsValidHtmlTag(tag: string): boolean;\nbegin\n  if (tag.Length < 3) or (tag[1] <> '<') or (tag[tag.Length] <> '>') then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  var tagName := tag.Substring(2, tag.Length - 2);\n  \n  if tagName.Length = 0 then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  if not (tagName[1] in ['a'..'z']) then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  for var i := 2 to tagName.Length do\n  begin\n    var ch := tagName[i];\n    if not (ch in ['a'..'z']) and not (ch in ['0'..'9']) and (ch <> '-') and (ch <> '_') then\n    begin\n      Result := false;\n      exit;\n    end;\n  end;\n  \n  Result := true;\nend;"
  },
  {
    "instruction": "Write a function to find the majority element in a given array. The majority element is the element that appears more than len(arr)/2 times.",
    "output": "function FindMajority(arr: array of integer): integer;\nbegin\n  var count := 0;\n  var candidate := 0;\n  \n  for var i := 0 to arr.Length - 1 do\n  begin\n    if count = 0 then\n      candidate := arr[i];\n    \n    if arr[i] = candidate then\n      count += 1\n    else\n      count -= 1;\n  end;\n  \n  Result := candidate;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of elements that should be removed from the array to make it a palindrome.",
    "output": "function MinRemovalsForPalindrome(arr: array of integer): integer;\nbegin\n  var left := 0;\n  var right := arr.Length - 1;\n  var removals := 0;\n  \n  while left < right do\n  begin\n    if arr[left] <> arr[right] then\n      removals += 1;\n    left += 1;\n    right -= 1;\n  end;\n  \n  Result := removals;\nend;"
  },
  {
    "instruction": "Write a function to find the word with the most vowels in it from a list of words. If there are multiple words with the same number of vowels, return the first one.",
    "output": "function FindMaxVowelWord(words: array of string): string;\nbegin\n  var vowels := HSet('a', 'e', 'i', 'o', 'u');\n  var maxVowels := 0;\n  var maxWord := '';\n  \n  for var i := 0 to words.Length - 1 do\n  begin\n    var count := 0;\n    for var j := 1 to words[i].Length do\n    begin\n      if vowels.Contains(words[i][j]) then\n        count += 1;\n    end;\n    \n    if count > maxVowels then\n    begin\n      maxVowels := count;\n      maxWord := words[i];\n    end;\n  end;\n  \n  Result := maxWord;\nend;"
  },
  {
    "instruction": "Write a function to find the most occurring character in a string.",
    "output": "function MostOccurringCharacter(str: string): char;\nbegin\n  var count := new Dictionary<char, integer>;\n  \n  for var i := 1 to str.Length do\n  begin\n    var ch := str[i];\n    if count.ContainsKey(ch) then\n      count[ch] += 1\n    else\n      count[ch] := 1;\n  end;\n  \n  var maxChar := ' ';\n  var maxCount := 0;\n  \n  foreach var pair in count do\n  begin\n    if pair.Value > maxCount then\n    begin\n      maxCount := pair.Value;\n      maxChar := pair.Key;\n    end;\n  end;\n  \n  Result := maxChar;\nend;"
  },
  {
    "instruction": "Write a function to remove all occurrences of a specified value from a list and return the modified list. The function should modify the list in place and return the new length of the list after removal. Do not use extra space for another list; you must do this by only modifying the input list in-place with O(1) extra memory.",
    "output": "function RemoveElements(var nums: array of integer; val: integer): integer;\nbegin\n  var i := 0;\n  var j := 0;\n  \n  while j < nums.Length do\n  begin\n    if nums[j] <> val then\n    begin\n      nums[i] := nums[j];\n      i += 1;\n    end;\n    j += 1;\n  end;\n  \n  Result := i;\nend;"
  },
  {
    "instruction": "Write a function to find the greatest common divisor (GCD) of two positive integers using the Euclidean algorithm.",
    "output": "function GCD(a, b: integer): integer;\nbegin\n  while b <> 0 do\n  begin\n    var temp := b;\n    b := a mod b;\n    a := temp;\n  end;\n  Result := a;\nend;"
  },
  {
    "instruction": "Write a function that returns the total number of substrings of a given string where each substring consists of the same character.",
    "output": "function CountEqualCharSubstrings(s: string): integer;\nbegin\n  var total := 0;\n  var count := 1;\n  \n  for var i := 2 to s.Length do\n  begin\n    if s[i] = s[i - 1] then\n      count += 1\n    else\n    begin\n      total += (count * (count + 1)) div 2;\n      count := 1;\n    end;\n  end;\n  \n  total += (count * (count + 1)) div 2;\n  Result := total;\nend;"
  },
  {
    "instruction": "Write a function to return the largest number possible from a list of integers, ignoring any negative numbers.",
    "output": "function MaxNonNegative(numbers: array of integer): integer;\nbegin\n  var maxNum := -1;\n  \n  for var i := 0 to numbers.Length - 1 do\n  begin\n    if (numbers[i] >= 0) and (numbers[i] > maxNum) then\n      maxNum := numbers[i];\n  end;\n  \n  if maxNum = -1 then\n    Result := 0\n  else\n    Result := maxNum;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum number of points that can be covered by a circle of given radius. The points are represented as a list of tuples, where each tuple contains the x and y coordinates of a point. The function should return the maximum number of points that can be covered by a circle of the given radius.",
    "output": "function GetMid(a, b: (real, real); r: real): ((real, real), (real, real));\nbegin\n  var (ax, ay) := a;\n  var (bx, by) := b;\n  var lx := bx - ax;\n  var ly := by - ay;\n  var lxy := Sqrt(lx * lx + ly * ly);\n  var r2 := r * r;\n  \n  if (lxy / 2) * (lxy / 2) > r2 then\n    Result := ((0.0, 0.0), (0.0, 0.0))\n  else\n  begin\n    var l := Sqrt(r2 - (lxy / 2) * (lxy / 2));\n    var yy := l * lx / lxy;\n    var xx := l * ly / lxy;\n    var mx := (ax + bx) / 2;\n    var my := (ay + by) / 2;\n    Result := ((mx + xx, my - yy), (mx - xx, my + yy));\n  end;\nend;\n\nfunction IsIn(rx, ry, x, y, r: real): boolean;\nbegin\n  var r2 := r * r;\n  Result := (rx - x) * (rx - x) + (ry - y) * (ry - y) <= r2 + 0.01;\nend;\n\nfunction CountIn(rx, ry: real; points: array of (real, real); r: real): integer;\nbegin\n  var cnt := 0;\n  for var i := 0 to points.Length - 1 do\n  begin\n    var (x, y) := points[i];\n    if IsIn(rx, ry, x, y, r) then\n      cnt += 1;\n  end;\n  Result := cnt;\nend;\n\nfunction MaxPointsCovered(points: array of (real, real); r: real): integer;\nbegin\n  var maxRes := 1;\n  var mapT := new HashSet<(real, real)>;\n\n  for var ii := 0 to points.Length - 1 do\n  begin\n    for var jj := ii + 1 to points.Length - 1 do\n    begin\n      var (c1, c2) := GetMid(points[ii], points[jj], r);\n      var (rx1, ry1) := c1;\n      var (rx2, ry2) := c2;\n      \n      if rx1 = 0.0 then\n        continue;\n        \n      var cnt1 := 0;\n      if not mapT.Contains((rx1, ry1)) then\n        cnt1 := CountIn(rx1, ry1, points, r);\n        \n      var cnt2 := 0;\n      if not mapT.Contains((rx2, ry2)) then\n        cnt2 := CountIn(rx2, ry2, points, r);\n        \n      mapT.Add((rx1, ry1));\n      mapT.Add((rx2, ry2));\n      maxRes := Max(maxRes, Max(cnt1, cnt2));\n    end;\n  end;\n  \n  Result := maxRes;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of all divisors of a number excluding the number itself.",
    "output": "function GetSumOfDivisors(n: integer): integer;\nbegin\n  var res := 0;\n  var i := 1;\n  \n  while i <= n div 2 do\n  begin\n    if n mod i = 0 then\n      res += i;\n    i += 1;\n  end;\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function that finds the length of the longest subarray with a sum less than or equal to a given value 'k'. If no such subarray exists, return 0.",
    "output": "function LongestSubarraySum(arr: array of integer; k: integer): integer;\nbegin\n  var maxLen := 0;\n  var currentSum := 0;\n  var left := 0;\n\n  for var right := 0 to arr.Length - 1 do\n  begin\n    currentSum += arr[right];\n\n    while (currentSum > k) and (left <= right) do\n    begin\n      currentSum -= arr[left];\n      left += 1;\n    end;\n\n    maxLen := Max(maxLen, right - left + 1);\n  end;\n\n  Result := maxLen;\nend;"
  },
  {
    "instruction": "Write a function to calculate the total number of leaf nodes in a binary tree.",
    "output": "type\n  TreeNode = class\n    val: integer;\n    left, right: TreeNode;\n    \n    constructor Create(v: integer; l, r: TreeNode);\n    begin\n      val := v;\n      left := l;\n      right := r;\n    end;\n  end;\n\nfunction CountLeafNodes(root: TreeNode): integer;\nbegin\n  if root = nil then\n  begin\n    Result := 0;\n    exit;\n  end;\n\n  var queue := new Queue<TreeNode>;\n  queue.Enqueue(root);\n  var leafCount := 0;\n\n  while queue.Count > 0 do\n  begin\n    var node := queue.Dequeue;\n    if (node.left = nil) and (node.right = nil) then\n      leafCount += 1;\n    \n    if node.left <> nil then\n      queue.Enqueue(node.left);\n    \n    if node.right <> nil then\n      queue.Enqueue(node.right);\n  end;\n\n  Result := leafCount;\nend;"
  },
  {
    "instruction": "Write a function to calculate the sum of the first n Fibonacci numbers.",
    "output": "function SumFibonacci(n: integer): integer;\nbegin\n  if n <= 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var fib := new List<integer>;\n  fib.Add(0);\n  fib.Add(1);\n  \n  for var i := 2 to n - 1 do\n    fib.Add(fib[fib.Count - 1] + fib[fib.Count - 2]);\n  \n  Result := fib.Sum;\nend;"
  },
  {
    "instruction": "Write a function to find the number of unique binary search trees that can be created with 'n' distinct nodes.\n\nThe binary search tree property: for any node, all elements on its left subtree are less than the node, and all elements on its right subtree are greater than the node.",
    "output": "function UniqueBinarySearchTrees(n: integer): integer;\nbegin\n  var catalan := new integer[n + 1];\n  for var i := 0 to n do\n    catalan[i] := 0;\n  \n  catalan[0] := 1;\n  catalan[1] := 1;\n  \n  for var i := 2 to n do\n  begin\n    for var j := 0 to i - 1 do\n    begin\n      catalan[i] += catalan[j] * catalan[i - j - 1];\n    end;\n  end;\n  \n  Result := catalan[n];\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns the sum of all numbers that are divisible by 3.",
    "output": "function SumDivisibleBy3(numbers: array of integer): integer;\nbegin\n  var total := 0;\n  for var i := 0 to numbers.Length - 1 do\n  begin\n    if numbers[i] mod 3 = 0 then\n      total += numbers[i];\n  end;\n  Result := total;\nend;"
  },
  {
    "instruction": "Write a function to calculate the total cost of gas for a journey based on the distance of the journey and the price of gas per liter. Assume the car's average consumption is 10 kilometers per liter.",
    "output": "function GasCost(distance, gasPrice: real): real;\nbegin\n  var liters := distance / 10;\n  var totalCost := liters * gasPrice;\n  Result := totalCost;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of the series 1^3 + 2^3 + 3^3 + ... + n^3.",
    "output": "function SumOfCubes(n: integer): integer;\nbegin\n  var sum := 0;\n  for var i := 1 to n do\n  begin\n    sum += i * i * i;\n  end;\n  Result := sum;\nend;"
  },
  {
    "instruction": "Create a function that takes a list of strings (representing a list of tweets) and a number k. The function should return a list of tweet authors who have had at least k tweets. If no author has reached this threshold, an empty list should be returned.",
    "output": "function AuthorsWithKTweets(tweets: array of string; k: integer): array of string;\nbegin\n  if tweets.Length = 0 then\n  begin\n    Result := new string[0];\n    exit;\n  end;\n  \n  var authors := new List<string>;\n  for var i := 0 to tweets.Length - 1 do\n  begin\n    var parts := tweets[i].ToWords;\n    if parts.Length > 0 then\n      authors.Add(parts[parts.Length - 1]);\n  end;\n  \n  var authorCounts := new Dictionary<string, integer>;\n  for var i := 0 to authors.Count - 1 do\n  begin\n    var author := authors[i];\n    if authorCounts.ContainsKey(author) then\n      authorCounts[author] += 1\n    else\n      authorCounts[author] := 1;\n  end;\n  \n  var authorsWithKTweets := new List<string>;\n  foreach var pair in authorCounts do\n  begin\n    if pair.Value >= k then\n      authorsWithKTweets.Add(pair.Key);\n  end;\n  \n  Result := authorsWithKTweets.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the number of zeros at the end of a factorial of a given number.",
    "output": "function ZerosInFactorial(n: integer): integer;\nbegin\n  if n = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var count := 0;\n  var i := 5;\n  \n  while n div i >= 1 do\n  begin\n    count += n div i;\n    i *= 5;\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to tile a 2xn rectangle with 2x1 tiles.",
    "output": "function TileWays(n: integer): integer;\nbegin\n  if (n = 0) or (n = 1) then\n  begin\n    Result := n;\n    exit;\n  end;\n  \n  var a := 1;\n  var b := 2;\n  \n  for var i := 2 to n - 1 do\n  begin\n    var temp := b;\n    b := a + b;\n    a := temp;\n  end;\n  \n  Result := b;\nend;"
  },
  {
    "instruction": "Write a function that takes in a string and returns the last non-repeating character in it. If it doesn't exist, return nil.",
    "output": "function LastNonRepeating(s: string): char?;\nbegin\n  var count := new Dictionary<char, integer>;\n  \n  for var i := 1 to s.Length do\n  begin\n    var ch := s[i];\n    if count.ContainsKey(ch) then\n      count[ch] += 1\n    else\n      count[ch] := 1;\n  end;\n  \n  for var i := s.Length downto 1 do\n  begin\n    if count[s[i]] = 1 then\n    begin\n      Result := s[i];\n      exit;\n    end;\n  end;\n  \n  Result := nil;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns True if all the integers in the list are below a certain threshold, and False otherwise.",
    "output": "function BelowThreshold(numbers: array of integer; threshold: integer): boolean;\nbegin\n  for var i := 0 to numbers.Length - 1 do\n  begin\n    if numbers[i] >= threshold then\n    begin\n      Result := false;\n      exit;\n    end;\n  end;\n  Result := true;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as input and returns a dictionary where the keys are the integers from the input list and the values are their corresponding squares.",
    "output": "function SquareDict(nums: array of integer): Dictionary<integer, integer>;\nbegin\n  var res := new Dictionary<integer, integer>;\n  for var i := 0 to nums.Length - 1 do\n  begin\n    res[nums[i]] := nums[i] * nums[i];\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings (representing names) and returns a dictionary where the keys are the first letters of the names and the values are lists of names that start with that letter.",
    "output": "function CategorizeByInitial(names: array of string): Dictionary<char, List<string>>;\nbegin\n  var categorizedNames := new Dictionary<char, List<string>>;\n  \n  for var i := 0 to names.Length - 1 do\n  begin\n    var name := names[i];\n    if name.Length > 0 then\n    begin\n      var initial := name[1];\n      if categorizedNames.ContainsKey(initial) then\n        categorizedNames[initial].Add(name)\n      else\n      begin\n        var newList := new List<string>;\n        newList.Add(name);\n        categorizedNames[initial] := newList;\n      end;\n    end;\n  end;\n  \n  Result := categorizedNames;\nend;"
  },
  {
    "instruction": "Write a function that finds the sum of the largest contiguous subarray within a given array of integers.",
    "output": "function LargestSum(nums: array of integer): integer;\nbegin\n  if nums.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n\n  var currentSum := nums[0];\n  var maxSum := nums[0];\n  \n  for var i := 1 to nums.Length - 1 do\n  begin\n    currentSum := Max(nums[i], currentSum + nums[i]);\n    maxSum := Max(maxSum, currentSum);\n  end;\n  \n  Result := maxSum;\nend;"
  },
  {
    "instruction": "Write a function to count the number of distinct numbers in a given list of integers.",
    "output": "function CountDistinctNumbers(numbers: array of integer): integer;\nbegin\n  var uniqueSet := new HashSet<integer>;\n  for var i := 0 to numbers.Length - 1 do\n  begin\n    uniqueSet.Add(numbers[i]);\n  end;\n  Result := uniqueSet.Count;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings and returns a list of strings with the duplicates removed, but instead of removing the duplicates, replace the duplicates with a custom string.",
    "output": "function ReplaceDuplicates(lst: array of string): array of string;\nbegin\n  var seen := new HashSet<string>;\n  var res := new List<string>;\n  \n  for var i := 0 to lst.Length - 1 do\n  begin\n    if seen.Contains(lst[i]) then\n      res.Add('DUPLICATE')\n    else\n    begin\n      seen.Add(lst[i]);\n      res.Add(lst[i]);\n    end;\n  end;\n  \n  Result := res.ToArray;\nend;"
  },
  {
    "instruction": "Write a function `group_by_owners` that takes a list of tuples containing file names and their owners, and returns a dictionary where keys are the owners and values are lists of files owned by that person.",
    "output": "function GroupByOwners(files: array of (string, string)): Dictionary<string, List<string>>;\nbegin\n  var res := new Dictionary<string, List<string>>;\n  \n  for var i := 0 to files.Length - 1 do\n  begin\n    var (fileName, owner) := files[i];\n    if res.ContainsKey(owner) then\n      res[owner].Add(fileName)\n    else\n    begin\n      var newList := new List<string>;\n      newList.Add(fileName);\n      res[owner] := newList;\n    end;\n  end;\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to calculate the area of a triangle given its base and height.",
    "output": "function CalculateTriangleArea(base, height: real): real;\nbegin\n  Result := 0.5 * base * height;\nend;"
  },
  {
    "instruction": "Write a function to find the number of ways to reach the last cell of a grid from the first cell, given that you can only move right or down.",
    "output": "function NumWaysToReachLastCell(m, n: integer): integer;\nbegin\n  if (m = 1) or (n = 1) then\n  begin\n    Result := 1;\n    exit;\n  end;\n  \n  var dp := new integer[m, n];\n  \n  for var i := 0 to m - 1 do\n    dp[i, 0] := 1;\n  \n  for var j := 0 to n - 1 do\n    dp[0, j] := 1;\n  \n  for var i := 1 to m - 1 do\n  begin\n    for var j := 1 to n - 1 do\n    begin\n      dp[i, j] := dp[i - 1, j] + dp[i, j - 1];\n    end;\n  end;\n  \n  Result := dp[m - 1, n - 1];\nend;"
  },
  {
    "instruction": "Write a function to find the intersection of two lists using set and lambda function.",
    "output": "function IntersectList(list1, list2: array of integer): array of integer;\nbegin\n  var set1 := new HashSet<integer>(list1);\n  var set2 := new HashSet<integer>(list2);\n  set1.IntersectWith(set2);\n  Result := set1.ToArray;\nend;"
  },
  {
    "instruction": "Write a function that takes a string and returns the string with all occurrences of consecutive duplicate characters collapsed to a single character.",
    "output": "function CollapseDuplicates(inputString: string): string;\nbegin\n  if inputString.Length = 0 then\n  begin\n    Result := '';\n    exit;\n  end;\n  \n  var res := new StringBuilder;\n  var prevChar := inputString[1];\n  res.Append(prevChar);\n  \n  for var i := 2 to inputString.Length do\n  begin\n    var currentChar := inputString[i];\n    if currentChar <> prevChar then\n    begin\n      res.Append(currentChar);\n      prevChar := currentChar;\n    end;\n  end;\n  \n  Result := res.ToString;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of swaps required to sort an array in ascending order.",
    "output": "function MinimumSwaps(arr: array of integer): integer;\nbegin\n  var n := arr.Length;\n  var ans := 0;\n  var temp := arr.ToArray;\n  &Array.Sort(temp);\n  var visited := new boolean[n];\n  \n  for var i := 0 to n - 1 do\n  begin\n    if visited[i] or (temp[i] = arr[i]) then\n      continue;\n  \n    var cycleSize := 0;\n    var j := i;\n    \n    while not visited[j] do\n    begin\n      visited[j] := true;\n      var index := &Array.IndexOf(temp, arr[j]);\n      j := index;\n      cycleSize += 1;\n    end;\n  \n    if cycleSize > 0 then\n      ans += cycleSize - 1;\n  end;\n  \n  Result := ans;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum unique value in a given array. A unique value is a value that appears exactly once in the array.",
    "output": "function FindMinUnique(arr: array of integer): integer;\nbegin\n  var frequency := new Dictionary<integer, integer>;\n  \n  for var i := 0 to arr.Length - 1 do\n  begin\n    var num := arr[i];\n    if frequency.ContainsKey(num) then\n      frequency[num] += 1\n    else\n      frequency[num] := 1;\n  end;\n  \n  var uniqueNums := new List<integer>;\n  foreach var pair in frequency do\n  begin\n    if pair.Value = 1 then\n      uniqueNums.Add(pair.Key);\n  end;\n  \n  if uniqueNums.Count > 0 then\n    Result := uniqueNums.Min\n  else\n    Result := -1;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings as an argument and returns a list of strings that contain at least one vowel.",
    "output": "function FilterVowelStrings(strings: array of string): array of string;\nbegin\n  var vowels := HSet('a', 'e', 'i', 'o', 'u');\n  var res := new List<string>;\n  \n  for var i := 0 to strings.Length - 1 do\n  begin\n    var hasVowel := false;\n    for var j := 1 to strings[i].Length do\n    begin\n      if vowels.Contains(strings[i][j]) then\n      begin\n        hasVowel := true;\n        break;\n      end;\n    end;\n    \n    if hasVowel then\n      res.Add(strings[i]);\n  end;\n  \n  Result := res.ToArray;\nend;"
  },
  {
    "instruction": "Write a function that performs a binary insertion sort on a given list. Binary insertion sort is an optimization of the traditional insertion sort algorithm, which uses binary search to find the proper location to insert the selected item at each iteration.",
    "output": "function BinaryInsertionSort(arr: array of integer): array of integer;\nbegin\n  var res := arr.ToArray;\n  \n  for var i := 1 to res.Length - 1 do\n  begin\n    var val := res[i];\n    var left := 0;\n    var right := i - 1;\n    \n    while left <= right do\n    begin\n      var mid := (left + right) div 2;\n      if res[mid] > val then\n        right := mid - 1\n      else\n        left := mid + 1;\n    end;\n    \n    for var j := i - 1 downto left do\n      res[j + 1] := res[j];\n    \n    res[left] := val;\n  end;\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function that takes in a list of integers and returns the list after sorting it using the quicksort algorithm.",
    "output": "function QuickSort(arr: array of integer): array of integer;\nbegin\n  if arr.Length <= 1 then\n  begin\n    Result := arr;\n    exit;\n  end;\n  \n  var pivot := arr[arr.Length div 2];\n  var left := new List<integer>;\n  var middle := new List<integer>;\n  var right := new List<integer>;\n  \n  for var i := 0 to arr.Length - 1 do\n  begin\n    if arr[i] < pivot then\n      left.Add(arr[i])\n    else if arr[i] = pivot then\n      middle.Add(arr[i])\n    else\n      right.Add(arr[i]);\n  end;\n  \n  Result := QuickSort(left.ToArray) + middle.ToArray + QuickSort(right.ToArray);\nend;"
  },
  {
    "instruction": "Write a function to find the kth largest element in an unsorted array.\nNote: The array may contain duplicate elements.",
    "output": "function FindKthLargest(nums: array of integer; k: integer): integer;\nbegin\n  if (nums.Length = 0) or (k <= 0) then\n  begin\n    Result := -1;\n    exit;\n  end;\n\n  var heap := new List<integer>;\n  \n  for var i := 0 to nums.Length - 1 do\n  begin\n    heap.Add(nums[i]);\n    \n    if heap.Count > k then\n    begin\n      heap.Sort;\n      heap.RemoveAt(0);\n    end;\n  end;\n  \n  heap.Sort;\n  Result := heap[0];\nend;"
  },
  {
    "instruction": "Write a function which returns an array of n length, where each element is the sum of its index and the previous element. The first element should always be 1.",
    "output": "function SumIndexPrev(n: integer): array of integer;\nbegin\n  if n = 1 then\n  begin\n    Result := new integer[1];\n    Result[0] := 1;\n    exit;\n  end;\n  \n  var arr := new integer[n];\n  arr[0] := 1;\n  \n  for var i := 1 to n - 1 do\n  begin\n    arr[i] := arr[i - 1] + i + 1;\n  end;\n  \n  Result := arr;\nend;"
  },
  {
    "instruction": "Write a function to find the smallest difference between two elements in a given list.",
    "output": "function SmallestDiff(arr: array of integer): integer;\nbegin\n  var sortedArr := arr.ToArray;\n  &Array.Sort(sortedArr);\n  \n  var minDiff := integer.MaxValue;\n  for var i := 1 to sortedArr.Length - 1 do\n  begin\n    var diff := sortedArr[i] - sortedArr[i - 1];\n    if diff < minDiff then\n      minDiff := diff;\n  end;\n  \n  Result := minDiff;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers as an input and returns a tuple. The first element in the tuple is the sum of all even numbers in the list. The second element is the product of all odd numbers in the list. If there are no even numbers, the sum should be 0. If there are no odd numbers, the product should be 1.",
    "output": "function SumEvenProductOdd(nums: array of integer): (integer, integer);\nbegin\n  var sumEven := 0;\n  var productOdd := 1;\n  var hasOdd := false;\n  \n  for var i := 0 to nums.Length - 1 do\n  begin\n    if nums[i] mod 2 = 0 then\n      sumEven += nums[i]\n    else\n    begin\n      productOdd *= nums[i];\n      hasOdd := true;\n    end;\n  end;\n  \n  if not hasOdd then\n    productOdd := 1;\n  \n  Result := (sumEven, productOdd);\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns the sum of the digits of the largest number in the list.",
    "output": "function SumLargestDigits(nums: array of integer): integer;\nbegin\n  var maxNum := nums.Max;\n  var maxNumStr := maxNum.ToString;\n  var sum := 0;\n  \n  for var i := 1 to maxNumStr.Length do\n  begin\n    sum += StrToInt(maxNumStr[i]);\n  end;\n  \n  Result := sum;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns a new list where each element is the count of how many elements in the original list are smaller than the current element.\n\nExample:\nInput: [8, 1, 2, 2, 3]\nOutput: [4, 0, 1, 1, 3]",
    "output": "function SmallerNumbersThanCurrent(nums: array of integer): array of integer;\nbegin\n  var res := new integer[nums.Length];\n  \n  for var i := 0 to nums.Length - 1 do\n  begin\n    var count := 0;\n    for var j := 0 to nums.Length - 1 do\n    begin\n      if (i <> j) and (nums[j] < nums[i]) then\n        count += 1;\n    end;\n    res[i] := count;\n  end;\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the largest divisor of a given number among a list of divisors.",
    "output": "function LargestDivisor(num: integer; divisors: array of integer): integer;\nbegin\n  var sortedDivisors := divisors.ToArray;\n  &Array.Sort(sortedDivisors);\n  &Array.Reverse(sortedDivisors);\n  \n  for var i := 0 to sortedDivisors.Length - 1 do\n  begin\n    if num mod sortedDivisors[i] = 0 then\n    begin\n      Result := sortedDivisors[i];\n      exit;\n    end;\n  end;\n  \n  Result := 1;\nend;"
  },
  {
    "instruction": "Write a function that converts a given date in the format \"DD Month YYYY\" to the ISO 8601 standard format \"YYYY-MM-DD\". The month should be in full name format (e.g., \"January\", \"February\", etc.).",
    "output": "function ConvertToISO(date: string): string;\nbegin\n  var months := new Dictionary<string, string>;\n  months['January'] := '01';\n  months['February'] := '02';\n  months['March'] := '03';\n  months['April'] := '04';\n  months['May'] := '05';\n  months['June'] := '06';\n  months['July'] := '07';\n  months['August'] := '08';\n  months['September'] := '09';\n  months['October'] := '10';\n  months['November'] := '11';\n  months['December'] := '12';\n  \n  var parts := date.ToWords;\n  if parts.Length <> 3 then\n  begin\n    Result := '';\n    exit;\n  end;\n  \n  var dayStr := parts[0];\n  if dayStr.Length > 2 then\n    dayStr := dayStr.Substring(1, dayStr.Length - 2);\n  \n  if dayStr.Length = 1 then\n    dayStr := '0' + dayStr;\n  \n  var month := months[parts[1]];\n  var year := parts[2];\n  \n  Result := year + '-' + month + '-' + dayStr;\nend;"
  },
  {
    "instruction": "Write a function to calculate the sum of the absolute values of all numbers in a list.",
    "output": "function SumOfAbs(lst: array of integer): integer;\nbegin\n  var sum := 0;\n  for var i := 0 to lst.Length - 1 do\n  begin\n    sum += Abs(lst[i]);\n  end;\n  Result := sum;\nend;"
  },
  {
    "instruction": "Write a function to find the level of a given binary tree.",
    "output": "type\n  TreeNode = class\n    val: integer;\n    left, right: TreeNode;\n    \n    constructor Create(v: integer; l, r: TreeNode);\n    begin\n      val := v;\n      left := l;\n      right := r;\n    end;\n  end;\n\nfunction FindLevel(root: TreeNode; k: integer): integer;\nbegin\n  if root = nil then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  if root.val = k then\n  begin\n    Result := 1;\n    exit;\n  end;\n  \n  var leftLevel := FindLevel(root.left, k);\n  if leftLevel > 0 then\n  begin\n    Result := leftLevel + 1;\n    exit;\n  end;\n  \n  var rightLevel := FindLevel(root.right, k);\n  if rightLevel > 0 then\n  begin\n    Result := rightLevel + 1;\n    exit;\n  end;\n  \n  Result := 0;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns a new list with each element squared, but only if the element is odd. If the element is even, it should be replaced with 0.",
    "output": "function SquareOdd(nums: array of integer): array of integer;\nbegin\n  var res := new integer[nums.Length];\n  \n  for var i := 0 to nums.Length - 1 do\n  begin\n    if nums[i] mod 2 <> 0 then\n      res[i] := nums[i] * nums[i]\n    else\n      res[i] := 0;\n  end;\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to find the greatest common divisor (GCD) and least common multiple (LCM) of two given numbers.",
    "output": "function GCDLCM(a, b: integer): (integer, integer);\nbegin\n  var c := Max(a, b);\n  var d := Min(a, b);\n  var t := 1;\n  \n  while t > 0 do\n  begin\n    t := c mod d;\n    c := d;\n    d := t;\n  end;\n  \n  var gcd := c;\n  var lcm := (a * b) div gcd;\n  \n  Result := (gcd, lcm);\nend;"
  },
  {
    "instruction": "Write a function to reorder a given string according to the specified indices.",
    "output": "function ReorderString(s: string; indices: array of integer): string;\nbegin\n  var resultArr := new char[s.Length];\n  \n  for var i := 0 to indices.Length - 1 do\n  begin\n    resultArr[indices[i]] := s[i + 1];\n  end;\n  \n  Result := new string(resultArr);\nend;"
  },
  {
    "instruction": "Write a function to simulate a simplified version of a file system path simplifier. Given a string which represents an absolute path, you need to return the simplified version of it. The simplified version of the path should not contain the following three types of parts:\n1. \".\" which represents the current directory.\n2. \"..\" which represents the parent directory.\n3. Any consecutive \"/\" in the path should be replaced by a single \"/\".",
    "output": "function SimplifyPath(path: string): string;\nbegin\n  var parts := path.Split('/');\n  var stack := new Stack<string>;\n  \n  for var i := 0 to parts.Length - 1 do\n  begin\n    if (parts[i] = '') or (parts[i] = '.') then\n      continue\n    else if parts[i] = '..' then\n    begin\n      if stack.Count > 0 then\n        stack.Pop;\n    end\n    else\n      stack.Push(parts[i]);\n  end;\n  \n  var resultParts := stack.ToArray;\n  &Array.Reverse(resultParts);\n  \n  Result := '/' + string.Join('/', resultParts);\nend;"
  },
  {
    "instruction": "Write a function which takes in a list of integers and returns a dictionary where the keys are the original numbers and the values are their corresponding squares.",
    "output": "function SquareDictionary(numbers: array of integer): Dictionary<integer, integer>;\nbegin\n  var res := new Dictionary<integer, integer>;\n  for var i := 0 to numbers.Length - 1 do\n  begin\n    res[numbers[i]] := numbers[i] * numbers[i];\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to determine if a given number is present in a sorted 2D matrix. The matrix is sorted such that each row and each column is in ascending order.",
    "output": "function FindInMatrix(matrix: array of array of integer; target: integer): boolean;\nbegin\n  if (matrix.Length = 0) or (matrix[0].Length = 0) then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  var m := matrix.Length;\n  var n := matrix[0].Length;\n  \n  var row := 0;\n  var col := n - 1;\n  \n  while (row < m) and (col >= 0) do\n  begin\n    if matrix[row, col] = target then\n    begin\n      Result := true;\n      exit;\n    end\n    else if matrix[row, col] < target then\n      row += 1\n    else\n      col -= 1;\n  end;\n  \n  Result := false;\nend;"
  },
  {
    "instruction": "Write a function to find the k smallest elements in an array.",
    "output": "function KSmallest(arr: array of integer; k: integer): array of integer;\nbegin\n  if (k = 0) or (arr.Length = 0) then\n  begin\n    Result := new integer[0];\n    exit;\n  end;\n  \n  var sortedArr := arr.ToArray;\n  &Array.Sort(sortedArr);\n  \n  var res := new integer[k];\n  for var i := 0 to k - 1 do\n    res[i] := sortedArr[i];\n  \n  Result := res;\nend;"
  },
  {
    "instruction": "Write a function to subtract two given numbers using bitwise operators.",
    "output": "function BitwiseSubtract(x, y: integer): integer;\nbegin\n  while y <> 0 do\n  begin\n    var borrow := (not x) and y;\n    x := x xor y;\n    y := borrow shl 1;\n  end;\n  Result := x;\nend;"
  },
  {
    "instruction": "Write a function to find the intersection of two lists of intervals. The intervals in the list are represented by a pair of integers [start, end]. The intersection of two intervals is a new interval [max(start1, start2), min(end1, end2)] where start1, end1 are the start and end of the first interval, and start2, end2 are the start and end of the second interval. The intersection of two lists of intervals is a list of the intersections of all pairs of intervals, one from each list.",
    "output": "function IntervalsIntersection(list1, list2: array of (integer, integer)): array of (integer, integer);\nbegin\n  var res := new List<(integer, integer)>;\n  var i := 0;\n  var j := 0;\n  \n  while (i < list1.Length) and (j < list2.Length) do\n  begin\n    var start := Max(list1[i].Item1, list2[j].Item1);\n    var endVal := Min(list1[i].Item2, list2[j].Item2);\n    \n    if start <= endVal then\n      res.Add((start, endVal));\n    \n    if list1[i].Item2 < list2[j].Item2 then\n      i += 1\n    else\n      j += 1;\n  end;\n  \n  Result := res.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to check whether the given number is a perfect power or not. A perfect power is a positive integer that can be expressed as an integer power of another positive integer. More formally, n is a perfect power if there exist natural numbers m > 1, and k > 1 such that mk = n.",
    "output": "function IsPerfectPower(n: integer): boolean;\nbegin\n  if n < 2 then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  for var base := 2 to Trunc(Sqrt(n)) do\n  begin\n    var exponent := 2;\n    while Power(base, exponent) <= n do\n    begin\n      if Power(base, exponent) = n then\n      begin\n        Result := true;\n        exit;\n      end;\n      exponent += 1;\n    end;\n  end;\n  \n  Result := false;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest continuous increasing subsequence (LCIS) in a list of numbers.",
    "output": "function LongestLCIS(nums: array of integer): integer;\nbegin\n  if nums.Length = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  var maxLen := 1;\n  var currentLen := 1;\n  \n  for var i := 1 to nums.Length - 1 do\n  begin\n    if nums[i] > nums[i - 1] then\n    begin\n      currentLen += 1;\n      maxLen := Max(maxLen, currentLen);\n    end\n    else\n      currentLen := 1;\n  end;\n  \n  Result := maxLen;\nend;"
  },
  {
    "instruction": "Write a function to check if a given number is a power of 2 or not.",
    "output": "function IsPowerOf2(n: integer): boolean;\nbegin\n  if n <= 0 then\n  begin\n    Result := false;\n    exit;\n  end;\n  \n  while n <> 1 do\n  begin\n    if n mod 2 <> 0 then\n    begin\n      Result := false;\n      exit;\n    end;\n    n := n div 2;\n  end;\n  \n  Result := true;\nend;"
  },
  {
    "instruction": "Create a function to perform matrix addition for two given matrices. The matrices will have the same dimensions. The function should return the resulting matrix after the addition.",
    "output": "function MatrixAddition(A, B: array[,] of integer): array[,] of integer;\nbegin\n  var n1 := A.GetLength(0);\n  var n2 := A.GetLength(1);\n  var newA := new integer[n1, n2];\n  \n  for var i := 0 to n1 - 1 do\n  begin\n    for var j := 0 to n2 - 1 do\n    begin\n      newA[i, j] := A[i, j] + B[i, j];\n    end;\n  end;\n  \n  Result := newA;\nend;"
  },
  {
    "instruction": "Write a function to find the mode(s) of a list of numbers. The mode is the number that appears most frequently in a list. If there are multiple numbers that appear the same maximum number of times, return all of them in a list sorted in ascending order.",
    "output": "function Modes(numbers: array of integer): array of integer;\nbegin\n  var count := new Dictionary<integer, integer>;\n  \n  for var i := 0 to numbers.Length - 1 do\n  begin\n    if count.ContainsKey(numbers[i]) then\n      count[numbers[i]] += 1\n    else\n      count[numbers[i]] := 1;\n  end;\n  \n  var maxCount := count.Values.Max;\n  var res := new List<integer>;\n  \n  foreach var pair in count do\n  begin\n    if pair.Value = maxCount then\n      res.Add(pair.Key);\n  end;\n  \n  res.Sort;\n  Result := res.ToArray;\nend;"
  },
  {
    "instruction": "Write a function to find the number of provinces in a given list of connections between cities. A province is a group of cities where every city is directly or indirectly connected to every other city in the group. Your function should take a list of lists as input, where each inner list represents the connections between cities, and return the number of provinces.",
    "output": "procedure DFS(city: integer; visit: HashSet<integer>; isConnected: array of array of integer);\nbegin\n  visit.Add(city);\n  for var another := 0 to isConnected.Length - 1 do\n  begin\n    if (another <> city) and (isConnected[city, another] = 1) and (not visit.Contains(another)) then\n      DFS(another, visit, isConnected);\n  end;\nend;\n\nfunction FindCircleNum(isConnected: array of array of integer): integer;\nbegin\n  var visit := new HashSet<integer>;\n  var province := 0;\n  var n := isConnected.Length;\n\n  for var city := 0 to n - 1 do\n  begin\n    if not visit.Contains(city) then\n    begin\n      province += 1;\n      DFS(city, visit, isConnected);\n    end;\n  end;\n\n  Result := province;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of strings, removes duplicates, and returns the list in alphabetical order.",
    "output": "function SortAndDeduplicate(lst: array of string): array of string;\nbegin\n  Result := lst.Distinct().Order().ToArray();\nend;"
  },
  {
    "instruction": "Write a function to multiply two matrices.",
    "output": "function Multiply(mat1, mat2: array [,] of integer): array [,] of integer;\nbegin\n  var m := mat1.GetLength(0);\n  var n := mat2.GetLength(1);\n  var p := mat1.GetLength(1);\n  Result := new integer[m, n];\n  \n  for var i := 0 to m - 1 do\n    for var j := 0 to n - 1 do\n    begin\n      var tmp := 0;\n      for var k := 0 to p - 1 do\n        tmp += mat1[i, k] * mat2[k, j];\n      Result[i, j] := tmp;\n    end;\nend;"
  },
  {
    "instruction": "Write a function to merge two sorted arrays into one sorted array without using extra space.",
    "output": "function UnionArray(nums1, nums2: List<integer>): List<integer>;\nbegin\n  nums1.RemoveAll(x -> x = 0);\n  nums2.RemoveAll(x -> x = 0);\n  \n  var i := 0;\n  var j := 0;\n  \n  while (i < nums1.Count) and (j < nums2.Count) do\n  begin\n    if nums1[i] <= nums2[j] then\n      i += 1\n    else\n    begin\n      nums1.Insert(i, nums2[j]);\n      i += 1;\n      j += 1;\n    end;\n  end;\n  \n  if j < nums2.Count then\n    nums1.AddRange(nums2.Skip(j));\n    \n  Result := nums1;\nend;"
  },
  {
    "instruction": "Write a function to find the maximum frequency of elements in a list that can be increased up to k times.",
    "output": "function MaxFreq(nums: array of integer; k: integer): integer;\nbegin\n  &Array.Sort(nums);\n  var left := 0;\n  var right := 0;\n  var maxFreq := 0;\n  var total := 0;\n  \n  while right < nums.Length do\n  begin\n    total += nums[right];\n    if nums[right] * (right - left + 1) <= total + k then\n      maxFreq := Max(maxFreq, right - left + 1)\n    else\n    begin\n      total -= nums[left];\n      left += 1;\n    end;\n    right += 1;\n  end;\n  \n  Result := maxFreq;\nend;"
  },
  {
    "instruction": "Write a function that takes a list of tuples, where each tuple contains a student's name and their grade for a particular assignment. The function should return a dictionary with the student's name as the key and their grade as the value, but with any students who received a grade below 60 removed.",
    "output": "function RemoveFailingStudents(grades: array of (string, integer)): Dictionary<string, integer>;\nbegin\n  Result := new Dictionary<string, integer>();\n  foreach var item in grades do\n    if item[1] >= 60 then\n      Result[item[0]] := item[1];\nend;"
  },
  {
    "instruction": "Write a function to find the longest sequence of consecutive zeros that is surrounded by ones at both ends in the binary representation of a given positive number.",
    "output": "function FindLongestZeros(number: integer): integer;\nbegin\n  var binaryStr := Convert.ToString(number, 2);\n  var maxGap := 0;\n  var currentGap := 0;\n  \n  foreach var bit in binaryStr do\n  begin\n    if bit = '0' then\n      currentGap += 1\n    else if bit = '1' then\n    begin\n      if currentGap > maxGap then\n        maxGap := currentGap;\n      currentGap := 0;\n    end;\n  end;\n  \n  Result := maxGap;\nend;"
  },
  {
    "instruction": "Write a function to find the sum of the factorial of each digit in a given number.",
    "output": "function Factorial(n: integer): integer;\nbegin\n  Result := 1;\n  for var i := 2 to n do\n    Result *= i;\nend;\n\nfunction SumOfDigitFactorials(n: integer): integer;\nbegin\n  Result := 0;\n  foreach var digitChar in n.ToString() do\n  begin\n    var digit := StrToInt(digitChar);\n    Result += Factorial(digit);\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the most frequent numbers in a list of integers.",
    "output": "function MostFrequentNumbers(numbers: array of integer): array of integer;\nbegin\n  var freqDict := new Dictionary<integer, integer>();\n  foreach var num in numbers do\n  begin\n    if freqDict.ContainsKey(num) then\n      freqDict[num] += 1\n    else\n      freqDict[num] := 1;\n  end;\n  \n  var maxCount := freqDict.Values.Max();\n  Result := freqDict.Where(x -> x.Value = maxCount).Select(x -> x.Key).ToArray();\nend;"
  },
  {
    "instruction": "Write a function to find perfect numbers within a given range.",
    "output": "function IsPerfect(n: integer): boolean;\nbegin\n  if n = 1 then\n  begin\n    Result := False;\n    exit;\n  end;\n  \n  var sum := 1;\n  var i := 2;\n  while i <= n / i do\n  begin\n    if n mod i = 0 then\n      sum += i + (n div i);\n    i += 1;\n  end;\n  \n  if i * i = n then\n    sum -= i;\n    \n  Result := sum = n;\nend;\n\nfunction FindPerfectNumbers(startVal, endVal: integer): array of integer;\nbegin\n  var perfectNumbers := new List<integer>();\n  \n  for var num := startVal to endVal do\n    if IsPerfect(num) then\n      perfectNumbers.Add(num);\n      \n  Result := perfectNumbers.ToArray();\nend;"
  },
  {
    "instruction": "Write a function to find the number of set bits in a given integer.",
    "output": "function CountSetBits(n: integer): integer;\nbegin\n  var count := 0;\n  var temp := n;\n  while temp > 0 do\n  begin\n    count += temp and 1;\n    temp := temp shr 1;\n  end;\n  Result := count;\nend;"
  },
  {
    "instruction": "Write a function to find the length of the longest substring without repeating characters.",
    "output": "function LengthLongestSubstring(s: string): integer;\nbegin\n  var charMap := new Dictionary<char, integer>();\n  var left := 0;\n  var maxLength := 0;\n  \n  for var right := 0 to s.Length - 1 do\n  begin\n    var currentChar := s[right + 1];\n    if charMap.ContainsKey(currentChar) then\n      left := Max(left, charMap[currentChar] + 1);\n    \n    charMap[currentChar] := right;\n    maxLength := Max(maxLength, right - left + 1);\n  end;\n  \n  Result := maxLength;\nend;"
  },
  {
    "instruction": "Write a function to find the second largest digit in a given string. If there is no second largest digit, return -1.",
    "output": "function SecondLargestDigit(s: string): integer;\nbegin\n  var digits := new List<integer>();\n  foreach var c in s do\n    if c.IsDigit() then\n      digits.Add(StrToInt(c));\n  \n  var uniqueDigits := digits.Distinct().Order().ToArray();\n  if uniqueDigits.Length < 2 then\n    Result := -1\n  else\n    Result := uniqueDigits[uniqueDigits.Length - 2];\nend;"
  },
  {
    "instruction": "Write a function that finds all possible combinations of a given list of numbers with a specific length.",
    "output": "function FindCombinations(nums: array of integer; k: integer): List<array of integer>;\nbegin\n  if nums.Length < k then\n  begin\n    Result := new List<array of integer>();\n    exit;\n  end;\n  \n  if nums.Length = k then\n  begin\n    Result := new List<array of integer>();\n    Result.Add(nums);\n    exit;\n  end;\n  \n  if k = 1 then\n  begin\n    Result := new List<array of integer>();\n    foreach var x in nums do\n      Result.Add(|x|);\n    exit;\n  end;\n  \n  Result := new List<array of integer>();\n  for var i := 0 to nums.Length - 1 do\n  begin\n    var remaining := nums.Skip(i + 1).ToArray();\n    var subsets := FindCombinations(remaining, k - 1);\n    foreach var subset in subsets do\n    begin\n      var newComb := new integer[subset.Length + 1];\n      newComb[0] := nums[i];\n      for var j := 0 to subset.Length - 1 do\n        newComb[j + 1] := subset[j];\n      Result.Add(newComb);\n    end;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the number of times a given pattern appears in a text as a subsequence.\n\nA pattern is a subsequence of a text if it can be derived from the text by deleting some or no characters without changing the order of the remaining characters.",
    "output": "function DpCountPattern(i, j: integer; text, pattern: string; lenText, lenPattern: integer): integer;\nbegin\n  if j = lenPattern then\n    Result := 1\n  else if i = lenText then\n    Result := 0\n  else if text[i + 1] = pattern[j + 1] then\n    Result := DpCountPattern(i + 1, j + 1, text, pattern, lenText, lenPattern) + DpCountPattern(i + 1, j, text, pattern, lenText, lenPattern)\n  else\n    Result := DpCountPattern(i + 1, j, text, pattern, lenText, lenPattern);\nend;\n\nfunction CountPatternAsSubsequence(text, pattern: string): integer;\nbegin\n  var lenText := text.Length;\n  var lenPattern := pattern.Length;\n  Result := DpCountPattern(0, 0, text, pattern, lenText, lenPattern);\nend;"
  },
  {
    "instruction": "Write a function that takes a list of integers and returns a new list with each element's sign converted to 1 (positive) or -1 (negative), except for zero, which is converted to 0.",
    "output": "function ConvertSigns(nums: array of integer): array of integer;\nbegin\n  Result := new integer[nums.Length];\n  for var i := 0 to nums.Length - 1 do\n  begin\n    if nums[i] > 0 then\n      Result[i] := 1\n    else if nums[i] < 0 then\n      Result[i] := -1\n    else\n      Result[i] := 0;\n  end;\nend;"
  },
  {
    "instruction": "Write a function to find the minimum number of changes required to make a binary string alternating. A binary string is alternating if no two adjacent characters are the same. The function should take a binary string as input and return the minimum number of changes required.",
    "output": "function MinChangesAlternating(s: string): integer;\nbegin\n  var count1 := 0;\n  var count2 := 0;\n  \n  for var i := 0 to s.Length - 1 do\n  begin\n    if i mod 2 = 0 then\n    begin\n      if s[i + 1] <> '1' then\n        count1 += 1\n      else\n        count2 += 1;\n    end\n    else\n    begin\n      if s[i + 1] <> '1' then\n        count2 += 1\n      else\n        count1 += 1;\n    end;\n  end;\n  \n  Result := Min(count1, count2);\nend;"
  },
  {
    "instruction": "Write a function to return the largest number in a list of integers. However, there's a twist: the function should ignore any negative numbers in the list.",
    "output": "function LargestPositive(numbers: array of integer): integer;\nbegin\n  var positiveNumbers := numbers.Where(x -> x >= 0).ToArray();\n  if positiveNumbers.Length = 0 then\n    raise new System.ArgumentException('No positive numbers in the list')\n  else\n    Result := positiveNumbers.Max();\nend;"
  },
  {
    "instruction": "Write a function to find the longest cycle in a directed graph represented as a list of edges. A cycle is a path that starts and ends at the same node. If no cycle exists, return -1.",
    "output": "function FindCycleSize(node: integer; var localInDegree: array of integer; edges: array of integer): integer;\nbegin\n  if localInDegree[node] = 0 then\n  begin\n    Result := 0;\n    exit;\n  end;\n  \n  localInDegree[node] -= 1;\n  Result := 1 + FindCycleSize(edges[node], localInDegree, edges);\nend;\n\nfunction LongestCycle(edges: array of integer): integer;\nbegin\n  var inDegree := new integer[edges.Length];\n  var queue := new Queue<integer>();\n  \n  for var i := 0 to edges.Length - 1 do\n    if edges[i] <> -1 then\n      inDegree[edges[i]] += 1;\n  \n  for var i := 0 to edges.Length - 1 do\n    if inDegree[i] = 0 then\n      queue.Enqueue(i);\n  \n  while queue.Count > 0 do\n  begin\n    var node := queue.Dequeue();\n    if edges[node] <> -1 then\n    begin\n      inDegree[edges[node]] -= 1;\n      if inDegree[edges[node]] = 0 then\n        queue.Enqueue(edges[node]);\n    end;\n  end;\n  \n  var maxCycle := -1;\n  var tempInDegree := Copy(inDegree);\n  for var i := 0 to edges.Length - 1 do\n  begin\n    if tempInDegree[i] <> 0 then\n    begin\n      var cycleSize := FindCycleSize(i, tempInDegree, edges);\n      if cycleSize > maxCycle then\n        maxCycle := cycleSize;\n    end;\n  end;\n  \n  Result := maxCycle;\nend;"
  }
]