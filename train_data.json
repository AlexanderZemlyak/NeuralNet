[
  {
    "instruction": "Implement the classic 15 puzzle game in PascalABC.NET using GraphABC and ABCObjects with tile movement, shuffling, and win condition detection",
    "output": "uses GraphABC,ABCObjects,ABCButtons;\n\nconst\n  n = 4;\n  sz = 100;\n  zz = 10;\n  x0 = 20;\n  y0 = 20;\n\nvar\n  p: array [1..n,1..n] of SquareABC;\n  digits: array [1..n*n-1] of integer;\n  MeshButton: ButtonABC;\n  StatusRect: RectangleABC;\n  EmptyCellX,EmptyCellY: integer;\n  MovesCount: integer;\n  EndOfGame: boolean;\n\nprocedure Swap(var p,p1: SquareABC);\nbegin\n  PABCSystem.Swap(p,p1);\n  var i := p.Left;\n  p.Left := p1.Left;\n  p1.Left := i;\n  i := p.Top;\n  p.Top := p1.Top;\n  p1.Top := i;\nend;\n\nfunction Neighbours(x1,y1,x2,y2: integer): boolean;\nbegin\n  Result := (Abs(x1-x2)=1) and (y1=y2) or (Abs(y1-y2)=1) and (x1=x2)\nend;\n\nprocedure FillDigitsArr;\nbegin\n  for var i:=1 to n*n-1 do\n    digits[i] := i;\nend;\n\nprocedure MixDigitsArr;\nvar x: integer;\nbegin\n  for var i:=1 to n*n-1 do\n  begin\n    repeat\n      x := Random(15)+1;\n    until x<>i;\n    Swap(digits[i],digits[x]);\n  end;\n  if n mod 2=0 then\n    Swap(digits[1],digits[2]);\nend;\n\nprocedure Fill15ByDigitsArr;\nbegin\n  Swap(p[EmptyCellY,EmptyCellX],p[n,n]);\n  EmptyCellX := n;\n  EmptyCellY := n;\n  var i := 1;\n  for var y:=1 to n do\n  for var x:=1 to n do\n  begin\n    if x*y=n*n then exit;\n    p[y,x].Number := digits[i];\n    i += 1;\n  end;\nend;\n\nprocedure Mix15;\nbegin\n  MixDigitsArr;\n  Fill15ByDigitsArr;\n  MovesCount := 0;\n  EndOfGame := False;\n  StatusRect.Text := 'Move count: '+IntToStr(MovesCount);\n  StatusRect.Color := RGB(200,200,255);\nend;\n\nprocedure Create15;\nbegin\n  EmptyCellX := n;\n  EmptyCellY := n;\n  for var x:=1 to n do\n  for var y:=1 to n do\n  begin\n    p[y,x] := new SquareABC(x0+(x-1)*(sz+zz),y0+(y-1)*(sz+zz),sz,clMoneyGreen);\n    p[y,x].BorderColor := clGreen;\n    p[y,x].BorderWidth := 2;\n    p[y,x].TextScale := 0.7;\n  end;\n  p[EmptyCellY,EmptyCellX].Color := clWhite;\n  p[EmptyCellY,EmptyCellX].BorderColor := clWhite;\n  FillDigitsArr;\n  MixDigitsArr;\n  Fill15ByDigitsArr;\nend;\n\nfunction IsSolution: boolean;\nbegin\n  Result:=True;\n  var i:=1;\n  for var y:=1 to n do\n  for var x:=1 to n do\n  begin\n    if p[y,x].Number<>i then\n    begin\n      Result:=False;\n      break;\n    end;\n    i += 1;\n    if i=n*n then i:=0;\n  end;\nend;\n\nprocedure MouseDown(x,y,mb: integer);\nbegin\n  if EndOfGame then\n    exit;\n  if ObjectUnderPoint(x,y)=nil then\n    exit;\n  var fx := (x-x0) div (sz+zz) + 1;\n  var fy := (y-y0) div (sz+zz) + 1;\n  if (fx>n) or (fy>n) then\n    exit;\n  if Neighbours(fx,fy,EmptyCellX,EmptyCellY) then\n  begin\n    Swap(p[EmptyCellY,EmptyCellX],p[fy,fx]);\n    EmptyCellX := fx;\n    EmptyCellY := fy;\n    Inc(MovesCount);\n    StatusRect.Text := 'Move count: ' + MovesCount;\n    if IsSolution then\n    begin\n      StatusRect.Text := 'Victory! Moves made: ' + MovesCount;\n      StatusRect.Color := RGB(255,200,200);\n      EndOfGame := True;\n    end\n  end;\nend;\n\nbegin\n  SetSmoothingOff;\n  Window.Title := '15 Puzzle Game';\n  Window.IsFixedSize := True;\n  SetWindowSize(2*x0+(sz+zz)*n-zz,2*y0+(sz+zz)*n-zz+90);\n  \n  EndOfGame := False;\n  Create15;\n\n  MeshButton := ButtonABC.Create((WindowWidth-200) div 2,2*y0+(sz+zz)*n-zz,200,'Shuffle',clLightGray);\n  MeshButton.OnClick := Mix15;\n  StatusRect := new RectangleABC(0,WindowHeight-40,WindowWidth,40,RGB(200,200,255));\n  StatusRect.TextVisible := True;\n  StatusRect.Text := 'Move count: '+IntToStr(MovesCount);\n  StatusRect.BorderWidth := 2;\n  StatusRect.BorderColor := RGB(80,80,255);\n\n  MovesCount := 0;\n\n  OnMouseDown := MouseDown;\nend."
  },
  {
    "instruction": "Create a parametric 3D spiral curve using Graph3D module in PascalABC.NET",
    "output": "uses Graph3D;\n\nfunction ParametricTrajectory(a,b: real; N: integer; fun: real->Point3D) := PartitionPoints(a,b,N).Select(fun);\n\nfunction ParametricCirve3D(a,b: real; fun: real->Point3D; N: integer := 200): SegmentsT;\nbegin\n  var tr := ParametricTrajectory(a,b,N,fun);\n  Result := Polyline3D(tr);\nend;\n\nbegin\n  ParametricCirve3D(0,20*Pi,t->P3D(0.04*t*cos(t),0.04*t*sin(t),0.1*t),1000);\nend."
  },
  {
    "instruction": "Compare performance between built-in Abs function and System.Math.Abs for integers in PascalABC.NET",
    "output": "begin\n  var s := 0;\n  var n := MaxInt;\n  loop n do\n    s := Abs(-2);\n  Print(MillisecondsDelta);\n  loop n do\n    s := System.Math.Abs(-2);\n  Print(MillisecondsDelta);\nend."
  },
  {
    "instruction": "Demonstrate ABCObjects module for creating and manipulating graphical objects with properties in PascalABC.NET",
    "output": "// ABCObjects module. Changing object properties\nuses ABCObjects,GraphABC;\n\nconst delay = 300;\n\nprocedure Pause := Sleep(delay);\n\nbegin\n  Window.Title := 'ABCObjects: properties of graphical objects';\n  var z := new StarABC(Window.Center.X,Window.Center.Y,70,30,6,Color.Green);\n  var r := new RectangleABC(100,100,200,100,Color.Gold);\n  Pause;\n  r.Center := Window.Center;\n  Pause;\n  r.Height := 70;\n  Pause;\n  r.Width := 220;\n  Pause;\n  z.Radius := 150;\n  Pause;\n  z.Color := Color.LightCoral;\n  Pause;\n  z.Count := 5;\n  Pause;\n \n  r.Text := 'PascalABC.NET';\n  r.Color := Color.Gainsboro;\n  Pause;\n  r.BorderWidth := 3;\n  r.BorderColor := Color.Blue;\n  Pause;\n  r.Center := Window.Center;\nend."
  },
  {
    "instruction": "Implement helper functions for parametric 3D curve generation in PascalABC.NET",
    "output": "uses Graph3D;\n\nfunction ParametricTrajectory(a,b: real; N: integer; fun: real->Point3D) := PartitionPoints(a,b,N).Select(fun);\n\nfunction ParametricCirve3D(a,b: real; fun: real->Point3D; N: integer := 200): SegmentsT;\nbegin\n  var tr := ParametricTrajectory(a,b,N,fun);\n  Result := Polyline3D(tr);\nend;"
  },
  {
    "instruction": "Create tile swapping logic for 15 puzzle game with neighbor detection",
    "output": "procedure Swap(var p,p1: SquareABC);\nbegin\n  PABCSystem.Swap(p,p1);\n  var i := p.Left;\n  p.Left := p1.Left;\n  p1.Left := i;\n  i := p.Top;\n  p.Top := p1.Top;\n  p1.Top := i;\nend;\n\nfunction Neighbours(x1,y1,x2,y2: integer): boolean;\nbegin\n  Result := (Abs(x1-x2)=1) and (y1=y2) or (Abs(y1-y2)=1) and (x1=x2)\nend;\n\nfunction IsSolution: boolean;\nbegin\n  Result:=True;\n  var i:=1;\n  for var y:=1 to n do\n  for var x:=1 to n do\n  begin\n    if p[y,x].Number<>i then\n    begin\n      Result:=False;\n      break;\n    end;\n    i += 1;\n    if i=n*n then i:=0;\n  end;\nend;"
  },
  {
    "instruction": "Implement array shuffling algorithm for 15 puzzle game with even permutation count",
    "output": "procedure FillDigitsArr;\nbegin\n  for var i:=1 to n*n-1 do\n    digits[i] := i;\nend;\n\nprocedure MixDigitsArr;\nvar x: integer;\nbegin\n  for var i:=1 to n*n-1 do\n  begin\n    repeat\n      x := Random(15)+1;\n    until x<>i;\n    Swap(digits[i],digits[x]);\n  end;\n  if n mod 2=0 then\n    Swap(digits[1],digits[2]);\nend;\n\nprocedure Fill15ByDigitsArr;\nbegin\n  Swap(p[EmptyCellY,EmptyCellX],p[n,n]);\n  EmptyCellX := n;\n  EmptyCellY := n;\n  var i := 1;\n  for var y:=1 to n do\n  for var x:=1 to n do\n  begin\n    if x*y=n*n then exit;\n    p[y,x].Number := digits[i];\n    i += 1;\n  end;\nend;"
  },
  {
    "instruction": "Create a simple ball animation with reflection from window boundaries using GraphWPF in PascalABC.NET",
    "output": "uses GraphWPF;\n\nbegin\n  Window.Title := 'Ball Reflection. Real direction of movement';\n  Brush.Color := Colors.Beige;\n  var x := 400.0;\n  var y := 300.0;\n  var dx := 2.1;\n  var dy := -1.2;\n  Circle(x,y,20);\n  while True do\n  begin\n    Sleep(10);\n    Window.Clear;\n    x += dx;\n    y += dy;\n    if not x.Between(0,Window.Width) then \n      dx := -dx;\n    if not y.Between(0,Window.Height) then \n      dy := -dy;\n    Circle(x,y,20);\n    if Milliseconds>2000 then\n      Window.Title := 'Seconds: ' + (Milliseconds div 100)/10;\n  end;\nend."
  },
  {
    "instruction": "Implement a BallInfo class for multiple ball animation with frame-based rendering in PascalABC.NET",
    "output": "uses GraphWPF;\n\ntype \n  BallInfo = auto class\n    x,y,r,dx,dy: real;\n    c: Color;\n    procedure Move := (x,y) := (x+dx,y+dy);\n    procedure Draw := FillCircle(x,y,r,c);\n    procedure CheckDirection;\n    begin\n      if not x.Between(r,Window.Width-r) then \n        dx := -dx;\n      if not y.Between(r,Window.Height-r) then \n        dy := -dy;\n    end;\n    procedure Step;\n    begin\n      Move; \n      CheckDirection;\n      Draw;\n    end;\n    class function CreateRandomBallArray(n: integer): array of BallInfo;\n    begin\n      var rr := 20;\n      Result := ArrGen(n,i->new BallInfo(RandomReal(rr,Window.Width-rr),\n        RandomReal(rr,Window.Height-rr),RandomReal(5,15),\n        RandomReal(-3,3),RandomReal(-3,3),RandomColor));\n    end;    \n  end;\n\nbegin\n  Window.Title := 'Ball Reflection. Frame-based animation';\n  \n  var n := 1000;\n  var a := BallInfo.CreateRandomBallArray(n);\n  \n  BeginFrameBasedAnimation(()->\n    foreach var ball in a do\n      ball.Step\n  );\nend."
  },
  {
    "instruction": "Create time-based ball animation with velocity control using OnDrawFrame event in PascalABC.NET",
    "output": "uses GraphWPF;\n\nconst vmax = 50;\n\ntype \n  BallInfo = auto class\n    x,y,r,vx,vy: real;\n    c: Color;\n    procedure Move(dt: real) := (x,y) := (x+vx*dt,y+vy*dt);\n    procedure Draw := FillCircle(x,y,r,c);\n    procedure CheckDirection;\n    begin\n      if not x.Between(r,Window.Width-r) then \n        vx := -vx;\n      if not y.Between(r,Window.Height-r) then \n        vy := -vy;\n    end;\n    procedure Step(dt: real);\n    begin\n      Move(dt); \n      CheckDirection;\n      Draw;\n    end;\n    class function CreateRandomBallArray(n: integer): array of BallInfo;\n    begin\n      var rr := 25;\n      Result := ArrGen(n,i->new BallInfo(RandomReal(rr,Window.Width-rr),\n        RandomReal(rr,Window.Height-rr),RandomReal(5,15),\n        RandomReal(-vmax,vmax),RandomReal(-vmax,vmax),RandomColor));\n    end;    \n  end;\n\nbegin\n  Window.Title := 'Ball Reflection. Frame-based animation';\n  \n  var n := 1000;\n  var a := BallInfo.CreateRandomBallArray(n);\n  \n  OnDrawFrame := dt ->\n    foreach var ball in a do\n      ball.Step(dt);\nend."
  },
  {
    "instruction": "Implement 3D cube animation with acceleration ratio and auto-reverse using Graph3D in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin\n  var ss := Cube(0,0,0,1.5,Colors.Red);\n  var anim := ss.AnimMoveByX(10).AutoReverse.Forever.AccelerationRatio(0.5,0.5);\n  anim.Begin;\nend."
  },
  {
    "instruction": "Create a rotating disc with attached spheres using 3D animation in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin\n  View3D.ShowGridLines := False;\n  var disc := Cylinder(0,0,0,0.2,6,Colors.DeepPink);\n\n  var r := 5;  \n  foreach var x in PartitionPoints(0,2*Pi,12) do \n    disc.AddChild(Sphere(r*cos(x),r*sin(x),0.2,0.1,Colors.White));\n  disc.AnimRotate(OrtZ,360,2).AccelerationRatio(1,1).AutoReverse.Forever.Begin;\nend."
  },
  {
    "instruction": "Implement a self-learning animal guessing game using binary decision tree in PascalABC.NET",
    "output": "type\n  TNode = class\n    s: string;\n    left,right: TNode;   \n    constructor(s: string);\n    begin\n      Self.s := s;\n      left := nil;\n      right := nil;\n    end;\n  end;\n\nvar f: text;\n\nprocedure SaveToFile(p: TNode);\nbegin\n  if p=nil then\n  begin\n    writeln(f,'');\n    exit\n  end;\n  writeln(f,p.s);\n  SaveToFile(p.left);\n  SaveToFile(p.right);\nend;\n\nfunction LoadFromFile: TNode;\nvar\n  s: string;\nbegin\n  readln(f,s);\n  if s='' then\n  begin\n    Result := nil;\n    exit\n  end;\n  var p := new TNode(s);\n  p.left := LoadFromFile;\n  p.right := LoadFromFile;\n  Result := p;\nend;\n\nvar\n  p,p1,p2,root: TNode;\n  x: integer;\n  s,q: string;\n\nbegin\n  writeln('Think of an animal');\n  assign(f, 'animals_data.txt');\n  if not FileExists('animals_data.txt') then\n    root := new TNode('Dog')\n  else\n  begin\n    reset(f);\n    root := loadfromfile;\n    close(f);\n  end;\n\n  p := root;\n  while p.left<>nil do\n  begin\n    Print(p.s+'? (0 - No, 1 - Yes):');\n    readln(x);\n    if x=1 then \n      p := p.left\n    else \n      p := p.right\n  end;\n  \n  write('Is it '+p.s+'? (0 - No, 1 - Yes): ');\n  readln(x);\n  if x=1 then\n    writeln('I guessed!')\n  else\n  begin\n    write('I lost. What animal is it? ');\n    readln(s);\n    write('Enter a question that distinguishes this animal from '+p.s+': ');\n    readln(q);\n    p1 := new TNode(s);\n    p2 := new TNode(p.s);\n    p.s := q;\n    p.left := p1;\n    p.right := p2;\n  end;\n  \n  Rewrite(f);\n  SaveToFile(root);\n  Close(f);\nend."
  },
  {
    "instruction": "Create 3D scaling animation with auto-reverse using Graph3D in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin\n  var ss := Cube(0,0,0,1.5,Colors.Red);\n  var anim := ss.AnimScale(3).Forever.AutoReverse;\n  anim.Begin;\nend."
  },
  {
    "instruction": "Show algorithm for determining prime numbers using for loop in PascalABC.NET",
    "output": "// Algorithm for determining prime numbers\n\nbegin\n  var N := ReadInteger('Enter number:');\n  var IsPrime := True;\n  for var i := 2 to Round(Sqrt(N)) do // if number is composite, then one of its factors ≤ sqrt(N)\n    if N mod i = 0 then\n    begin\n      IsPrime := False;\n      break;\n    end;\n  if IsPrime then\n    Println('Number', N, 'is prime') else Println('Number', N, 'is composite');\nend."
  },
  {
    "instruction": "Show algorithm for calculating polynomial value using Horner's scheme in PascalABC.NET",
    "output": "// Algorithm for calculating polynomial value at point x using Horner's scheme\n\nconst n = 5;\n\nbegin\n  var x := ReadReal('Enter value x:');\n  Print($'Enter polynomial coefficients ({n + 1} pieces):');\n  var a := ReadReal;\n  var s := a;\n  for var i := 1 to n do\n  begin\n    a := ReadReal;\n    s := s * x + a;\n  end;\n  Println('Polynomial value at point', x, 'equals', s);\nend."
  },
  {
    "instruction": "Create various 3D primitives demonstration using Graph3D module in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin\n  Window.Title := '3D Primitives';\n  \n  var rr := Rectangle3D(-3.5,-2,0,3,2,Colors.MediumPurple);\n  rr.Rotate(v3d(0,1,0),30);\n  \n  var arrows := CoordinateSystem(2);\n  \n  var Ar := Arrow(3,0,0,0,0,2,Colors.Tan);\n\n  var p := P3D(5,-5,0);\n  var t := TruncatedCone(p,2,0.9,0.7,False,Colors.Red);\n  p := p.MoveX(-2);\n  TruncatedCone(p,2,0.9,0.7,Colors.BlueViolet);\n  p := p.MoveX(-2);\n  Cylinder(p,2,0.9,False,Colors.Crimson);\n  p := p.MoveX(-2);\n  var cc := Cylinder(p,2,0.9,Colors.Chocolate);\n  p := p.MoveX(-2);\n  var cone := Cone(p,2.5,0.9,Colors.DarkGreen);\n  p := p.MoveX(-2);\n  var c := Sphere(p.MoveZ(0.7),1,Colors.Crimson);\n  Text3D(p.MoveZ(2.3),'Sphere',0.7);\n  \n  p := P3D(5,-2,0);\n  var teapot := Teapot(p.MoveZ(0.9),Colors.ForestGreen);\n  var bb := BillboardText(p.Move(2,0,0.7),'Billboard'+NewLine + '\"Teapot\"',12);\n  p := p.MoveX(-2.75);\n  var cb := Cube(p.MoveZ(0.75),1.5,Colors.DodgerBlue);\n  cb.Scale(1.2);\n  cb.Rotate(V3D(0,0,1),45);\n  p := p.MoveX(-2.75);\n  var b := Box(p,Sz3D(2,1,1),Colors.PaleGreen);\n  b.Rotate(V3D(0,1,0),-30);\n  p := P3D(5,1,0);\n  var ellipsoid := Ellipsoid(p.MoveZ(0.6),1.3,0.8,0.6,Colors.Violet);\n  p := p.MoveX(-7);\n  var pp := Tube(p,2,0.7,0.5,Colors.DodgerBlue);\nend."
  },
  {
    "instruction": "Split string into words using AllDelimiters constant in PascalABC.NET",
    "output": "begin\n  var s := '123@!45  @#$678\\/|?90~;';\n  s.ToWords(AllDelimiters).Println;\nend."
  },
  {
    "instruction": "Demonstrate that all types except pointers are derived from Object in PascalABC.NET",
    "output": "// All types except pointers - derived from Object\nvar \n  i: integer;\n  r: real;\n  o: object;\n\nbegin\n  o := i;\n  Println(o.GetType,TypeName(o));\n  o := r;\n  Println(o.GetType,TypeName(o));\n  if o.GetType = typeof(real) then\n    Println('Variable o has real type');\nend."
  },
  {
    "instruction": "Show how to use the \"&\" symbol to remove keyword attribute in PascalABC.NET",
    "output": "// Example illustrating the use of \"&\" symbol to remove keyword attribute\n\nbegin\n  var &begin,&end: integer;  \n\n  &begin := 1;\n  &end := 2;\n  var t: System.Type := &begin.GetType; // no need to use & in System.Type\n  write(&begin,' ',&end,' ',t);\nend."
  },
  {
    "instruction": "Demonstrate using the \"&\" symbol for explicit template type specification in PascalABC.NET",
    "output": "// Example illustrating the use of \"&\" symbol for explicit template routine type specification\n\nfunction GetDefault<T>: T :=\n  default(T);\n\ntype\n  GenericType<T> = class\n    constructor := exit;\n    static procedure p1 := writeln(typeof(T));\n  end;\n\nbegin\n  // The compiler doesn't distinguish between comparison operator < and opening angle bracket\n  // so we need to use \"&\" to escape \"<\"\n  var o := GetDefault&<byte>;\n  \n  // For template types - usually \"&\" is not needed\n  var a := new GenericType<word>;\n  \n  // However for static method call - it must be placed\n  GenericType&<real>.p1;\n  \nend."
  },
  {
    "instruction": "Create simple linear animation moving a circle across the screen using GraphWPF in PascalABC.NET",
    "output": "uses GraphWPF;\n\nbegin\n  Window.Title := 'Simple Animation';\n  var x := 30;\n  Brush.Color := Colors.Beige;\n  Circle(x,50,20);\n  loop 600 do\n  begin\n    Sleep(10);\n    Window.Clear;\n    x += 1;\n    Circle(x,50,20);\n    Window.Title := '' + (Milliseconds div 100)/10;\n  end;\nend."
  },
  {
    "instruction": "Generate character code table from ASCII 32 to 255 with formatting in PascalABC.NET",
    "output": "begin\n  for var i:=32 to 255 do\n  begin\n    write(i:4,chr(i):2,'  ');\n    if i mod 8 = 7 then writeln;\n  end;\nend."
  },
  {
    "instruction": "Demonstrate child object attachment and rotation in 3D graphics using Graph3D in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin\n  var s := Sphere(0,1,2,2,Colors.Orchid);\n  s.AddChild(Sphere(0,2,1,0.5,Colors.White));\n  s.Rotate(OrtZ,90);\nend."
  },
  {
    "instruction": "Show class constructors and static fields in PascalABC.NET with random person generation example",
    "output": "// Example of using class (static) constructor\ntype \n  Person = class\n  private\n    class arr: array of Person; // Class field. Associated not with class variable, but with class. \n    name: string;\n    age: integer;\n  public\n    class constructor; // Class constructor. Called before creating first class object and before calling any class method\n    begin\n      Println('  Class constructor called');\n      SetLength(arr,3);\n      arr[0] := new Person('Ivanov',20);\n      arr[1] := new Person('Petrova',19);\n      arr[2] := new Person('Popov',35);\n    end;\n    constructor (n: string; a: integer);\n    begin\n      name := n;\n      age := a;\n    end;\n    function ToString: string; override;\n    begin\n      Result := $'Name: {name}   Age: {age}';      \n    end;\n    class function RandomPerson: Person; // Class method. Can only access class fields\n    begin\n      Result := arr[Random(3)];\n    end;\n  end;\n  \nbegin\n  Println('Random persons');\n  for var i:=1 to 5 do\n    Println(Person.RandomPerson); // Calling class method\nend."
  },
  {
    "instruction": "Show how to define methods inside class interface and demonstrate constructor usage in PascalABC.NET",
    "output": "// Method description inside class interface\n// Convenience: methods can be implemented immediately after declaration\n// Inconvenience: for large classes interface is hard to read\ntype \n  Person = class\n  private\n    // Class fields, as a rule, are private. Access to them - through methods and properties\n    name: string;\n    age: integer;\n  public\n    // Constructor implicitly has name Create\n    constructor (n: string; a: integer);\n    begin\n      name := n; age := a;\n    end;\n    procedure Print;\n    begin\n      Println('Name:',name,' Age:',age);\n    end;\n  end;\n\nvar p,p1: Person;\n\nbegin\n  p := new Person('Ivanov',20); // New constructor call syntax (recommended)\n  p.Print;\n  p1 := Person.Create('Popov',19); // Old constructor call syntax (not recommended)\n  p1.Print;\n  // Destructors are absent, instead - automatic garbage collection\nend."
  },
  {
    "instruction": "Create digital clock with frame-based animation using GraphWPF in PascalABC.NET",
    "output": "uses GraphWPF;\n\nbegin\n  Window.Title := 'Digital clock';\n  Font.Size := 180;\n  BeginFrameBasedAnimation(\n    ()->DrawText(Window.ClientRect,DateTime.Now.ToLongTimeString.Replace(' AM','').Replace(' PM',''),Colors.Red),\n    1\n  );\nend."
  },
  {
    "instruction": "Demonstrate 3D object cloning and animation in Graph3D module using PascalABC.NET",
    "output": "uses Graph3D;\nbegin\n  var b := Box(0,0,1,1,3,2,RandomColor);\n  var b1 := b.Clone;\n  b1.MoveBy(3,0,0);\n  b1.AnimRotate(OrtZ,90).Begin;\nend."
  },
  {
    "instruction": "Create hierarchical 3D object structure with cloning and animation in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin\n  var s := Sphere(0,0,0,1,Colors.Red);\n  var c := Cube(0,0,1.5,1,Colors.Blue);\n  var p := Pyramid(0,0,0.5,4,0.5,1,Colors.LightGreen);\n  s.AddChild(c);\n  c.AddChild(p);\n  var s1 := s.Clone;\n  s1.MoveByX(2);\n  var g := Group(s,s1);\n  var g1 := g.Clone;\n  g.MoveByY(-4);\n  s1.AnimRotateAt(OrtZ,360,P3D(-2,0,0)).Begin;\nend."
  },
  {
    "instruction": "Generate clustered data points using MathNet.Numerics for normal distribution in PascalABC.NET",
    "output": "{$reference Mathnet.Numerics.dll}\nuses Mathnet.Numerics;\nuses Coords;\n\nfunction GenerateCluster(X, Y, spread: real; count: integer): array of Point;\nbegin\n  var xx := Generate.Normal(count, X, spread);\n  var yy := Generate.Normal(count, Y, spread);\n  Result := ArrGen(count, i -> Pnt(xx[i],yy[i]));\nend;\n\nbegin\n  Window.Title := 'Cluster generation';\n  var cluster1 := GenerateCluster(5, 3, 0.5, 90);\n  var cluster2 := GenerateCluster(7, -6, 1.5, 105);\n  var cluster3 := GenerateCluster(-7, 2, 1, 44);\n  \n  DrawPoints(cluster1,3);\n  DrawPoints(cluster2,3);\n  DrawPoints(cluster3,PointRadius := 3);\nend."
  },
  {
    "instruction": "Demonstrate colored console output using special character codes in PascalABC.NET",
    "output": "begin\n  Writeln('123456789');\n  Writeln(#65535'123456789');\n  Writeln(#65534'123456789');\n  Writeln(#65533'123456789');\n  Writeln(#65532'123456789');\n  Writeln(#65531'123456789');\nend."
  },
  {
    "instruction": "Fix compilation error by adding missing semicolon in variable declaration in PascalABC.NET",
    "output": "var i: integer;\n\nbegin\n  i := 2;\n  Writeln(i);\nend."
  },
  {
    "instruction": "Fix compilation errors by declaring variable and correcting function name in PascalABC.NET",
    "output": "var r: real;\n\nbegin\n  r := 2.5;\n  Writeln(r);\nend."
  },
  {
    "instruction": "Fix compilation error by using decimal point instead of comma in real number assignment in PascalABC.NET",
    "output": "var k: real;\n\nbegin\n  k := 2.5;\n  Writeln(k);\nend."
  },
  {
    "instruction": "Fix the compilation error by changing the variable type of x to match the assigned value",
    "output": "// Fix compilation errors by changing variable x type\n\nbegin\n  var x: real := 3/5;\nend."
  },
  {
    "instruction": "Demonstrate complex number operations including square root and magnitude calculation in PascalABC.NET",
    "output": "begin\n  var a := new Complex(0,1);\n  Println('Imaginary unit: ', a);\n  \n  var b := Sqrt(a);\n  Println('Principal root of imaginary unit: ', b);\n  \n  var c := a*a;\n  Println('Square of imaginary unit: ', c);\n  \n  var d := Cplx(1,2);\n  Println($'Magnitude of {ObjectToString(d)} equals {d.Magnitude}');\nend."
  },
  {
    "instruction": "Extract and display English consonants by excluding vowels from alphabet in PascalABC.NET",
    "output": "begin\n  var vowel: string := 'aeiouy';\n\n  var all := ('a'..'z').JoinToString;\n  all.Except(vowel).Println;\nend."
  },
  {
    "instruction": "Create interactive 3D pyramid with dynamic property controls using Graph3D and Controls in PascalABC.NET",
    "output": "uses Graph3D, Controls;\n\nbegin\n  var l := LeftPanel(200, Colors.LightGoldenrodYellow);\n  \n  var height := IntegerBox('Height:', 1, 15);\n  height.Value := 5;\n  height.Tooltip := 'Use mouse wheel';\n  var radius := IntegerBox('Radius:', 1, 6);\n  radius.Value := 2;\n  radius.Tooltip := 'Use mouse wheel';\n  var sides := Slider('Number of sides: ', 3, 20);\n  sides.Frequency := 1;\n  sides.Value := 5;\n  \n  var p := Pyramid(Origin, sides.Value, height.Value, radius.Value, Colors.Green);\n  \n  height.ValueChanged := procedure -> begin\n    p.Height := height.Value;\n  end;\n  radius.ValueChanged := procedure -> begin\n    p.Radius := radius.Value;\n  end;\n  sides.ValueChanged := procedure -> begin\n    p.Sides := sides.Value;\n  end;\nend."
  },
  {
    "instruction": "Demonstrate character code functions Ord and Chr with Windows encoding in PascalABC.NET",
    "output": "var \n  i: integer;\n  c: char;\n\nbegin\n  c := 'z';\n  i := Ord(c);\n  writelnFormat('Character {0} code in Windows encoding equals {1}',c,i);\n  i := 193;\n  c := Chr(i);\n  writelnFormat('Character with code {0} in Windows encoding is {1}',i,c);\nend."
  },
  {
    "instruction": "Demonstrate Unicode character code functions OrdUnicode and ChrUnicode in PascalABC.NET",
    "output": "var \n  i: integer;\n  c: char;\n\nbegin\n  c := 'Д';\n  i := OrdUnicode(c);\n  writelnFormat('Character {0} code in Unicode encoding equals {1}',c,i);\n  i := 1046;\n  c := ChrUnicode(i);\n  writelnFormat('Character with code {0} in Unicode encoding is {1}',i,c);\nend."
  },
  {
    "instruction": "Demonstrate character case conversion functions UpperCase and LowerCase in PascalABC.NET",
    "output": "var c: char;\n\nbegin\n  c := 'д';\n  writelnFormat('Character {0} in upper case: {1}',c,UpperCase(c));\n  c := 'F';\n  writelnFormat('Character {0} in lower case: {1}',c,LowerCase(c));\nend."
  },
  {
    "instruction": "Demonstrate standard character functions Ord, Chr, OrdWindows, ChrWindows for different encodings in PascalABC.NET",
    "output": "// Standard functions Ord, Chr, OrdWindows, ChrWindows\n\nbegin\n  Println('sizeof(char) =',sizeof(char));\n  Println;\n  var c: char  := 'Ж';\n  var i: integer := Ord(c);\n  Println($'Character code {c} in Unicode encoding equals {i}');\n  c := Chr(i);\n  Println($'Character with code {i} in Unicode encoding - this is {c}');\n  Println;\n  i := OrdWindows(c);\n  Println($'Character code {c} in Windows encoding equals {i}');\n  c := ChrWindows(i);\n  Println($'Character with code {i} in Windows encoding - this is {c}');\nend."
  },
  {
    "instruction": "Demonstrate the use of ranges and sequences in PascalABC.NET with the following operations: create a character range 'a' to 'z', check if 3 is in range 1..5, iterate through range 1..10, create an array and hash set from range 1..5, and calculate squares of numbers 1 to 9.",
    "output": "begin\n  var diap := 'a'..'z';\n  Println(diap);\n  var g := 3 in 1..5;\n  Println(g);\n  foreach var x in 1..10 do\n    Print(x);\n  var a := Arr(1..5);\n  var h := HSet(1..5);\n  Println(a,h);\n  (1..9).Select(x->x*x).Println;\nend."
  },
  {
    "instruction": "Create and display a dictionary from an array of key-value pairs in PascalABC.NET.",
    "output": "##\nvar pairs := Arr((1,'один'),(2,'два'));\nvar d := Dict(pairs);\nPrintln(pairs);\nPrintln(d);"
  },
  {
    "instruction": "Create and use a string dictionary and integer list in PascalABC.NET. Add 'cat' translation for 'кошка' to dictionary and add numbers 2 and 3 to the list.",
    "output": "##\nvar d := DictStr;\nd['кошка'] := 'cat';\nd.Println;\nvar L := LstInt;\nL.Add(2); L.Add(3);\nL.Println;"
  },
  {
    "instruction": "Solve the Cauchy problem for orbital motion using RKF45 method in PascalABC.NET with NumLibABC library.",
    "output": "uses NumLibABC;\n\nprocedure Orbit(t:real; y,yp:array of real);\nbegin\n  var alpha:=Sqr(ArcTan(1.0));\n  var r:=y[0]*y[0]+y[1]*y[1]; r:=r*Sqrt(r)/alpha;\n  yp[0]:=y[2]; yp[1]:=y[3]; yp[2]:=-y[0]/r; yp[3]:=-y[1]/r\nend;\n\nbegin\n  var e:=0.25;\n  var y:=Arr(1.0-e,0.0,0.0,ArcTan(1)*Sqrt((1.0+e)/(1.0-e)));\n  var (abserr,relerr):=(0.0,0.3e-6);\n  var oL:=new RKF45(Orbit, y, abserr, relerr);\n  var (t,tb,th):=(0.0,12.0,0.5);\n  var t_out:=t;\n  repeat\n    oL.Solve(t,t_out);\n    Writeln(t:5:1,oL.y[0]:15:9,oL.y[1]:15:9);\n    case oL.flag of\n    -3,-2,-1,1,8:begin Writeln('Flag=',oL.flag); Exit end;\n    2:t_out:=t+th;\n    end\n  until t>=tb\nend."
  },
  {
    "instruction": "Create a digital clock using GraphABC and System libraries in PascalABC.NET that displays current time in HH:MM:SS format and updates every second.",
    "output": "uses GraphABC,System;\n\nbegin\n  Font.Size := 80;\n  var x0 := (Window.Width - TextWidth('00:00:00')) div 2;\n  var y0 := (Window.Height - TextHeight('00:00:00')) div 2;\n  while True do\n  begin\n    var t := DateTime.Now;\n    var s := string.Format('{0:d2}:{1:d2}:{2:d2}',t.Hour,t.Minute,t.Second);\n    TextOut(x0,y0,s);\n    Sleep(1000);\n  end;\nend."
  },
  {
    "instruction": "Create graphics with random points, shapes and text using Coords library in PascalABC.NET.",
    "output": "uses Coords;\n\nfunction RandomPoint: Point := Pnt(Random(-13,13),Random(-10,10));\n\nbegin\n  DrawPoints(ArrGen(10,i -> RandomPoint),PointRadius := 4);\n  DrawPoints(ArrGen(10,i -> RandomPoint),PointRadius := 6);\n  DrawPoint(2,3,Colors.Red);\n  DrawCircle(1,1,1,Colors.LightBlue);\n  DrawRectangle(3,2,2,1);\n  DrawText(3,2,'Hello');\n  DrawTextUnscaled(0,0,'Текст не масштабируется', Size := 20, Color := Colors.Red);\n  DrawText(-4,7,'Текст масштабируется', FontName := 'Courier New', Size := 34);\nend."
  },
  {
    "instruction": "Draw points with labels and calculate distances between them using Coords library in PascalABC.NET.",
    "output": "uses Coords;\n\nbegin\n  Globals.PointRadius := 2.3;\n  Globals.LineWidth := 1.0;\n  var p1 := Pnt(2,3);\n  var p2 := Pnt(-4,7.3);\n  var p3 := Pnt(-5,-3);\n  DrawPoint(p1); \n  DrawPoint(p2);\n  DrawPoint(p3);\n  DrawText(p1,'A', Align := Alignment.LeftBottom, Size := 18);\n  DrawText(p2,'B', Align := Alignment.LeftBottom, Size := 18);\n  DrawText(p3,'C', Align := Alignment.RightTop, Size := 18);\n  DrawLine(p1,p2);\n  DrawLine(p1,p3);\n  DrawLine(p2,p3);\n  DrawText(Middle(p1,p2), p1.Distance(p2).ToString(2), Align := Alignment.Center, BackgroundColor := Colors.LightBlue);\n  DrawText(Middle(p2,p3), p2.Distance(p3).ToString(2), Align := Alignment.Center,\n    BackgroundColor := Colors.White, BorderWidth := 0.5);\n  DrawText(Middle(p1,p3), p1.Distance(p3).ToString(2), Align := Alignment.Center, BackgroundColor := Colors.LightGreen);\nend."
  },
  {
    "instruction": "Count occurrences of number 1 in an array using CountOf method in PascalABC.NET.",
    "output": "begin\n  var a := Arr(1,3,5,7,1,2,1,3,1,5);\n  a.CountOf(1).Print;\nend."
  },
  {
    "instruction": "Demonstrate covariance with sequences of different types in PascalABC.NET.",
    "output": "begin\n  var a: sequence of object;\n  var b: sequence of integer;\n  a := b;\n  a := Arr(1,2,3);\n  a := new List<DateTime>;\nend."
  },
  {
    "instruction": "Create a console drawing application using Crt library in PascalABC.NET with cursor movement and color changing functionality.",
    "output": "uses Crt;\n\nvar\n  draw: boolean;\t\t\t\n  color: integer;\n  \nfunction IsCoordCorrect(x,y: integer): boolean;  \nbegin\n  Result := (x in [1..WindowWidth]) and (y in [1..WindowHeight]);\nend;\n  \nprocedure MyGotoXY(x,y: integer);\nbegin\n  if not IsCoordCorrect(x,y) then  \n    exit;\n  GotoXY(x,y);  \nend;\n\nprocedure DrawSymbol(x,y: integer; c: char);\nbegin\n  if not IsCoordCorrect(x,y) then  \n    exit;\n  GotoXY(x,y);  \n  write(c);\n  GotoXY(x,y);  \nend;\n  \nbegin\n  draw := True;\n  color := Green;\n  ClrScr;\n  SetWindowTitle('Рисование курсором (Esc-выход, Num 5 - изменение цвета)');\n  TextBackGround(color);\n  GotoXY(WindowWidth div 2,WindowHeight div 2);\n  var c: char;\n  repeat\n    c := ReadKey;\n    if c=#32 then \n      draw := not draw;\n    if c=#0 then \n    begin\n      c := ReadKey;\n      case c of                           \n    {5} #12: begin\n              color := color + 1;\n              if color=16 then \n                color := 0;\n              TextBackGround(color);\n            end;\n    {RU}#33: MyGotoXY(WhereX+1,WhereY-1);\n    {RD}#34: MyGotoXY(WhereX+1,WhereY+1);\n    {LD}#35: MyGotoXY(WhereX-1,WhereY+1);\n    {LU}#36: MyGotoXY(WhereX-1,WhereY-1);\n    {L} #37: MyGotoXY(WhereX-1,WhereY);\n    {U} #38: MyGotoXY(WhereX,WhereY-1);\n    {R} #39: MyGotoXY(WhereX+1,WhereY);\n    {D} #40: MyGotoXY(WhereX,WhereY+1);\n        #67: ClrScr;\n      end;\n      if draw then \n        DrawSymbol(WhereX, WhereY,' ');\n    end;\n  until c=#27;\n  TextBackGround(Black);\n  GotoXY(1,25);\nend."
  },
  {
    "instruction": "Display all CRT color combinations in PascalABC.NET.",
    "output": "uses CRT;\n\nbegin\n  SetWindowTitle('Стандартные CRT-цвета');\n  for var i:=0 to 15 do\n  begin\n    TextBackground(i);\n    for var j:=0 to 15 do\n    begin\n      TextColor(j);\n      write(' CRT');\n    end;\n    writeln;\n  end;\n  HideCursor;\n  TextBackground(0);\n  TextColor(0);\nend."
  },
  {
    "instruction": "Create a 3D cube grid using Graph3D library in PascalABC.NET.",
    "output": "uses Graph3D;\n\nbegin\n  View3D.ShowGridLines := False;\n  View3D.ShowViewCube := False;\n  View3D.ShowCoordinateSystem := False;\n  var w := 1;\n  for var x := -5 to 5 do\n  for var y := -5 to 5 do\n  for var z := -4 to 6 do\n    Cube(x*w,y*w,z*w,w*0.96,RandomColor)\nend."
  },
  {
    "instruction": "Create various graphical shapes and text using GraphWPF library in PascalABC.NET with save/load functionality.",
    "output": "uses GraphWPF;\n\nbegin\n  Window.Title := 'Всякая Курья Мурья';\n  Pen.Width := 0.5;\n  Brush.Color := RGB(128,200,100);\n  Ellipse(100,100,30,20);\n  Brush.Color := RandomColor;\n  Circle(170,100,20);\n  Brush.Color := RandomColor;\n  Rectangle(220,80,70,50);\n  Line(220,80,220+70,80+50);\n  Brush.Color := RGB(200,200,255);\n  Polygon(Arr(Pnt(20,20),Pnt(20,120),Pnt(120,20)));\n  Brush.Color := Colors.Black;\n  for var i:=0 to 400 do\n    Rectangle(1+2*i,2,0,0);\n  Font.Size := 30;\n  Font.Color := Colors.Red;\n  TextOut(0,0,'Hello');  \n  Font.Size := 40;\n  Font.Color := Colors.Blue;\n  Font.Name := 'Times New Roman';\n  Font.Style := FontStyle.BoldItalic;\n  TextOut(200,0,'Привет'); \n  Sleep(1000);\n  Window.Save('1.png');\n  Window.Title := 'Сохранили';\n  Sleep(1000);\n  Window.Clear;\n  Window.Title := 'Очистили';\n  Sleep(1000);\n  Window.Load('1.png');\n  Window.Title := 'Загрузили';\nend."
  },
  {
    "instruction": "Demonstrate working with DateTime and TimeSpan in PascalABC.NET including date arithmetic and formatting",
    "output": "uses System;\n\nbegin\n  // Getting current date - calling static method\n  var d1 := DateTime.Now; \n  Println(d1);\n  \n  // Date and time after one month\n  var d2 := d1.AddMonths(1);\n  Println(d2);\n\n  // Date and time 12 hours earlier\n  d2 := d1.AddHours(-12);\n  Println(d2);\n\n  // Creating date - calling object constructor (year, month, day)\n  var d3 := new DateTime(2001, 1, 1);\n  Println(d3);\n  \n  // Determining time passed since millennium start (date difference)\n  var ts: TimeSpan := d1.Subtract(d3);\n\n  // Time interval in days (result - real number)\n  Println(ts.TotalDays);\n  \n  // Time interval in days, hours, minutes and seconds\n  Println($'{ts.Days} {ts.Hours}:{ts.Minutes}:{ts.Seconds}');\nend."
  },
  {
    "instruction": "Parse date string, check for leap year, and format DateTime to different string representations in PascalABC.NET.",
    "output": "Uses System;\n\nbegin\n  var s := '03.27.2008 9:58:17';\n  var d: DateTime;\n  if not DateTime.TryParse(s, d) then\n  begin\n    Println('Строка не содержит значение даты и времени');\n    Exit;\n  end;\n\n  if DateTime.IsLeapYear(d.Year) then\n     Println('Год високосный')\n  else\n     Println('Год невисокосный');\n  \n  s := d.ToString;\n  Println(s);\n  \n  s := d.ToShortDateString;\n  Println(s);\n\n  s := d.ToShortTimeString;\n  Println(s);\nend."
  },
  {
    "instruction": "Measure code execution time using DateTime in PascalABC.NET.",
    "output": "begin\n  var dt: DateTime := DateTime.Now;\n  var ms := Random(1000);\n  Writeln('Sleep','(',ms,')');\n  Sleep(ms);\n  Println((DateTime.Now-dt).TotalMilliseconds,'ms');\nend."
  },
  {
    "instruction": "Solve system of linear equations using Decomp from NumLibABC library in PascalABC.NET.",
    "output": "uses NumLibABC;\n\nbegin\n  var A:=new real[3,3] ((2,3,-1),(1,-2,1),(1,0,2));\n  var B:=new real[3] (9,3,2);\n  var oL:=new Decomp(A);\n  oL.Solve(B);\n  B.Println;\n  Writeln('cond=',oL.cond)\nend."
  },
  {
    "instruction": "Create a game where squares must be deleted in numerical order using WPFObjects library in PascalABC.NET.",
    "output": "uses WPFObjects;\n\nconst CountSquares = 20;\n\nvar\n  CurrentDigit: integer;\n  Mistakes: integer;\n  StatusRect: RectangleWPF;\n\nprocedure DrawStatusText;\nbegin\n  if CurrentDigit<=CountSquares then\n    StatusRect.Text := $'Удалено квадратов: {CurrentDigit-1}     Ошибок: {Mistakes}'\n  else StatusRect.Text := $'Игра окончена. Время: {Milliseconds div 1000} с.    Ошибок: {Mistakes}';\nend;\n\nprocedure MyMouseDown(x,y: real; mb: integer);\nbegin\n  var ob := ObjectUnderPoint(x,y);\n  if (ob<>nil) and (ob is RectangleWPF) and (ob<>StatusRect) then\n    if ob.Number=CurrentDigit then\n    begin\n      ob.Destroy;\n      Inc(CurrentDigit);\n      DrawStatusText;\n    end\n    else\n    begin\n      ob.Color := Colors.Red;\n      Inc(Mistakes);\n      DrawStatusText;\n    end;\nend;\n\nbegin\n  Window.Title := 'Игра: удали все квадраты по порядку';\n  for var i:=1 to CountSquares do\n  begin\n    var x := Random(Window.Width-50);\n    var y := Random(Window.Height-100);\n    var ob := RectangleWPF.Create(x,y,50,50,Colors.LightGreen,1);\n    ob.FontSize := 25;\n    ob.Number := i;\n  end;\n  StatusRect := RectangleWPF.Create(0,Window.Height-40,Window.Width,40,Colors.LightBlue);\n  CurrentDigit := 1;\n  Mistakes := 0;\n  DrawStatusText;\n  OnMouseDown := MyMouseDown;\nend."
  },
  {
    "instruction": "Display letters/digits and punctuation characters from ASCII range 0-127 in PascalABC.NET.",
    "output": "begin\n  Range(#0,#127).Where(c->char.IsLetterOrDigit(c)).Println;\n  Range(#0,#127).Where(c->char.IsPunctuation(c)).Println;\nend."
  },
  {
    "instruction": "Draw a circle interactively using mouse in GraphWPF. Press and hold mouse button to draw circles with random colors.",
    "output": "uses GraphWPF;\n\nbegin\n  var x1,y1: real;\n  var c: Color;\n  OnMouseDown := procedure(x,y,mb) -> begin\n    (x1,y1) := (x,y);\n    c := RandomColor;\n  end;\n  OnMouseMove := procedure(x,y,mb) -> if mb=1 then\n  begin\n    var r := Sqrt(Sqr(x1-x)+Sqr(y1-y));\n    Window.Clear;\n    Circle(x1,y1,r,c);\n  end;\nend."
  },
  {
    "instruction": "Draw multiple mathematical functions (x*sin(x), sin, cos, exp) using GraphABC with transparent brush.",
    "output": "uses GraphABC;\n\nbegin\n  Brush.Color := ARGB(0,0,0,0);\n  Draw(x->x*sin(x),-20,20);\n  Draw(sin);\n  Draw(cos);\n  Draw(exp);\nend."
  },
  {
    "instruction": "Draw mathematical functions in different scaled rectangles using GraphABC. Implement Scale and Move extension methods for Rectangle.",
    "output": "uses GraphABC;\n\nfunction System.Drawing.Rectangle.Scale(m: real): System.Drawing.Rectangle;\nbegin\n  Result := Self;\n  Result.Width := Trunc(Result.Width * m);\n  Result.Height := Trunc(Result.Height * m)\nend;\n\nfunction System.Drawing.Rectangle.Move(dx,dy: integer): System.Drawing.Rectangle;\nbegin\n  Result := Self;\n  Result.X := Result.X + dx;\n  Result.Y := Result.Y + dy;\nend;\n\nbegin\n  var r := ClientRectangle;\n  r := r.Scale(0.5);\n  var r1 := r.Move(r.Width,0);\n  var r2 := r.Move(0,r.Height);\n  var r3 := r.Move(r.Width,r.Height);\n  Draw(x->x*sin(x),-20,20,r);\n  Draw(sin,r1);\n  Draw(cos,r2);\n  Draw(exp,20,10,r3);\nend."
  },
  {
    "instruction": "Draw multiple function graphs in different window quadrants using GraphWPF: sin(4x)+cos(3x), x², exp(x), and x*cos(2x-1).",
    "output": "uses GraphWPF;\n\nbegin\n  Window.Title := 'Графики функций';\n  var ww := Window.Width / 2;\n  var hh := Window.Height / 2;\n  DrawGraph(x -> sin(4 * x) + cos(3 * x), -5, 5, 0, 0, ww, hh, 'sin(4 * x) + cos(3 * x)');\n  DrawGraph(x -> x * x, -5, 5, ww - 1, 0, ww, hh, 'x * x');\n  DrawGraph(x -> exp(x), -3, 3, 0, 10, 0, hh-1, ww, hh, 'exp(x)');\n  DrawGraph(x -> x*cos(2*x-1), -15, 15, ww - 1, hh-1, ww, hh, 'x * cos(2*x-1)');\nend."
  },
  {
    "instruction": "Generate and display a pixel matrix with calculated RGB colors using GraphWPF, then measure drawing performance.",
    "output": "uses GraphWPF;\n\nbegin\n  Window.SetSize(640, 480);\n  var m := MatrGen(640,480,(x,y)->RGB(2 * x - y, x - 3 * y, x + y));\n  MillisecondsDelta.Println;  \n  DrawPixels(0,0,m);\n  MillisecondsDelta.Println;  \nend."
  },
  {
    "instruction": "Draw random points using Turtle library. Generate arrays of random coordinates and plot them.",
    "output": "uses Turtle;\n\nbegin\n  Window.Title := 'DrawPoints';\n  var n := 1000;\n  var d := 10;\n  var a := ArrRandomReal(n,-d,d);\n  DrawPoints(a[::2],a[1::2]);\n  a := ArrRandomReal(n,-d,d);\n  DrawPoints(a[::2],a[1::2]);\nend."
  },
  {
    "instruction": "Create parametric trajectory functions and duplicate 3D objects along a spiral path using Graph3D.",
    "output": "uses Graph3D;\n\nfunction ParametricTrajectory(a,b: real; fun: real->Point3D; N: integer) := PartitionPoints(a,b,N).Select(fun);\n\nfunction ParametricCirve3D(a,b: real; fun: real->Point3D; N: integer := 200): SegmentsT;\nbegin\n  var tr := ParametricTrajectory(a,b,fun,N);\n  Result := Polyline3D(tr);\nend;\n\nprocedure DuplicateByTrajectory(c: Object3D; a,b: real; fun: real->Point3D; N: integer);\nbegin\n  c.MoveTo(fun(a));\n  foreach var p in PartitionPoints(a,b,N).Skip(1).Select(fun) do\n  begin\n    var c1 := c.Clone.MoveTo(p);\n    c1.Rotate(OrtZ,3);\n    (c1 as CubeT).Color := RandomColor;\n    c := c1;\n  end;\nend;\n\nbegin\n  var c := Cube(0,0,0,0.7,Colors.Green);\n  DuplicateByTrajectory(c,0,4*Pi,t->P3D(4*cos(t),4*sin(t),0.5*t),40);\nend."
  },
  {
    "instruction": "Show procedures and methods for working with dynamic arrays including sorting, reversing, and searching in PascalABC.NET",
    "output": "// Procedures and methods for working with dynamic array\n\nbegin\n  var a := ArrRandomInteger(10);\n  \n  // Output all array elements\n  a.Println;\n  \n  // Array sorting\n  a.Sort;\n  a.Println;\n\n  // Array reversal\n  a.Reverse;\n  a.Println;\n\n  // Changing array size with element preservation\n  SetLength(a,a.Length+2);\n  a.Println;\n\n  // Searching for element in array\n  var i := a.IndexOf(50);\n  Println(i);\nend."
  },
  {
    "instruction": "Create and display a dynamic array of random integers using SetLength and foreach loop.",
    "output": "var a: array of integer;\n\nbegin\n  var n := 20;\n  SetLength(a,n);\n  for var i:=0 to a.Length-1 do\n    a[i] := Random(1,99);\n  writeln('Содержимое случайного динамического массива целых: ');  \n  foreach var x in a do\n    Print(x);\nend."
  },
  {
    "instruction": "Demonstrate that dynamic array assignment creates references, not copies. Show how modifying one array affects another.",
    "output": "var a: array of integer;\n\nbegin\n  writeln('При присваивании динамических массивов две переменные начинают указывать на одну память:');\n  var n := 20;\n  a := new integer[n];\n  for var i:=0 to a.Length-1 do\n    a[i] := i;\n  writeln('До присваивания b[5]: a[5]=',a[5]);\n  var b: array of integer;\n  b := a;\n  b[5] := 666;\n  writeln('После присваивания b[5]: a[5]=',a[5]);\nend."
  },
  {
    "instruction": "Show how SetLength preserves existing elements when resizing a dynamic array.",
    "output": "var a: array of integer;\n\nbegin\n  writeln('SetLength при повторном вызове не портит старые элементы:');\n  SetLength(a,5);\n  for var i:=0 to a.Length-1 do\n    a[i] := i+1;\n  a.Println;\n  SetLength(a,10);\n  a.Println;\nend."
  },
  {
    "instruction": "Demonstrate passing dynamic arrays as parameters. Show when to use var parameter for array creation.",
    "output": "procedure WriteArr(a: array of integer);\nbegin\n  foreach x: integer in a do\n    write(x,' ');\n  writeln;\nend;\n\nprocedure CreateRandomArr(var a: array of integer; n: integer);\nbegin\n  a := new integer[n];\n  for var i:=0 to a.Length-1 do\n    a[i] := Random(10);\nend;\n\nvar a: array of integer;\n\nbegin\n  writeln('Случайный целый массив: ');\n  CreateRandomArr(a,30);\n  WriteArr(a);\nend."
  },
  {
    "instruction": "Demonstrate common dynamic array errors: accessing array without memory allocation and index out of bounds.",
    "output": "// Error 1: No memory allocation\nvar a: array of integer;\nbegin\n  a[0] := 666;\nend.\n\n// Error 2: Index out of bounds  \nvar a: array of integer;\nbegin\n  SetLength(a,10);\n  a[10] := 666;\nend."
  },
  {
    "instruction": "Convert number to digits in base 2 and back using School library in PascalABC.NET.",
    "output": "##\nuses School;\nvar lst := 1234.Digits(2);\nlst.Println;\nvar n := lst.DigitsToInt64(2);\nPrintln(n);"
  },
  {
    "instruction": "Demonstrate div and mod operations for digit manipulation in PascalABC.NET",
    "output": "// div and mod operations\n\nbegin\n  var a := ReadInteger('Enter a:');\n  Println('Last digit of number:', a mod 10);\n  Println('Number without last digit:', a div 10);\n  Println('If number a is even, then 0:', a mod 2);\nend.\n\n// div and mod operations\n\nbegin \n  var a: integer := 247;\n  Print('Digits of number in reverse order:');\n  // Output last digit\n  Print(a mod 10);\n  // Discard last digit\n  a := a div 10;\n  Print(a mod 10);\n  a := a div 10;\n  Print(a mod 10);\nend."
  },
  {
    "instruction": "Use Drawman library to draw simple geometric shapes. Move to point, draw line, and return to origin.",
    "output": "uses Drawman;\n\nbegin\n  Task('a1');\n  ToPoint(2,3);\n  PenDown;\n  OnVector(1,2);\n  PenUp;\n  ToPoint(0,0);\nend."
  },
  {
    "instruction": "Download a file from web using System.Net.WebClient and execute it in PascalABC.NET.",
    "output": "uses System.Net;\n\nconst \n  address = 'www.yandex.ru';\n  filename = 'LogoPABCNET2010_Rus.png';\n\nbegin\n  var w := new WebClient();\n  w.DownloadFile('http://pascalabc.net/images/logo/'+filename,filename);\n  Exec(filename);\nend."
  },
  {
    "instruction": "Generate Dragon Curve fractal using GraphABC and Utils libraries in PascalABC.NET with performance measurement.",
    "output": "program Dragon;\n\nuses GraphABC,Utils;\n\nvar\n  x := 200;\n  y := 150;\n  dx := 0;\n  dy := -4;\n  turn: array [1..1000] of Boolean;\n\nbegin\n  SetWindowSize(790,500);\n  Window.Title := 'Кривая Дракона';\n  var f := True;\n  for var a := 1 to 64 do\n  begin\n    turn[2*a-1] := f;\n    f := not f;\n    turn[2*a] := turn[a];\n  end;\n  var b := 0;\n  var d := 1;\n  f := false;\n  MoveTo(x,y);\n  \n  for var a:=1 to 128 do\n  begin\n    var t: integer;\n    LockDrawing;\n    for var i:=1 to 127*4 do\n    begin\n      b += d; \n      x += dx; \n      y += dy;\n      LineTo(x,y);\n      if f and not turn[b] or not f and turn[b] then\n      begin\n        t := dy;\n        dy := -dx;\n      end\n      else\n      begin\n        t := -dy;\n        dy := dx;\n      end;\n      dx := t;\n    end;\n    b += d; \n    x += dx; \n    y += dy;\n    LineTo(x,y);\n    d := -d;\n    f := not f;\n    if turn[a] then\n    begin\n      t := dy;\n      dy := -dx;\n    end\n    else\n    begin\n      t := -dy;\n      dy := dx;\n    end;\n    dx := t;\n    UnLockDrawing;\n  end;\n  write('Время работы = ',Milliseconds/1000,' с');\nend."
  },
  {
    "instruction": "Draw a rectangle and an ellipse in a window using GraphWPF",
    "output": "uses GraphWPF;\n\nbegin\n  Pen.Width := 1;\n  Rectangle(0,0,Window.Width-1,Window.Height-1);\n  Ellipse((Window.Width-1)/2,(Window.Height-1)/2,(Window.Width-1)/2,(Window.Height-1)/2);\nend."
  },
  {
    "instruction": "Explain enumerated types in PascalABC.NET with operations like Inc, Dec, Succ, Pred and boundary behavior",
    "output": "// Enumerated type\ntype Months = (January,February,March,April,May,June,\n  July,August,September,October,November,December);\n\nbegin\n  var m: Months := February;\n  writeln(m);\n  // Using enumerated type constants after type name is convenient: after dot intellisense shows list of constants\n  m := Months.April;\n  Println('Next month:',m);\n  Inc(m);\n  Println('Next month:',m);\n  m := Succ(m);  \n  Println('Next month:',m);\n  m := Pred(m);  \n  Println('Previous month:',m);\n  Dec(m);\n  Println('Previous month:',m);\n  Println('Its ordinal number (numbering - from zero):',Ord(m));\n  // No error\n  Println('Month before January - out of bounds:',Pred(Months.January));\n  // No error\n  Println('Month after December - out of bounds:',Succ(Months.December));\nend."
  },
  {
    "instruction": "Work with enumeration type using System namespace to get names and values",
    "output": "// Enumeration type\nuses System;\n\ntype Months = (January,February,March,April,May,June,July,August,September,October,November,December);\n\nbegin\n  var t: &Type := typeof(Months);\n  var names: array of string := Enum.GetNames(t);\n  writeln('Cycle by enumeration type names');\n  foreach name: string in names do\n    write(name,' ');\n  writeln; writeln;\n  \n  var v: &Array := Enum.GetValues(t);\n  var mm: array of Months := new Months[v.Length];\n  writeln('Cycle by array of all enumeration type values');\n  for var i:=0 to v.Length-1 do\n    mm[i] := Months(v.GetValue(i));\n     \n  for var i:=0 to mm.Length-1 do\n    write(mm[i],' ');    \nend."
  },
  {
    "instruction": "Demonstrate EOF function usage for reading until end of input in PascalABC.NET",
    "output": "// Demonstration of EOF function work. Run with Shift-F9, finish with Ctrl-Z\n// Ctrl-Z doesn't work with 3.9\nbegin\n  while not Eof do\n  begin\n    var s := ReadChar;\n    Println('-', Ord(s), '-',CurrentIOSystem.peek);\n  end;\nend."
  },
  {
    "instruction": "Demonstrate EOLN function for reading until end of line",
    "output": "// Demonstration of EOLN function\nbegin\n  while not Eoln do\n  begin\n    var c := ReadChar;\n    Print(c);\n  end;\nend."
  },
  {
    "instruction": "Implement Sieve of Eratosthenes algorithm to find prime numbers up to 100000",
    "output": "// \"Sieve of Eratosthenes\" - computing prime numbers\nconst n = 100000;\n\nbegin\n  var primes := HSet(2..n);\n  \n  for var i:=2 to Round(Sqrt(n)) do\n  begin\n    if not (i in primes) then\n      continue;\n    var x := i*i;\n    while x<=n do\n    begin\n      primes -= x;\n      x += i;\n    end;\n  end;\n\n  Println('Prime numbers <',n,';');\n  Println(primes);\n  Println;\n  Println('Computation time:',Milliseconds/1000);\nend."
  },
  {
    "instruction": "Draw E-squares using recursion with GraphABC",
    "output": "// E-squares. Recursion demonstration\nuses GraphABC;\n\nconst mw = 2.9;\n\nprocedure ESquares(n,x,y,w: integer);\nbegin\n  var w1 := round(w/mw);\n  var h := (w-2*w1) div 3;\n  Brush.Color := clRandom;\n  Rectangle(x,y,x+w,y+w);\n  if n>0 then\n  begin\n    Sleep(1);\n    ESquares(n-1,x+h,y+h,w1);\n    ESquares(n-1,x+w-h-w1,y+h,w1);\n    ESquares(n-1,x+h,y+w-h-w1,w1);\n    ESquares(n-1,x+w-h-w1,y+w-h-w1,w1);\n  end;\nend;\n\nbegin\n  Window.Title := 'Recursion: E-squares';\n  SetWindowSize(750,530);\n  Pen.Color := clWhite;\n  ESquares(4,125,18,490);\nend."
  },
  {
    "instruction": "Create a simple function that returns 3 using exit with parameter",
    "output": "function fff: integer;\nbegin\n  exit(3)\nend;\n\nbegin\n  Print(fff());\nend."
  },
  {
    "instruction": "Implement IsPrime function using exit with parameter for early returns",
    "output": "function IsPrime(n: integer): boolean;\nbegin\n  if n < 2 then exit(False);\n  for var i:=2 to n.Sqrt.Trunc do\n    if n.Divs(i) then\n      exit(False);\n  exit(True);\nend;\n\nbegin\n  IsPrime(17).Print;\n  IsPrime(1).Print;\nend."
  },
  {
    "instruction": "Implement IsPrime as lambda function using exit with parameter",
    "output": "begin\n  var IsPrime: integer → boolean := n → begin\n    if n < 2 then exit(False);\n    for var i:=2 to n.Sqrt.Trunc do\n    if n.Divs(i) then\n      exit(False);\n    exit(True);\n  end;\n  \n  IsPrime(17).Print;\n  IsPrime(1).Print;\nend."
  },
  {
    "instruction": "Implement FastPower function using recursion and exit with parameter for efficient exponentiation",
    "output": "function FastPower(a: real; n: integer): real;\nbegin\n  if n = 0 then exit(1); // a^0 = 1\n  if n = 1 then exit(a); // a^1 = a\n  if n < 0 then exit(1 / FastPower(a, -n)); // negative exponent\n  \n  var half := FastPower(a, n div 2);\n  if n mod 2 = 0 then exit(half * half); // even exponent\n  exit(half * half * a); // odd exponent\nend;\n\nbegin\n  Writeln('2^10 = ', FastPower(2, 10)); // 1024\n  Writeln('3^-2 = ', FastPower(3, -2)); // 0.111...\nend."
  },
  {
    "instruction": "Use extended foreach with tuple unpacking for arrays of tuples and sequences",
    "output": "// Extended foreach with value unpacking into variables\nbegin\n  var a := Arr((1,2),(3,4),(5,6));\n  foreach var (x,y) in a do // Tuple unpacking\n    Print(x,y);\n  Println;\n  var b := Arr(|1,2,3|,|4,5|,|6,7,8,9|);\n  foreach var (x,y) in b do // Sequence unpacking\n    Print(x,y);\nend."
  },
  {
    "instruction": "Create GUI application with FormsABC for calculating sum and product of two numbers",
    "output": "uses FormsABC;\n\nvar \n  a,b,sum,prod: IntegerField;\n  d: Button;\n\nprocedure MyClick;\nbegin\n  sum.Value := a.Value + b.Value;\n  prod.Value := a.Value * b.Value;\nend;\n\nbegin\n  a := new IntegerField('a:');\n  b := new IntegerField('b:');\n  LineBreak;\n  sum := new IntegerField('Sum:',220);\n  LineBreak;\n  prod := new IntegerField('Product:',220);\n  LineBreak;\n  EmptyLine(20);\n  d := new Button('Calculate');\n  d.Click += MyClick;\nend."
  },
  {
    "instruction": "Create GUI application using class with FormsABC for calculating sum and product",
    "output": "uses FormsABC;\n\ntype \n  View = class\n  private\n    a,b,sum,prod: IntegerField;\n    procedure MyClick;\n    begin\n      sum.Value := a.Value + b.Value;\n      prod.Value := a.Value * b.Value;\n    end;\n  public\n    constructor Create;\n    begin\n      a := new IntegerField('a:');\n      b := new IntegerField('b:');\n      LineBreak;\n      sum := new IntegerField('Sum:',220);\n      LineBreak;\n      prod := new IntegerField('Product:',220);\n      LineBreak;\n      EmptyLine(20);\n      var d := new Button('Calculate');\n      d.Click += MyClick;\n    end;\n  end;\n\nbegin\n  var v := new View;\nend."
  },
  {
    "instruction": "Use Each method to create dictionary with zeros for range 1 to 10",
    "output": "##\nvar dct := Arr(1..10).Each(x -> 0);\nPrint(dct); // dictionary"
  },
  {
    "instruction": "Use EachCount to get frequency dictionary for characters in string",
    "output": "##\nvar s := 'каракатица так и катится';\n// EachCount returns frequency dictionary (element,count)\ns.EachCount.Println"
  },
  {
    "instruction": "Create 3D Earth rotation animation with Graph3D using image material",
    "output": "uses Graph3D;\n\nbegin\n  HideObjects;\n  View3D.Title := 'Earth rotation';\n  View3D.CameraMode := CameraMode.Inspect;\n  View3D.ShowCoordinateSystem := False;\n  View3D.ShowGridLines := False;\n  View3D.ShowViewCube := False;\n  View3D.ShowCameraInfo := False;\n  View3D.BackgroundColor := Colors.Black;\n  \n  var c := Sphere(0,0,0,5,Colors.Wheat);\n  c.Material := ImageMaterial('Earth.jpg');\n  ShowObjects;\n\n  var gr := 0;\n  var dgr := 1;\n  while True do\n  begin\n    c.Rotate(V3D(0,0,1),1);\n    Sleep(10);\n    gr += dgr;\n    if (gr<=0) or (gr>=255) then\n      dgr := - dgr;\n    View3D.BackgroundColor := RGB(gr,gr,gr);\n  end;\nend."
  },
  {
    "instruction": "Use polynomial economization on interval with NumLibABC",
    "output": "uses NumLibABC;\n\n// Polynomial economization on interval\nbegin\n  var x:=ArrGen(8,-0.75,x->x+0.25);\n  var p:=new Polynom(0,1,-1/2,1/3,-1/4,1/5);\n  var r:=p.EconomSym(0.75, 0.05);\n  Println(r.eps,r.n);\n  r.PrintlnBeauty;\n  for var i:=1 to x.Length do\n    Write(r.Value(x[i-1]):0:3,' ')\nend."
  },
  {
    "instruction": "Draw multiple random ellipses using GraphWPF for performance testing",
    "output": "uses GraphWPF;\n \nbegin\n  Window.Title := 'Drawing ellipses';\n  Pen.Width := 1;\n  var n := 20000;\n  for var i:=1 to n do\n  begin\n    if i mod 10000 = 0 then\n      Println(i,MillisecondsDelta); \n    Brush.Color := RandomColor;\n    Ellipse(Random(800),Random(600),Random(20),Random(20));\n  end;\nend."
  },
  {
    "instruction": "Work with typed files in PascalABC.NET: write 10 random numbers to file, then read them and delete file",
    "output": "// Typed files\n// Write 10 numbers to file, on next run - read these numbers and delete file\nconst filename = 'a.dat';\n\nvar f: file of integer;\n\nbegin\n  if not FileExists(filename) then\n  begin\n    assign(f,filename);\n    rewrite(f);\n    writeln('Writing to file ',filename);\n    for var i:=1 to 10 do\n    begin\n      var x := random(100); \n      write(x,' ');\n      write(f,x);\n    end;  \n    close(f);  \n  end\n  else \n  begin\n    assign(f,filename);\n    reset(f);\n    writeln('Reading from file ',filename);\n    for var i:=1 to 10 do\n    begin\n      var x: integer;\n      read(f,x);\n      write(x,' ');\n    end;  \n    close(f);  \n    erase(f);\n  end;  \nend."
  },
  {
    "instruction": "Implement generic function IndexOf<T> that finds index of element in array",
    "output": "// Generic functions\n// Type T inference from parameter types\n\nfunction IndexOf<T>(a: array of T; val: T): integer;\nbegin\n  Result := -1;\n  for var i:=0 to a.Length-1 do\n    if a[i]=val then\n    begin\n      Result := i;\n      exit;\n    end;\nend;\n\nvar a := Arr('Ваня', 'Коля', 'Саша', 'Сережа');\n\nbegin\n  var s := 'Сережа';\n  writelnFormat('Index of element with value ''{0}'' is {1}',s,IndexOf(a,s));\nend."
  },
  {
    "instruction": "Find first 3 minimum values in random array using LINQ methods",
    "output": "// First 3 minimums\nbegin\n  ArrRandom(20).Println.Distinct.Order.Take(3).Println;\nend."
  },
  {
    "instruction": "Create waving flag animation using Graph3D with cloth physics",
    "output": "uses Graph3D;\n\nbegin  \n  Window.Caption := 'Waving flag';\n  View3D.HideAll;\n  Cylinder(0,4,0,6,0.07,Colors.Brown);\n  var c := Cloth(0,4,0,3,4,6,'FlagOfRussia.png');\n  c.WindSpeed := 6;\n  c.WindDirection := 180;\n  c.Gravity := 4;\n  c.Damping := 0.999;\n  c.Mass := 0.8;\n  c.Iterations := 20;\n  Sleep(1000);\n  c.Stop;\n  Sleep(1000);\n  c.Start;\nend."
  },
  {
    "instruction": "Create flame animation using GraphABC with pixel manipulation and color palette",
    "output": "uses GraphABC;\n\ntype TByteArray = array of byte;\nconst frames = 25;\n      size   = 250;\n      dxy    = size div 2;\n      dm     = 2*PI/1024;\n      flameh = 4;            \n      Light: byte = 255;\n      \nprocedure FillPallete(ColorsTable: array of Color);\nbegin\n  for var i:=0 to 255 do\n    if(i<128) then\n      ColorsTable[i] := RGB(i,0,i div 2)\n    else\n      ColorsTable[i] := RedColor(i);\nend;\n\nbegin  \n  // Create screen buffer\n  var ScreenBuffer := new TByteArray[size+1];\n  for var i:=0 to size do\n    ScreenBuffer[i] := new byte[size+1];\n  // Create palette\n  var ColorsTable := new Color[256];\n  FillPallete(ColorsTable);\n  // Configure window\n  SetWindowSize(size,size);\n  SetBrushColor(clBlack);\n  FillRectangle(0,0,WindowWidth,WindowHeight);\n  SetSmoothingOff;\n  LockDrawing;\n  // Start animation\n  var x, y, s, tt, xx, yy: Integer;\n  var dt := System.DateTime.Now;\n  var ds := WindowWidth div 4;\n  repeat\n    tt := tt + 1;\n    xx := dxy + Round(ds*Sin(tt*dm));\n    yy := dxy + Round(ds*Cos(tt*dm));\n    ScreenBuffer[xx,yy] := Light;\n    SetPixel(xx,yy,ColorsTable[Light]);\n    for var i:=0 to 5 do begin\n      x := Random(size-1) + 1;\n      y := Random(size-1) + 1;\n      s := ScreenBuffer[Y,X];\n      if s>=flameh then \n        s := s - flameh;\n      if s=0 then \n        continue;\n      ScreenBuffer[y-1,x+1] := s;\n      ScreenBuffer[y-1,x  ] := s;\n      ScreenBuffer[y-1,x-1] := s;\n      ScreenBuffer[y+1,x  ] := s;\n      var c := ColorsTable[s];\n      SetPixel(y-1,x+1,c);\n      SetPixel(y-1,x,  c);\n      SetPixel(y-1,x-1,c);\n      SetPixel(y+1,x,  c);\n    end;\n    if((system.datetime.Now-dt).TotalMilliseconds>1000/frames) then begin\n      dt := System.Datetime.Now;\n      Redraw;\n    end;\n  until False;\nend."
  },
  {
    "instruction": "Demonstrate image flipping using GraphWPF with timer animation",
    "output": "uses GraphWPF,Timers;\n\nbegin\n  var b := new Bitmap('m1.png');\n  b.ScaleX := 0.5;\n  b.ScaleY := 0.5;\n  var b1 := b.Clone;\n  b1.FlipVertical;\n  \n  OnDrawFrame := dt -> \n  begin\n    DrawImage(100,100,b);\n    DrawImage(300,100,b1);\n  end;  \n  \n  var t := new Timer(500);\n  t.TimerProc := procedure -> b.FlipHorizontal;\n  t.Start;\nend."
  },
  {
    "instruction": "Implement FloodFill algorithm using queue and GraphABC for visualization",
    "output": "uses GraphABC;\n\nprocedure DrawCell(a: array [,] of integer; x,y: integer);\nvar sz := 30;\nbegin\n  case a[y,x] of\n0: Brush.Color := Color.White;\n1: Brush.Color := Color.Black;\n2: Brush.Color := Color.Chocolate;\n  end;\n  Rectangle(x*sz,y*sz,x*sz+sz-1,y*sz+sz-1)\nend;\n\nprocedure AddToQueue(a: array [,] of integer; x,y: integer; q: Queue<(integer,integer)>);\nbegin\n  if a[y,x] = 0 then\n  begin\n    q.Enqueue(new Point(x,y));\n    a[y,x] := 2;\n    Sleep(200);\n    DrawCell(a,x,y);\n  end;\nend;\n\nprocedure FloodFill(a: array [,] of integer; x,y: integer);\nbegin\n  var q := new Queue<(integer,integer)>;\n  AddToQueue(a,x,y,q);\n  while not (q.Count=0) do\n  begin\n    (x,y) := q.Dequeue();\n    AddToQueue(a,x+1,y,q);\n    AddToQueue(a,x-1,y,q);\n    AddToQueue(a,x,y+1,q);\n    AddToQueue(a,x,y-1,q);\n  end;\nend;\n\nprocedure ReadFromFile(fname: string; var a: array [,] of integer);\nbegin\n  var f := OpenRead(fname);\n  var dimx,dimy: integer; \n  Readln(f,dimy,dimx);\n  SetLength(a,dimy,dimx);\n  for var y := 0 to dimy-1 do\n  begin\n    for var x := 0 to dimx-1 do\n    begin\n      var c := f.ReadChar;\n      a[y,x]:= if c='*' then 1 else 0;\n    end;\n    f.Readln  \n  end;\n  f.Close;\nend;\n\nprocedure Draw(a: array [,] of integer);\nbegin\n  for var y := 0 to a.RowCount-1 do\n  for var x := 0 to a.ColCount-1 do\n    DrawCell(a,x,y);\nend;\n\nbegin\n  Window.Title := 'FloodFill algorithm illustration';\n  var a: array [,] of integer;\n  ReadFromFile('field.txt',a);\n  Draw(a);\n  FloodFill(a,4,4);\nend."
  },
  {
    "instruction": "Demonstrate different for loop variations with step parameter for integers, chars and enumeration types",
    "output": "type Days = (Mon,Tue,Wed,Thi,Fri,sat);\n\nbegin\n  for var i:=1 to 5 step 2 do\n    Print(i);\n  Println;\n  \n  for var i:='5' to '2' step -2 do\n    Print(i);\n  Println;\n  \n  for var i:=Mon to Sat step 2 do\n    Print(i);\n  Println;\nend."
  },
  {
    "instruction": "Show different ways to generate sequences using for loops in PascalABC.NET",
    "output": "// For loop. Sequence of random numbers\n\nconst n = 20;\n\nbegin\n  Print('Random grades:');\n  for var i := 1 to n do\n    Print(Random(2, 5));\n  Println;\n  Print('Random integers from 1 to 99:');\n  for var i := n downto 1 do\n    Print(Random(1, 99));\n  Println;\nend.\n\n// For loop. Sequence of random numbers\nconst n = 20;\n\nbegin\n  Println('Random integers from 2 to 5:');\n  for var i := 1 to n do\n    Print(Random(2, 5));\n  Println;\n  Println;\n  Println('Random integers from 1 to 99:');\n  for var i := n downto 1 do\n    Print(Random(1, 99));\nend."
  },
  {
    "instruction": "Show multiple approaches to generate even and odd numbers using for loops in PascalABC.NET",
    "output": "// For loop. Step 2\nconst n = 25;\n\nbegin\n  Println('Even numbers from 1 to', 2 * n);\n  for var i := 1 to n do\n    Print(2 * i);\n  Println;\n  Println;\n\n  Println('Even numbers from 1 to', 2 * n);\n  var x := 2;\n  for var i := 1 to n do\n  begin\n    Print(x);\n    x += 2;\n  end;\n  Println;\n  Println;\n\n  Println('Odd numbers from 1 to', 2 * n);\n  for var i := 1 to n do\n    Print(2 * i - 1);\n  Println;\n  Println;\n\n  Println('Odd numbers from 1 to', 2 * n);\n  x := 1;\n  for var i := 1 to n do\n  begin\n    Print(x);\n    x += 2;\n  end;\n  Println;\n  Println;\nend."
  },
  {
    "instruction": "Create MVC pattern GUI application with FormsABC for calculating sum and product",
    "output": "uses FormsABC;\n\ntype \n  Model = class\n    class procedure Calc(x,y: integer; var sum,prod: integer);\n    begin\n      sum := x + y;\n      prod := x * y;\n    end;\n  end;\n  \n  View = class\n  private\n    a,b,sum,prod: IntegerField;\n    procedure MyClick;\n    begin\n      var s,p: integer;\n      Model.Calc(a.Value,b.Value,s,p);\n      sum.Value := s;\n      prod.Value := p;\n    end;\n  public\n    constructor Create;\n    begin\n      a := new IntegerField('a:');\n      b := new IntegerField('b:');\n      LineBreak;\n      sum := new IntegerField('Sum:',220);\n      LineBreak;\n      prod := new IntegerField('Product:',220);\n      LineBreak;\n      EmptyLine(20);\n      var d := new Button('Calculate');\n      d.Click += MyClick;\n    end;\n  end;\n\nbegin\n  var v := new View;\nend."
  },
  {
    "instruction": "Use faststring for efficient string manipulation with replace operations",
    "output": "// 6.0 sec PascalABC.NET vs 11.4 sec Python\nbegin\n  var mx := 0;\n  for var n := 4 to 9999 do\n  begin\n    var s: faststring := '4' + '1' * n;\n\n    while ('411' in s) or ('1111' in s) do\n      s.Replace('411', '14', 1).Replace('1111', '1', 1);\n    \n    mx := max(mx, s.ToString.Sum(d -> d.todigit));\n  end;\n  print(mx, Milliseconds / 1000);\nend."
  },
  {
    "instruction": "Show for loop for generating Fibonacci numbers in PascalABC.NET",
    "output": "// For loop. Fibonacci numbers\nconst n = 25;\n\nbegin\n  var a := 1;\n  var b := 1;\n  Println('Fibonacci numbers:');\n  Print(a,b);\n  for var i := 3 to n do\n  begin\n    var c := a + b;\n    Print(c);\n    a := b;\n    b := c;\n  end;\n  Println;\nend."
  },
  {
    "instruction": "Show for loop for finding maximum value from input numbers in PascalABC.NET",
    "output": "// For loop. Maximum from entered numbers\n\nconst n = 10;\n\nbegin\n  Println('Enter', n, 'numbers');\n  var max := real.MinValue; // smallest real number\n  for var i := 1 to n do\n  begin\n    var x := ReadReal;\n    if x > max then\n      max := x;\n  end;\n  Println('Maximum equals', max);\nend."
  },
  {
    "instruction": "Show for loop with break statement for searching values in PascalABC.NET",
    "output": "// For loop. Search for value. Break operator\nconst n = 10;\n\nbegin\n  var k := ReadInteger('Enter number to search:');\n  Println('Enter', n, 'numbers');\n  var found := False;\n  for var i := 1 to n do\n  begin\n    var x := ReadInteger;\n    if x = k then\n    begin\n      found := True;\n      break;\n    end;\n  end;\n  if found then\n    Println('Found') \n  else Println('Not found');\nend."
  },
  {
    "instruction": "Demonstrate the capabilities of foreach operator with different data structures in PascalABC.NET",
    "output": "// Example illustrating foreach operator capabilities\n\nbegin\n  var a: array of integer := [1,3,5,7,9];\n  Write('foreach over regular array: ':35);\n  foreach x: integer in a do\n    Print(x);\n  Println;  \n  \n  var s: set of integer := [2..5,10..14];\n  Write('foreach over set: ':35);\n  foreach var x in s do\n    Print(x);\n  Println;  \n  \n  var l := new List<integer>;\n  l.Add(7); l.Add(2); l.Add(5);\n  Write('foreach over dynamic array: ':35);\n  foreach var x in l do\n    Print(x);\n  Println;  \n\n  Write('foreach over range: ':35);\n  foreach var x in 1..10 do\n    Print(x);\n  Println;  \nend."
  },
  {
    "instruction": "Use foreach loop with index to iterate through array elements",
    "output": "begin\n  var index := 0;\n  var a := Arr(3, 5, 7);\n  foreach var x in a index i do\n    Println(i, x);\nend."
  },
  {
    "instruction": "Demonstrate foreach loop with various container types including static array, dynamic array, set, and list",
    "output": "// Example illustrates all possible container types\n// that can be iterated using foreach operator\n\nconst n = 10;\n\nvar \n  a: array [1..n] of integer;\n  b: array of integer;\n  s: set of integer;\n  l: List<integer>;\n\nbegin\n  for var i:=1 to n do \n    a[i] := Random(100);\n  // Foreach loop over static array\n  foreach var x in a do\n    Print(x);\n  writeln;  \n    \n  SetLength(b,n);\n  for var i:=0 to n-1 do \n    b[i] := Random(100);\n  \n  // Foreach loop over dynamic array\n  foreach var x in b do\n    Print(x);\n  writeln;  \n  \n  s := [2..5,10..14];\n  // Foreach loop over set\n  foreach var x in s do\n    Print(x);\n  writeln;  \n  \n  l := new List<integer>;\n  l.AddRange(b);\n  l.Reverse;\n  // Foreach loop over list\n  foreach var x in l do\n    Print(x);\n  writeln;  \n  \nend."
  },
  {
    "instruction": "Iterate over character set using foreach loop",
    "output": "// Loop over set. Order - not alphabetical, since sets are implemented based on hash tables\nbegin\n  foreach var c in ['a'..'z'] do\n    Write(c);\nend."
  },
  {
    "instruction": "Implement IEnumerable interface for custom Fibonacci generator class to use in foreach loop",
    "output": "// Example illustrates class implementation of IEnumerable interface \n// for using it in foreach operator\ntype\n  // Fibonacci numbers generator\n  FibGen = class(IEnumerable<integer>, IEnumerator<integer>)\n  private\n    a,b,n,i: integer;\n  public\n    constructor Create(n: integer);\n    begin\n      i := -1;\n      a := 0;\n      b := 1;\n      Self.n := n;\n    end;\n    function Get_Current: integer;\n    begin\n      if i=0 then \n        Result := 1\n      else Result := b;\n    end;\n    function System.Collections.IEnumerator.Get_Current: object := Get_Current;\n    function GetEnumerator: IEnumerator<integer> := Self;\n    function System.Collections.IEnumerable.GetEnumerator: System.Collections.IEnumerator := Self;\n    function MoveNext: boolean;\n    begin\n      i += 1;\n      Result := i<n;\n      if i=0 then exit;\n      (a,b) := (b,a+b);\n    end;\n    property Current: integer read Get_Current;\n    procedure Reset;\n    begin\n    end;\n    procedure Dispose;\n    begin\n    end;\n  end;\n\nbegin\n  writeln('Fibonacci numbers');\n  var f := new FibGen(25);\n  foreach var x in f do\n    Print(x);\nend."
  },
  {
    "instruction": "Show nested for loops for creating different patterns including multiplication table and star patterns in PascalABC.NET",
    "output": "// Nested for loops. Multiplication table\nconst n = 9;\n\nbegin\n  Println('Multiplication table');\n  for var i := 1 to n do\n  begin\n    for var j := 1 to n do\n      Print($'{i*j,4}');\n    Println;\n  end;\nend.\n\n// Nested for loops\nconst n = 6;\n\nbegin\n  for var i:=1 to n do\n  begin\n    for var j:=1 to i do\n      Write('*');\n    Writeln;  \n  end;\n  Writeln;  \n  for var i:=1 to n do\n  begin\n    for var j:=1 to 3*n do\n      if Odd(i+j) then \n        Write('*')\n      else Write(' ');  \n    Writeln;  \n  end;  \nend."
  },
  {
    "instruction": "Create patterns using nested for loops with stars and spaces",
    "output": "// Nested for loops\nconst n = 6;\n\nbegin\n  for var i:=1 to n do\n  begin\n    for var j:=1 to i do\n      write('*');\n    writeln;  \n  end;\n  writeln;  \n  for var i:=1 to n do\n  begin\n    for var j:=1 to 3*n do\n      if Odd(i+j) then \n        write('*')\n      else write(' ');  \n    writeln;  \n  end;  \nend."
  },
  {
    "instruction": "Show nested for loops with GraphABC for creating grid of colored squares in PascalABC.NET",
    "output": "// Nested for loops. Grid of squares\nuses GraphABC;\n\nconst \n  sz = 35;\n  zz = 5;\n\nbegin\n  var h := sz+zz;\n  for var nx:=0 to Window.Width div h - 1 do\n  for var ny:=0 to Window.Height div h - 1 do\n  begin\n    Brush.Color := clRandom;\n    Rectangle(zz+nx*h,zz+ny*h,zz+nx*h+sz,zz+ny*h+sz);\n  end;  \nend."
  },
  {
    "instruction": "Create Windows form with WebBrowser component to display website",
    "output": "// Illustration of WebBrowser component usage\n{$apptype windows}\n{$reference System.Windows.Forms.dll}\n\nuses \n  System.Windows.Forms,\n  System.Net;\n\nbegin\n  var myForm := new Form; \n  var w := new WebBrowser;\n  w.Url := new System.Uri('http://pascalabc.net');\n  w.Dock := Dockstyle.Fill; \n  myForm.Controls.Add(w);\n  myForm.WindowState := FormWindowState.Maximized; \n  Application.Run(myForm);\nend."
  },
  {
    "instruction": "Implement fraction class with operator overloading for addition and subtraction",
    "output": "// Operator overloading. \"Fraction\" class\ntype \n  Frac = record\n  private\n    n,m: integer;\n  public\n    constructor (n,m: integer);\n    begin\n      Self.n := n; \n      Self.m := m;\n    end;\n    class function operator+(f1,f2: Frac): Frac; // operator is overloaded as class function\n    begin\n      Result.n := f1.n*f2.m+f1.m*f2.n;\n      Result.m := f1.n*f1.m;\n    end;\n    class function operator-(f1,f2: Frac): Frac;\n    begin\n      Result.n := f1.n*f2.m-f1.m*f2.n;\n      Result.m := f1.n*f1.m;\n    end;\n    function ToString: string; override; // Need to override this function to output Frac type variables in write\n    begin\n      Result := Format('{0}/{1}',n,m);\n    end;\n  end;\n\nbegin\n  var f := new Frac(2,3);\n  var f1 := new Frac(1,2);\n  writelnFormat('{0} + {1} = {2} ',f,f1,f+f1);\n  // f+f1 is translated by compiler to Frac.operator+(f,f1)\n  writelnFormat('{0} - {1} = {2} ',f,f1,f-f1);\nend."
  },
  {
    "instruction": "Calculate expression with ordinary fractions using NumLibABC",
    "output": "uses NumLibABC;\n\n// calculation of expression with ordinary fractions\nbegin\n   var r:=((Frc(5,5,9)-Frc(7,18))/35+(Frc(40,63)-Frc(8,21))/20+\n      (Frc(83,90)-Frc(41,50))/2)*50;\n   r.Print   \nend."
  },
  {
    "instruction": "Calculate sum of all two-digit numbers using for loop",
    "output": "// For loop. Sum of all two-digit numbers\n\nbegin\n  var s := 0;\n  for var i:=10 to 99 do\n    s += i; \n  Println('Sum of all two-digit numbers =',s);  \nend."
  },
  {
    "instruction": "Calculate power of number using for loop and compare with standard operator",
    "output": "// For loop. Calculating a to the power n\n\nbegin\n  var a := ReadlnReal('Enter a:');\n  var n := ReadlnInteger('Enter n:');\n\n  var p := 1.0;\n  for var i:=1 to n do\n    p *= a; \n  Println($'{a} to the power {n} = {p}');\n  \n  Println($'Standard operation {a} ** {n} = {a ** n}');  \nend."
  },
  {
    "instruction": "Show for loop for creating function table with real numbers in PascalABC.NET",
    "output": "// For loop. Function table\nvar \n  a: real := 0;\n  b: real := 4;\n  n: integer := 16;\n\nbegin\n  var h := (b-a)/n;\n  var x := a;\n  for var i:=0 to n do\n  begin\n    Println($'{x:f2}  {Sqrt(x):f4}');  \n    x += h;\n  end;\nend."
  },
  {
    "instruction": "Create a red cube that rotates continuously around the Z-axis with auto-reverse animation",
    "output": "uses Graph3D;\n\nbegin\n  var ss := Cube(0,0,0,1.5,Colors.Red);\n  var anim := ss.AnimRotate(OrtZ,360).Forever.AutoReverse;\n  anim.Begin;\nend."
  },
  {
    "instruction": "Create a green cylinder and a red cube that rotates around point (3,0,0) on the Z-axis forever",
    "output": "uses Graph3D;\n\nbegin\n  Cylinder(Origin,6,0.3,Colors.Green);\n  var ss := Cube(-3,0,0,1.5,Colors.Red);\n  var anim := ss.AnimRotateAt(OrtZ,360,P3D(3,0,0),2).Forever;\n  anim.Begin;\nend."
  },
  {
    "instruction": "Create a green box with combined animations: move on Z-axis, scale on Z-axis, and move on X-axis simultaneously",
    "output": "uses Graph3D;\n\nbegin\n  var jmp := 0.3;\n  var time := 0.5;\n  var c := Box(0,0,2,1,2,4,Colors.Green);\n  var a := c.AnimMoveByZ(-0.4,time).AutoReverse.Forever * c.AnimScaleZ(0.95,time).AutoReverse.Forever * c.AnimMoveByX(1*10,time*10);\n  a.Begin;\nend."
  },
  {
    "instruction": "Create a parametric trajectory and animate a blue sphere moving along it forever",
    "output": "uses Graph3D;\n\nfunction ParametricTrajectory(a,b: real; N: integer; fun: real->Point3D) := PartitionPoints(a,b,N).Select(fun);\n\nbegin\n  var tr := ParametricTrajectory(0,2*Pi,100,t->P3D(8*cos(t),4*sin(t),0));\n  Polyline3D(tr);\n  var b := Sphere(tr.First,1,Colors.Blue);\n  b.AnimMoveTrajectory(tr.Skip(1),5).Forever.Begin;\nend."
  },
  {
    "instruction": "Create a blue sphere and animate it moving along a rectangular trajectory forever",
    "output": "uses Graph3D;\n\nbegin\n  var b := Sphere(Origin,1,Colors.Blue);\n  \n  var (p1,p2,p3,p4) := (P3D(3,0,0),P3D(3,3,0),P3D(0,3,0),P3D(0,0,0));\n  \n  b.MoveTo(p1);\n  b.AnimMoveTrajectory(Arr(p2,p3,p4,p1),3).Forever.Begin;\nend."
  },
  {
    "instruction": "Create a blue box with sequential and parallel animations: move to point p1 with scaling, then move to point p2 with scaling, then rotate around Z-axis",
    "output": "uses Graph3D;\n\nbegin\n  Window.Title := 'a+b+c - sequential execution, a*b - parallel execution';\n  var s := Box(0,0,0,3,1,2,Colors.Blue);\n  var p1 := P3D(5,0,0);\n  var p2 := P3D(5,5,0);\n  var OrtZ := V3D(0,0,1);\n  var an := s.AnimMoveTo(p1,1.Sec)*s.AnimScale(1.5,1.Sec) + \n            s.AnimMoveTo(p2,1.Sec)*s.AnimScale(1,1.Sec) + \n            s.AnimRotate(OrtZ,90,1.Sec);\n  an.Begin;\nend."
  },
  {
    "instruction": "Create a blue box and animate it with sequential movement: first move on Y-axis, then move on X-axis",
    "output": "uses Graph3D;\n\nbegin\n  var s := Box(0,0,0,3,1,2,Colors.Blue);\n  var an := Animate.Sequence(\n    s.AnimMoveByY(5),\n    s.AnimMoveByX(5)\n  );\n  an.Begin;\nend."
  },
  {
    "instruction": "Create a blue box that moves to point (5,0,0) and display text when animation completes",
    "output": "uses Graph3D;\n\nbegin\n  var t := Text3D(0,-7,1,'Animation start...',2);\n  var s := Box(0,0,0,3,1,2,Colors.Blue);\n  var an := s.AnimMoveTo(P3D(5,0,0),2).WhenCompleted(procedure -> t.Text := 'End!');\n  an.Begin\nend."
  },
  {
    "instruction": "Approximate tabular function using Chebyshev polynomials with least squares method",
    "output": "uses NumLibABC;\n\nbegin\n  var e:=0.1;\n  var x:=ArrGen(12,i->0.25*i-2); x.Println;\n  var y:=x.Select(z->2*z-5*Sqr(z)+8*z*Sqr(z)).ToArray; y.Println;\n  var oL:=new ApproxCheb(x,y,e);\n  oL.f.Println;  // approximated values\n  Println(oL.r,oL.tol);  // suggested polynomial degree and calculated error\n  oL.MakeCoef; // decoded coefficients\n  oL.c.Println;\nend."
  },
  {
    "instruction": "Draw arrows between points using mathematical coordinate system",
    "output": "uses GraphWPF;\n\nbegin\n  Parameters.ArrowSizeAcross := 4;\n  Parameters.ArrowSizeAlong := 10;\n  SetMathematicCoords;\n  var (p1,p2,p3) := (Pnt(0,0),Pnt(2,3),Pnt(4,-1));\n  Arrow(p1,p2);\n  Arrow(p2,p3);\n  Arrow(p3,p1);\nend."
  },
  {
    "instruction": "Draw arcs and sectors with different radii and angles",
    "output": "uses GraphWPF;\n\nbegin\n  Window.Title := 'Arcs and sectors';\n  var (x,y) := (200,Window.Height/2);\n  Circle(x,y,5);\n  for var i:=1 to 18*2 do\n    Arc(x,y,5*i,0,10*i);\n  (x,y) := (600,Window.Height/2);  \n  for var i:=1 to 12 do\n  begin\n    Brush.Color := RandomColor;\n    Sector(x,y,180,30*(i-1),30*i);\n  end;\nend."
  },
  {
    "instruction": "Draw a directed weighted graph using dictionary representation",
    "output": "uses GraphWPF;\n\nbegin\n  var graph := Dict(\n    ('A',Dict(('B',2),('E',5))),\n    ('C',Dict(('B',7),('D',9))),\n    ('D',Dict(('B',34))),\n    ('E',Dict(('C',12),('B',66)))\n  );\n  var dPoints := new Dictionary<char,Point>;\n  var R := 200;\n  var n := ('A'..'E').Count;\n  var Phi := 0.0; \n  for var c := 'A' to 'E' do\n  begin  \n    dPoints[c] := Window.Center + R * Vect(Cos(Phi),Sin(Phi));\n    Phi += 2 * Pi/n;\n  end;\n  \n  Window.Title := 'Directed graph drawing';\n  var Radius := 10;\n  foreach var kv in dPoints do\n  begin\n    var p := kv.Value;\n    Circle(p,Radius);\n    TextOut(p.x,p.y,kv.Key,Alignment.Center);\n  end;\n  foreach var k1 in graph.Keys do\n  foreach var k2 in graph[k1].Keys do\n  begin\n    var weight := graph[k1][k2];\n    var (p1,p2) := (dPoints[k1],dPoints[k2]);\n    var v := p2 - p1;\n    var pp1 := p1 + v.Norm * Radius;\n    var pp2 := p2 - v.Norm * Radius;\n    Arrow(pp1,pp2);\n    var cc := p1 + v/2;\n    var txt := weight.ToString;\n    var sz := TextSize(txt);\n    FillRectangle(cc.X - sz.Width/2, cc.Y - sz.Height/2, sz.Width, sz.Height);\n    TextOut(cc.x,cc.y,weight,Alignment.Center);\n  end;\nend."
  },
  {
    "instruction": "Implement arithmetic expression evaluator using pattern matching for constants, addition, multiplication, and negation",
    "output": "type\n  Expr = interface\n  end;\n  Cons = auto class(Expr)\n    r: real;\n  end;\n  Add = auto class(Expr)\n    left,right: Expr;\n  end;\n  Mult = auto class(Expr)\n    left,right: Expr;\n  end;\n  Neg = auto class(Expr)\n    ex: Expr;\n  end;\n  \nfunction ConsC(r: real) := new Cons(r);\nfunction AddC(l,r: Expr) := new Add(l,r);\nfunction MultC(l,r: Expr) := new Mult(l,r);\nfunction NegC(ex: Expr) := new Neg(ex);\n\nfunction Eval(e: Expr): real;\nbegin\n  match e with\n    Cons(c): Result := c;\n    Neg(n): Result := -Eval(n);\n    Add(l,r): Result := Eval(l) + Eval(r);\n    Mult(l,r): Result := Eval(l) * Eval(r);\n  end;\nend;  \n  \nbegin\n  var r := AddC(NegC(ConsC(2)),MultC(ConsC(3),ConsC(4)));\n  Eval(r).Print;\nend."
  },
  {
    "instruction": "Implement arithmetic expression simplifier that handles constants, variables, addition, multiplication, and negation with algebraic simplification rules",
    "output": "type\n  Expr = interface\n  end;\n  V = auto class(Expr)\n    name: string;\n  end;\n  Cons = auto class(Expr)\n    r: real;\n  end;\n  Add = auto class(Expr)\n    left,right: Expr;\n  end;\n  Mult = auto class(Expr)\n    left,right: Expr;\n  end;\n  Neg = auto class(Expr)\n    ex: Expr;\n  end;\n  \nfunction NegC(ex: Expr) := new Neg(ex);  \nfunction ConsC(r: real) := new Cons(r);  \nfunction AddC(ex1,ex2: Expr) := new Add(ex1,ex2);  \nfunction MultC(ex1,ex2: Expr) := new Mult(ex1,ex2);  \nfunction VC(name: string) := new V(name);  \n  \nfunction Simplify(e: Expr): Expr; forward;\n\nfunction Simplify1(e: Expr): Expr;\nbegin\n  match e with\n    Mult(Cons(c),Cons(c1)): Result := ConsC(c*c1);\n    Mult(Cons(1.0),ex): Result := Simplify(ex);\n    Mult(Cons(0.0),ex): Result := ConsC(0);\n    Add(Cons(0.0),ex): Result := Simplify(ex);\n    Add(ex,Cons(0.0)): Result := Simplify(ex);\n    Add(Cons(c),Cons(c1)): Result := ConsC(c+c1); \n    Add(Cons(c),ex): Result := AddC(ex,ConsC(c)); // constants at the end!\n    Mult(Cons(c),ex): Result := MultC(ex,ConsC(c));\n    Add(Add(ex,Cons(c)),Cons(c1)): Result := AddC(ex,ConsC(c+c1)); // associativity\n    Mult(Mult(ex,Cons(c)),Cons(c1)): Result := MultC(ex,ConsC(c*c1)); // associativity\n    Neg(Cons(c)): Result := ConsC(-c); \n    else Result := e;\n  end;\nend;\n\nfunction Simplify(e: Expr): Expr;\nbegin\n  match e with\n    Mult(e1,e2): Result := Simplify1(MultC(Simplify(e1),Simplify(e2)));\n    Add(e1,e2): Result := Simplify1(AddC(Simplify(e1),Simplify(e2)));\n    Neg(e1): Result := Simplify1(NegC(Simplify(e1)));\n    else Result := e;\n  end;\nend;\n\nfunction Str(e: Expr): string;\nbegin\n  match e with\n    Mult(l,r): Result := Str(l) + ' * ' + Str(r);\n    Add(l,r): Result := Str(l) + ' + ' + Str(r);\n    Neg(n): Result := '-' + Str(n);\n    Cons(c): Result := c.ToString;\n    V(x): Result := x;\n  end;\nend;\n  \nbegin\n  var r: Expr := AddC(ConsC(1),AddC(MultC(ConsC(1),VC('x')),ConsC(1)));\n  r := AddC(r,MultC(ConsC(0),AddC(ConsC(2),VC('a'))));\n  r := AddC(r,ConsC(2));\n  Str(r).Println;\n  r := Simplify(r);\n  Str(r).Println;\nend."
  },
  {
    "instruction": "Measure performance of array slicing operation",
    "output": "begin\n  var s := Arr(1..1000);\n  var s1: array of integer;\n  var n := 100000000;\n  MillisecondsDelta;\n  loop n do\n    s1 := s[1:11];\n  MillisecondsDelta.Println;\nend."
  },
  {
    "instruction": "Measure performance of array slice assignment operation",
    "output": "begin\n  var s := Arr(1..10);\n  Milliseconds;\n  var n := 100000000;\n  MillisecondsDelta.Println;\n  loop n do\n    s[0:10] := s;\n  MillisecondsDelta.Println;\nend."
  },
  {
    "instruction": "Demonstrate array initialization with empty collections and nested arrays",
    "output": "begin\n  var a: array of array of integer := [[],[],[1]];\n  Println(a,TypeName(a));\n  var b := [[],[1],[]];\n  Println(b,TypeName(b));\n  var aa: array of array of array of integer := [[[],[2]],[]];\n  Print(aa,TypeName(aa));\nend."
  },
  {
    "instruction": "Calculate r to the power of 8 using auxiliary variables for intermediate results",
    "output": "begin\n  var r := ReadlnReal('Enter r: ');\n  var r2,r4,r8: real; // auxiliary variables\n  r2 := r * r;\n  r4 := r2 * r2;\n  r8 := r4 * r4;\n  Println(r,'to the power of 8 =',r8);\nend."
  },
  {
    "instruction": "Swap values of two variables using a temporary variable",
    "output": "var x,y: real;\n\nbegin\n  Write('Enter x,y: ');\n  Readln(x,y);\n  var v: real; // temporary variable\n  v := x;\n  x := y;\n  y := v;\n  Writeln('New values x,y: ',x,' ',y);\nend."
  },
  {
    "instruction": "Define and use functions in short programs in PascalABC.NET",
    "output": "##\n// In short programs you can describe subroutines\nfunction Add(a,b: integer) := a + b;\n\nPrint(Add(2,3));"
  },
  {
    "instruction": "Create function table for sin using PartitionPoints and PrintLines",
    "output": "// Output table of sin function values\n\n##\nPartitionPoints(0,Pi,20).Select(x->$'({x:f4}, {sin(x):f7})').PrintLines;"
  },
  {
    "instruction": "Show garbage collection in PascalABC.NET by setting variables to nil",
    "output": "// Garbage collection: to free object assign nil to variable\nbegin\n  var L := new List<integer>;\n  L.Add(3);\n  L.Add(5);\n  L.Add(2);\n  \n  foreach var x in L do\n    Print(x);\n  L := nil; // after this, memory occupied by dynamic array will be collected by garbage collector \nend."
  },
  {
    "instruction": "Show runtime error handling for non-numeric input and demonstrate proper input validation",
    "output": "// Enter non-number\n// See what runtime error looks like\n\nbegin\n  var s: string;\n  var i: integer;\n  repeat\n    try\n      s := ReadString('Enter integer:');\n      i := StrToInt(s);\n      break;\n    except\n      on e: Exception do\n        Println('Invalid input. Please enter a valid integer.');\n    end;\n  until false;\n  Println('You entered:', i);\nend."
  },
  {
    "instruction": "Compare performance of global variables vs block variables in PascalABC.NET",
    "output": "// Comparison of global and block variable performance.\n// See also file BlockVars.pas\nvar \n  s: real := 0; \n  i: real := 1;\n\nbegin\n  while i<1000000000 do\n  begin\n    s += 1/i;\n    i += 1;\n  end;  \n  writeln(s);\n  writeln('Calculation time = ',Milliseconds/1000,' s');\nend."
  },
  {
    "instruction": "Implement Golomb sequence with caching for efficient recursive calculation",
    "output": "// Golomb sequence G(n) is such unique non-decreasing sequence \n// of natural numbers, in which n appears exactly G(n) times\n// 1 2 2 3 3 4 4 4 5 5 5 6 6 6 6 …\n// Without caching execution time is huge due to repeated recursive calls\n[Cache]\nfunction G(n: int64): int64 := n = 1 ? 1 : 1 + G(n - G(G(n - 1)));\n\nbegin\n  var n := 100000;\n  (1..n).Sum(i -> G(i)).Print;\n  Milliseconds.Print;\nend."
  },
  {
    "instruction": "Show common compilation and runtime errors in PascalABC.NET with their fixes",
    "output": "// Common errors and their fixes in PascalABC.NET\n\n// Error 1: Missing semicolon\nvar i: integer; // Fixed: added semicolon\n\nbegin\n  i := 2;\n  \n  // Error 2: Using undeclared variable\n  var r: real := 2.5; // Fixed: declared variable\n  Println(r);\n  \n  // Error 3: Type mismatch\n  var x: real := 3/5; // Fixed: changed to real type\n  \n  // Error 4: Wrong decimal separator\n  var k: real := 2.5; // Fixed: used dot instead of comma\n  \n  // Error 5: Integer division by zero (runtime)\n  var divisor: integer := 0;\n  if divisor <> 0 then\n    Println(2 div divisor) // Fixed: added validation\n  else\n    Println('Cannot divide by zero');\n  \n  // Error 6: Invalid input (runtime)\n  var inputStr: string;\n  var number: integer;\n  repeat\n    try\n      inputStr := ReadString('Enter integer:');\n      number := StrToInt(inputStr);\n      break;\n    except\n      Println('Please enter a valid integer');\n    end;\n  until false;\n  \n  Println('All errors fixed successfully!');\nend."
  },
  {
    "instruction": "Define custom function and create its value table using for loop",
    "output": "// Function definition. Output table of its values\n\nfunction MyFun(x: real): real;\nbegin\n  Result := x*sin(x);\nend;\n\nconst \n  a = 0.0;\n  b = 2*Pi;\n  n = 10;\n\nbegin\n  var h := (b-a)/n;\n  var x := a;\n  writeln('Table of MyFun function values:');\n  for var i := 0 to n do\n  begin\n    writeln(x:5:2,MyFun(x):10:4);\n    x += h;\n  end;  \nend."
  },
  {
    "instruction": "Implement Power function using for loop for exponentiation",
    "output": "// Power function\n\nfunction Power(x: real; n: integer): real;\nbegin\n  Result := 1;\n  for var i:=1 to n do\n    Result *= x;\nend;\n\nvar \n  x: real; \n  n: integer;\n\nbegin\n  x := 2; n := 5;  \n  writelnFormat('{0} to the power {1} = {2}',x,n,Power(x,n));\nend."
  },
  {
    "instruction": "Show how to use variable number of parameters (params) in PascalABC.NET functions",
    "output": "// Variable number of parameters \nfunction Sum(params arg: array of integer): integer;\nbegin\n  Result := 0;\n  foreach var x in arg do\n    Result += x;\nend;\n\nbegin\n  Println(Sum(1,2,3));\n  Println(Sum(4,5,6,7));\nend."
  },
  {
    "instruction": "Create interactive function graph with transformation parameters using GraphWPF",
    "output": "uses\n  GraphWPF;\n\nvar\n  h := 0.01;\n  mx := 2.0;\n  my := 0.35;\n  dy := 0.0;\n  dx := 0.0;\n  f: real -> real := x -> x * sin(x);\n\nconst\n  boundx = 5;\n  boundy = 3;\n\nfunction Transform(f: real -> real): real -> real;\nbegin\n  Result := x -> my * f(mx * (x + dx)) + dy;\nend;\n\nprocedure DrawGraphic(f: real -> real);\nbegin\n  Window.Clear;\n  DrawGraph(f, -boundx, boundx, -boundy, boundy); \n  Window.Title := Format('mx={0:f2}  my={1:f2}  dx={2:f2}  dy={3:f2}', mx, my, dx, dy);\nend;\n\nvar ArrowKeys := HSet(Key.Left, Key.Right, Key.Up, Key.Down, Key.Home, Key.&End, Key.PageUp, Key.PageDown);\n\nprocedure KeyDown(k: Key);\nbegin\n  var g := Transform(f);\n  case k of\n    Key.Left:     my -= h;\n    Key.Right:    my += h;\n    Key.Up:       mx -= h;\n    Key.Down:     mx += h;\n    Key.Home:     dx += h;\n    Key.PageUp:   dx -= h;\n    Key.PageDown: dy += h;\n    Key.End:      dy -= h;\n  end;\n  if k in ArrowKeys then\n    DrawGraphic(g);\nend;\n\nbegin\n  DrawGraphic(Transform(f));\n  OnKeyDown := KeyDown;\nend."
  },
  {
    "instruction": "Create Brownian motion animation with various graphical objects using ABCObjects",
    "output": "// Changing properties of graphical objects\n// Brownian motion of graphical objects\nuses ABCObjects,GraphABC;\n\nprocedure MoveAll(a,b: integer);\nbegin\n  for var j:=0 to Objects.Count-1 do\n    Objects[j].moveOn(a,b);\nend;\n\nbegin\n//  LockDrawingObjects;\n  Window.Title := 'Brownian motion of objects';\n  var sq := new SquareABC(30,5,90,clSkyBlue);\n  var r := new RectangleABC(10,10,100,180,RGB(255,100,100));\n  var rr := new RoundRectABC(200,180,180,50,20,clRandom);\n  var rsq:= new RoundSquareABC(20,180,80,10,clRandom);\n  var c := new CircleABC(160,55,70,clGreen);\n  var z := new StarABC(200,150,70,135,5,clRandom);\n  z.Filled := False;\n  var el := new EllipseABC(5,55,65,50,clRandom);\n  el.Bordered := False;\n  var t := new TextABC(100,170,15,'Hello, ABCObjects!');\n  var br := new BoardABC(200,20,7,5,20,20);\n  br.Filled := False;\n  z.Height := 200;\n  z.Radius := 70;\n  sq.Width := 120;\n  t.TransparentBackground := False;\n  t.BackgroundColor := clYellow;\n  t.FontName := 'Times New Roman';\n  t.FontSize := 20;\n  c.Height := 50;\n  c.Scale(2);\n  MoveAll(160,110);\n  \n  while True do\n  begin\n    for var j:=0 to Objects.Count-1 do\n      Objects[j].moveOn(Random(-1,1),Random(-1,1));\n//    RedrawObjects;\n  end;\nend."
  },
  {
    "instruction": "Create Brownian motion animation with WPFObjects for better performance",
    "output": "// Changing properties of graphical objects\n// Brownian motion of graphical objects\nuses WPFObjects;\n\nprocedure MoveAll(a,b: integer);\nbegin\n  for var j:=0 to Objects.Count-1 do\n    Objects[j].moveOn(a,b);\nend;\n\nbegin\n  Window.Title := 'Brownian motion of objects';\n  HideObjects;\n  var sq := new SquareWPF(30,5,90,Colors.SkyBlue,1);\n  var r := new RectangleWPF(10,10,100,180,RGB(255,100,100),1);\n  var rr := new RoundRectWPF(200,180,180,50,20,RandomColor,1);\n  var rsq:= new RoundSquareWPF(20,180,80,10,RandomColor,1);\n  var c := new CircleWPF(160,55,70,Colors.Green);\n  var z := new StarWPF(200,150,70,135,5,EmptyColor,1);  \n  var el := new EllipseWPF(5,55,65,50,RandomColor,2,RandomColor);\n  var t := new TextWPF(100,170,40,'Hello, WPFObjects!'); //\n  t.BackgroundColor := Colors.Yellow;\n  t.FontName := 'Times New Roman';\n  //var br := new BoardWPF(200,20,7,5,20,20);\n  //br.Filled := False;\n  z.Height := 220;\n  z.Radius := 160;\n  sq.Width := 120;\n  //t.FontSize := 40;\n  c.Height := 50;\n  c.Scale(2);\n  MoveAll(160,110);\n  ShowObjects;\n  \n  while True do\n  begin\n    for var j:=0 to Objects.Count-1 do\n      Objects[j].MoveOn(Random(-1,1),Random(-1,1));\n    Sleep(10);\n  end;\nend."
  },
  {
    "instruction": "Clone graphical objects recursively to create fractal pattern using ABCObjects",
    "output": "// Cloning graphical objects. \n// Graphical objects container. Nested containers\nuses GraphABC,ABCObjects;\n\n/// Create four graphical objects from one\nprocedure Four(var g: ObjectABC);\nbegin\n  var w := 8*g.Width div 7;\n  var f := ContainerABC.Create(0,0);\n  f.Add(g);\n  g := g.Clone;;\n  g.moveon(w,0);\n  g := g.Clone;\n  g.moveon(0,w);\n  g := g.Clone;\n  g.moveon(-w,0);\n  g := f;\nend;\n\nbegin\n  LockDrawingObjects;\n  SetWindowSize(630,630);\n  \n  var g: ObjectABC := new SquareABC(0,0,14,clYellow);\n  Four(g);\n  Four(g);\n  Four(g);\n  Four(g);\n  Four(g);\n  UnLockDrawingObjects;\nend."
  },
  {
    "instruction": "Implement object dragging with mouse using ABCObjects",
    "output": "// Moving graphical objects with mouse\nuses ABCObjects,GraphABC;\n\nvar \n  ob: ObjectABC;\n  sx,sy: integer;\n\nprocedure MyMouseDown(x,y,mb: integer);\nbegin\n  ob := ObjectUnderPoint(x,y);\n  if ob<>nil then\n  begin\n    sx := ob.Left - x;\n    sy := ob.Top - y;\n  end; \nend;\n\nprocedure MyMouseMove(x,y,mb: integer);\nbegin\n  if ob<>nil then\n    ob.Position := new Point(x+sx,y+sy);\nend;\n\nprocedure MyMouseUp(x,y,mb: integer);\nbegin\n  ob := nil;\nend;\n\n\nbegin\n  Window.Title := 'Move objects with mouse';\n  for var i:=1 to 10 do\n  begin\n    var p := new PictureABC(Random(Window.Width-100),Random(Window.Height-100),'demo.bmp');\n    p.Transparent := True;\n  end;  \n  OnMouseDown := MyMouseDown;\n  OnMouseMove := MyMouseMove;\n  OnMouseUp := MyMouseUp;\nend."
  },
  {
    "instruction": "Implement object intersection detection using Intersect method in ABCObjects",
    "output": "// Illustration of Intersect method for graphical objects\nuses ABCObjects,GraphABC;\n\nvar Destroyer: CircleABC;\n\nprocedure CheckPulyaIntersects;\nbegin\n  for var i:=Objects.Count-1 downto 0 do\n  begin\n    if (Destroyer.Intersect(Objects[i])) and (Objects[i]<>Destroyer) then\n      Objects[i].Destroy;\n  end;    \nend;\n\nbegin\n  Window.Title := 'Destroyer: Intersect method for object intersection';\n  for var i:=1 to 500 do\n    new RectangleABC(Random(WindowWidth-200)+100,Random(WindowHeight-100),Random(200),Random(200),clRandom);\n  Destroyer := new CircleABC(10,WindowHeight div 2,100,clBlack);\n  Destroyer.FontColor := clYellow;\n  Destroyer.Text := 'Destroyer';\n\n  for var i:=1 to 900 do\n  begin\n    Destroyer.MoveOn(1,0);\n    CheckPulyaIntersects;\n  end;\nend."
  },
  {
    "instruction": "Implement object intersection detection using IntersectionList in WPFObjects",
    "output": "uses WPFObjects;\n\nvar Destroyer: CircleWPF;\n\nprocedure CheckPulyaIntersects;\nbegin\n  Destroyer.IntersectionList.ForEach(procedure(o)->o.Destroy);\nend;\n\nbegin\n  HideObjects;\n  Window.SetSize(640,480);\n  Window.Title := 'Destroyer: Intersect method for object intersection';\n  loop 500 do\n    new RectangleWPF(Random(Window.Width.Round-200)+100,Random(Window.Height.Round-100),Random(200),Random(200),clRandom);\n  Destroyer := new CircleWPF(10,Window.Height / 2,100,Colors.Black);\n  Destroyer.SetText('Destroyer',30,'Arial',Colors.Yellow);\n  ShowObjects;\n\n  loop 900 do\n  begin\n    Destroyer.MoveOn(1,0);\n    CheckPulyaIntersects;\n    Sleep(1);\n  end;\nend."
  },
  {
    "instruction": "Create parametric motion animation with ABCObjects along Lissajous and astroid curves",
    "output": "// Motion along trajectory\nuses ABCObjects,GraphABC;\n\nconst\n/// Step along curve parameter\n  step = 0.03;\n/// Time delay, ms\n  delay = 10;\n\ntype\n  PointR = record\n    x,y: real;\n  end;\n\nfunction Position(t: real): PointR; // astroid\nbegin\n  var si := sin(1.5 * t);\n  var co := cos(1.5 * t);\n  Result.x := si*si*si;\n  Result.y := co*co*co;\nend;\n\nfunction Position1(t: real): PointR; // Lissajous figure\nbegin\n  Result.x := cos(4*t);\n  Result.y := cos(2.97221*t + 2*Pi/3);\nend;\n\nfunction LogicalToScreen(p: PointR): Point;\nbegin\n  var ww := WindowWidth div 2;\n  var hh := WindowHeight div 2;\n  Result.x := round((ww - 50) * p.x + ww);\n  Result.y := round((hh - 50) * p.y + hh);\nend;\n\nprocedure InitScreen;\nbegin\n  SetBrushColor(clMoneyGreen);\n  Rectangle(10,10,WindowWidth-10,WindowHeight-10);\n  var p := LogicalToScreen(Position1(0));\n  MoveTo(p.x,p.y);\nend;\n\nbegin\n  Window.IsFixedSize := True;\n  Window.Title := 'Motion along trajectory';\n  SetWindowSize(640,480);\n  CenterWindow;\n\n  InitScreen;\n  var c := new CircleABC(200,200,25,clGreen);\n  var d := new StarABC(200,200,40,20,5,clYellow);\n\n  var t: real := 0;\n  while True do\n  begin\n    c.Center := LogicalToScreen(Position1(t));\n    d.Center := LogicalToScreen(Position(t));\n    if t<20*Pi then\n      LineTo(c.Center.x,c.Center.y)\n    else\n    begin\n      t := 0;\n      InitScreen;\n    end;\n    t += step;\n    Sleep(delay);\n  end;\nend."
  },
  {
    "instruction": "Create parametric motion animation with WPFObjects for smoother graphics",
    "output": "// Motion along trajectory\nuses WPFObjects,GraphWPF;\n\nconst\n/// Step along curve parameter\n  step = 0.02;\n/// Time delay, ms\n  delay = 5;\n\ntype\n  PointR = record\n    x,y: real;\n  end;\n\nfunction Position(t: real): PointR; // astroid\nbegin\n  var si := sin(1.7 * t);\n  var co := cos(1.5 * t);\n  Result.x := si*si*si;\n  Result.y := co*co*co;\nend;\n\nfunction Position1(t: real): PointR; // Lissajous figure\nbegin\n  Result.x := cos(4*t);\n  Result.y := cos(2.97221*t + 2*Pi/3);\nend;\n\nfunction LogicalToScreen(p: PointR): GPoint;\nbegin\n  var ww := Window.Width / 2;\n  var hh := Window.Height / 2;\n  Result.x := Round((ww - 50) * p.x + ww);\n  Result.y := Round((hh - 50) * p.y + hh);\nend;\n\nprocedure InitScreen;\nbegin\n  Brush.Color := Colors.LightGreen;\n  Rectangle(10,10,Window.Width-20,Window.Height-20);\n  var p := LogicalToScreen(Position1(0));\n  MoveTo(p.x,p.y);\nend;\n\nbegin\n  //Window.IsFixedSize := True;\n  Window.Title := 'Motion along trajectory';\n  Window.SetSize(640,480);\n  Window.CenterOnScreen;\n\n  InitScreen;\n  var c := new CircleWPF(200,200,25,Colors.Green);\n  var d := new StarWPF(200,200,40,20,5,Colors.Yellow);\n\n  var t: real := 0;\n  while True do\n  begin\n    c.Center := LogicalToScreen(Position1(t));\n    d.Center := LogicalToScreen(Position(t));\n    if t<20*Pi then\n      LineTo(c.Center.x,c.Center.y)\n    else\n    begin\n      t := 0;\n      InitScreen;\n    end;\n    t += step;\n    Sleep(delay);\n  end;\nend."
  },
  {
    "instruction": "Create and use sprites with multiple states and frames using ABCSprites",
    "output": "// Creating sprite and its states\nuses GraphABC,ABCSprites,ABCObjects,Events;\n\nvar s: SpriteABC;\n\nbegin\n  Window.Title := 'Sprite creation';\n  SetWindowSize(400,300);\n  CenterWindow;\n  \n  // Creating sprite and adding frames to it\n  s := new SpriteABC(150,100,'SpriteFrames\\multi1.bmp');\n  s.Add('SpriteFrames\\multi2.bmp');\n  s.Add('SpriteFrames\\multi3.bmp');\n  s.Add('SpriteFrames\\multi2.bmp');\n  s.Add('SpriteFrames\\multi4.bmp');\n  s.Add('SpriteFrames\\multi5.bmp');\n  \n  // Adding states to sprite\n  s.AddState('fly',4); // Fly - 4 frames\n  s.AddState('stand',1); // Stand - 1 frame\n  s.AddState('sit',1); // Sit - 1 frame\n  \n  // Setting sprite animation speed (1..10)\n  s.Speed := 9;\n  \n  // Saving sprite to \"long\" image and creating sprite info file\n  s.SaveWithInfo('spr.png');\nend."
  },
  {
    "instruction": "Switch sprite states on mouse click using ABCSprites",
    "output": "// Switching sprite states with mouse click\nuses GraphABC,ABCSprites,ABCObjects,Events;\n\nvar\n  s: SpriteABC;\n  t: TextABC;\n\nprocedure MyMouseDown(x,y,mb: integer);\nbegin\n  if s.PtInside(x,y) then\n  begin\n    // Transition to next sprite state\n    if s.State<s.StateCount then\n      s.State := s.State + 1\n    else s.State := 1;\n    t.Text := 'Sprite state: ' + s.StateName;\n  end;\nend;\n  \nbegin\n  Window.Title := 'Click mouse on sprite';\n  SetWindowSize(400,300);\n  CenterWindow;\n  s := new SpriteABC(150,100,'spr.spinf');\n  t := new TextABC(55,30,15,'Sprite state: '+s.StateName,clRed);\n  OnMouseDown := MyMouseDown;\nend."
  },
  {
    "instruction": "Create basic graphics program with lines using GraphABC",
    "output": "// Graphics. Lines. Window sizes. Window title\nuses GraphABC;\n\nbegin\n  Window.Title := 'First graphics program';\n  Line(0,0,Window.Width-1,Window.Height-1);\n  Line(0,Window.Height-1,Window.Width-1,0);\nend."
  },
  {
    "instruction": "Show how to use GraphABC module for drawing random pixels and measuring performance in PascalABC.NET",
    "output": "// Graphics. Point. Random color. Performance speed\nuses GraphABC;\n\nbegin\n  for var i:=1 to 100000 do\n    SetPixel(Random(Window.Width),Random(Window.Height),clRandom);\n  Println('Working time:',Milliseconds/1000,'seconds');  \nend."
  },
  {
    "instruction": "Demonstrate pen and brush properties in GraphABC",
    "output": "// Graphics. Pen and brush properties\nuses GraphABC;\n\nbegin\n  Window.Title := 'Pen and brush properties';\n  Pen.Color := Color.Red;\n  Pen.Width := 3;\n  Pen.Style := psDashDot;\n  Brush.Style := bsHatch;\n  Brush.Color := Color.Green;\n  Brush.Hatch := bhDiagonalBrick;\n  Brush.HatchBackgroundColor := Color.Bisque;\n  Rectangle(20, 20, Window.Width - 20, Window.Height - 20);\nend."
  },
  {
    "instruction": "Use Draw and Fill procedures for rectangle animation in GraphABC",
    "output": "// Graphics. Draw and Fill - procedures\nuses GraphABC;\n\nbegin\n  Window.Title := 'Draw and Fill - procedures';\n  for var i := 1 to 100 do\n  begin\n    Pen.Color := clRandom;\n    var x := Random(Window.Width-100);\n    var y := Random(Window.Height-100);\n    DrawRectangle(x,y,x+Random(100),y+Random(100));\n    Sleep(30);\n  end;\n  for var i := 1 to 100 do\n  begin\n    Brush.Color := clRandom;\n    var x := Random(Window.Width-100);\n    var y := Random(Window.Height-100);\n    FillRectangle(x,y,x+Random(100),y+Random(100));\n    Sleep(30);\n  end;\nend."
  },
  {
    "instruction": "Create pie chart using Pie procedure in GraphABC",
    "output": "// Graphics. Pie\nuses GraphABC;\n\nconst r = 200;\n\nbegin\n  Window.Title := 'Pie chart';\n  var x := Window.Center.X;\n  var y := Window.Center.Y;\n  Brush.Color := clRandom;\n  Pie(x,y,r,0,30);  \n  Brush.Color := clRandom;\n  Pie(x,y,r,30,110);  \n  Brush.Color := clRandom;\n  Pie(x,y,r,110,160);  \n  Brush.Color := clRandom;\n  Pie(x,y,r,160,280);  \n  Brush.Color := clRandom;\n  Pie(x,y,r,280,360);  \nend."
  },
  {
    "instruction": "Demonstrate transparency using ARGB colors in GraphABC",
    "output": "// Graphics. Transparency\nuses GraphABC;\n\nbegin\n  Window.Title := 'Transparency demonstration';\n  \n  Brush.Color := clRed;\n  FillRectangle(50,50,100,Window.Height - 50);\n  Brush.Color := clGreen;\n  FillRectangle(150,50,200,Window.Height - 50);\n  Brush.Color := clBlue;\n  FillRectangle(250,50,300,Window.Height - 50);\n  Brush.Color := ARGB(127,255,0,0);\n  FillRectangle(20,100,420,150);\n  Brush.Color := ARGB(63,0,127,0);\n  FillRectangle(20,200,420,250);\n  Brush.Color := ARGB(31,0,0,255);\n  FillRectangle(20,300,420,350);\nend."
  },
  {
    "instruction": "Save and load graphic window to/from file using GraphABC",
    "output": "// Graphics. Saving graphic window image to file and loading from file \nuses GraphABC;\n\nconst \n  delay = 500;\n  filename = 'GraphWindow.bmp';\n\nbegin\n  Window.Title := 'Window.Save and Window.Load';\n  SetWindowSize(320,240);\n  \n  for var x:=0 to Window.Width - 1 do\n  for var y:=0 to Window.Height - 1 do\n    SetPixel(x,y,RGB(x-2*y,y+x,y-2*x));\n  \n  Window.Save(filename);\n  for var i := 1 to 5 do\n  begin\n    Window.Clear;\n    Sleep(delay);\n    Window.Load(filename);\n    Sleep(delay);\n  end;\nend."
  },
  {
    "instruction": "Demonstrate anti-aliasing effects in GraphABC",
    "output": "// Graphics. Anti-aliasing\nuses GraphABC;\n\nbegin\n  Window.Title := 'Anti-aliasing demonstration';\n  TextOut(40,20,'With anti-aliasing');\n  Pen.Width := 2;\n  \n  Ellipse(40,60,300,200);\n  Line(340,60,600,130);\n  Line(600,130,340,200);\n  \n  SetSmoothingOff;\n  TextOut(40,240,'Without anti-aliasing');\n  Ellipse(40,280,300,420);\n  Line(340,280,600,350);\n  Line(600,350,340,420);\nend."
  },
  {
    "instruction": "Create stopwatch using RealNumber property in ABCObjects",
    "output": "uses ABCObjects,GraphABC;\n\nconst \n/// x-axis margin\n  zx = 100;\n/// y-axis margin\n  zy = 50;\n\nbegin\n  Window.IsFixedSize := True;\n  Window.Title := 'Stopwatch';\n  var r := new RoundRectABC(zx,zy,Window.Width-2*zx,Window.Height-2*zy,100,clMoneyGreen);\n  r.BorderWidth := 5;\n  r.BorderColor := clGreen;\n  for var i:=1 to 1000 do\n  begin\n    r.RealNumber := i/10;\n    Sleep(100);\n  end;\nend."
  },
  {
    "instruction": "Create stopwatch using RealNumber property in WPFObjects",
    "output": "uses WPFObjects;\n\nconst\n  /// x-axis margin\n  zx = 100;\n  /// y-axis margin\n  zy = 50;\n\nbegin\n  Window.IsFixedSize := True;\n  Window.Title := 'Stopwatch';\n  var r := new RoundRectWPF(zx, zy, Window.Width - 2 * zx, Window.Height - 2 * zy, 100, Colors.LightGreen, 5, Colors.Green);\n  r.FontSize := 200;\n  for var i := 1 to 1000 do\n  begin\n    r.RealNumber := i/10;\n    Sleep(100);\n  end;\nend."
  },
  {
    "instruction": "Demonstrate ScaleX and ScaleY properties for PictureABC with horizontal scaling animation",
    "output": "// ScaleX and ScaleY properties of PictureABC class\nuses ABCObjects,GraphABC;\n\nconst delay = 2;\n\nvar p: PictureABC;\n\nbegin\n  Window.Title := 'Movement and horizontal scaling of picture';\n  SetWindowSize(640,260);\n  p := PictureABC.Create(100,100,'demo.bmp');\n  while True do\n  begin\n    for var x:=100 to 450 do\n    begin\n      Sleep(delay);\n      p.MoveOn(1,0);\n    end;\n    for var i:=100 downto -100 do\n    begin\n      Sleep(delay);\n      var w := p.Width;\n      p.ScaleX := i/100;\n      p.MoveOn(w - p.Width,0);\n    end;\n    for var x:=450 downto 100 do\n    begin\n      Sleep(delay);\n      p.MoveOn(-1,0);\n    end;\n    for var i:=-100 to 100 do\n    begin\n      Sleep(delay);\n      p.ScaleX:=i/100;\n    end;\n  end;\nend."
  },
  {
    "instruction": "Create text cloning effect with color gradient using ABCObjects",
    "output": "// Cloning graphical objects\nuses ABCObjects,GraphABC;\n\nvar bt: TextABC;\n  \nbegin\n  var x := 224;\n  bt := new TextABC(60,110,110,'Hello!',RGB(x,x,x));\n  while x>32 do\n  begin\n    Sleep(40);\n    x -= 32;\n    bt := bt.Clone;\n    bt.Color := RGB(x,x,x);\n    bt.MoveOn(7,7);\n  end;\nend."
  },
  {
    "instruction": "Animate star properties - increase points count and rotate using ABCObjects",
    "output": "// Changing properties of StarABC object\nuses ABCObjects,GraphABC;\n\nvar z: StarABC;\n\nbegin\n  z := new StarABC(WindowWidth div 2,WindowHeight div 2,WindowHeight div 2 - 5,WindowHeight div 4 + 16,6,clRed);\n  for var i:=1 to 20 do\n  begin\n    Sleep(100);\n    z.Count := z.Count + 1;\n  end;\n  for var i:=1 to 180 do\n  begin\n    Sleep(10);\n    z.Angle := z.Angle + 1;\n  end;\nend."
  },
  {
    "instruction": "Animate star properties with manual rotation using WPFObjects",
    "output": "// Changing properties of StarWPF object\nuses WPFObjects, GraphWPF;\n\nbegin\n  var z := new StarWPF(Window.Width / 2, Window.Height / 2, Window.Height / 2 - 5, Window.Height / 4 + 16, 6, Colors.Red);\n  loop 20 do\n  begin\n    Sleep(100);\n    z.Count += 1;\n  end;\n  loop 200 do\n  begin\n    Sleep(10);\n    z.Rotate(1);\n  end;\nend."
  },
  {
    "instruction": "Animate star properties with automatic rotation using WPFObjects",
    "output": "// Changing properties of StarWPF object\nuses WPFObjects;\n\nbegin\n  var z := new StarWPF(Window.Width / 2, Window.Height / 2, Window.Height / 2 - 5, Window.Height / 4 + 16, 6, Colors.Red);\n  loop 20 do\n  begin\n    Sleep(100);\n    z.Count += 1;\n  end;\n  z.AnimRotate(200,2);\nend."
  },
  {
    "instruction": "Work with objects as sequences using pattern matching in WPFObjects",
    "output": "uses WPFObjects;\n\nfunction GenRandomWPF: ObjectWPF;\nbegin\n  var x := Random(Window.Width);\n  var y := Random(Window.Height);\n  case Random(3) of\n    0: Result := new CircleWPF(x,y,Random(15,20),RandomColor);\n    1: Result := new EllipseWPF(x,y,Random(15,60),Random(15,60),RandomColor); \n    2: Result := new RegularPolygonWPF(x,y,Random(15,30),Random(3,8),RandomColor);\n  end;\nend;\n\nbegin\n  loop 100 do\n    GenRandomWPF;\n  \n  Sleep(1000);\n  foreach var o in Objects.Seq do\n    match o with\n      CircleWPF(c): c.Radius += 10;\n      EllipseWPF(e): e.AnimMoveBy(Random(-50,50),Random(-50,50),1);\n      RegularPolygonWPF(r) when r.Count<6: r.SetBorder;  \n    end\nend."
  },
  {
    "instruction": "Create interactive standard colors palette with ABCObjects using reflection",
    "output": "uses \n  GraphABC,\n  ABCObjects,\n  System.Reflection;\n\nconst lim = 127 + 32;\n\nvar \n  CurrentBackColor := clWhite;\n  InfoString: RectangleABC;\n\nprocedure ChangeInfoStringText(colorName: string);\nbegin\n  var c := Color.FromName(colorName);\n  InfoString.Text := string.Format('Color.{0}: (R: {1}  G: {2}  B: {3})   (H: {4:f1}  S: {5:f1}  B: {6:f1})',colorName,c.R,c.G,c.B,c.GetHue,c.GetSaturation,c.GetBrightness);\n  InfoString.Color := c;\n  if c.R*c.R+c.G*c.G+c.B*c.B <= 3*lim*lim then \n    InfoString.FontColor := clWhite\n  else InfoString.FontColor := clBlack;\n  if c.A = 0 then \n   InfoString.FontColor := clGray;\nend;\n\nprocedure CreateStandardColors(backColor: Color);\nbegin\n  ClearWindow(backColor);\n  var t := typeof(Color);\n  var mi := t.GetProperties();\n  var y := 10;\n  var x := 10;\n  var h := Window.Width div 5 - 11;\n  foreach m: PropertyInfo in mi do\n  begin\n    if m.GetGetMethod(true).IsStatic then\n    begin\n      var c := Color(m.GetValue(nil,nil)); \n      var r := new RectangleABC(x,y,h,22,c);\n      r.Text := m.Name;\n      r.TextScale := 0.9;\n      r.Bordered := False;\n      if c.R*c.R+c.G*c.G+c.B*c.B <= 3*lim*lim then \n        r.FontColor := clWhite\n      else r.FontColor := clBlack;\n      if c.A = 0 then \n        r.FontColor := clGray;\n      y += 25;\n      if y > Window.Height-40 then\n      begin\n        y := 10;\n        x += h + 10;\n      end;  \n    end;\n  end;\nend;\n\nvar \n  ob: ObjectABC;\n  dx,dy: integer;\n\nprocedure MouseDown(x,y,mb: integer);\nbegin\n  ob := ObjectUnderPoint(x,y);\n  if ob=InfoString then\n    ob := nil;\n  if ob<>nil then\n  begin\n    ob.ToFront;\n    dx := x - ob.Left;\n    dy := y - ob.Top;\n    var c := ob.Color;\n    if (mb=2) then \n      ob.Scale(2)\n    else ob.Color := Color.FromArgb(128,c.R,c.G,c.B);\n  end;  \nend;\n\nprocedure MouseUp(x,y,mb: integer);\nbegin\n  if ob<>nil then\n  begin\n    if (mb=2) then \n      ob.Scale(0.5)\n    else\n    begin\n      var c := ob.Color;\n      if ob.Text = 'Transparent' then\n        ob.Color := Color.FromArgb(0,c.R,c.G,c.B)\n      else ob.Color := Color.FromArgb(255,c.R,c.G,c.B);\n    end;  \n    ob:= nil;\n  end;\nend;\n\nprocedure MouseMove(x,y,mb: integer);\nbegin\n  if (ob<>nil) and (mb=1) then\n  begin\n    ob.ToFront;\n    ob.Left := x - dx;\n    ob.Top := y - dy;\n  end;\n  if ob=nil then\n  begin\n    InfoString.Text := '';\n    InfoString.Color := CurrentBackColor;\n  end;\n  var ob1 := ObjectUnderPoint(x,y);\n  if ob1=InfoString then\n    ob1 := nil;\n  if (ob1<>nil) and (mb=0) then\n    ChangeInfoStringText(ob1.Text);\nend;\n\nprocedure KeyDown(Key: integer);\nbegin\n  if Key=vk_Space then\n  begin\n    if CurrentBackColor=clWhite then \n    begin\n      CurrentBackColor := clBlack;\n      InfoString.BorderColor := clWhite;\n    end  \n    else \n    begin\n      CurrentBackColor := clWhite;\n      InfoString.BorderColor := clBlack;\n    end;  \n    ClearWindow(CurrentBackColor);\n    RedrawObjects;\n  end;  \nend;\n\nbegin\n  SetWindowSize(1024,768);\n  Window.IsFixedSize := True;\n  Window.CenterOnScreen;\n  Window.Title := 'Standard colors (press Space to change background color)';\n  CreateStandardColors(CurrentBackColor);\n  InfoString := new RectangleABC(10,Window.Height-30,Window.Width-20,25);\n  OnMouseMove := MouseMove;\n  OnMouseDown := MouseDown;\n  OnMouseUp := MouseUp;\n  OnKeyDown := KeyDown;\nend."
  },
  {
    "instruction": "Create interactive standard colors palette with WPFObjects using reflection",
    "output": "uses \n  GraphWPF,\n  WPFObjects,\n  System.Reflection;\n\nconst lim = 127 + 32;\n\nvar \n  CurrentBackColor := Colors.White;\n  InfoString: RectangleWPF;\n\nprocedure ChangeInfoStringText(colorName: string);\nbegin\n  var c := Colors.LightGray;//Color.FromName(colorName);\n  InfoString.Text := $'Colors.{colorName}: (R: {c.R}  G: {c.G}  B: {c.B})';\n  InfoString.Color := c;\n  if c.R*c.R+c.G*c.G+c.B*c.B <= 3*lim*lim then \n    InfoString.FontColor := Colors.White\n  else InfoString.FontColor := Colors.Black;\n  if c.A = 0 then \n    InfoString.FontColor := Colors.Gray;\nend;\n\nprocedure CreateStandardColors(backColor: Color);\nbegin\n  Window.Clear(backColor);\n  var t := typeof(Colors);\n  var mi := t.GetProperties();\n  var y := 10.0;\n  var x := 10.0;\n  var h := Window.Width / 5 - 11;\n  foreach m: PropertyInfo in mi do\n  begin\n    if m.GetGetMethod(true).IsStatic then\n    begin\n      var c := Color(m.GetValue(nil,nil)); \n      var r := new RectangleWPF(x,y,h,22,c);\n      r.Text := m.Name;\n      r.FontSize := 16;//.TextScale := 0.9;\n      //r.Bordered := False;\n      if c.R*c.R+c.G*c.G+c.B*c.B <= 3*lim*lim then \n        r.FontColor := Colors.White\n      else r.FontColor := Colors.Black;\n      if c.A = 0 then \n        r.FontColor := Colors.Gray;\n      y += 25;\n      if y > Window.Height-40 then\n      begin\n        y := 10;\n        x += h + 10;\n      end;  \n    end;\n  end;\nend;\n\nvar \n  ob: ObjectWPF;\n  dx,dy: real;\n\nprocedure MouseDown(x,y: real; mb: integer);\nbegin\n  ob := ObjectUnderPoint(x,y);\n  if ob=InfoString then\n    ob := nil;\n  if ob<>nil then\n  begin\n    ob.ToFront;\n    dx := x - ob.Left;\n    dy := y - ob.Top;\n    var c := ob.Color;\n    if (mb=2) then \n      ob.ScaleFactor := 2\n    else ob.Color := Color.FromArgb(128,c.R,c.G,c.B);\n  end;  \nend;\n\nprocedure MouseUp(x,y: real; mb: integer);\nbegin\n  if ob<>nil then\n  begin\n    if (mb=2) then \n      ob.Scale(0.5)\n    else\n    begin\n      var c := ob.Color;\n      if ob.Text = 'Transparent' then\n        ob.Color := Color.FromArgb(0,c.R,c.G,c.B)\n      else ob.Color := Color.FromArgb(255,c.R,c.G,c.B);\n    end;  \n    ob:= nil;\n  end;\nend;\n\nprocedure MouseMove(x,y: real; mb: integer);\nbegin\n  if (ob<>nil) and (mb=1) then\n  begin\n    ob.ToFront;\n    ob.Left := x - dx;\n    ob.Top := y - dy;\n  end;\n  if ob=nil then\n  begin\n    InfoString.Text := '';\n    InfoString.Color := CurrentBackColor;\n  end;\n  var ob1 := ObjectUnderPoint(x,y);\n  if ob1=InfoString then\n    ob1 := nil;\n  if (ob1<>nil) and (mb=0) then\n    ChangeInfoStringText(ob1.Text);\nend;\n\nprocedure KeyDown(k: Key);\nbegin\n  if k=Key.Space then\n  begin\n    if CurrentBackColor=Colors.White then \n    begin\n      CurrentBackColor := Colors.Black;\n      InfoString.BorderColor := Colors.White;\n    end  \n    else \n    begin\n      CurrentBackColor := Colors.White;\n      InfoString.BorderColor := Colors.Black;\n    end;  \n    Window.Clear(CurrentBackColor);\n    //RedrawObjects;\n  end;  \nend;\n\nbegin\n  Window.SetSize(1024,768);\n  //Window.IsFixedSize := True;\n  Window.CenterOnScreen;\n  Window.Title := 'Standard colors (press Space to change background color)';\n  CreateStandardColors(CurrentBackColor);\n  InfoString := new RectangleWPF(10,Window.Height-30,Window.Width-20,25,Colors.LightGray);\n  OnMouseMove := MouseMove;\n  OnMouseDown := MouseDown;\n  OnMouseUp := MouseUp;\n  OnKeyDown := KeyDown;\nend."
  },
  {
    "instruction": "Create a basic 'Hello World' program in PascalABC.NET",
    "output": "// First program\nprogram HelloWorld;\nbegin\n  Writeln('Привет, мир!');\nend."
  },
  {
    "instruction": "Implement depth-first traversal of a directed graph in PascalABC.NET",
    "output": "// Depth-first traversal of directed graph\nprocedure TraverseDepth(gr: array of array of integer; p: array of boolean; x: integer);\nbegin\n  Print(x);\n  p[x] := True;\n  foreach var y in gr[x] do\n    if not p[y] then\n      TraverseDepth(gr,p,y);\nend;\n\nbegin\n  var gr := [[1, 2], [3], [1, 4], [5], [6], [4, 7], [], []];\n  var p := [False] * gr.Count;\n  TraverseDepth(gr,p,0);  \nend."
  },
  {
    "instruction": "Demonstrate coordinate system transformations in GraphABC with rotation and scaling",
    "output": "// Demonstration of coordinate system transformations\nuses GraphABC;\n\nbegin\n  Window.Title := 'Coordinate system transformations';\n  Window.IsFixedSize := True;\n\n  // Rotation\n  Coordinate.Angle := 30; \n  // Scale\n  Coordinate.Scale := 3;\n  // Coordinate origin - in window center\n  Coordinate.Origin := Window.Center;\n\n  Brush.Color := clMoneyGreen;\n  Ellipse(-50,-20,50,20);\n  Line(-70,0,70,0);\n  Line(0,-40,0,40);\nend."
  },
  {
    "instruction": "Create circular pattern using coordinate transformations in GraphABC",
    "output": "// Demonstration of coordinate system transformations\nuses GraphABC;\n\nbegin\n  Window.Title := 'Coordinate system transformations';\n  Window.IsFixedSize := True;\n\n  Coordinate.Origin := Window.Center;\n  Circle(0,0,200);\n  for var i := 1 to 12 do\n  begin\n    Circle(0,180,10);\n    Coordinate.Angle := Coordinate.Angle + 30; \n  end;  \nend."
  },
  {
    "instruction": "Create rotating ellipse animation using coordinate transformations in GraphABC",
    "output": "uses GraphABC;\n\nbegin\n  Coordinate.Origin := Window.Center;\n  Coordinate.SetMathematic;\n  while True do\n  begin\n    LockDrawing;\n    ClearWindow;\n    Ellipse(-120,-70,120,70);\n    Line(0,0,200,0);\n    Line(0,0,0,200);\n    Redraw;\n    Coordinate.Angle := Coordinate.Angle + 1;\n    Sleep(100);\n  end;\nend."
  },
  {
    "instruction": "Demonstrate font properties and styles in GraphABC with different fonts and colors",
    "output": "// Demonstration of working with fonts\nuses GraphABC;\n\nbegin\n  Window.Title := 'Fonts';\n  SetWindowSize(760,460);\n  Font.Name := 'Arial';\n  Font.Style := fsBoldItalic;\n  for var i:=4 to 14 do\n  begin\n    Font.Size := 2*i;\n    Font.Color := clRandom;\n    TextOut(30,2*i*i-15,'PascalABC.NET');\n  end;\n  Font.Name := 'Times New Roman';\n  Font.Style := fsBoldUnderline;\n  for var i:=4 to 14 do\n  begin\n    Font.Size := 2*i;\n    Font.Color := clRandom;\n    TextOut(400,2*i*i-15,'PascalABC.NET');\n  end;\nend."
  },
  {
    "instruction": "Center text in window using TextWidth and TextHeight functions in GraphABC",
    "output": "// Demonstration of using TextWidth and TextHeight\nuses GraphABC;\n\nconst s = 'Width & Height';\n  \nbegin\n  Window.Title := 'Centered text';\n  Window.IsFixedSize := True;\n  SetWindowSize(700,300);\n  Window.Center;\n  Font.Name := 'Times';\n  Font.Size := 50;\n  var tw := TextWidth(s);\n  var th := TextHeight(s);\n  TextOut((Window.Width-tw) div 2,(Window.Height-th) div 2,s);\nend."
  },
  {
    "instruction": "Use Polyline, Polygon, Curve, and ClosedCurve procedures with coordinate translation in GraphABC",
    "output": "// Procedures Polyline, Polygon, Curve, ClosedCurve\n// Coordinate system origin translation\nuses GraphABC;\n\nvar a: array of Point := (new Point(0,0), new Point(50,170), new Point(100,100), new Point(150,170), new Point(200,0));\n\nbegin\n  Window.Title := 'Drawing by point array';\n  Brush.Color := Color.Beige;\n  Coordinate.SetOrigin(60,30);\n  Polyline(a);\n  Coordinate.OriginX := 360;\n  Polygon(a);\n  Coordinate.Origin := new Point(60,250);\n  Curve(a);\n  Coordinate.OriginX := 360;\n  ClosedCurve(a);\nend."
  },
  {
    "instruction": "Implement Tower of Hanoi algorithm with graphical visualization in GraphABC",
    "output": "// Tower of Hanoi\nuses GraphABC;\n\ntype\n  /// Disk type\n  DiskType = record\n    /// Disk diameter\n    Sz: integer;\n    /// Disk color\n    Color: GraphABC.Color;\n  end;\n  /// Type of disk array on rod\n  DiskArr = array of DiskType;\n\nconst\n  /// Number of disks\n  CountDisks = 8;\n  /// Disk height\n  DiskHeight = 12;\n  /// Disk width increment\n  DiskWidthDelta = 12;\n  h = CountDisks * DiskWidthDelta * 2 + 20; \n  /// y-coordinate of disk pyramid base\n  y0 = DiskHeight * CountDisks + 80;\n  hh = 30;\n  /// x-coordinate of first rod\n  x1 = h div 2 + hh;\n  /// x-coordinate of second rod\n  x2 = x1 + h;\n  /// x-coordinate of third rod\n  x3 = x2 + h;\n  /// Pause, ms\n  delay = 50;\n\nvar\n  /// Array of disk pyramids \n  Tower: array [1..3] of DiskArr;\n  /// Array of disk counts in pyramids\n  DisksInTower: array [1..3] of integer;\n  /// Move number\n  MoveNumber: integer;\n\n/// Drawing pyramid\nprocedure DrawTower(a: DiskArr; n: integer; x0,y0: integer);\nbegin\n  Brush.Color := clBlack;\n  Rectangle(x0-5,y0,x0+5,y0-DiskHeight*CountDisks-10);\n  for var i:=0 to n-1 do\n  begin\n    Brush.Color := a[i].Color;\n    Rectangle(x0-a[i].sz*DiskWidthDelta,y0-DiskHeight*(i-1),x0+a[i].sz*DiskWidthDelta,y0-DiskHeight*i+1)\n  end;\nend;\n\n/// Drawing all pyramids and info string\nprocedure DrawAll;\nbegin\n  DrawTower(Tower[1],DisksInTower[1],x1,y0);\n  DrawTower(Tower[2],DisksInTower[2],x2,y0);\n  DrawTower(Tower[3],DisksInTower[3],x3,y0);\n  Brush.Color := clWhite;\n  TextOut(20,20,'Number of disk moves = '+MoveNumber);\n  Redraw;\nend;\n\n/// Moving disk from rod FromN to rod ToN\nprocedure MoveDisk(FromN, ToN: integer);\nbegin\n  Inc(MoveNumber);\n  Inc(DisksInTower[ToN]);\n  Tower[ToN][DisksInTower[ToN]-1] := Tower[FromN][DisksInTower[FromN]-1];\n  Dec(DisksInTower[FromN]);\n  Sleep(delay);\n  ClearWindow;\n  DrawAll;\nend;\n\n/// Main recursive procedure of \"Tower of Hanoi\" algorithm\nprocedure MoveTower(n: integer; FromN, ToN, WorkN: integer);\nbegin\n  if n=0 then exit;\n  MoveTower(n-1, FromN, WorkN, ToN);\n  MoveDisk(FromN, ToN);\n  MoveTower(n-1, WorkN, ToN, FromN);\nend;\n\n/// Array initialization\nprocedure InitTowers;\nbegin\n  SetLength(Tower[1],CountDisks);\n  SetLength(Tower[2],CountDisks);\n  SetLength(Tower[3],CountDisks);\n  DisksInTower[1] := CountDisks;\n  DisksInTower[2] := 0;\n  DisksInTower[3] := 0;\n  for var i:=0 to DisksInTower[1]-1 do\n  begin\n    Tower[1][i].Sz := DisksInTower[1]-i+1;\n    Tower[1][i].Color := clRandom;\n  end;\nend;\n\n/// Window initialization\nprocedure InitWindow;\nbegin\n  SetWindowSize(x3+x1,y0+50);\n  CenterWindow;\n  Window.Title := 'Tower of Hanoi';\n  Font.Size := 14;\n  Font.Name := 'Arial';\nend;\n\nbegin\n  InitWindow;\n  InitTowers;\n  LockDrawing;\n  DrawAll;\n  MoveTower(CountDisks,1,3,2);\nend."
  },
  {
    "instruction": "Demonstrate transparency effect with random colored circles in GraphABC",
    "output": "// Transparency illustration\nuses GraphABC;\n \nbegin\n  for var Transparency:=0 to 255 do\n  begin\n    Brush.Color := ARGB(Transparency,Random(256),Random(256),Random(256));\n    FillCircle(Random(Window.Width),Random(Window.Height),Random(20,60));\n    sleep(100);\n  end;\nend."
  },
  {
    "instruction": "Use if statement in full form to compare two numbers in PascalABC.NET",
    "output": "// Conditional operator. Full form\nvar \n  x: integer := 5;\n  y: integer := 3;\n\nbegin\n  if x<y then\n    writeln(x,'<',y)\n  else writeln(y,'<',x);\nend."
  },
  {
    "instruction": "Show different types of conditional statements in PascalABC.NET including if-else and case statements",
    "output": "// Conditional operator. Full form\n\nbegin\n  var x: integer := 5;\n  var y: integer := 3;\n  if x < y then\n    Println(x, '<', y)\n  else Println(y, '<', x);\nend.\n\n// Conditional operator. Short form\n\nbegin\n  var pass := ReadString('Enter password:');\n  if pass = 'NET' then\n    Println('Password correct');\nend.\n\n// Conditional operator. Logical conditions with or and and\n\nbegin\n  var x := ReadInteger('Enter x (from 1 to 99):');\n  if (x >= 1) and (x <= 9) then\n    Println('Single-digit number');\n  // Odd — function returning True if x is odd\n  if Odd(x) and (x >= 10) and (x <= 99) then\n    Println('Odd two-digit number');\n  if (x = 3) or (x = 9) or (x = 27) or (x = 81) then\n    Println('Power of three');\nend.\n\n// Nested conditional operators\n\nbegin\n  var x := ReadInteger('Enter grade (1..5):');\n  if x = 1 then\n    Println('One')\n  else if x = 2 then\n    Println('Two')\n  else if x = 3 then\n    Println('Three')\n  else if x = 4 then\n    Println('Four')\n  else if x = 5 then\n    Println('Five')\n  else Println('No such grade');\nend.\n\n// Selection operator\n\nbegin\n  var x := ReadInteger('Enter grade (1..5):');\n  case x of\n    1: Println('One');\n    2: Println('Two');\n    3: Println('Three');\n    4: Println('Four');\n    5: Println('Five');\n  else\n    Println('No such grade');\n  end;\nend.\n\n// Selection operator\n\nbegin\n  var day := ReadInteger('Enter day of week number (1..7):');\n  case day of\n    1..5: Println('Weekday');\n    6,7: Println('Weekend');\n  else Println('Invalid day of week');\n  end;\nend.\n\n// Selection operator\n\nbegin\n  var c := ReadChar('Enter character:');\n  case c of\n    '0'..'9': Println('This is digit');\n    'a'..'z', 'A'..'Z': Println('This is English letter');\n    'а'..'я', 'А'..'Я': Println('This is Russian letter');\n  end;\nend."
  },
  {
    "instruction": "Demonstrate naive animation with flickering effect in GraphABC",
    "output": "// Graphics. Example of \"naive\" animation. Flickering effect\nuses GraphABC;\n\nbegin\n  Window.Title := 'Simple animation demonstration';\n  var y := 200;\n  Brush.Color := clGreen;\n  for var x := 70 to 500 do\n  begin\n    Window.Clear(clWhite);    \n    Circle(x,y,50);\n    Sleep(3);\n  end;\nend."
  },
  {
    "instruction": "Implement smooth animation without flickering using LockDrawing and Redraw in GraphABC",
    "output": "// Graphics. Using LockDrawing-Redraw. No flickering\nuses GraphABC;\n\nbegin\n  Window.Title := 'Animation without flickering';\n  var y := 200;\n  Brush.Color := clGreen;\n  // Disable drawing in window\n  LockDrawing;\n  for var x := 70 to 500 do\n  begin\n    Window.Clear(clWhite);    \n    Circle(x,y,50);\n    // Redraw window from off-screen buffer\n    Redraw;\n    Sleep(3);\n  end;\nend."
  },
  {
    "instruction": "Create function graph plotting procedure with Y-axis scaling and window resize handling in GraphABC",
    "output": "// Procedure drawGraph for drawing function graph in full window\n// with Y-axis scaling\n// Redraws graph when window size changes\nuses GraphABC;\n\nfunction f(x: real) := x*sin(x)*exp(-0.1*x);\n\n// l (logical) - logical coordinates\n// s (screen) - physical coordinates\nprocedure drawGraph(x1,x2: real; f: real -> real);\n var\n  xl0,wl,yl0,hl: real;\n  xs0,ws,ys0,hs: integer;\n\n function LtoSx(xl: real) := round(ws/wl*(xl-xl0)+xs0);\n function LtoSy(yl: real) := round(hs/hl*(yl-yl0)+ys0);\n function StoLx(xs: integer) := wl/ws*(xs-xs0)+xl0;\n\nbegin // drawGraph\n  xs0 := 0;\n  ys0 := WindowHeight-1;\n  ws := WindowWidth;\n  hs := WindowHeight-1;\n  \n  xl0 := x1;\n  wl := x2-x1;\n\n  var yi: array of real;\n  SetLength(yi,ws+1);\n\n  var min := real.MaxValue;\n  var max := real.MinValue;\n  for var xi:=0 to ws do\n  begin\n    yi[xi] := f(StoLx(xi+xs0));\n    if yi[xi]<min then \n      min := yi[xi];\n    if yi[xi]>max then \n      max := yi[xi];\n  end;\n  \n  yl0 := min;\n  hl := -(max-min);\n\n  // Draw coordinate system axes\n  Line(0,LtoSy(0),ws,LtoSy(0));\n  Line(LtoSx(0),0,LtoSx(0),hs);\n\n  Pen.Color := clBlue;\n  MoveTo(xs0,LtoSy(yi[0]));\n  for var xi:=xs0+1 to xs0+ws do\n    LineTo(xi,LtoSy(yi[xi-xs0]));\nend;\n\nprocedure Resize;\nbegin\n  ClearWindow;\n  drawGraph(0,60,f);\n  Redraw;\nend;\n\nbegin\n  LockDrawing;\n  SetWindowCaption('Function graph: scaling');\n  drawGraph(0,60,f);\n  Redraw;\n  OnResize := Resize;\nend."
  },
  {
    "instruction": "Create 3D function plot using GraphABC (legacy code from KuMir/PMir)",
    "output": "// Example from KuMir/PMir package\n// Published almost without changes\n// Precious as memory :)\nUses GraphABC;\n\nvar Xmin,Xmax,Xstep: real;\n    Ymin,Ymax,Ystep,asp: real;\n    dx: integer;\n\nfunction f(x,y:real): integer;\nvar r: real;\nbegin\n  r := x*x+y*y+1;\n  f := round(5*asp*(cos(r)/r+0.1))\nend;\n\nprocedure gr(N : integer);\nvar X,Y: real; \n    i,j,k,Z0,dy: integer; \n    pred: array [1..100] of integer;\n    jj,maxX,maxY: integer;\nbegin\n  Xmin := -4;\n  Xmax := 4;\n  Ymin := -3;\n  Ymax := 3;\n  maxX := 600;\n  maxY := 400;\n  Xstep := dx*(Xmax-Xmin)/maxX; \n  X := Xmin;\n  Ystep := (Ymax-Ymin)/N;     \n  Y := Ymin;\n  dy := maxY div N div 2;        \n  asp := maxY/8;\n  for i := 1 to N do\n  begin\n    pred[i] := maxY-i*dy-f(X,Y);\n    Y := Y + Ystep\n  end;\n  for jj := 1 to maxX div dx do \n  begin\n    j := jj*dx;\n    X := X + Xstep;\n    Y := Ymin; Z0 := maxY;\n    for i := 1 to N do \n    begin\n      k := maxY-i*dy-f(X,Y);\n      if k<Z0 then\n      begin\n        Line(j-dx,pred[i],j,k);\n        Z0 := k\n      end;\n      pred[i] := Z0;\n      Y := Y+Ystep\n    end;\n  end;\nend;\n\nbegin\n  SetWindowCaption('Function graph of two variables');\n  SetWindowSize(600,400);\n  dx := 2; { X-axis resolution }\n  gr(100); { number of lines by Y <= MaxN }\nend."
  },
  {
    "instruction": "Create simple rotating coordinate system animation using GraphABC",
    "output": "// Illustration of simplest GraphABC capabilities\nuses GraphABC;\n\nbegin\n  Coordinate.Origin := Window.Center;\n  Coordinate.SetMathematic;\n  Brush.Color := Color.LightSkyBlue;\n  while True do\n  begin\n    LockDrawing;\n    ClearWindow;\n    Ellipse(-120,-70,120,70);\n    Line(0,0,200,0);\n    Line(0,0,0,200);\n    Redraw;\n    Coordinate.Angle := Coordinate.Angle + 1;\n    Sleep(100);\n  end;\nend."
  },
  {
    "instruction": "Create group animation with rotating prisms and pyramids using Graph3D",
    "output": "uses Graph3D;\n\nbegin\n  View3D.ShowGridLines := False;\n  \n  var a := new GroupAnimation;\n  \n  var p := P3D(9,-3,0);\n  var sz := 1.3;\n  var h := 4;\n  for var n:=3 to 10 do\n  begin\n    var pr := Prism(p,n,sz,4,Colors.Beige);\n    var prw := PrismWireFrame(p,n,sz+0.01,4);\n    p := p.MoveX(-2*sz-0.3);\n    a += pr.AnimRotate(OrtZ,360,10).Forever;\n    a += prw.AnimRotate(OrtZ,360,10).Forever;\n  end;\n\n  p := P3D(9,3,0);\n  for var n:=3 to 10 do\n  begin\n    var pr := Pyramid(p,n,sz,4,Colors.Beige);\n    var prw := PyramidWireFrame(p,n,sz+0.01,4);\n    p := p.MoveX(-2*sz-0.3);\n    a += pr.AnimRotate(OrtZ,360,10).Forever;\n    a += prw.AnimRotate(OrtZ,360,10).Forever;\n  end;\n  a.Begin;\nend."
  },
  {
    "instruction": "Create forever rotating cubes animation using Graph3D GroupAnimation",
    "output": "uses Graph3D;\n\nbegin\n  var c := Cube(-2,0,0,2,Colors.Beige);\n  var c1 := Cube(2,0,0,2,Colors.Green);\n  var a := c.AnimRotate(OrtZ,360,4).Forever * c1.AnimRotate(OrtZ,360,1).Forever;\n  a.Begin;\nend."
  },
  {
    "instruction": "Create and manipulate groups of 3D objects using Graph3D",
    "output": "uses Graph3D;\n\nbegin\n  var b := Box(0,0,0,3,1,2,Colors.Blue);\n  var s := Sphere(0,0,2,1,Colors.Green);\n \n  var g := Group(b,s);\n  g.MoveByY(-4);\n  var g1 := g.Clone;\n  g.MoveByY(3);\n  var gg := Group(g,g1);\n  gg.MoveByX(3);\nend."
  },
  {
    "instruction": "Use if-then-else as expression to find minimum of two numbers in PascalABC.NET",
    "output": "begin\n  var (a,b) := (2,3);\n  var min: integer;\n  min := if a<b then a else b;\n  Print(min)\nend."
  },
  {
    "instruction": "Use nested if-then-else expressions to determine quadrant based on coordinates in PascalABC.NET",
    "output": "begin\n  var (x,y) := (5,-3);\n  var q := \n    if x>0 then\n      if y>0 then\n        1\n      else 4\n    else\n      if y>0 then\n        2\n      else 3;\n        \n  Print(q)\nend."
  },
  {
    "instruction": "Implement indexer properties with a visual array of colored squares using GraphABC",
    "output": "// Indexer properties. Array of colored squares \nuses GraphABC;\n\nconst \n  sz = 50;\n  dim = 10;\n  delay = 500;\n\ntype \n  /// \n  VisualArray = class\n  private\n    a: array of Color;\n    procedure SetItem(i: integer; x: Color); // Procedure setting color of i-th square\n    begin\n      if (i<0) or (i>=a.Length) then\n        raise new System.ArgumentException('Index out of bounds: '+IntToStr(i));\n      a[i] := x;\n      Draw(i);\n    end;\n    function GetItem(i: integer): Color; // Function returning color of i-th square\n    begin\n      if (i<0) or (i>=a.Length) then\n        raise new System.ArgumentException('Index out of bounds: '+IntToStr(i));\n      Result := a[i];\n    end;\n  public\n    constructor (n: integer);\n    begin\n      a := ArrFill(n,Color.White);\n      Draw;\n    end;\n    /// Draws i-th square\n    procedure Draw(i: integer);\n    begin\n      Brush.Color := a[i];\n      Rectangle(sz+sz*i,sz,sz+sz*(i+1)+1,sz+sz);\n    end;\n    /// Draws array of colored squares\n    procedure Draw;\n    begin\n      for var i:=0 to a.Length-1 do\n        Draw(i);\n    end;\n    /// Default indexer property\n    property Item[i: integer]: Color read GetItem write SetItem; default;\n  end;\n\nvar arr: VisualArray;\n\nbegin\n  Window.Title := 'Indexer properties illustration';\n  arr := new VisualArray(dim);\n  Window.SetSize(sz*(dim+2),3*sz);\n  arr[0] := clGreen; // arr.Items[0] = arr[0] since Items property is default property\n  Sleep(delay);\n  arr[1] := clBlack;\n  Sleep(delay);\n  arr[2] := clYellow;\n  Sleep(delay);\n  arr[3] := clGray;\n  Sleep(delay);\n  arr[4] := clRed;\n  Sleep(delay);\n  arr[5] := clMagenta;\n  Sleep(delay);\n  arr[6] := clBrown;\n  Sleep(delay);\n  arr[7] := clMoneyGreen;\n  Sleep(delay);\n  arr[8] := clOlive;\n  Sleep(delay);\n  arr[9] := clLinen;\nend."
  },
  {
    "instruction": "Implement infix (in-order) traversal of binary tree using recursion and yield sequence in PascalABC.NET",
    "output": "type Node<T> = auto class\n  data: T;\n  left,right: Node<T>;\nend;\n\nfunction CNode<T>(x: T; l: Node<T> := nil; \n  r: Node<T> := nil): Node<T> := new Node<T>(x,l,r);\n\nfunction Infix<T>(root: Node<T>): sequence of T;\nbegin\n  if root = nil then exit;\n  yield sequence Infix(root.left);\n  yield root.data;\n  yield sequence Infix(root.right);\nend;\n\nbegin\n  var root := CNode(1,CNode(2,CNode(3),CNode(4)),CNode(5));\n  Infix(root).Print;\nend."
  },
  {
    "instruction": "Demonstrate inheritance, polymorphism and virtual methods with Person, Pupil and Teacher classes",
    "output": "// Inheritance. Polymorphism and virtual functions\ntype \n  Person = class\n  private\n    name: string;\n    age: integer;\n  public\n    constructor (n: string; a: integer);\n    begin\n      name := n; age := a;\n    end;\n    procedure Print; virtual; // Virtual function. Overridden in derived classes\n    begin\n      var s := GetType.ToString;\n      write('Type: ',Copy(s,pos('.',s)+1,Length(s)):7,'   Name: ',name,'   Age: ',age);\n    end;\n    procedure Println;\n    begin\n      Print;\n      writeln;\n    end;\n  end;\n  \n  Pupil = class(Person) // Pupil - inheritor of Person\n  private\n    clas: integer;\n  public\n    constructor (n: string; a,c: integer);\n    begin\n      inherited Create(n,a); // Call inherited constructor\n      clas := c;\n    end;\n    procedure Print; override;\n    begin\n      inherited Print;\n      write('   Class: ',clas);\n    end;\n  end;\n  \n  Teacher = class(Person)\n  private\n    predm: string;\n  public\n    constructor (n: string; a: integer; p: string);\n    begin\n      inherited Create(n,a); // Call inherited constructor\n      predm := p;\n    end;\n    procedure Print; override;\n    begin\n      inherited Print;\n      write('   Subject: ',predm);\n    end;\n  end;\n  \nvar a: array of Person := new Person[4]; // Polymorphic container - container of base class objects. Can contain objects of derived classes\n\nbegin\n  a[0] := new Pupil('Вова',11,5);\n  a[1] := new Teacher('Марья Ивановна',30,'Информатика');\n  a[2] := new Person('Иванов',65);\n  a[3] := new Pupil('Вася',12,6);\n  \n  for var i:=0 to a.Length-1 do\n    a[i].Println;\nend."
  },
  {
    "instruction": "Explain how to use record field initializers in PascalABC.NET with automatic type inference",
    "output": "// Record field initializers\ntype \n  Frac = record\n    num: integer := 0;\n    denom := 1; // automatic type inference - denom: integer\n  end;\n  \n\nbegin\n  var f: Frac;  \n  var f1: Frac := (num: 2; denom: 3);\n  Println(f.num,'/',f.denom);\n  Println(f1.num,'/',f1.denom);\nend."
  },
  {
    "instruction": "Demonstrate InRange method behavior with different data types in PascalABC.NET",
    "output": "begin\n  // Behavior changed!! Now range [6,2] is considered empty\n  5.InRange(6,2).Println; \n\n  // Universal InRange. Should support IEnumerable<T> interface\n  InRange(5,2,6).Println;\n\n  var dt1 := DateTime.Create(2025,04,16);\n  var dt2 := DateTime.Create(2025,04,29);\n  var dt3 := DateTime.Now;\n  InRange(dt2,dt1,dt3).Println; \nend."
  },
  {
    "instruction": "Use logical conditions with AND and OR operators in if statements in PascalABC.NET",
    "output": "// Conditional operator. Logical conditions with or and and\nvar x: integer;\n\nbegin\n  writeln('Enter x (from 1 to 99): ');\n  readln(x);\n  if (x>=1) and (x<=9) then \n    writeln('Single-digit number');\n  // Odd - function returning True only if x is odd\n  if Odd(x) and (x>=10) and (x<=99) then \n    writeln('Odd two-digit number');\n  if (x=3) or (x=9) or (x=27) or (x=81) then \n    writeln('Power of three');\nend."
  },
  {
    "instruction": "Use nested if statements for grade evaluation in PascalABC.NET",
    "output": "// Nested conditional operators\nvar x: integer;\n\nbegin\n  writeln('Enter grade (1..5): ');\n  readln(x);\n  if (x=1) then \n    writeln('One')\n  else if (x=2) then \n    writeln('Two')\n  else if (x=3) then \n    writeln('Three')\n  else if (x=4) then \n    writeln('Four')\n  else if (x=5) then \n    writeln('Five')  \n  else writeln('No such grade')  \nend."
  },
  {
    "instruction": "Demonstrate nested conditional operators for finding antonyms in PascalABC.NET",
    "output": "// Nested conditional operators. Antonyms\n\nbegin\n  var s := ReadString('Enter word from list (black,high,light,joy,smart):');\n  Print('Antonym: ');\n  if s = 'black' then\n    Println('white')\n  else if s = 'high' then\n    Println('low')\n  else if s = 'light' then\n    Println('darkness')\n  else if s = 'joy' then\n    Println('sorrow')\n  else if s = 'smart' then\n    Println('stupid')\n  else Println('No such word in list');\nend."
  },
  {
    "instruction": "Create a PascalABC.NET program that checks if a leaderboard of players is ordered by points in descending order, and if not, sorts it correctly. The program should use the IsOrderedByDescending method and display appropriate messages.",
    "output": "type\n  Player = auto class\n    Name: string; Points: integer;\n  end;  \n\nfunction GetPlayers := [\n  new Player('Alice', 120),\n  new Player('Bob', 95),\n  new Player('Charlie', 130),\n  new Player('Diana', 110)\n];\n\nbegin\n  var leaderboard := GetPlayers;\n  Println(leaderboard);\n  if not leaderboard.IsOrderedByDescending(p -> p.Points) then\n    Println('Leaderboard is incorrectly arranged!');\n\n  leaderboard := leaderboard.OrderByDescending(p -> p.Points).ToArray;\n  Println(leaderboard);\n  if leaderboard.IsOrderedByDescending(p -> p.Points) then\n    Println('Now the leaderboard is correctly arranged!');\nend."
  },
  {
    "instruction": "Create a 3D graphics program in PascalABC.NET that allows controlling a blue box using keyboard keys. Use left/right/up/down arrows for movement and X/Y/Z keys for rotation around respective axes.",
    "output": "uses Graph3D;\n\nbegin\n  View3D.ShowViewCube := False;\n  var s := Box(0,0,0,3,1,2,Colors.Blue);\n  OnKeyDown := k -> \n    case k of\n    Key.Left: s.MoveBy(1,0,0);\n    Key.Right: s.MoveBy(-1,0,0);\n    Key.Up: s.MoveBy(0,-1,0);\n    Key.Down: s.MoveBy(0,1,0);\n    Key.X: s.Rotate(OrtX,10);\n    Key.Y: s.Rotate(OrtY,10);\n    Key.Z: s.Rotate(OrtZ,10);\n    end;\nend."
  },
  {
    "instruction": "Create a frame-based animation in PascalABC.NET for moving a sphere using keyboard controls. Implement smooth movement with W/A/S/D and arrow keys, using velocity and direction vectors.",
    "output": "uses Graph3D;\n\nbegin\n  Window.Title := 'Ball movement - frame-based animation'; \n  View3D.Title := 'Use keys:';\n  View3D.SubTitle := 'W,A,S,D,Arrows - movement';\n  var c := Sphere(0,0,0,1,Colors.SeaGreen);\n  c.Direction := V3D(-1,0,0);\n  c.Velocity := 5;\n  \n  var kl,kr,ku,kd: boolean;\n  \n  BeginFrameBasedAnimationTime(dt -> begin\n    if kr then \n      c.Direction := V3D(-1,c.Direction.Y,0)\n    else if kl then \n      c.Direction := V3D(1,c.Direction.Y,0)\n    else c.Direction := V3D(0,c.Direction.Y,0);  \n    if ku then \n      c.Direction := V3D(c.Direction.X,-1,0)\n    else if kd then \n      c.Direction := V3D(c.Direction.X,1,0)\n    else c.Direction := V3D(c.Direction.X,0,0);\n    c.MoveTime(dt);\n  end);\n  \n  OnKeyDown := k ->\n  begin\n    case k of\n      Key.w,Key.Up:    begin ku := true; kd := false; end; \n      Key.s,Key.Down:  begin kd := true; ku := false; end;\n      Key.a,Key.Left:  begin kl := true; kr := false; end;\n      Key.d,Key.Right: begin kr := true; kl := false; end;\n    end;  \n  end;\n  OnKeyUp := k ->\n  begin\n    case k of\n      Key.w,Key.Up:    ku := false;\n      Key.s,Key.Down:  kd := false;\n      Key.a,Key.Left:  kl := false;\n      Key.d,Key.Right: kr := false;\n    end;  \n  end;\nend."
  },
  {
    "instruction": "Create a shooting game in PascalABC.NET using ABCObjects where the player controls a rectangle at the bottom and shoots bullets at colored enemy rectangles. Implement keyboard controls, collision detection, scoring system, and game states.",
    "output": "uses ABCObjects,GraphABC,Timers;\n\nconst \n  clPlayer = Color.BurlyWood;\n\nvar\n  kLeftKey,kRightKey: boolean;\n  kSpaceKey: integer;\n  Player: RectangleABC;\n  t: Timer;\n  EndOfGame: boolean;\n  StaticObjectsCount: integer;\n  Wins: integer;\n  Falls: integer;\n  InfoString: RectangleABC;\n  NewGame: RoundRectABC;\n\ntype\n  Pulya = class(CircleABC)\n  public\n    constructor Create(x,y: integer);\n    procedure Move; override;\n  end;\n  \n  Enemy = class(RectangleABC)\n  public\n    constructor Create(x,y,w: integer);\n    procedure Move; override;\n  end;\n\nconstructor Pulya.Create(x,y: integer);\nbegin\n  inherited Create(x,y,5,clRed);\n  dx := 0; \n  dy := -5;\nend;\n\nprocedure Pulya.Move; \nbegin\n  inherited Move; \n  if Top<0 then\n    Visible := False;\n  for var j:=StaticObjectsCount to Objects.Count-1 do\n    if (Objects[j]<>Self) and Intersect(Objects[j]) then\n    begin\n      Objects[j].Visible := False;\n      Visible := False;\n    end;\nend;\n\nconstructor Enemy.Create(x,y,w: integer);\nbegin\n  inherited Create(x,y,w,20,clRandom);\n  if Random(2)=0 then\n    dx := 5\n  else dx := -5;\n  dy := 0;\nend;\n\nprocedure Enemy.Move; \nbegin\n  if Random(2)<>0 then \n    Exit;\n  if Random(10)=0 then \n    dy := 5;\n  if (Left<0) or (Left+Width>Window.Width) or (Random(30)=0) then\n    dx := -dx;\n  inherited Move;\n  if dy<>0 then \n    dy := 0;\n  if Top>Window.Height-50 then\n    EndOfGame := True;\nend;\n\nfunction NumberOfEnemies: integer;\nbegin\n  Result := 0;\n  for var i:=0 to Objects.Count-1 do\n    if Objects[i] is Enemy then\n      Result += 1;\nend;\n\nprocedure CreateObjects;\nbegin\n  Player := new RectangleABC(280,WindowHeight-30,100,20,clPlayer);\n  for var i:=1 to 100 do\n  begin\n    var r1 := new Enemy(Random(WindowWidth-50),40+Random(10),50);\n    r1.TextVisible := True;\n    r1.Number := i;\n  end;\nend;\n\nprocedure DestroyObjects;\nbegin\n  for var i:=Objects.Count-1 downto StaticObjectsCount do\n    Objects[i].Destroy;\nend;\n\nprocedure MoveObjects;\nbegin\n  for var i:=StaticObjectsCount+1 to Objects.Count-1 do\n    Objects[i].Move;\nend;\n\nprocedure DestroyKilledObjects;\nbegin\n  for var i:=ObjectsCount-1 downto StaticObjectsCount+1 do\n    if not Objects[i].Visible then\n      Objects[i].Destroy;\nend;\n\nprocedure KeyDown(Key: integer);\nbegin\n  case Key of\nvk_Left:  kLeftKey := True;\nvk_Right: kRightKey := True;\nvk_Space: if kSpaceKey=2 then kSpaceKey := 1;\n  end;\nend;\n\nprocedure KeyUp(Key: integer);\nbegin\n  case Key of\nvk_Left:  kLeftKey := False;\nvk_Right: kRightKey := False;\nvk_Space: kSpaceKey := 2;\n  end;\nend;\n\nprocedure ChangeInfoString;\nbegin\n  InfoString.Text := 'Enemies: '+IntToStr(NumberOfEnemies)+'      Wins: '+IntToStr(Wins)+'      Losses: '+IntToStr(Falls);\nend;\n\nprocedure KeyPress(Key: char);\nbegin\n  if (Key in ['G','П','g','п']) and EndOfGame then\n  begin\n    NewGame.Visible := False;\n    EndOfGame := False;\n    t.Start;\n    CreateObjects;\n    kSpaceKey := 2;\n    kLeftKey := False;\n    kRightKey := False;\n  end;\nend;\n\nprocedure MouseUp(x,y,mb: integer);\nbegin\n  if NewGame.PTInside(x,y) then\n    KeyPress('G');\nend;\n\nprocedure TimerProc;\nbegin\n  if kLeftKey and (Player.Left>0) then\n    Player.MoveOn(-10,0);\n  if kRightKey and (Player.Left+Player.Width<WindowWidth) then\n    Player.MoveOn(10,0);\n  if kSpaceKey=1 then\n  begin\n    new Pulya(Player.Left+Player.Width div 2,Player.Top-10);\n    kSpaceKey := 0;\n  end;\n  MoveObjects;\n  DestroyKilledObjects;\n  RedrawObjects;\n  ChangeInfoString;\n  var n := NumberOfEnemies;\n  if n=0 then\n    EndOfGame := True;\n  if EndOfGame then\n  begin\n    if t.Enabled=False then Exit;  \n    t.Stop;\n    if n>0 then\n      Falls += 1\n    else Wins += 1;\n    NewGame.Visible := True;\n    DestroyObjects;\n    ChangeInfoString;\n    RedrawObjects;\n  end;\nend;\n\nbegin\n  Window.Title := 'Shooter';\n  Window.IsFixedSize := True;\n  ClearWindow(clBlack);\n  LockDrawingObjects;\n  EndOfGame := True;\n  InfoString := new RectangleABC(0,0,Window.Width,38,Color.DarkBlue);\n  InfoString.Bordered := False;\n  InfoString.FontColor := clWhite;\n  InfoString.TextScale := 0.9;\n  \n  var zz := 100;\n  NewGame := new RoundRectABC(zz,200,400,200,30,Color.Violet);\n  NewGame.Center := Window.Center;\n  NewGame.Text := 'G - New Game';\n  StaticObjectsCount := Objects.Count;\n  ChangeInfoString;\n  RedrawObjects;\n\n  OnKeyDown := KeyDown;\n  OnKeyPress := KeyPress;\n  OnKeyUp := KeyUp;\n  OnMouseUp := MouseUp;\n\n  t := new Timer(1,TimerProc);\nend."
  },
  {
    "instruction": "Demonstrate interface implementation with multiple interfaces and cross-casting in PascalABC.NET",
    "output": "// Illustration of interface usage\ntype\n  IShape = interface\n    procedure Draw;\n    property X: integer read;\n    property Y: integer read;\n  end;\n\n  ICloneable = interface\n    function Clone: Object;\n  end;\n\n  Point = class(IShape,ICloneable)\n  private\n    xx,yy: integer;\n  public\n    constructor Create(x,y: integer);\n    begin\n      xx := x; yy := y;\n    end;  \n    procedure Draw; begin end;\n    property X: integer read xx;\n    property Y: integer read yy;\n    function Clone: Object;\n    begin\n      Result := new Point(xx,yy);\n    end;\n  end;\n  \nbegin\n  var p: Point := new Point(2,3);\n  var ish: IShape := p;\n  var icl: ICloneable := p;\n\n  Println(ish.X,ish.Y);\n\n  var p1: Point := Point(icl.Clone);\n  p := nil;\n  Println(p1.X,p1.Y);\n\n  Println(ish is Point);\n  Println(ish is ICloneable); // Cross cast!\nend."
  },
  {
    "instruction": "Implement sorting of Student objects in PascalABC.NET using IComparer interface with different comparison criteria (by name and by age). Create custom comparer classes and demonstrate array sorting.",
    "output": "uses System,System.Collections.Generic;\n\ntype \n  Student = class\n  private\n    name: string;\n    age,course,group: integer;\n  public\n    constructor (n: string; a,c,g: integer);\n    begin\n      name := n; \n      age := a;\n      course := c;\n      group := g;\n    end;\n    function ToString: string; override;\n    begin\n      Result := Format('Name: {0,9}   Age: {1}   Course: {2}   Group: {3}',name,age,course,group);\n    end;\n  end;\n  \n  SortByName = class(IComparer<Student>)\n  public\n    function Compare(s1,s2: Student): integer;\n    begin\n      Result := string.Compare(s1.name,s2.name);\n    end;\n  end;\n\n  SortByAge = class(IComparer<Student>)\n  public\n    function Compare(s1,s2: Student): integer;\n    begin\n      Result := s1.age - s2.age;\n    end;\n  end;\n  \nprocedure WriteArray<T>(prompt: string; a: array of T);\nbegin\n  writeln(prompt);\n  foreach x: T in a do\n    writeln(x);\n  writeln;  \nend;\n  \nvar a: array of Student;  \n\nbegin\n  SetLength(a,5);\n  a[0] := new Student('Ivanova',18,2,3);\n  a[1] := new Student('Kozlov',19,3,10);\n  a[2] := new Student('Sidorova',22,5,1);\n  a[3] := new Student('Krikunov',17,1,2);\n  a[4] := new Student('Likhachev',25,4,8);\n  WriteArray('Original array:',a);\n  &Array.Sort(a,new SortByName);\n  WriteArray('Sort by name: ',a);\n  &Array.Sort(a,new SortByAge);\n  WriteArray('Sort by age: ',a);\nend."
  },
  {
    "instruction": "Create a PascalABC.NET program that demonstrates finding elements in an array using lambda expressions with the Array.FindIndex method on Student objects.",
    "output": "uses System,System.Collections.Generic;\n\ntype \n  Student = class\n  private\n    name: string;\n    age,course,group: integer;\n  public\n    constructor (n: string; a,c,g: integer);\n    begin\n      name := n; \n      age := a;\n      course := c;\n      group := g;\n    end;\n    function ToString: string; override;\n    begin\n      Result := Format('Name: {0,9}   Age: {1}   Course: {2}   Group: {3}',name,age,course,group);\n    end;\n  end;\n  \nprocedure WriteArray<T>(prompt: string; a: array of T);\nbegin\n  writeln(prompt);\n  foreach x: T in a do\n    writeln(x);\n  writeln;  \nend;\n  \nvar a: array of Student;  \n\nbegin\n  SetLength(a,5);\n  a[0] := new Student('Ivanova',18,2,3);\n  a[1] := new Student('Kozlov',19,3,10);\n  a[2] := new Student('Sidorova',22,5,1);\n  a[3] := new Student('Krikunov',17,1,2);\n  a[4] := new Student('Likhachev',25,4,8);\n  WriteArray('Original array:',a);\n  \n  writeln('Index of Kozlov = ',&Array.FindIndex(a,(s: Student)-> s.name = 'Kozlov'));\nend."
  },
  {
    "instruction": "Create a PascalABC.NET program that demonstrates currying with function types, using nested lambda expressions to generate a multiplication table.",
    "output": "type int = integer;\n\nbegin\n  var f: int -> int -> int := i -> j -> i*j;\n  MatrGen(10,10,(i,j)->f(i)(j)).Println;  \nend."
  },
  {
    "instruction": "Demonstrate window property manipulation in PascalABC.NET by toggling the IsFixedSize property of a GraphWPF window.",
    "output": "uses GraphWPF;\n\nbegin\n  Window.IsFixedSize := True;\n  Print(Window.IsFixedSize);\n  Window.IsFixedSize := False;\n  Print(Window.IsFixedSize);\nend."
  },
  {
    "instruction": "Create a PascalABC.NET program that processes a string by checking if words are integers or real numbers using IsInteger and IsReal methods, then calculates their sums separately.",
    "output": "begin\n  var s := '123.4 3 5 6.6 a v 67';\n  var (si,sr) := (0,0.0);\n  foreach var w in s.ToWords do\n    if w.IsInteger then\n      si += w.ToInteger\n    else if w.IsReal then\n      sr += w.Toreal;\n  Print(si,sr);  \nend."
  },
  {
    "instruction": "Implement Conway's Game of Life on a toroidal grid in PascalABC.NET using GraphWPF with optimization through uniform grid hashing. The program should handle cell updates efficiently and display generation information.",
    "output": "uses GraphWPF;\n\nconst \n  w = 4.0;\n  m = 300;\n  n = 220;\n  x0 = 0;\n  y0 = 21;\n  mk = 15;\n  nk = 10;\n\nvar\n  configuration,NeighborsA,NeighborsB: array [0..n+1,0..m+1] of byte;\n  updateA,updateB: array [1..nk,1..mk] of boolean;\n  CountCells: integer;\n  updateFlag: boolean;\n  generation: integer;\n  configurationVisual: DrawingVisual;\n  infoVisual: DrawingVisual;\n\nprocedure DrawConfiguration;\nbegin\n  DrawOnVisual(configurationVisual,dc->begin\n    for var i:=1 to n do\n    for var j:=1 to m do\n      if configuration[i,j]=1 then\n        DrawRectangleDC(dc,x0+(j-1)*w+0.5,y0+(i-1)*w+0.5,w-1,w-1,Brushes.Black,nil);\n  end);  \nend;\n\nprocedure DrawInfo;\nbegin\n  DrawOnVisual(infoVisual,dc->begin\n    TextOutDC(dc,14,0,'Generation: '+generation);\n    TextOutDC(dc,Window.Width - 110,0,'Cells: '+CountCells);\n  end);  \nend;\n\nprocedure DrawField;\nbegin\n  var hm := m div mk;\n  var hn := n div nk;\n  Pen.Color := Colors.LightGray;\n  for var i:=0 to m do\n    if i mod hm <> 0 then\n      Line(x0+i*w,y0,x0+i*w,y0+n*w);\n  for var i:=0 to n do\n    if i mod hn <> 0 then\n      Line(x0,y0+i*w,x0+m*w,y0+i*w);\n  Pen.Color := Colors.Gray;\n  for var i:=0 to m do\n    if i mod hm = 0 then\n      Line(x0+i*w,y0,x0+i*w,y0+n*w);\n  for var i:=0 to n do\n    if i mod hn = 0 then\n      Line(x0,y0+i*w,x0+m*w,y0+i*w);\n  FlushDrawingToBitmap;\nend;\n\nprocedure IncNeighbors(i,j: integer);\nbegin\n  var i1,i2,j1,j2: integer;\n  if i=1 then i1:=n else i1:=i-1;\n  if i=n then i2:=1 else i2:=i+1;\n  if j=1 then j1:=m else j1:=j-1;\n  if j=m then j2:=1 else j2:=j+1;\n  NeighborsB[i1,j1] += 1;\n  NeighborsB[i1,j]  += 1;\n  NeighborsB[i1,j2] += 1;\n  NeighborsB[i,j1]  += 1;\n  NeighborsB[i,j2]  += 1;\n  NeighborsB[i2,j1] += 1;\n  NeighborsB[i2,j]  += 1;\n  NeighborsB[i2,j2] += 1;\nend;\n\nprocedure DecNeighbors(i,j: integer);\nbegin\n  var i1,i2,j1,j2: integer;\n  if i=1 then i1:=n else i1:=i-1;\n  if i=n then i2:=1 else i2:=i+1;\n  if j=1 then j1:=m else j1:=j-1;\n  if j=m then j2:=1 else j2:=j+1;\n  NeighborsB[i1,j1] -= 1;\n  NeighborsB[i1,j]  -= 1;\n  NeighborsB[i1,j2] -= 1;\n  NeighborsB[i,j1]  -= 1;\n  NeighborsB[i,j2]  -= 1;\n  NeighborsB[i2,j1] -= 1;\n  NeighborsB[i2,j]  -= 1;\n  NeighborsB[i2,j2] -= 1;\nend;\n\nprocedure SetCell(i,j: integer);\nbegin\n  if configuration[i,j] = 0 then\n  begin\n    configuration[i,j] := 1;\n    updateFlag := True;\n    IncNeighbors(i,j);\n    CountCells += 1;\n  end;\nend;\n\nprocedure UnSetCell(i,j: integer);\nbegin\n  if configuration[i,j] = 1 then\n  begin\n    configuration[i,j] := 0;\n    updateFlag := True;\n    DecNeighbors(i,j);\n    CountCells -= 1;\n  end;\nend;\n\nprocedure ProcessCell(i,j: integer);\nbegin\n  case NeighborsA[i,j] of\n0..1,4..9: UnSetCell(i,j);\n3: SetCell(i,j);\n  end; \nend;\n\nprocedure NextGen;\nbegin\n  var hm := m div mk;\n  var hn := n div nk;\n  for var ik:=1 to nk do\n  begin\n    for var jk:=1 to mk do\n    begin\n      updateFlag := False;\n      var ifirst := (ik-1)*hn+1;\n      var ilast := (ik-1)*hn+hn;\n      var jfirst := (jk-1)*hm+1;\n      var jlast := (jk-1)*hm+hm;\n      if updateA[ik,jk] then\n      begin\n        for var i:=ifirst to ilast do\n        for var j:=jfirst to jlast do\n          ProcessCell(i,j);\n      end\n      else\n      begin\n        var ik1,jk1,ik2,jk2: integer;\n        if ik=1 then ik1:=nk else ik1:=ik-1;\n        if ik=nk then ik2:=1 else ik2:=ik+1;\n        if jk=1 then jk1:=mk else jk1:=jk-1;\n        if jk=mk then jk2:=1 else jk2:=jk+1;\n        var l := updateA[ik,jk1];\n        var r := updateA[ik,jk2];\n        var u := updateA[ik1,jk];\n        var d := updateA[ik2,jk];\n        var lu := updateA[ik1,jk1];\n        var ld := updateA[ik2,jk1];\n        var ru := updateA[ik1,jk2];\n        var rd := updateA[ik2,jk2];\n        if u then\n          for var j:=jfirst+1 to jlast-1 do\n            ProcessCell(ifirst,j);\n        if d then\n          for var j:=jfirst+1 to jlast-1 do\n            ProcessCell(ilast,j);\n        if l then\n          for var i:=ifirst+1 to ilast-1 do\n            ProcessCell(i,jfirst);\n        if r then\n          for var i:=ifirst+1 to ilast-1 do\n            ProcessCell(i,jlast);\n        if u or l or lu then\n          ProcessCell(ifirst,jfirst);\n        if u or r or ru then\n          ProcessCell(ifirst,jlast);\n        if d or l or ld then\n          ProcessCell(ilast,jfirst);\n        if d or r or rd then\n          ProcessCell(ilast,jlast);\n      end;\n      updateB[ik,jk] := updateFlag;\n    end;\n  end;\nend;\n\nprocedure InitWindow;\nbegin\n  if (m mod mk<>0) or (n mod nk<>0) then\n  begin\n    Writeln('Cluster size does not match field size. Program terminated');\n    exit\n  end;\n  Window.SetSize(x0+m*w,y0+n*w);\n  Window.CenterOnScreen;\n  Window.Title := 'Game of Life';\n  Font.Name := 'Arial';\n  Font.Size := 14;\nend;\n\nprocedure InitArrays;\nbegin\n  for var i:=0 to n+1 do\n  for var j:=0 to m+1 do\n    configuration[i,j] := 0;\n  NeighborsB := configuration;\n  NeighborsA := NeighborsB;\n  for var ik:=1 to nk do\n  for var jk:=1 to mk do\n    updateB[ik,jk] := True;\n  updateA := updateB;\n  CountCells := 0;\nend;\n\nvar yc := n div 2;\nvar xc := m div 2;\n\nprocedure InitConfiguration;\nbegin\n  SetCell(yc,xc);\n  SetCell(yc,xc+1);\n  SetCell(yc,xc+2);\n  SetCell(yc-1,xc+2);\n  SetCell(yc+1,xc+1);\nend;\n\nbegin\n  InitWindow;\n  InitArrays;\n  InitConfiguration;\n  \n  DrawField;\n  configurationVisual := CreateVisual;\n  infoVisual := CreateVisual;\n  \n  DrawConfiguration;\n  DrawInfo;\n  \n  MillisecondsDelta;\n  generation := 0;\n  while True do\n  begin\n    generation += 1;\n    NeighborsA := NeighborsB;\n    updateA := updateB;\n    NextGen;\n    DrawConfiguration;\n    if generation mod 10 = 0 then\n      DrawInfo;\n    if generation mod 1000 = 0 then\n      Writeln('Generation ',generation,': ',MillisecondsDelta/1000,' s');\n  end;\nend."
  },
  {
    "instruction": "Show how to use LinkedList (doubly linked list) from standard library with iterators in PascalABC.NET",
    "output": "// Using LinkedList - doubly linked list of standard library - and its iterator\n\nbegin\n  var L: LinkedList<integer> := new LinkedList<integer>;\n\n  L.AddLast(3);\n  L.AddLast(5);\n  L.AddLast(7);\n  L.AddFirst(2);\n  Println(L);\n  \n  var a := new integer[10];\n  L.CopyTo(a,0);\n  Println(a);\n  \n  var lit: LinkedListNode<integer> := L.Find(5);\n  L.AddBefore(lit,777);\n  Println(L);\nend."
  },
  {
    "instruction": "Create PascalABC.NET programs demonstrating LINQ operations including generating sequences, mathematical ranges, and character ranges.",
    "output": "begin\n  Range(1,20).Select(x->x*x).Println;\n  PartitionPoints(0.0,1.0,10).Println;\n  Range('a','z').Println;\nend."
  },
  {
    "instruction": "Implement prime number generation in PascalABC.NET using LINQ with both sequential and parallel execution for performance comparison.",
    "output": "function IsPrime(x: integer): boolean;\nbegin\n  var sqx := Round(Sqrt(x));\n  var i := 2;\n  while (i <= sqx) and (x mod i <> 0) do\n    i += 1;\n  Result := i > sqx; \nend;\n\nvar n := 3000000;\n\nbegin\n  writeln(Range(2,n).Where(IsPrime).Count);\n  writeln(Milliseconds);\n  writeln(Range(2,n).AsParallel.Where(IsPrime).Count);\n  writeln(MillisecondsDelta);\nend."
  },
  {
    "instruction": "Solve the knapsack problem in PascalABC.NET using backtracking to find all subsets of items that exactly fill the knapsack capacity.",
    "output": "const Sz=100;\n\ntype IntArr = array [1..Sz] of integer;\n\nprocedure PrintArr(const A: IntArr; n: integer);\nbegin\n  for var i:=1 to n do\n    Print(A[i]);\n  Println;\nend;\n\nprocedure TrySolve(n: integer; const B: IntArr; nb: integer);\nvar\n  Subset: IntArr;\n  space: integer;\n  ns: integer;\n\n  procedure TrySolve0(i: integer);\nbegin\n    if space=0 then \n      PrintArr(Subset,ns)\n    else if (space<0) or (i>nb) then \n      exit\n    else\n    begin\n      TrySolve0(i+1);\n      ns += 1; \n      Subset[ns] := B[i]; \n      space := space - B[i];\n      TrySolve0(i+1);\n      space := space + B[i]; \n      ns -= 1;\n    end;\n  end;\n  \nbegin\n  space:=n;\n  TrySolve0(1);\nend;\n\nprocedure FillArr(var B: IntArr; var n: integer);\nbegin\n  n:=5;\n  B[1]:=8; B[2]:=5; B[3]:=13; B[4]:=3; B[5]:=15;\nend;\n\nvar\n  B: IntArr;\n  nb: integer;\n\nbegin\n  FillArr(B,nb);\n  TrySolve(23,B,5);\nend."
  },
  {
    "instruction": "Create PascalABC.NET programs that demonstrate DLL usage, including calling functions and accessing variables from external libraries.",
    "output": "{$reference mydll.dll}\n\nbegin\n  PrintPascalABCNET;\n  writeln(n);\n  writeln(add(2,3));\nend."
  },
  {
    "instruction": "Build a LEGO structure in 3D using Graph3D in PascalABC.NET with different colored blocks stacked on top of each other.",
    "output": "uses Graph3D;\n\nbegin\n  var l := Lego(-4,-1,0,8,4,1,Colors.Green);\n  Lego(-2,0,0.4,4,2,1,Colors.Blue);\n  Lego(-1,0,0.8,1,1,1,Colors.Red);\n  Lego(-1,1,0.8,2,1,1,Colors.Yellow);\nend."
  },
  {
    "instruction": "Compare performance between array and list operations in PascalABC.NET by measuring execution time for large-scale element assignments.",
    "output": "begin\n  var n := 300000000;\n  var a := ArrFill(n,1);\n  var l := Lst(a);\n  MillisecondsDelta;\n  for var i:=0 to n-1 do\n    a[i] := 2;\n  MillisecondsDelta.Println;\n  for var i:=0 to n-1 do\n    l[i] := 2;\n  MillisecondsDelta.Println;\nend."
  },
  {
    "instruction": "Send an email using System.Net.Mail in PascalABC.NET with proper SMTP server configuration and message formatting.",
    "output": "uses System.Net.Mail;\n\nconst \n  SMTPServerName = 'mail.spark-mail.ru';\n\nbegin\n  var fromSender := 'ivanov@mail.ru';\n  var toReceiver := 'petrov@yandex.ru';\n  var subject := 'Proba';\n  var body := 'Hello!' + NewLine + 'I am robot!';\n  var message := new MailMessage(fromSender, toReceiver, subject, body);\n  \n  var mailClient := new SmtpClient(SMTPServerName);\n  mailClient.Send(message);\nend."
  },
  {
    "instruction": "Demonstrate lambda expression syntax in PascalABC.NET showing different ways to write procedure assignments with side effects.",
    "output": "begin\n  var f: procedure(x: integer);\n  var sum := 0;\n  f := x -> begin sum += x end;\n  f := x -> (sum += x);\nend."
  },
  {
    "instruction": "Create fractal visualizations in PascalABC.NET using the Paporotnik library to draw multiple fractal patterns in a single window.",
    "output": "uses GraphABC, Paporotnik, PaporotnikData;\n\nconst \n  Iterations = 300000;         \n  Height     = 600;            \n  Fast       = false;\n  Width      = Height div 2;        \n  WindowWidth= Width * 3;        \n  Brightness = 170;\n\nvar \n  Paprotnik := new PaporotnikFractal(PaprotnikData);\n  SimplePaprotnik := new PaporotnikFractal(SimplePaprotnikData);\n  Elka := new PaporotnikFractal(ElkaData);\n\nbegin\n  InitWindow(200, 50, WindowWidth , Height, clBlack);\n  Paprotnik.Draw(0, 0, Iterations, Height, Brightness, fast);\n  SimplePaprotnik.Draw(Width, 0, Iterations, Height, Brightness, fast);\n  Elka.Draw(Width*2, 0, Iterations, Height, Brightness, fast);\nend."
  },
  {
    "instruction": "Measure performance of list slicing operations in PascalABC.NET by timing repeated slice operations on large lists.",
    "output": "begin\n  var s := Lst(1..1000);\n  var s1: List<integer>;\n  Milliseconds;\n  var n := 10000000;\n  MillisecondsDelta.Println;\n  loop n do\n    s1 := s[1:11];\n  MillisecondsDelta.Println;\nend."
  },
  {
    "instruction": "Benchmark list slice assignment performance in PascalABC.NET by timing repeated slice assignments on lists.",
    "output": "begin\n  var s := Lst(1..10);\n  Milliseconds;\n  var n := 100000000;\n  MillisecondsDelta.Println;\n  loop n do\n    s[0:10] := s;\n  MillisecondsDelta.Println;\nend."
  },
  {
    "instruction": "Generate the Mandelbrot fractal set in PascalABC.NET using GraphWPF by iterating complex numbers and coloring pixels based on iteration count.",
    "output": "uses GraphWPF;\n\nconst\n  max = 10;\n  coef1 = 0.5;\n  coef2 = 0.88;\n  scalex = 0.0035;\n  scaley = 0.0035;\n  dx = 430;\n  dy = 300;\n\nbegin\n  Window.Title := 'Fractals: Mandelbrot Set';\n  Window.SetSize(600,600);\n  Window.CenterOnScreen;\n  var m := Window.Width.Round;\n  var n := Window.Height.Round;\n  var a := new Color[m,n];\n  for var ix:=0 to m-1 do\n  for var iy:=0 to n-1 do\n  begin\n    var cx := scalex * (ix - dx);\n    var cy := scaley * (iy - dy);\n    var c := Cplx(cx,cy);\n    var z := Cplx(0,0);\n    var i := 1;\n    while i<255 do\n    begin\n      z := z*z+c; \n      if z.Magnitude>max then break;\n      i += 1;\n    end;\n    if i>=255 then a[ix,iy] := Colors.Red\n      else a[ix,iy] := RGB(255,255-i,255-i);\n  end;\n  DrawPixels(0,0,a);\n  Writeln('Calculation time = ',Milliseconds/1000,' s');\nend."
  },
  {
    "instruction": "Demonstrate delegate pattern matching in PascalABC.NET by storing different function types in a System.Delegate variable and using match to invoke them.",
    "output": "begin\n  var s: real->real := x -> x * x;\n  var add: (real,real)->real := (x, y)-> x + y;\n  var d: System.Delegate := s;  \n  d := add;\n  match d with\n    Func<real, real>(var i): Print(i(2));\n    Func2<real, real, real>(var i): Print(i(2,3));\n  end;\nend."
  },
  {
    "instruction": "Implement the 'Matches' game in PascalABC.NET where players take turns removing 1-3 matches, with computer AI and win/lose conditions.",
    "output": "const InitialCount=15;\n\nvar\n  Count: integer;\n  Num: integer;\n  Player: integer;\n\nbegin\n  Player := 1;\n  Count := InitialCount;\n  repeat\n    if Player=1 then\n    begin\n      var Correct: boolean;\n      repeat\n        Write('Your turn. There are ',Count,' matches. ');\n        Write('How many matches do you take? ');\n        Readln(Num);\n        Correct := (Num>=1) and (Num<=3) and (Num<=Count);\n        if not Correct then\n          writeln('Incorrect! Repeat input!');\n      until Correct;\n    end\n    else\n    begin\n      Num := Random(1,3);\n      if Num>Count then \n        Num := Count;\n      Writeln('My turn. I took ',Num,' matches');\n    end;\n    Count -= Num;\n    if Player=1 then \n      Player := 2\n    else Player := 1;\n  until Count=0;\n  if Player=1 then\n    Writeln('You won!')\n  else Writeln('You lost!');\nend."
  },
  {
    "instruction": "Use tuple pattern matching with when conditions in PascalABC.NET to compare two variables and print the relationship between them.",
    "output": "begin\n  var (a,b) := (3,2);\n  match (a,b) with\n  (var x,var y) when x < y: Print('a < b');\n  (var x,var y) when x = y: Print('a = b');\n  (var x,var y) when x > y: Print('a > b');\n  end;\nend."
  },
  {
    "instruction": "Create 3D objects with different material properties in PascalABC.NET using Graph3D, combining diffuse, specular, and emissive materials.",
    "output": "uses Graph3D;\n\nbegin\n  var m := DiffuseMaterial(Colors.Green) + SpecularMaterial(128,30) + EmissiveMaterial(RGB(0,64,0));\n  Sphere(4,0,0,2,m);\n  Cube(8,0,0,4,RainbowMaterial);\n  Cube(0,0,0,4,DiffuseMaterial(Colors.Green) + ImageMaterial('dog.jpg',0.5,0.5));\nend."
  },
  {
    "instruction": "Demonstrate material properties variation in PascalABC.NET by creating spheres with different specular and emissive parameters arranged in rows.",
    "output": "uses Graph3D;\n\nbegin\n  for var i:=0 to 6 do\n    Sphere(6-2*i,-3,0,1,\n      Materials.Diffuse(Colors.Green) + \n      Materials.Specular(255-32*i,100));\n  for var i:=0 to 6 do\n    Sphere(6-2*i,0,0,1,\n      Materials.Diffuse(Colors.Green) +\n      Materials.Specular(255,100-15*i));\n  for var i:=0 to 6 do\n    Sphere(6-2*i,3,0,1,\n      Materials.Diffuse(Colors.Green) + \n      Materials.Specular(128,100) + \n      Materials.Emissive(GrayColor(15*i)));\nend."
  },
  {
    "instruction": "Search for a specific value in a random matrix using goto statement for early exit from nested loops in PascalABC.NET.",
    "output": "const \n  sz = 10;\n  m = 4;\n  n = 5;\n\ntype Matrix = array [1..sz,1..sz] of integer;\n\nlabel 1;\n\nvar matr: Matrix;\n\nbegin\n  for var i := 1 to m do\n  for var j := 1 to n do\n    matr[i,j] := Random(100);\n  for var i := 1 to m do\n  begin\n    for var j := 1 to n do\n      write(matr[i,j]:3);\n    writeln;\n  end;  \n  var found5 := False;\n  for var i := 1 to m do\n  for var j := 1 to n do\n    if matr[i,j]=5 then\n    begin\n      found5 := True;\n      goto 1;\n    end;\n1: \n  if found5 then \n    writeln('Element 5 found')\n  else writeln('Element 5 not found')  \nend."
  },
  {
    "instruction": "Create and manipulate dynamic matrix arrays in PascalABC.NET with functions for creation, random filling, and display.",
    "output": "type Matrix = array of array of integer;\n\nfunction CreateMatrix(m,n: integer): Matrix;\nbegin\n  SetLength(Result,m);\n  for var i:=0 to m-1 do\n    SetLength(Result[i],n);\nend;\n\nprocedure FillMatrByRandom(matr: Matrix);\nbegin\n  for var i:=0 to matr.Length-1 do\n  for var j:=0 to matr[0].Length-1 do\n    matr[i][j] := Random(100);  \nend;\n\nprocedure WriteMatrix(matr: Matrix);\nbegin\n  for var i := 0 to matr.Length-1 do\n  begin\n    for var j := 0 to matr[0].Length-1 do\n      write(matr[i,j]:3);\n    writeln;\n  end;  \nend;\n\nvar matr: Matrix;\n\nbegin\n  var m := 5;\n  var n := 7;\n  matr := CreateMatrix(m,n);\n  FillMatrByRandom(matr);\n  WriteMatrix(matr);\nend."
  },
  {
    "instruction": "Perform linear algebra operations in PascalABC.NET using NumLibABC to calculate matrix determinant of complex expression.",
    "output": "uses NumLibABC;\n\nbegin\n  var A:=new Matrix(2,4,-3,0,4,-1,2,-7,5,6);\n  var B:=new Matrix(2,3,8,1,-5,6,7,2);\n  var C:=new Matrix(3,4,1,-1,7,0,3,2,9,4,5,0,-2,-4);\n  var M:=(((A-B*C).Transpose)*A).Det;\n  Writeln(M)\nend."
  },
  {
    "instruction": "Generate random mazes using recursive backtracking algorithm in PascalABC.NET with GraphWPF visualization.",
    "output": "uses GraphWPF;\n\nconst \n  w = 60;\n  h = 40;\n  cellSize = 10;\n  wallColor = Colors.Black;\n  pathColor = Colors.White;\n  startColor = Colors.Green;\n  endColor = Colors.Red;\n\nvar maze := MatrGen(w*2+1, h*2+1, (x,y) -> True);\n\nvar dirs := Arr(\n    (0, -2),\n    (2,  0),\n    (0,  2),\n    (-2, 0)\n  );\n\nprocedure DrawCell(x, y: integer; c: Color)\n  := FillRectangle(x*cellSize/2, y*cellSize/2, \n       cellSize/2, cellSize/2, c);\n\nprocedure GenerateMaze(x, y: integer);\nbegin\n  maze[x, y] := false;\n  dirs.Shuffle;\n  foreach var (dx, dy) in dirs do\n  begin\n    var (nx, ny) := (x + dx, y + dy);\n    if (nx in 1..w*2-1) and (ny in 1..h*2-1) and maze[nx, ny] then\n    begin\n      var (wx, wy) := (x + dx div 2, y + dy div 2);\n      maze[wx, wy] := false;\n      GenerateMaze(nx, ny);\n    end;\n  end;\nend;\n\nprocedure DrawMaze;\nbegin\n  Window.SetSize(w*cellSize + 5, h*cellSize + 5);\n  Window.Clear(Colors.White);\n  for var x := 0 to w*2 do\n    for var y := 0 to h*2 do\n      if maze[x, y] then\n        DrawCell(x, y, wallColor)\n      else DrawCell(x, y, pathColor);\n  DrawCell(0, 1, startColor);\n  DrawCell(w*2, h*2-1, endColor);\nend;\n\nbegin\n  Window.Title := 'Random Maze Generator';\n  GenerateMaze(1, 1);\n  DrawMaze;\nend."
  },
  {
    "instruction": "Call Windows API MessageBox function from PascalABC.NET using external DLL declaration.",
    "output": "function MessageBox(h:integer;m,c:string;t:integer):integer;\nexternal 'User32.dll' name 'MessageBox';\n\nbegin\n  MessageBox(0,'Hello!','Message',0);\nend."
  },
  {
    "instruction": "Compare performance between static array and matrix filling operations in PascalABC.NET for large datasets.",
    "output": "const n = 20000;\n\nvar a: array [1..n,1..n] of real;\n\nbegin\n  for var i:=1 to n do\n  for var j:=1 to n do\n    a[i,j] := 1;\n  Println(MillisecondsDelta/1000);\n  var m := MatrFill(n,n,1);\n  Println(MillisecondsDelta/1000);\nend."
  },
  {
    "instruction": "Calculate Pi using Monte Carlo method in PascalABC.NET by generating random points and counting those inside unit circle.",
    "output": "begin\n  var n := 10000000;\n  var pp := (1..n).Select(x->(Random(),Random())).Where(p->sqr(p[0])+sqr(p[1])<1).Count/n*4;\n  Print(pp);\nend."
  },
  {
    "instruction": "Create animated mosaic pattern in PascalABC.NET by randomly swapping colored squares in a grid with continuous animation.",
    "output": "uses GraphABC;\n\nconst \n  w  = 25;\n  w1 = 1;\n  m  = 50;\n  n  = 70;\n  x0 = 0;\n  y0 = 0;\n  delay = 10;\n\nvar a: array [0..n,0..m] of Color;\n\nbegin\n  Window.Title := 'Mosaic';\n  Window.SetSize(800,600);\n  for var i:=0 to n-1 do\n  for var j:=0 to m-1 do\n  begin\n    a[i,j] := clRandom;\n    Brush.Color := a[i,j];\n    FillRect(x0+i*w,y0+j*w,x0+(i+1)*w-w1,y0+(j+1)*w-w1);\n  end;\n  var k := 0;\n  while true do\n  begin\n    k += 1;\n    if k mod 1000 = 0 then \n    begin\n      k := 0;\n      Sleep(delay);\n    end;  \n    var i := Random(1,n-2);\n    var j := Random(1,m-2);\n    var di := Random(-1,1);\n    var dj := Random(-1,1);\n    var i1 := i+di; \n    var j1 := j+dj;\n    Swap(a[i,j],a[i1,j1]);\n    Brush.Color := a[i,j];\n    FillRect(x0+i*w,y0+j*w,x0+(i+1)*w-w1,y0+(j+1)*w-w1);\n    Brush.Color := a[i1,j1];\n    FillRect(x0+i1*w,y0+j1*w,x0+(i1+1)*w-w1,y0+(j1+1)*w-w1);\n  end;\nend."
  },
  {
    "instruction": "Handle mouse and keyboard events in PascalABC.NET using GraphWPF to draw circles on mouse click and print key codes.",
    "output": "uses GraphWPF;\n\nbegin\n  OnMouseDown := (x,y,mb) -> if mb=1 then Circle(x,y,5);\n  OnKeyDown := k -> Print(k);\nend."
  },
  {
    "instruction": "Generate the Mandelbrot fractal set in PascalABC.NET using GraphABC by iterating complex numbers and setting pixels based on iteration count.",
    "output": "uses GraphABC;\n\nconst\n  max = 10;\n  coef1 = 0.5;\n  coef2 = 0.88;\n  scalex = 0.0035;\n  scaley = 0.0035;\n  dx = 430;\n  dy = 300;\n\nbegin\n  Window.Title := 'Fractals: Mandelbrot Set';\n  SetWindowSize(600,600);\n  CenterWindow;\n  for var ix:=0 to Window.Width-1 do\n  for var iy:=0 to Window.Height-1 do\n  begin\n    var cx := scalex * (ix - dx);\n    var cy := scaley * (iy - dy);\n    var c := Cplx(cx,cy);\n    var z := Cplx(0,0);\n    var i := 1;\n    while i<255 do\n    begin\n      z := z*z+c; \n      if z.Magnitude>max then break;\n      i += 1;\n    end;\n    if i>=255 then SetPixel(ix,iy,clRed)\n      else SetPixel(ix,iy,RGB(255,255-i,255-i));\n  end;\n  writeln('Calculation time = ',Milliseconds/1000,' s');\nend."
  },
  {
    "instruction": "Create mouse drawing applications in PascalABC.NET using different approaches: GraphABC for simple drawing and Windows Forms for advanced drawing with random colors.",
    "output": "// Simple mouse drawing with GraphABC\nuses GraphABC;\n\nbegin\n  Window.Title := 'Mouse Drawing';\n  OnMouseDown := (x,y,mb) -> MoveTo(x,y);\n  OnMouseMove := (x,y,mb) -> if mb=1 then LineTo(x,y);\nend.\n\n// Advanced mouse drawing with Windows Forms\n{$apptype windows}\n{$reference 'System.Windows.Forms.dll'}\n{$reference 'System.Drawing.dll'}\n\nuses \n  System, \n  System.Drawing, \n  System.Windows.Forms;\n\ntype\n  MyForm = class(Form)\n  private\n    g: Graphics;\n    x,y: integer;\n  public  \n    constructor;\n    begin\n      Size := new System.Drawing.Size(640,480);\n      StartPosition := FormStartPosition.CenterScreen;\n      Text := 'Mouse Drawing on Form';\n      MouseDown\t+= OnMouseDown;\n      MouseMove\t+= OnMouseMove;\n      Resize\t+= OnResize;\n      g := Graphics.FromHwnd(Handle);\n    end;\n    procedure OnMouseDown(sender: object; e: MouseEventArgs);\n    begin\n      x := e.x;\n      y := e.y;\n    end; \n    procedure OnMouseMove(sender: object; e: MouseEventArgs);\n    begin\n      if e.Button = System.Windows.Forms.MouseButtons.Left then \n      begin\n        g.DrawLine(new Pen(Color.FromARGB(PABCSystem.Random(255),PABCSystem.Random(255),PABCSystem.Random(255))),x,y,e.x,e.y);\n        x := e.x;\n        y := e.y;\n        writeln(e.x,' ',e.y);\n      end;\n    end; \n    procedure OnResize(sender: object; e: EventArgs);\n    begin\n      g := Graphics.FromHwnd(Handle);\n    end;\n  end;\n    \nbegin\n  Application.Run(new MyForm);\nend."
  },
  {
    "instruction": "Implement mouse event handling in PascalABC.NET using GraphWPF for drawing with custom pen settings and screenshot saving functionality.",
    "output": "uses GraphWPF;\n\nbegin\n  Window.Title := 'Mouse Drawing';\n  Pen.Color := Colors.Blue;\n  Pen.Width := 3;\n  OnMouseDown := (x,y,mb) -> MoveTo(x,y);\n  OnMouseMove := (x,y,mb) -> if mb=1 then LineTo(x,y);\n  OnKeyDown := k -> if k = Key.Space then Window.Save('a.png');\nend."
  },
  {
    "instruction": "Create mouse interaction examples in PascalABC.NET showing different event handling patterns including circle drawing on click and continuous line drawing.",
    "output": "// Draw circles on mouse click\nuses GraphABC;\n\nbegin\n  OnMouseDown := (x,y,mb) -> Circle(x,y,5);\nend.\n\n// Continuous line drawing with mouse\nuses GraphABC;\n\nprocedure MouseDown(x,y,mb: integer);\nbegin\n  MoveTo(x,y);\nend;\n\nprocedure MouseMove(x,y,mb: integer);\nbegin\n  if mb=1 then LineTo(x,y);\nend;\n\nbegin\n  OnMouseDown := MouseDown;\n  OnMouseMove := MouseMove;\nend."
  },
  {
    "instruction": "Implement frame-based animation with keyboard controls in PascalABC.NET using WPFObjects for smooth object movement.",
    "output": "uses WPFObjects;\n\nbegin\n  var c := new CircleWPF(Window.Center, 20, Colors.Green);\n  \n  OnDrawFrame := dt -> begin\n    c.MoveTime(dt);    \n  end;\n  \n  OnKeyDown := k -> begin\n    case k of\n      Key.Left: c.Direction := Direction.Left;\n      Key.Right: c.Direction := Direction.Right;\n      Key.Up: c.Direction := Direction.Up;\n      Key.Down: c.Direction := Direction.Down;\n    end;\n  end;\n  \n  OnKeyUp := k -> begin\n    c.Direction := Direction.Zero;\n  end;\nend."
  },
  {
    "instruction": "Demonstrate 3D object manipulation in PascalABC.NET using Graph3D for cloning, rotating, and positioning boxes in 3D space.",
    "output": "uses Graph3D;\n\nbegin\n  var b := Box(0,0,0,3,1,2,Colors.Blue);\n  var b1 := b.Clone.RotateAt(OrtZ,90,P3D(1.5,0,0)).MoveByX(-0.5);\n  b1 := b.Clone.RotateAt(OrtZ,-90,P3D(-1.5,0,0)).MoveByX(0.5);\n  View3D.BackgroundColor := Colors.Black;\n  View3D.ShowGridLines := False;\nend."
  },
  {
    "instruction": "Demonstrate multidimensional array slicing operations in PascalABC.NET with various slice patterns including reverse indexing and partial slices.",
    "output": "begin\n  var m := MatrByRow(||1,2,3,4|,|5,6,7,8|,|9,10,11,12||);\n  Println(m[:,:]);           // [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n  Println(m[::1,::1]);       // [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n  Println(m[1:3,1:4]);       // [[6,7,8],[10,11,12]]\n  Println(m[::2,::3]);       // [[1,4],[9,12]]\n  Println(m[::-2,::-1]);     // [[12,11,10,9],[4,3,2,1]] \n  Println(m[^2::-1,^2::-1]); // [[7,6,5],[3,2,1]] \n  Println(m[:^1,:^1]);       // [[1,2,3],[5,6,7]] \n  Println(m[1,:]);           // One-dimensional array [5,6,7,8] \n  Println(m[^1,:]);          // One-dimensional array [9,10,11,12] \n  Println(m[:,^1]);          // One-dimensional array [4,8,12] \nend."
  },
  {
    "instruction": "Show how to create and use DLL libraries in PascalABC.NET including both PascalABC.NET DLLs and native DLLs",
    "output": "// DLL library\nlibrary MyDll;\n\nconst n = 10;\n\nfunction add(a,b: integer): integer;\nbegin\n  Result := a + b;\nend;\n\nprocedure PrintPascalABCNET;\nbegin\n  Println('PascalABC.NET');\nend;\n\nend.\n\n// This is the main program\n// Names from dll-library written in PascalABC.NET can be used without connecting namespaces\n{$reference mydll.dll}\n\nbegin\n  PrintPascalABCNET;\n  Println(n);\n  Println(add(2,3));\nend.\n\n{$platformtarget x86}\n// Calling function from regular dll\nfunction add(a,b: integer): integer; external 'NativeDll.dll' name 'add'; // external function declaration\n\nbegin // main program\n  Println(add(2,3));\nend."
  },
  {
    "instruction": "Implement mathematical algorithms in PascalABC.NET including square root calculation using iterative method and Newton's method for equation solving.",
    "output": "// Square root using iterative method\nfunction MySqrt(x: real): real;\nbegin\n  var eps := 1e-15;\n  (var a, var b) := (x, real.MaxValue);\n  while abs(b-a) >= eps do\n    (a,b) := (b,(a + x / a) / 2);\n  Result := b;  \nend;\n\nbegin\n  Println(MySqrt(2));\n  Println(MySqrt(3));\n  Println(MySqrt(4));\nend.\n\n// Newton's method for equation solving\nfunction f(x: real) := exp(x) - 4;\nfunction df(x: real) := exp(x);\n\nfunction NewtonMethod(x, eps: real): real;\nbegin\n  while abs(f(x)) > eps do\n    x := x - f(x) / df(x); \n  Result := x;\nend;\n\nbegin\n  var x := 0.5;\n  var eps := 0.00001;\n  var root := NewtonMethod(x, eps);\n  Println('Equation root: ', root);\nend."
  },
  {
    "instruction": "Show how to create and use modules in PascalABC.NET with simplified structure and documentation comments",
    "output": "/// Module of simplified structure\nunit MyUnit; // module name must match file name\n\n// Documentation comments are displayed when hovering over name with mouse cursor\n/// Returns maximum element in array\nfunction Max(a: array of integer): integer;\nbegin\n  Result := integer.MinValue;\n  foreach var x in a do\n    if x > Result then \n      Result := x;\nend;\n\nend.\n\nuses MyUnit; // connected module\n\nvar a: array of integer := (1,5,3,7,3,6,4,5,1,8,3,5,6);\n\nbegin\n  Println('Maximum element in array =',Max(a));\nend."
  },
  {
    "instruction": "Create PascalABC.NET modules with different structures including initialization/finalization sections, and array utilities.",
    "output": "// Module with initialization/finalization\nunit MyUnit; \n\ninitialization\n  writeln('Initialization section. Executed before main program')\nfinalization\n  writeln('Finalization section. Executed after main program')\nend.\n\n// Module with array utilities\nunit MyUnit;\n\nconst Size = 100;\n\ntype IntArr = array [1..Size] of integer;\n\nvar Delimiter: string := ' ';\n\nprocedure FillArr(var a: IntArr; n: integer);\nbegin\n  for var i:=1 to n do\n    a[i] := Random(100);\nend;\n\nprocedure WriteArr(const a: IntArr; n: integer);\nbegin\n  for var i:=1 to n do\n    write(a[i],Delimiter);\n  writeln;  \nend;\n\nfunction Min(const a: IntArr; n: integer): integer;\nbegin\n  Result := a[1];\n  for var i:=1 to n do\n    if Result>a[i] then \n      Result := a[i];\nend;\n\nend."
  },
  {
    "instruction": "Demonstrate named parameter usage in PascalABC.NET procedures with default parameter values and explicit naming.",
    "output": "procedure p(s: string; x: integer := 1; y: integer := 2; z: integer := 3);\nbegin\n  Print(s,x,y,z);\nend;\n\nbegin\n  p('Hello', z := 33, y := 22);\nend."
  },
  {
    "instruction": "Create multiple unit modules in PascalABC.NET with same-named procedures and demonstrate resolution using module name qualification.",
    "output": "// Unit MyA\nunit MyA; \n\nprocedure p;\nbegin\n  writeln('MyA.p');\nend;\n\nbegin\nend.\n\n// Unit MyB\nunit MyB; \n\nprocedure p;\nbegin\n  writeln('MyB.p');\nend;\n\nbegin\nend.\n\n// Main program using both units\nuses MyA,MyB;\n\nbegin\n  p; // Calls MyB.p\n  MyA.p; // Calls MyA.p using module qualification\nend."
  },
  {
    "instruction": "Implement Conway's Game of Life with advanced features in PascalABC.NET including colony types, mouse interaction, and performance optimization.",
    "output": "uses GraphABC;\n\nconst \n  w =3;\n  w1=1;\n  k=20;\n  m=300;\n  n=220;\n  graphW=0;\n  mk=m div k;\n  nk=n div k;\n  mm=m+1;\n  nn=n+1;\n  x0=1;\n  y0=21;\n  ClearColor=clBlack;\n  FillColor=clLimeGreen;\n\nvar  \n  FiledColor := RGB(0,40,0);\n  FiledColor2 := RGB(0,70,0);\n  a,b,sosedia,sosedib:array of array of byte;\n  obnovA,obnovB: array of array of boolean;\n  count: integer;\n\nprocedure AssignArray(var arr:array of array of boolean; n,m:integer);\nbegin\n  SetLength(arr,n);\n  for var i:=0 to n-1 do\n    SetLength(arr[i],m);\nend;\n\nprocedure AssignArray(var arr:array of array of byte; n,m:integer);\nbegin\n  SetLength(arr,n);\n  for var i:=0 to n-1 do\n    SetLength(arr[i],m);\nend;\n\nprocedure CopyArray(arr1,arr2:array of array of byte);\nbegin\n  for var i:=0 to arr1.Length-1 do \n    arr1[i].CopyTo(arr2[i],0);\nend;\n\nprocedure CopyArray(arr1,arr2:array of array of boolean);\nbegin\n  for var i:=0 to arr1.Length-1 do \n    arr1[i].CopyTo(arr2[i],0);\nend;\n\ntype\n  ColonyType = (Big, LD, RD, LU, RU);\n\nprocedure AddColonyType(xc,yc:integer; ctype:ColonyType);\nbegin\n case ctype of\n    ColonyType.Big:begin\n      // Implementation for Big colony type\n    end;\n    ColonyType.LD:begin\n      // Implementation for LD colony type\n    end;\n  end;\n  CopyArray(sosedib,sosedia);\n  for var ik:=1 to nk do\n    for var jk:=1 to mk do\n      obnovB[ik,jk]:=true;\n  CopyArray(obnovB,obnovA);\nend;\n\nbegin\n  // Main game loop implementation\n  SetConsoleIO;\n  AssignArray(obnovA,nk+1,mk+1);\n  AssignArray(obnovB,nk+1,mk+1);\n  AssignArray(a,nn+1,mm+1);\n  AssignArray(b,nn+1,mm+1);\n  AssignArray(sosedia,nn+1,mm+1);\n  AssignArray(sosedib,nn+1,mm+1);\n  SetWindowCaption('Game of Life');\n  // Game initialization and main loop\nend."
  },
  {
    "instruction": "Demonstrate operator overloading for a Fraction record with arithmetic and comparison operations in PascalABC.NET",
    "output": "// Operator overloading\ntype \n  Frac = record\n  private\n    num,denom: integer;\n  public  \n    constructor (n,d: integer);\n    begin\n      num := n;\n      denom := d;\n    end;\n    class function operator+(a,b: Frac): Frac; \n    begin\n      Result := new Frac(a.num*b.denom+b.num*a.denom,a.denom*b.denom); \n    end; \n    class function operator-(a,b: Frac): Frac; \n    begin\n      Result := new Frac(a.num*b.denom-b.num*a.denom,a.denom*b.denom); \n    end; \n    class function operator*(a,b: Frac): Frac; \n    begin\n      Result := new Frac(a.num*b.num,a.denom*b.denom); \n    end;\n    class function operator/(a,b: Frac): Frac; \n    begin\n      Result := new Frac(a.num*b.denom,a.denom*b.num); \n    end;\n    class function operator=(a,b: Frac): boolean; \n    begin\n      Result := (a.num = b.num) and (a.denom = b.denom);\n    end; \n    class function operator<>(a,b: Frac): boolean; \n    begin\n      Result := not (a=b);\n    end; \n    class function operator<(a,b: Frac): boolean; \n    begin\n      Result := a.num/real(a.denom)<b.num/real(b.denom);\n    end; \n    class function operator<=(a,b: Frac): boolean; \n    begin\n      Result := a.num/real(a.denom)<=b.num/real(b.denom);\n    end; \n    class function operator>(a,b: Frac): boolean; \n    begin\n      Result := a.num/real(a.denom)>b.num/real(b.denom);\n    end; \n    class function operator>=(a,b: Frac): boolean; \n    begin\n      Result := a.num/real(a.denom)>=b.num/real(b.denom);\n    end; \n    class procedure operator+=(var a: Frac; b: Frac); \n    begin\n      a := a + b;\n    end; \n    class function operator-(a: Frac): Frac; \n    begin\n      Result := new Frac(-a.num,a.denom);\n    end; \n    class function operator+(a: Frac): Frac; \n    begin\n      Result := a;\n    end; \n    function ToString: string; override;\n    begin\n      Result := Format('{0}/{1}',num,denom);\n    end;\n  end;\n\nvar \n  f := new Frac(1,2);\n  f1 := new Frac(3,5);\n\nbegin\n  Println($'{f} + {f1} = {f+f1}');\n  Println($'{f} - {f1} = {f-f1}');\n  Println($'{f} * {f1} = {f*f1}');\n  Println($'{f} / {f1} = {f/f1}');\n  Println(f1 = f);\n  f += f1;\n  Println(-f);\nend."
  },
  {
    "instruction": "Demonstrate function overloading with different parameter types in PascalABC.NET",
    "output": "// Overloading subroutine names\nprocedure proc(i: integer);\nbegin\n  Println('integer');\nend;\n\nprocedure proc(c: char);\nbegin\n  Println('char');\nend;\n\nprocedure proc(r: real);\nbegin\n  Println('real');\nend;\n\nbegin\n  proc(1);\n  proc(2.5);\n  proc('d');\nend."
  },
  {
    "instruction": "Create a GUI application in PascalABC.NET using FormsABC to draw the Mandelbrot fractal with configurable parameters and threading support.",
    "output": "uses\n  System.Drawing, \n  System.Windows.Forms,\n  System.Threading,\n  FormsABC; \n\nprocedure DrawMandelbrot(g: Graphics; w,h: integer; scale: real; dx,dy: integer);\nconst max = 10;\nbegin\n  for var ix:=0 to w-1 do\n  for var iy:=0 to h-1 do\n  begin\n    var x := 0.0;\n    var y := 0.0;\n    var cx := scale * (ix - dx);\n    var cy := scale * (iy - dy);\n    var i := 1;\n    while i<255 do\n    begin\n      var x1 := x*x-y*y+cx;\n      var y1 := 2*x*y+cy;\n      x := x1;\n      y := y1;\n      if (abs(x)>max) and (abs(y)>max) then break;\n      i += 1;\n    end;\n    if i>=255 then \n      g.FillRectangle(Brushes.Red,ix,iy,1,1)\n    else \n      g.FillRectangle(new SolidBrush(Color.FromArgb(255,255-i,255-i)),ix,iy,1,1)\n  end;\nend;\n\nvar \n  Scale := new RealField('Scale: ');\n  l1 := new FlowBreak;\n  dx := new IntegerField('dx: ');\n  l2 := new FlowBreak;\n  dy := new IntegerField('dy: ');\n  l3 := new FlowBreak(20);\n  b := new Button(' Draw ');\n  p: PaintBox;\n\nprocedure Draw;\nbegin\n  var g := p.Graphics;\n  DrawMandelbrot(g,p.Width,p.Height,Scale.Value,dx.Value,dy.Value);\n  p.Invalidate;\nend;\n\nprocedure My(o: Object);\nbegin\n  Draw;\nend;\n\nprocedure Click;\nbegin\n  ThreadPool.QueueUserWorkItem(My);\nend;\n\nbegin\n  MainForm.Title := 'Mandelbrot Set';\n  MainForm.SetSize(700, 600);\n  MainPanel.Dock := Dockstyle.Left;\n  MainPanel.Width := 120;\n  Scale.Value := 0.0035;\n  dx.Value := 430;\n  dy.Value := 280;\n  b.Click += Click;\n  ParentControl := MainForm;\n  p := new PaintBox;\n  p.Dock := DockStyle.Fill;\n  ThreadPool.QueueUserWorkItem(My);\nend."
  },
  {
    "instruction": "Find and display palindromes in a string using PascalABC.NET LINQ operations, filtering words that read the same forwards and backwards.",
    "output": "begin\n  var s := ' hello  aha paap   zz ';\n  s.ToWords.Where(w -> w.Inverse = w).OrderBy(s->s.Length).Println(',');\nend."
  },
  {
    "instruction": "Create a fern fractal module in PascalABC.NET with configurable fractal parameters and drawing methods for different fern types.",
    "output": "unit Paporotnik;\n\nuses GraphABC;\n\ntype\n  PaporotnikFractalInitalData = record\n    data: array of array of real; \n    P0,P1,P2,P3:real;\n  end;\n  \n  PaporotnikFractal = class\n  private\n    data: array of array of real; \n    P0,P1,P2,P3:real;\n  public\n    constructor(initdata: PaporotnikFractalInitalData);\n    begin\n      data := initdata.data;\n      P0 := initdata.P0;\n      P1 := initdata.P1;\n      P2 := initdata.P2;\n      P3 := initdata.P3;\n    end;\n    procedure Draw(x0,y0,Iterations,Height,Brightness: integer; fast: boolean);\n    begin\n      var plotx, ploty, x, y : real;\n      var Size := Height/11;\n      var Width := Height div 2;\n      var dx := Width div 2;\n      var dc := Iterations div Brightness;\n      if fast then\n        LockDrawing;\n      for var i:=1 to Iterations do begin\n        var P := Random(100);    \n        var rnd := P<P0 ? 0 : P<P1+P0 ? 1 : P<P2+P1+P0 ? 2 : 3;\n        plotx := data[rnd,0]*x + data[rnd,1]*y;\n        ploty := data[rnd,2]*x + data[rnd,3]*y + data[rnd,5];\n        x := plotx;\n        y := ploty;\n        SetPixel(x0+Round(x*Size) + dx, y0+Height - Round(y*Size), GreenColor(byte(30 + (i div dc))));\n      end;\n      if fast then\n        UnlockDrawing;      \n    end;\n  end;\n\nend."
  },
  {
    "instruction": "Implement parallel programming patterns in PascalABC.NET including parallel invocation, task-based prime checking, and parallel for loops with thread synchronization.",
    "output": "// Parallel file downloads\nUses System,System.Net,System.Threading.Tasks;\n\nbegin\n  Parallel.Invoke (\n    procedure -> begin (new WebClient()).DownloadFile ('http://yandex.ru', 'yandex.html') end,\n    procedure -> begin (new WebClient()).DownloadFile ('http://pascalabc.net', 'pabc.html') end\n  );\nend.\n\n// Task-based prime number checking\ntype\n  Int = class\n    N: int64;\n    constructor(NN: int64);\n    begin\n      N := NN;\n    end;\n    function IsPrime: boolean;\n    begin\n      Result := True;\n      for var i: int64 := 2 to round(sqrt(N)) do\n        if N mod i = 0 then\n        begin\n          Result := False;\n          exit;\n        end;\n    end;\n  end;\n\ntype\n  BTask = Task<boolean>;\n\nbegin\n  var ss: array of int64 := (1265713689122381, 1265713689122461, 1265713689142451, 1265713689542501);\n  var tb := new BTask[4];\n  for var i := 0 to ss.Length - 1 do\n    tb[i] := Task.Factory.StartNew((new Int(ss[i])).IsPrime);\n  for var i := 0 to tb.Length - 1 do\n    writeln(tb[i].Result);\n  writeln(Milliseconds);  \nend.\n\n// Parallel for with thread-safe list\ntype\n  ListSimple = class\n    l := new List<int64>();\n    procedure AddPrime(N: int64);\n    begin\n      var Result := True;\n      for var i: int64 := 2 to round(sqrt(N)) do\n        if N mod i = 0 then\n        begin\n          Result := False;\n          break;\n        end;\n      lock l do \n        if Result then\n          l.Add(N);\n    end;\n  end;\n\nvar hh := 1000;\n\nbegin\n  var ls := new ListSimple;\n  var ii: int64 := 1265713689181;\n  Parallel.For(ii,ii+hh,ls.AddPrime);\n  Println(ls.l.Count);\nend."
  },
  {
    "instruction": "Create functions with variable number of parameters in PascalABC.NET for string concatenation and formatted output similar to Writeln.",
    "output": "// Variable parameter string concatenation\nfunction Concat(params strs: array of string): string;\nbegin\n  var sb := new StringBuilder;\n  foreach var x in strs do\n    sb.Append(x);\n  Result := sb.ToString;\nend;\n\nbegin\n  Writeln(Concat('Pascal','ABC','.NET'));\nend.\n\n// Variable parameter output procedure\nprocedure MyWriteln(params args: array of object);\nbegin\n  foreach var x in args do\n    Write(x);\n  WriteLn;\nend;\n\nvar \n  a: integer := 777;\n  b: boolean := True;\n  r: real := 3.1415;\n\nbegin\n  MyWriteln(a,' ',b,' ',r);\nend."
  },
  {
    "instruction": "Demonstrate array operations in PascalABC.NET including partial sums, incremental differences, and permutation generation.",
    "output": "// Partial sums and incremental differences\nbegin\n  var a := Arr(1..10);\n  a.Println;\n  var ps := a.PartialSum;\n  ps.Println;\n  ps.Incremental.Println;\nend.\n\n// Permutation generation\nbegin\n  var a := Arr(1..4);\n  repeat\n    a.Println;\n  until not NextPermutation(a);\nend.\n\n// Not in operator\nbegin\n  var a := Arr(1,3,5);\n  if 4 not in a then\n    Print('4 not in ' + a.JoinToString(','));\nend."
  },
  {
    "instruction": "Create a particle system in PascalABC.NET using Graph3D with configurable particle properties like lifetime, velocity, acceleration, and emission rate.",
    "output": "uses Graph3D;\n\nbegin\n  View3D.BackgroundColor := Colors.Black;\n  var ps := ParticleSystem(0,0,0,'smoke.png');\n  ps.LifeTime := 5;\n  ps.FadeOutTime := 0;\n  ps.VelocityDamping := 0.999;\n  ps.AngularVelocity := 10;\n  ps.SizeRate := 1;\n  ps.AccelerationDirection := V3D(3,0,-1);\n  ps.Acceleration := 4;\n  ps.AccelerationSpreading := 10;\n  ps.EmitRate := 100;\n  ps.StartRadius := 0;\n  ps.StartSize := 0.5;\n  ps.StartDirection := V3D(0,0,1);\n  ps.StartSpreading := 10;\n  ps.StartVelocity := 4;\n  ps.StartVelocityRandomness := 2;\n  ps.Position := P3D(0, 0, 0);\nend."
  },
  {
    "instruction": "Implement frame-based animation in PascalABC.NET using GraphWPF with smooth object movement controlled by time delta.",
    "output": "uses GraphWPF;\n\nbegin\n  var x0 := 100.0;\n  var v := 100;\n  OnDrawFrame := dt -> \n  begin\n    x0 += v * dt;\n    Circle(x0,100,30,Colors.Yellow);\n  end; \nend."
  },
  {
    "instruction": "Create fractal data modules in PascalABC.NET defining different fern fractal configurations including curved fern, straight fern, and fir tree patterns.",
    "output": "unit PaporotnikData;\n\nuses Paporotnik;\n\nvar\n  PaprotnikData: PaporotnikFractalInitalData := (\n    data: (( 0.0000,  0.0000,  0.0000,  0.1600, 0, 0.0000),\n           ( 0.8500,  0.0400, -0.0400,  0.8500, 0, 1.6000),\n           ( 0.1667, -0.2887,  0.2887,  0.1667, 0, 1.6000),\n           (-0.1667,  0.2887,  0.2887,  0.1667, 0, 0.4400));\n    P0: 3; \n    P1: 83;\n    P2: 7; \n    P3: 7);\n    \n  SimplePaprotnikData: PaporotnikFractalInitalData := (\n    data: (( 0.00,  0.00, 0.00, 0.16, 0, 0.00),\n           ( 0.85,  0.00, 0.00, 0.85, 0, 1.60),\n           ( 0.20, -0.26, 0.23, 0.22, 0, 1.60),\n           (-0.20,  0.26, 0.23, 0.22, 0, 1.60));\n    P0: 3; \n    P1: 83;\n    P2: 7; \n    P3: 7);\n\n  ElkaData: PaporotnikFractalInitalData := (\n    data: (( 0.1000,  0.0000,  0.0000,  0.1600, 0, 0.0000),\n           ( 0.8500,  0.0000,  0.0000,  0.8500, 0, 1.6000),\n           (-0.1667, -0.2887,  0.2887, -0.1667, 0, 1.6000),\n           (-0.1667,  0.2887, -0.2887, -0.1667, 0, 1.6000));\n    P0: 1; \n    P1: 85;\n    P2: 7; \n    P3: 7);\n\nend."
  },
  {
    "instruction": "Create a unit test procedure for the ApproxCheb class in PascalABC.NET that tests polynomial approximation with Chebyshev coefficients. The procedure should compare computed values with expected values within a given tolerance.",
    "output": "procedure TestApproxCheb(s:string; a,b:array of real; eps:real);\n// a - array of computed values\n// b - array of expected values\n// eps - allowable absolute error of solutions\nbegin\n  for var i:=0 to a.Length-1 do begin\n    var Msg:=s+': found: '+a[i]+', expected '+b[i];\n    Assert(Abs(Abs(a[i])-Abs(b[i]))<=eps,Msg);\n    end\nend;"
  },
  {
    "instruction": "Create a unit test procedure for the Decomp class in PascalABC.NET that tests matrix decomposition and linear system solving. The procedure should check for matrix singularity and compare computed solutions with expected values.",
    "output": "procedure TestDecomp(s:string; a:array[,] of real; b:array of real;\n    roots:array of real; eps:real);\n// a - system matrix;\n// b - right-hand side vector;\n// roots - vector of reference solutions;\n// eps - maximum absolute error of solutions\nbegin\n  var oD:=new Decomp(a);\n  var Msg:=s+': cond='+oD.cond+' matrix singularity detected';\n  var Flag:=oD.cond+1=oD.cond;\n  Assert(not Flag,Msg);\n  if not Flag then begin\n    oD.Solve(b);\n    var sum:=b.Zip(roots,(p,q)->Abs(Abs(p)-Abs(q))).Sum;\n    Msg:=s+': unacceptable error '+sum+' > '+eps+NewLine+\n        'Received : '+b.JoinIntoString(' ')+NewLine+\n        'Expected: '+roots.JoinIntoString(' ');\n    Assert(sum<=eps,Msg);\n    end\nend;"
  },
  {
    "instruction": "Create a unit test procedure for the Factors class in PascalABC.NET that tests polynomial factorization. The procedure should compare computed factors with expected integer roots.",
    "output": "procedure TestFactors(s:string; a:array of integer; roots:array of integer);\n// a - polynomial coefficients;\n// aroots - vector of reference solutions;\nbegin\n  var oL:=new Factors(a);\n  var r:=oL.Factorize;\n  var r1:=r.Rows.SelectMany(x->x);\n  var Msg:=s+': error.'+Newline+r1.JoinIntoString+': received'+NewLine+\n      roots.JoinIntoString+': expected';\n  if r1.Count=roots.Count then begin\n    var s1:=r1.Zip(roots,(i,j)->i-j).Sum;\n    Assert(s1=0,Msg)\n    end\n  else\n    Assert(false,Msg)\nend;"
  },
  {
    "instruction": "Create a unit test procedure for the FMin class in PascalABC.NET that tests single-variable function minimization. The procedure should compare found minimum points and function values with expected values within given tolerances.",
    "output": "procedure TestFMin(s:string; f:real->real; a,b,etx,ety,epsx,epsy:real);\n// etx - expected argument value\n// etx - expected function value\n// epsx - allowable absolute error for argument\n// epsy - allowable absolute error for function\nbegin\n  var oL:=new FMin(f,a,b);\n  var (x,y):=(oL.x,oL.Value);\n  var Msg:=s+': found argument: '+x+', expected '+etx;\n  Assert(Abs(x-etx)<=epsx,Msg);\n  Msg:=s+': function value: '+y+', expected '+ety;\n  Assert(Abs(y-ety)<=epsy,Msg);\nend;"
  },
  {
    "instruction": "Create a unit test procedure for the FMinN class in PascalABC.NET that tests multi-variable function minimization using the Hooke-Jeeves method. The procedure should compare found arguments and function values with expected values.",
    "output": "procedure TestFMinN1(s:string; f:function(x:array of real):real;\n    xb:array of real; etx:array of real; ety,epsx,epsy:real);\n// xb - array of arguments\n// etx - array of expected argument values\n// etx - expected function value\n// epsx - allowable absolute error for argument\n// epsy - allowable absolute error for function\nbegin\n  var oL:=new FMinN(xb,f);\n  var x:=oL.HJ;\n  var y:=f(x);\n  var Msg:=s+':'+NewLine+'found arguments  : '+\n      x.Select(t->Format('{0}',t)).JoinIntoString+NewLine+\n      'expected arguments: '+\n      etx.Select(t->Format('{0}',t)).JoinIntoString;\n  for var i:=0 to x.Length-1 do\n    if Abs(x[i]-etx[i])>epsx then begin\n      Assert(false,Msg);\n      break\n    end;\n  Msg:=s+': function value: '+y+', expected '+ety;\n  Assert(Abs(y-ety)<=epsy,Msg);\nend;"
  },
  {
    "instruction": "Create a unit test procedure for the Fraction class in PascalABC.NET that tests fraction arithmetic operations. The procedure should compare computed fractions with expected results.",
    "output": "procedure TestFraction(s:string; res,ans:Fraction);\n// result comparison res=ans\nbegin\n  Assert(res=ans,s+': received '+res.ToString+', expected '+ans.ToString)\nend;"
  },
  {
    "instruction": "Create unit test procedures for the Matrix class in PascalABC.NET that test scalar, vector, and matrix operations with error tolerance checking.",
    "output": "procedure TestMatrixS(s:string; a,r,eps:real);\n// a - found value;\n// r - expected value;\n// eps - maximum allowable absolute error\nbegin\n  var Msg:=s+': error exceeds allowable.'+Newline+'Received value '+\n      a+', expected value '+r;\n  Assert(Abs(a-r)<=eps,Msg)\nend;\n\nprocedure TestMatrixV(s:string; a,r:Vector; eps:real);\n// a - vector of found values;\n// r - vector of expected values;\n// eps - maximum allowable absolute error\nbegin\n  for var i:=0 to a.Length-1 do\n    Assert(Abs(a.Value[i]-r.Value[i])<=eps,\n        s+': error exceeds allowable.'+Newline+'Received value '+\n        a.Value[i]+', expected value '+r.Value[i])\nend;\n\nprocedure TestMatrixM(s:string; a,r:Matrix; eps:real);\n// a - computed matrix;\n// r - reference matrix;\n// eps - maximum allowable absolute error\nbegin\n  for var i:=0 to a.RowCount-1 do\n    for var j:=0 to a.ColCount-1 do\n      Assert(Abs(a.Value[i,j]-r.Value[i,j])<=eps,\n          s+': error exceeds allowable.'+Newline+'Received value a['+\n          i+','+j+']='+a.Value[i,j]+', expected value '+r.Value[i,j])\nend;"
  },
  {
    "instruction": "Create a unit test procedure for the PolRt class in PascalABC.NET that tests polynomial root finding. The procedure should handle complex roots and compare them with expected values within tolerance.",
    "output": "procedure TestPolRt(s:string; a:Polynom; roots:array of complex; eps:real);\n// roots - array of expected root values\n// eps - maximum absolute error of solutions\nbegin\n  var oP:=new PolRt(a);\n  if oP.ier>0 then begin\n    var Msg:=s+': test failed, error with code '+oP.ier;\n    Assert(false,Msg)\n    end\n  else begin\n    var r:=oP.Value;\n    for var i:=0 to r.Length-1 do begin\n      var Msg:=s+': found: ('+r[i].Real+','+r[i].Imaginary+'), expected ('+\n        roots[i].Real+','+roots[i].Imaginary+')';\n      Assert(Complex.Abs(r[i]-roots[i])<=eps,Msg);\n      end\n    end  \nend;"
  },
  {
    "instruction": "Create unit test procedures for the Polynom class in PascalABC.NET that test polynomial evaluation, economization, and arithmetic operations.",
    "output": "procedure TestPolynomD(s:string; res,lim:real; n1,n2:integer);\n// res - computed value\n// lim - maximum allowable value for res\n// also checks condition n2<n1\nbegin\n  Assert(n1>n2,s+': no economization occurred');\n  Assert(res<=lim,s+': deviation '+res+' exceeds '+lim);\nend;\n\nprocedure TestPolynomV(s:string; p:Polynom; x,r,eps:real);\n// х - argument for polynomial evaluation\n// r - expected value\n// eps - maximum absolute error of solution\nbegin\n  var a:=p.Value(x);\n  var Msg:=s+': found: '+a+', expected '+r;\n  Assert(Abs(a-r)<=eps,Msg)\nend;"
  },
  {
    "instruction": "Create a unit test procedure for the Quanc8 class in PascalABC.NET that tests numerical integration with adaptive quadrature. The procedure should compare computed integrals with expected values.",
    "output": "procedure TestQuanc8(s:string; a,b:real; F:real->real; ae,re,r2,eps:real);\n// cres - analytically found integral value\n// eps - allowable absolute error of solution\nbegin\n  var Msg:string;\n  var oQ:=new Quanc8(f,a,b,ae,re);\n  var r1:=oQ.Value;\n  if r1[2]=0 then begin\n    Msg:=s+': computed '+r1[0]+', expected '+r2;\n    Assert(Abs(r1[0]-r2)<=eps,Msg)\n    end\n  else begin\n    Msg:=s+': computed '+r1[0]+', expected '+r2+', errest='+r1[1]+', flag='+r1[2];\n    Assert(Abs(r1[0]-r2)<=eps,Msg)\n    end\nend;"
  },
  {
    "instruction": "Create a unit test procedure for the RKF45 class in PascalABC.NET that tests Runge-Kutta-Fehlberg ODE solving. The procedure should compare control sums with expected values.",
    "output": "procedure TestRKF45(s:string; res,ans,eps:real);\nbegin\n  Assert(Abs(res-ans)<=eps,s+': control sum '+res+', expected '+ans)\nend;"
  },
  {
    "instruction": "Create a unit test procedure for the RootsIsolation class in PascalABC.NET that tests root isolation for functions. The procedure should verify that roots fall within the found intervals.",
    "output": "procedure TestRootsIsolation(s:string; f:real->real; a,b,h:real;\n    t:array of real);\n// f - function\n// a,b - search interval boundaries\n// h - search step\n// t - reference array of function zeros\nbegin\n  var oRI:=new RootsIsolation(f,a,b,h);\n  var r:=oRI.Value;\n  for var i:=0 to t.Length-1 do begin\n    var Msg:=s+': zero point '+t[i]+' not in interval ['+r[i][0]+';'+r[i][1]+']';\n    Assert(t[i].Between(r[i][0],r[i][1]),Msg)\n    end;\nend;"
  },
  {
    "instruction": "Create a unit test procedure for the Spline class in PascalABC.NET that tests spline interpolation accuracy. The procedure should compare spline values with original function values.",
    "output": "procedure TestSpline(st:string; x:real; F:real->real; eps:real; S:Spline);\n// eps - relative error in percent\nbegin\n  var r1:=F(x);\n  var r2:=S.Value(x);\n  var Msg:=st+': F('+x+')='+r1+', received '+r2;\n  Assert(Abs((r1-r2)/r1)<=eps/100,Msg);\nend;"
  },
  {
    "instruction": "Create a unit test procedure for the Svenn class in PascalABC.NET that tests interval search for function minimization. The procedure should verify that the found interval contains the expected minimum.",
    "output": "procedure TestSvenn(s:string; f:real->real; x0,t,a,b:real);\n// f - function\n// x0 - initial search point\n// t - search step\n// a,b - expected interval (result should belong to it)\nbegin\n  var oS:=new Svenn(f,x0,t);\n  var r:=oS.Value;\n  var Msg:=s+': no solution found, expected ['+a+';'+b+']';\n  Assert(r[2]=0,Msg);\n  Msg:=s+': interval ['+a+';'+b+'] not within ['+r[0]+';'+r[1]+']';\n  Assert(a.Between(r[0],r[1]) and b.Between(r[0],r[1]),Msg)\nend;"
  },
  {
    "instruction": "Create unit test procedures for the Vector class in PascalABC.NET that test vector operations including modulus, orthogonalization, cross products, and angles.",
    "output": "procedure TestVector1(s:string; a,r,eps:real);\n// a - found value;\n// r - expected value;\n// eps - maximum allowable absolute error\nbegin\n  var Msg:=s+': error exceeds allowable.'+Newline+'Received value '+\n      a+', expected value '+r;\n  Assert(Abs(a-r)<=eps,Msg)\nend;\n\nprocedure TestVectorN(s:string; a,r:Vector; eps:real);\n// a - vector of found values;\n// r - vector of expected values;\n// eps - maximum allowable absolute error\nbegin\n  for var i:=0 to a.Length-1 do\n    Assert(Abs(a.Value[i]-r.Value[i])<=eps,\n        s+': error exceeds allowable.'+Newline+'Received value '+\n        a.Value[i]+', expected value '+r.Value[i])\nend;"
  },
  {
    "instruction": "Create a unit test procedure for the Zeroin class in PascalABC.NET that tests root finding for functions. The procedure should compare found roots with expected values within tolerance.",
    "output": "procedure TestZeroin(s:string; a,b:real; F:real->real; root,eps:real);\n// root - exact root value\n// eps - absolute error of root value\nbegin\n  var oZ:=new Zeroin(F,eps);\n  var x:=oZ.Value(a,b);\n  var Msg:=s+': root: '+x+', expected '+root;\n  Assert(Abs(x-root)<=eps,Msg);\nend;"
  },
  {
    "instruction": "Create a Person class in PascalABC.NET with external method implementation. The class should have private name and age fields, a constructor, and a Print method. Show both old and new syntax for constructor calls.",
    "output": "type \n  Person = class\n  private\n    name: string;\n    age: integer;\n  public\n    constructor (n: string; a: integer);\n    procedure Print;\n  end;\n\nconstructor Person.Create(n: string; a: integer);\nbegin\n  name := n; age := a;\nend;\n\nprocedure Person.Print;\nbegin\n  writeln('Имя: ',name,'  Возраст: ',age);\nend;\n\nvar p: Person;\n\nbegin\n  p := new Person('Иванов',20);\n  p.Print;\nend."
  },
  {
    "instruction": "Create a Person class in PascalABC.NET with internal method implementation. The class should have private fields and public constructor and Print methods implemented directly in the class interface.",
    "output": "type \n  Person = class\n  private\n    name: string;\n    age: integer;\n  public\n    constructor (n: string; a: integer);\n    begin\n      name := n; age := a;\n    end;\n    procedure Print;\n    begin\n      writeln('Имя: ',name,'  Возраст: ',age);\n    end;\n  end;\n\nvar p,p1: Person;\n\nbegin\n  p := new Person('Иванов',20);\n  p.Print;\n  p1 := Person.Create('Попов',19);\n  p1.Print;\nend."
  },
  {
    "instruction": "Create a multiplication table test application in PascalABC.NET using GraphWPF. The program should generate random multiplication questions, track answers, and provide a grade after 10 questions.",
    "output": "uses GraphWPF,Controls,Sounds;\n\nvar x, y: integer;\n\nprocedure NextQuestion;\nbegin\n  Window.Clear;\n  (x, y) := Random2(2, 9);  \n  DrawText(GraphWindow.ClientRect,$'{x} × {y} = ?');\nend;\n\nfunction Оценка(ВерныхОтветов: integer): integer;\nbegin\n  case ВерныхОтветов of\n    10, 9: Оценка := 5;\n    8, 7:  Оценка := 4;\n    4..6:  Оценка := 3;\n    else   Оценка := 2;\n  end;  \nend;\n\nbegin\n  Window.Title := 'Проверка таблицы умножения';\n  Font.Size := 40;\n  var l := LeftPanel(200);\n  l.FontSize := 16;\n  var sb := StatusBar;\n  NextQuestion;\n\n  var Результат := IntegerBox('Введите ответ:',0,100);\n  var b := Button('Ответить');\n  var КоличествоОтветов := IntegerBlock('Ответов:');\n  var ВерныхОтветов := IntegerBlock('Верных ответов:');\n  \n  b.Click := procedure → begin\n    if x * y = Результат then\n    begin\n      sb.Text := 'Верно!';\n      ВерныхОтветов += 1;\n    end  \n    else \n    begin\n      sb.Text := 'Неверно :(';\n    end;  \n    КоличествоОтветов += 1;\n    Результат := 0;\n    if КоличествоОтветов = 10 then\n    begin\n      MessageBox.Show('Тест окончен.'#10#10'Верных ответов: ' + \n        ВерныхОтветов.Value + #10#10 + 'Оценка: ' + Оценка(ВерныхОтветов));\n      ВерныхОтветов := 0;\n      КоличествоОтветов := 0;\n    end;\n    NextQuestion;\n  end;\n  OnResize := procedure → begin\n    Window.Clear;\n    DrawText(GraphWindow.ClientRect,$'{x} × {y} = ?');\n  end;\nend."
  },
  {
    "instruction": "Create an improved multiplication table test in PascalABC.NET using procedures for better code organization. Include separate procedures for test completion, drawing, and next question generation.",
    "output": "uses GraphWPF,Controls,Sounds;\n\nfunction Оценка(ВерныхОтветов: integer): integer;\nbegin\n  case ВерныхОтветов of\n    10, 9: Оценка := 5;\n    8, 7:  Оценка := 4;\n    4..6:  Оценка := 3;\n    else   Оценка := 2;\n  end;  \nend;\n\nbegin\n  Window.Title := 'Проверка таблицы умножения';\n  Font.Size := 60;\n  var l := LeftPanel(200);\n  l.FontSize := 16;\n  var sb := StatusBar;\n\n  var Результат := IntegerBox('Введите ответ:',0,100);\n  var b := Button('Ответить');\n  var КоличествоОтветов := IntegerBlock('Ответов:');\n  var ВерныхОтветов := IntegerBlock('Верных ответов:');\n  \n  var ТестОкончен := procedure → begin\n    MessageBox.Show('Тест окончен.'+#10#10+'Верных ответов: ' + \n      ВерныхОтветов.Value + #10#10 + 'Оценка: ' + Оценка(ВерныхОтветов));\n    ВерныхОтветов := 0;\n    КоличествоОтветов := 0;\n  end;\n  \n  var x, y: integer;\n\n  var НарисоватьТест := procedure → begin\n    Window.Clear;\n    DrawText(GraphWindow.ClientRect,$'{x} × {y} = ?');\n  end;\n\n  var СледующийВопрос := procedure → begin\n    (x, y) := Random2(2, 9);\n    НарисоватьТест;\n  end;\n  СледующийВопрос;\n  \n  b.Click := procedure → begin\n    if x * y = Результат then\n    begin\n      sb.Text := 'Верно!';\n      ВерныхОтветов += 1;\n    end  \n    else \n    begin\n      sb.Text := 'Неверно :(';\n    end;  \n    КоличествоОтветов += 1;\n    Результат := 0;\n    if КоличествоОтветов = 10 then\n      ТестОкончен;\n    СледующийВопрос;\n  end;\n  OnResize := НарисоватьТест;\nend."
  },
  {
    "instruction": "Create a network ping utility in PascalABC.NET that pings a server and displays its IP address and response time.",
    "output": "uses System.Net.NetworkInformation;\n\nconst address = 'www.yandex.ru';\n\nbegin\n  var p := new Ping();\n  try\n    var res := p.Send(address);\n    writeln('IP адрес сервера: ',res.Address);\n    writeln('Время отклика: ',res.RoundtripTime,' мс');\n  except\n    on e: Exception do\n      write(e.Message);\n  end;    \nend."
  },
  {
    "instruction": "Create a 3D planet rotation animation in PascalABC.NET using Graph3D. Show two spheres rotating around each other with different rotation speeds.",
    "output": "uses Graph3D;\n\nbegin\n  Window.Title := 'Вращение планет';\n  View3D.ShowCoordinateSystem := False;\n  View3D.ShowGridLines := False;\n  View3D.ShowViewCube := False;\n  View3D.BackgroundColor := Colors.Black;\n\n  var s := Sphere(2,0,0,0.5,Colors.Red);\n  var ss := Sphere(0,0,0,1,Colors.Blue);\n  Sphere(0,0,0,2,DiffuseMaterial(Colors.Yellow)+SpecularMaterial(32));\n  var g := Group(s,ss);\n  g.MoveBy(-7,0,0);\n  var anim := s.AnimRotateAt(OrtZ,360*100,P3D(-2,0,0),2*100)\n    * g.AnimRotateAt(OrtZ,360*100,P3D(7,0,0),10*100)\n  ;\n   \n  anim.Begin;\nend."
  },
  {
    "instruction": "Create a solar system animation in PascalABC.NET with Earth, Moon, and Sun using texture maps and orbital trajectories.",
    "output": "uses Graph3D;\n\nbegin\n  Window.Title := 'Вращение планет';\n  View3D.HideAll;\n  View3D.BackgroundColor := Colors.Black;\n  \n  var s := Sphere(0,0,0,30);\n  s.BackMaterial := ImageMaterial('skymap.jpg');\n\n  var Sun := Sphere(0,0,0,2,ImageMaterial('sunmap.jpg'));\n  var Earth := Sphere(-7,0,0,1,ImageMaterial('earthmap.jpg'));\n  var Moon := Sphere(2,0,0,0.5,ImageMaterial('moonmap.jpg'));\n  Earth.AddChild(Moon);\n  \n  var tr := ParametricTrajectory(0,2*Pi,100,t->P3D(7*cos(t),7*sin(t),0));\n  Polyline3D(tr,1.2,GrayColor(70));\n  \n  Moon.AnimRotateAt(OrtZ,360,P3D(-2,0,0),2.sec).Forever.Begin;\n  Earth.AnimRotateAtAbsolute(OrtZ,360,Origin,20.sec).Forever.Begin;\n  Earth.AnimRotate(OrtZ,-360,5.sec).Forever.Begin;\n  Sun.AnimRotate(OrtZ,-360,20.sec).Forever.Begin;\nend."
  },
  {
    "instruction": "Create a frame-based planet rotation animation in PascalABC.NET using OnDrawFrame event for continuous animation.",
    "output": "uses Graph3D;\n\nbegin\n  Window.Title := 'Вращение планет';\n  View3D.HideAll;\n  \n  var s := Sphere(0,0,0,30);\n  s.BackMaterial := ImageMaterial('skymap.jpg');\n\n  var earth := Sphere(-7,0,0,1,ImageMaterial('earthmap.jpg'));\n  var moon := Sphere(2,0,0,0.5,ImageMaterial('moonmap.jpg'));\n  earth.AddChild(moon);\n  var Sun := Sphere(0,0,0,2,ImageMaterial('sunmap.jpg'));\n  Sun.AnimRotate(OrtZ,-360,20.sec).Forever.Begin;\n  \n  var tr := ParametricTrajectory(0,2*Pi,100,t->P3D(7*cos(t),7*sin(t),0));\n  Polyline3D(tr,1.2,GrayColor(80));\n  \n  var tr1 := ParametricTrajectory(0,2*Pi,100,t->P3D(2*cos(t),2*sin(t),0));\n  var pl1 := Polyline3D(tr1,1.2,GrayColor(80));\n  earth.AddChild(pl1);\n\n  OnDrawFrame := dt -> begin\n    moon.RotateAt(OrtZ,360*dt/3,P3D(-2,0,0));\n    earth.RotateAtAbsolute(OrtZ,360*dt/6,Origin);\n  end;\nend."
  },
  {
    "instruction": "Create a 3D visualization of Platonic solids in PascalABC.NET using Graph3D. Display icosahedron, dodecahedron, tetrahedron, and octahedron with optional circumscribed spheres.",
    "output": "uses Graph3D;\n\nbegin\n  var РисоватьОписанныеСферы := True;\n  var p := P3D(6,0,0);\n  var p1 := p;\n  var h := -4;\n  Icosahedron(p,2,Colors.Green);\n  p.Offset(h,0,0);\n  Dodecahedron(p,2,Colors.Blue);\n  p.Offset(h,0,0);\n  Tetrahedron(p,2,Colors.Red);\n  p.Offset(h,0,0);\n  Octahedron(p,2,Colors.Magenta);\n  \n  p := p1;\n  if РисоватьОписанныеСферы then\n    loop 4 do\n    begin\n      var s := Sphere(p,2.0,DiffuseMaterial(Colors.Gold.ChangeAlpha(64))+SpecularMaterial(64));\n      s.BackMaterial := nil;\n      p.Offset(h,0,0);\n    end;\nend."
  },
  {
    "instruction": "Create a complete Platonic solids visualization in PascalABC.NET including cube with all five solids and their circumscribed spheres.",
    "output": "uses Graph3D;\n\nbegin\n  Window.Title := 'Платоновы тела';\n  var РисоватьОписанныеСферы := True;\n  var p := P3D(8,0,0);\n  var p1 := p;\n  var h := -4;\n  Icosahedron(p,2,Colors.Green);\n  p.Offset(h,0,0);\n  Dodecahedron(p,2,Colors.Blue);\n  p.Offset(h,0,0);\n  Tetrahedron(p,2,Colors.Red);\n  p.Offset(h,0,0);\n  Octahedron(p,2,Colors.Magenta);\n  p.Offset(h,0,0);\n  Cube(p,2*2/Sqrt(3),Colors.Brown);\n  \n  p := p1;\n  if РисоватьОписанныеСферы then\n    loop 5 do\n    begin\n      var s := Sphere(p,2.0,DiffuseMaterial(Colors.Gold.ChangeAlpha(64))+SpecularMaterial(64));\n      s.BackMaterial := nil;\n      p.Offset(h,0,0);\n    end;\nend."
  },
  {
    "instruction": "Create various types of graphs in PascalABC.NET using PlotWPF including line graphs, marker graphs, and grid layouts.",
    "output": "uses PlotWPF;\n\nbegin\n  var g := new GridWPF(2,2,10);\n\n  var c := new LineGraphWPF(0,Pi,v -> v*Sin(v*10));\n  c.PlotRect := Rect(0,0,10,10);\n  c.Graph[0].ChangeData(0,Pi,x->x*x);\n  c.Graph[0].Color := Colors.Green;\n  c.Graph[0].Thickness := 3;\n  c.AddLineGraph(0,Pi,v -> Sqrt(v));\n  \n  var c2 := new LineGraphWPF(0,Pi,v -> Sin(v*10)-Cos(v*7));\n  \n  var c4 := new MarkerGraphWPF(|1.0,2,3,4,5|,|5.0,15,7,12,2|);\n  c4.AddLineGraph(|1.0,2,3,4,5|,|5.0+1,15+1,7+1,12+1,2+1|);\n  c4.AddMarkerGraph(|1.0,2,3,4,5|,|5.0+1,15+1,7+1,12+1,2+1|,Colors.Bisque,MarkerType.Diamond,8);\n  c4.Graph[0].Thickness := 0.7;\n  c4.Graph[1].MarkerType := MarkerType.Box;\n  c4.Graph[2].Thickness := 0.7;\n\n  var gg := new GridWPF(2,2,3);\n  new LineGraphWPF(0,2,x->Cos(10*x));\n  new LineGraphWPF(0,2,x->Sqrt(x));\n  new LineGraphWPF(0,2,x->Sin(10*x));\n  new LineGraphWPF(0,2,x->exp(x));\nend."
  },
  {
    "instruction": "Demonstrate typed pointers in PascalABC.NET by creating integer pointers and manipulating values through pointer dereferencing.",
    "output": "var\n  i: integer := 5;\n  j: integer := 3;\n  p: ^integer;\n  \nbegin\n  writeln('Исходные значения переменных i и j: ',i,' ',j);\n  p := @i;\n  writeln('По адресу ',p,' находится значение ',p^);\n  p^ := 2;\n  p := @j;\n  writeln('По адресу ',p,' находится значение ',p^);\n  p^ += 1;\n  writeln('Новые значения переменных i и j: ',i,' ',j);\nend."
  },
  {
    "instruction": "Explain pointer restrictions in PascalABC.NET regarding reference types and exceptions for strings and dynamic arrays",
    "output": "// Pointers to reference types are prohibited. Exception: pointers to strings and dynamic arrays\ntype\n  A = class\n    i: integer;\n  end;\n\nbegin\n  var p: ^record field: A; end; // error \nend."
  },
  {
    "instruction": "Demonstrate untyped pointers in PascalABC.NET with type casting to manipulate different data types through the same pointer variable.",
    "output": "var\n  i: integer := 5;\n  r: real := 3.14;\n  p: pointer;\n  \ntype \n  pinteger = ^integer;\n  preal = ^real;\n  \nbegin\n  writeln('Исходные значения переменных i и r: ');\n  writeln(i,' ',r);\n  p := @i; \n  pinteger(p)^ := 8;\n  p := @r;\n  preal(p)^ += 1;\n  writeln('Новые значения переменных i и r: ');\n  writeln(i,' ',r);\nend."
  },
  {
    "instruction": "Demonstrate dynamic memory allocation in PascalABC.NET using New and Dispose procedures for pointer management.",
    "output": "var p: ^real;\n  \nbegin\n  New(p);\n  p^ := 3;\n  writeln('Значение в динамичесской памяти = ',p^);\n  Dispose(p);\nend."
  },
  {
    "instruction": "Compare two approaches for creating linked lists in PascalABC.NET: using references (recommended) vs using pointers",
    "output": "// Using references instead of pointers for creating singly linked list\n// We recommend this approach\ntype \n  Node = class\n    data: integer;\n    next: Node;\n    constructor (d: integer; n: Node);\n    begin\n      data := d;\n      next := n;\n    end;\n  end;\n  \nbegin\n  // Variable of type \"class\" represents a reference to object allocated by constructor\n  var first: Node := nil;\n  // Add to beginning of singly linked list\n  first := new Node(3,first);\n  first := new Node(7,first);\n  first := new Node(5,first);\n  \n  // Output singly linked list. ^ are absent\n  Println('Contents of singly linked list (using references instead of pointers):');\n  var p := first;\n  while p<>nil do\n  begin\n    Print(p.data);\n    p := p.next;\n  end;\n  \n  // Destruction of singly linked list\n  first := nil; // Garbage collector will collect memory that no one points to anymore\nend.\n\n// Dynamic memory allocation\n// Using pointers for creating singly linked list\ntype \n  PNode = ^TNode;\n  TNode = record\n    data: integer;\n    next: PNode;\n  end;\n\nfunction NewNode(d: integer; n: PNode): PNode;\nbegin\n  New(Result);\n  Result^.data := d;\n  Result^.next := n;\nend;\n\nbegin\n  var first: PNode := nil;\n  \n  // Add to beginning of singly linked list\n  first := NewNode(3,first);\n  first := NewNode(7,first);\n  first := NewNode(5,first);\n  \n  // Output singly linked list\n  Println('Contents of singly linked list:');\n  var p := first;\n  while p<>nil do\n  begin\n    Print(p^.data);\n    p := p^.next;\n  end;\n  \n  // Destruction of singly linked list\n  p := first;\n  while p<>nil do\n  begin\n    var p1 := p;\n    p := p^.next;\n    Dispose(p1); // Memory must be returned\n  end;\nend."
  },
  {
    "instruction": "Demonstrate permutations, combinations, and Cartesian products in PascalABC.NET using both arrays and sequences.",
    "output": "var a := Arr(1,3,5,7);\na.Permutations.Println;\na.Cartesian(2).Println;\na.Permutations(2).Println;\na.Combinations(2).Println;\nPrintln;\nvar s := Seq(1,3,5,7);\ns.Permutations.Println;\ns.Cartesian(2).Println;\ns.Permutations(2).Println;\ns.Combinations(2).Println;"
  },
  {
    "instruction": "Create a recursive permutation algorithm in PascalABC.NET that generates all permutations of numbers from 1 to n.",
    "output": "const n = 4;\n\nprocedure Perm(a: array of integer; m: integer);\nbegin\n  if m=1 then\n    a.Println;\n  for var i:=0 to m-1 do\n  begin\n    Swap(a[i],a[m-1]);\n    Perm(a,m-1);\n    Swap(a[i],a[m-1]);\n  end;  \nend;\n\nbegin\n  var a := Range(1,n).ToArray;\n  Perm(a,n);\nend."
  },
  {
    "instruction": "Create a procedural variable example in PascalABC.NET that demonstrates assigning different functions to the same procedural variable and calling them.",
    "output": "function add(a,b: integer): integer;\nbegin\n  Result := a + b;\nend;\n\nfunction mult(a,b: integer): integer;\nbegin\n  Result := a * b;\nend;\n\nvar p: function (a,b: integer): integer;\n  \nbegin\n  p := add;\n  writeln('Сумма 2 и 3 равна ',p(2,3));\n  p := mult;\n  writeln('Произведение 2 и 3 равно ',p(2,3));\nend."
  },
  {
    "instruction": "Create a procedure in PascalABC.NET that takes a procedural variable as a parameter to apply operations to array elements. Include examples of multiplication and printing procedures.",
    "output": "procedure for_each(a: array of real; p: procedure(var r: real));\nbegin\n  for var i := 0 to a.Length-1 do\n    p(a[i]);\nend;\n\nprocedure mult2(var r: real);\nbegin\n  r := 2*r\nend;\n\nprocedure print(var r: real);\nbegin\n  write(r,' ');\nend;\n\nvar a: array of real := (1,2,3,6,7);\n\nbegin\n  writeln('Содержимое массива: ');\n  for_each(a,print); \n  writeln;\n  for_each(a,mult2);\n  writeln('Содержимое массива после умножения его элеметов на 2: ');\n  for_each(a,print);\nend."
  },
  {
    "instruction": "Create a simplified version of procedural variable usage in PascalABC.NET with lambda-style procedure definitions for array operations.",
    "output": "procedure for_each(a: array of real; p: procedure(var r: real));\nbegin\n  for var i := 0 to a.Length-1 do\n    p(a[i]);\nend;\n\nprocedure mult2(var r: real) := r := 2*r;\n\nprocedure print(var r: real) := write(r,' ');\n\nvar a: array of real := (1,2,3,6,7);\n\nbegin\n  for_each(a,print); writeln;\n  for_each(a,mult2);\n  for_each(a,print);\nend."
  },
  {
    "instruction": "Show all possible ways to initialize procedural variables in PascalABC.NET using delegates with += and -= operations",
    "output": "// All possible ways to initialize procedural variable\n// Procedural type is implemented through .NET delegates, +=, -= operations are available for it\n\nprocedure pp;\nbegin\n  Println('Call of regular procedure');\nend;\n\ntype \n  A = class\n  private\n    x: integer;\n  public  \n    constructor Create(xx: integer);\n    begin\n      x := xx;\n    end;\n    procedure pp;\n    begin\n      Println('Call of class method, field value equals',x);\n    end;\n    class procedure ppstatic; \n    begin\n      Println('Call of class static method');\n    end;\n  end;\n\nbegin\n  var p: procedure;\n\n  p := pp;\n  var a1: A := new A(5);\n  p += a1.pp;\n  p += A.ppstatic;\n  p;\n  Println;\n  p -= pp;\n  p;\nend."
  },
  {
    "instruction": "Create a 3D point light visualization in PascalABC.NET using Graph3D. Include a sphere as light source, cylinder, and textured ground plane with point lighting.",
    "output": "uses Graph3D;\n\nbegin\n  var p := P3D(-3,3,3);\n  Sphere(p,0.3,Colors.White);\n  View3D.ShowGridLines := false;\n  Cylinder(0,0,0,5,2,True,Colors.Yellow);\n  Rectangle3D(0,0,-0.01,15,15,OrtZ,OrtX,ImageMaterial('трава.jpg',0.2,0.2));\n  Sleep(2000);\n  Lights.AddPointLight(GrayColor(64),p);\nend."
  },
  {
    "instruction": "Create a polynomial root finding example in PascalABC.NET using NumLibABC to find all roots of a polynomial with real coefficients.",
    "output": "uses NumLibABC;\n\nbegin\n  var p:=new Polynom(-609, -283 ,294, -38, -5,1);\n  var oL:=new PolRt(p);\n  if oL.ier=0 then oL.Value.Println\n  else Writeln('Ошибка: ier=',oL.ier);\nend."
  },
  {
    "instruction": "Create polynomial operations examples in PascalABC.NET including polynomial evaluation, integration, and differentiation using NumLibABC.",
    "output": "uses NumLibABC;\n\nbegin\n   var u:=(new Polynom(2, -6, 0, 3.8, 0, 1)).Value(-7.16);\n   Println(u);\n   \n   var t:=new Polynom(1, -7, 12, -3, -2);\n   var (p,q):=(t.PInt, t.PDif);\n   p.PrintlnBeauty; q.PrintlnBeauty;\nend."
  },
  {
    "instruction": "Create polynomial arithmetic examples in PascalABC.NET including addition, subtraction, multiplication, and polynomial division with quotient and remainder.",
    "output": "uses NumLibABC;\n\nbegin\n  var a:=new Polynom(6.5,-4,2.12,1);\n  var b:=new Polynom(3,0,-3.8);\n  var c:=new Polynom(ArrGen(5,i->i*i+1.0));\n      (-c +(a-2*b)*a+11.5*(1-b)).Println;\n  \n  a:=new Polynom(3,0,-72,12,0,-1,2);\n  b:=new Polynom(-1,0,2,1);\n  var (p,q):=a/b;\n  Print('Частное'); p.PrintlnBeauty;\n  Print('остаток'); b.PrintlnBeauty\nend."
  },
  {
    "instruction": "Create an interactive 3D teapot in PascalABC.NET that can be moved using arrow keys for navigation in 3D space.",
    "output": "uses Graph3D;\n\nbegin\n  View3D.Title := 'Двигайте чайник при помощи стрелок';\n  var t := Teapot(0, 0, 1, Colors.Green);\n  OnKeyDown := k -> begin\n    case k of\n   Key.Left: t.X += 1; \n   Key.Right: t.X -= 1; \n   Key.Down: t.Y += 1; \n   Key.Up: t.Y -= 1; \n   Key.PageUp: t.Z += 1; \n   Key.PageDown: t.Z -= 1; \n    end;\n  end;\nend."
  },
  {
    "instruction": "Create a 3D coordinate system visualization in PascalABC.NET with three colored planes (XY, XZ, YZ) and coordinate axes with labels.",
    "output": "uses Graph3D;\n\nbegin\n  View3D.ShowGridLines := False;\n  \n  Camera.Position := P3D(12,16,24);\n  Camera.LookDirection := Camera.Position.Multiply(-1).ToVector3D;\n\n  var sz := 12;\n  var alpha := 100;\n  var planeXZ := Rectangle3D(0,0,0,sz,sz,V3D(0,1,0),Colors.Green.ChangeAlpha(alpha));\n  var planeXY := Rectangle3D(0,0,0,sz,sz,V3D(0,0,1),Colors.Blue.ChangeAlpha(alpha));\n  var planeYZ := Rectangle3D(0,0,0,sz,sz,V3D(1,0,0),V3D(0,1,0),Colors.Red.ChangeAlpha(alpha));\n  BillboardText(sz/2,sz/2,0,'XY',20);\n  BillboardText(0,sz/2,sz/2,'YZ',20);\n  BillboardText(sz/2,0,sz/2,'XZ',20);\n  var len := 8;\n  CoordinateSystem(len,0.3);\n  BillboardText(len+0.5,0,0,'X',20);\n  BillboardText(0,len+0.5,0,'Y',20);\n  BillboardText(0,0,len+0.5,'Z',20);\nend."
  },
  {
    "instruction": "Create a camera rotation animation in PascalABC.NET that orbits around a teapot object with continuous circular camera movement.",
    "output": "uses Graph3D;\n\nbegin\n  Window.Title := 'Вращение камеры';\n  var tp := Teapot(0,0,2,Colors.Green);\n  tp.Scale(2);\n  Camera.Position := P3D(8,16,20);\n  Camera.LookDirection := Camera.Position.Multiply(-1).ToVector3D;\n  var d := 26.0;\n  var t := 0.0;\n  while True do\n  begin\n    Sleep(10);\n    Camera.Position := P3D(15*cos(t),15*sin(t),10);\n    Camera.UpDirection := V3D(0,0,1);\n    Camera.LookDirection := Camera.Position.Multiply(-1).ToVector3D;\n    t += 2*Pi/360/2;\n  end;\n  \n  Camera.LookDirection := Camera.Position.Multiply(-1).ToVector3D;\nend."
  },
  {
    "instruction": "Create a prime number generator in PascalABC.NET that finds and prints large prime numbers starting from a random number.",
    "output": "begin\n  Println('Большие простые числа: ');\n  var count := 0;\n  var beg := Random(1000000000)+2;\n  for var i:=beg to beg+5000 do\n  begin\n    var f := True;\n    var j := 2;\n    var r := Round(Sqrt(i));\n    while f and (j<=r) do\n      if i mod j = 0 then f := False\n        else j += 1;\n    if f then\n    begin\n      Print(i);\n      count += 1;\n      if count mod 8 = 0 then \n        Println;\n    end;\n  end;\nend."
  },
  {
    "instruction": "Show how to use Print procedure for output with space-separated data in PascalABC.NET",
    "output": "/// Output using Print - data is separated by spaces\nbegin\n  Print(1,2,3)\nend."
  },
  {
    "instruction": "Create a 3D group animation in PascalABC.NET where a box and sphere rotate together around a fixed point using Group object.",
    "output": "uses Graph3D;\n\nbegin\n  var b := Box(0,0,0,6,1,2,Colors.Blue);\n  var s := Sphere(0,0,2,1,Colors.Green);\n\n  var g := Group(b,s);\n  g.AnimRotateAt(OrtZ,360,P3D(3,0,0),2).Begin;\nend."
  },
  {
    "instruction": "Create a 3D group animation with multiple objects in PascalABC.NET where an array of boxes rotates together as a group.",
    "output": "uses Graph3D;\n\nbegin\n  var bb := ArrGen(15,i -> Object3D(Box(0.5*i,0,0,0.1,6,2,RandomColor)));\n  var g := Group(bb).MoveByX(-5);\n  g.AnimRotateAt(ortZ,360,P3D(-1,0,0),2).Forever.Begin;  \nend."
  },
  {
    "instruction": "Create a procedure in PascalABC.NET that demonstrates all basic arithmetic operations on two integer parameters.",
    "output": "procedure Operations(a,b: integer);\nbegin\n  writeln(a,' + ',b,' = ',a+b);\n  writeln(a,' - ',b,' = ',a-b);\n  writeln(a,' * ',b,' = ',a*b);\n  writeln(a,' / ',b,' = ',a/b);\n  writeln(a,' div ',b,' = ',a div b);\n  writeln(a,' mod ',b,' = ',a mod b);\nend;\n\nbegin\n  Operations(5,3);\n  writeln;\n  Operations(7,4);\nend."
  },
  {
    "instruction": "Create a procedure in PascalABC.NET that uses var parameters to return both division quotient and modulus results from a single operation.",
    "output": "procedure DivMod(a,b: integer; var d,m: integer);\nbegin\n  d := a div b;\n  m := a mod b;\nend;\n\nvar \n  a,b: integer;\n  d,m: integer;\n\nbegin\n  a := 7;\n  b := 3;\n  DivMod(a,b,d,m);\n  writelnFormat('{0} div {1} = {2};  {0} mod {1} = {3}',a,b,d,m);\n  a := 23;\n  b := 5;\n  DivMod(a,b,d,m);\n  writelnFormat('{0} div {1} = {2};  {0} mod {1} = {3}',a,b,d,m);\nend."
  },
  {
    "instruction": "Create a record type and procedure in PascalABC.NET that demonstrates parameter packing using records for drawing lines between points.",
    "output": "uses GraphABC;\n\ntype \n  Point = record\n    x,y: integer;\n    constructor (xx,yy: integer);\n    begin\n      x := xx;\n      y := yy;\n    end;\n  end;\n\nprocedure Line(p1,p2: Point);\nbegin\n  GraphABC.Line(p1.x,p1.y,p2.x,p2.y);\nend;\n\nbegin\n  var p1 := new Point(10,10);\n  var p2 := new Point(10,210);\n  var p3 := new Point(210,10);\n  Line(p1,p2);\n  Line(p2,p3);\n  Line(p3,p1);\nend."
  },
  {
    "instruction": "Explain how to use automatic variable type inference and variable declaration in a for loop header in PascalABC.NET",
    "output": "// Automatic variable type inference\n// Variable declaration in for loop header\nbegin\n  var x := 2;\n  for var i:=1 to 10 do\n  begin\n    Print(x);\n    x += 2;\n  end;  \nend."
  },
  {
    "instruction": "Implement complex fish ecosystem simulation with predator-prey behavior using GraphABC in PascalABC.NET",
    "output": "uses GraphABC;\n \nconst types = 3;\n      rmax = 4;\n      CanEat = rmax;\n      eps = 0.00001;\n      epsustupi = 0.1;\n      strahkraj = 3;\n      ustupi = CanEat*10;\n      BkColor = clBlack;\n      Height = 600;\n      Width = 780;\n      xmin = 10;\n      ymin = 10;\n      xmax = Width - 100;\n      ymax = Height - 140;\n\nType\nfishtype = class\n           c : color;\n           public\n    CanRazm, MaxKol, Kol, MaxLife, MinFood: integer;\n           Speed, See: real;\n           constructor create(ac:color; aCanRazm, aMaxKol, aMaxLife, aMinFood:integer; aSpeed, aSee: real);\n             begin\n             c:= ac; CanRazm:= aCanRazm; MaxKol:= aMaxKol; Kol:= 1;\n             MaxLife:= aMaxLife; MinFood:= aMinFood; Speed:= aSpeed; See:= aSee\n             end;\n           procedure ShowKol(y: integer);\n             var s: string;\n             begin\n             SetFontColor(c);\n             TextOut(xmax + 20, y, '      ');\n             s := IntToStr(kol);\n             TextOut(xmax + 20, y, s);\n             end;\n           end;\n\nvar opisanie: array[0..types] of fishtype;\n\nType\nfish = class\n       x, y, r, dx0, dy0: real;\n       tip, life, razm, status, food: integer;\n       next, prev: fish;\n       constructor Create(ax, ay, ar: real; atip: integer; aprev, anext: fish);\n         begin\n         x:= ax; y:= ay; r:= ar; tip:= atip; prev:= aprev; next:= anext;\n         life:= 0; razm:= 0; dx0:= random; dy0:= random; status:= 1; food:= 0;\n         end;\n       procedure show;\n         begin\n         SetPenColor(opisanie[tip].c);\n         circle(round(x), round(y), round(r))\n         end;\n       procedure hide;\n         begin\n         SetPenColor(BkColor);\n         circle(round(x), round(y), round(r))\n         end;\n       procedure Destroy;\n         begin\n         hide;\n         opisanie[tip].kol:= opisanie[tip].kol - 1;\n         opisanie[tip].ShowKol(tip*40 + 20);\n         end;\n       procedure moveto(dx, dy: real);\n         begin\n         hide;\n         x:= x + dx; y:= y + dy;\n         if x > xmax then x:= xmax;\n         if x < xmin then x:= xmin;\n         if y > ymax then y:= ymax;\n         if y < ymin then y:= ymin;\n         show\n         end;\n\n       procedure MakeDeti(var mama, StartAkula, KonAkula, StartKilka, KonKilka : fish);\n         var d: fish;\n         begin\n         razm:= 0;\n         food:= 0;\n         d:= fish.create(x, y, r, tip, mama, next);\n         next.prev:= d;\n         next:= d;\n         if mama = KonAkula then KonAkula:= d;\n         if mama = KonKilka then KonKilka:= d;\n         opisanie[tip].kol:= opisanie[tip].kol + 1;\n         opisanie[tip].ShowKol(tip*40 + 20);\n         end;\n\n       procedure step(var ribka, StartAkula, KonAkula, StartKilka, KonKilka : fish);\n         var \n             dx, dy, d, dx2, dy2, dmin: real;\n             t, trup, found: fish;\n             FoundOhot: boolean;\n         begin\n         status:= 1;\n         dx:= 0; dy:= 0;\n         if tip > 0 then\n           begin\n           t:= StartAkula;\n           if t<>nil then\n             repeat\n             d:= sqrt((x - t.x)*(x - t.x) + (y - t.y)*(y - t.y));\n             if d < opisanie[tip].See then\n               begin\n               if d < eps then d:= eps;\n               dx2:= (x - t.x)/(d*d);\n               dy2:= (y - t.y)/(d*d);\n               dx:= dx + dx2;\n               dy:= dy + dy2;\n               status:= 2;\n               end;\n             t:= t.next\n             until t = KonAkula.next;\n           if x - xmin < opisanie[tip].See then dx:= dx + 1/((x - xmin + eps)*strahkraj);\n           if xmax - x < opisanie[tip].See then dx:= dx + 1/((x - xmax - eps)*strahkraj);\n           if y - ymin < opisanie[tip].See then dy:= dy + 1/((y - ymin + eps)*strahkraj);\n           if ymax - y < opisanie[tip].See then dy:= dy + 1/((y - ymax - eps)*strahkraj);\n           d:= sqrt(dx*dx + dy*dy);\n           if d < eps then\n             begin\n             dx:= 2*status*random()*opisanie[tip].Speed - status*opisanie[tip].Speed;\n             dy:= 2*status*random()*opisanie[tip].Speed - status*opisanie[tip].Speed\n             end\n                      else\n             begin\n             dx:= status*opisanie[tip].Speed*dx/d;\n             dy:= status*opisanie[tip].Speed*dy/d\n             end\n           end\n                     else\n           begin\n           dmin:= 11000;\n           t:= StartAkula;\n           while t<>ribka do\n             begin\n             d:= sqrt((x - t.x)*(x - t.x) + (y - t.y)*(y - t.y));\n             if (d < dmin) and (abs(dx0 - t.dx0) < epsustupi) and\n                (abs(dy0 - t.dy0) < epsustupi) then dmin:= d;\n             t:= t.next\n             end;\n           FoundOhot:= dmin < ustupi;\n           dmin:= 11000;\n           found:= nil;\n           t:= StartKilka;\n           if (t<>nil) and (life > 100) and not FoundOhot then\n             repeat\n             d:= sqrt((x - t.x)*(x - t.x) + (y - t.y)*(y - t.y));\n             if d < dmin then\n               begin\n               dmin:= d;\n               found:= t\n               end;\n             t:= t.next\n             until t = KonKilka.next;\n           if (found <> nil) and (dmin < opisanie[tip].See) then\n             begin\n             status:= 2;\n             dx:= found.x - x;\n             dy:= found.y - y;\n             if dmin < CanEat + status*opisanie[tip].Speed then\n               begin\n               found.next.prev:= found.prev;\n               found.prev.next:= found.next;\n               if found = StartKilka then\n                 StartKilka:= StartKilka.next;\n               if found = KonKilka then\n                 KonKilka:= KonKilka.prev;\n               found.destroy;\n        found := nil;\n               food:= food + 1\n               end\n             end\n                           else\n             if (x <= xmin) or (x >= xmax) or (y <= ymin) or (y >= ymax) then\n               begin\n               dx:= 2*status*random()*opisanie[tip].Speed - status*opisanie[tip].Speed;\n               dy:= 2*status*random()*opisanie[tip].Speed - status*opisanie[tip].Speed\n               end\n                                                                         else\n               begin\n               dx:= dx0; dy:= dy0\n               end;\n           d:= sqrt(dx*dx + dy*dy);\n           if d > eps then\n             begin\n             dx:= status*opisanie[tip].Speed*dx/d;\n             dy:= status*opisanie[tip].Speed*dy/d;\n             end\n           end;\n         moveto(dx, dy);\n         dx0:= dx; dy0:= dy;\n         life:= life + 1; razm:= razm + 1;\n         if opisanie[tip].Kol >= opisanie[tip].MaxKol then Razm:= 0;\n         if (razm > opisanie[tip].CanRazm) and (food >= opisanie[tip].minfood) then\n           MakeDeti(ribka, StartAkula, KonAkula, StartKilka, KonKilka);\n           if life > opisanie[tip].MaxLife then\n             begin\n             trup:= ribka; ribka:= ribka.prev;\n             trup.next.prev:= trup.prev;\n             trup.prev.next:= trup.next;\n             if trup = StartKilka then\n               StartKilka:= StartKilka.next;\n             if trup = KonKilka then\n               KonKilka:= KonKilka.prev;\n             if trup = StartAkula then\n               StartAkula:= StartAkula.next;\n             if trup = KonAkula then\n               KonAkula:= KonAkula.prev;\n             if trup = trup.next then ribka:= nil;\n             if trup <> nil then \n             trup.destroy;\n        trup := nil;\n             end\n         end;\n       end;\n\nfunction getAllCount:integer;\nvar i,c:integer;\nbegin\n  c:=0;\n  for i:=0 to types do\n    c:=c+opisanie[i].Kol;\n  getAllCount:=c;\nend;\n\nvar i: integer;\n    p, q, StartAkula, StartKilka, KonAkula, KonKilka, tek: fish;\n\nbegin\n  SetSmoothing(False);\n  SetWindowSize(Width, Height);\n  SetWindowLeft(200);\n  SetWindowTop(50);\n  SetWindowCaption('Battle for Life');\n  SetFontSize(7);\n  SetFontName('Arial');\n  SetBrushColor(BkColor);\n  FillRectangle(0, 0, Width, Height);\n  SetFontColor(clWhite);\n  TextOut(10, ymax + 20, 'Author: Ivanov S.O.          e-mail: ssyy@yandex.ru');\n  TextOut(10, ymax + 20+1*18, 'Program simulates behavior of several fish schools. Right - current fish counts');\n  TextOut(10, ymax + 20+2*18, 'By changing parameters in code, you can influence battle outcome.');\n  TextOut(10, ymax + 20+3*18, 'Default: red - predators, eat any fish from other schools, do not breed');\n  TextOut(10, ymax + 20+4*18, 'until they eat; blue - prey, slowest but breed fastest; green - prey');\n  TextOut(10, ymax + 20+5*18, 'faster than blue but breed slower; yellow - fastest among prey but few.');\n  SetFontSize(12);\n  StartAkula:= nil;\n  StartKilka:= nil;\n  KonAkula:= nil;\n  KonKilka:= nil;\n  \n  opisanie[3]:= fishtype.create(clYellow, 300,     15,     1500,    -1,      0.99,    50);\n  opisanie[2]:= fishtype.create(clGreen,  150,     50,     1500,    -1,      0.9,     50);\n  opisanie[1]:= fishtype.create(clBlue,   30,      50,     500,     -1,      0.7,     35);\n  opisanie[0]:= fishtype.create(clRed,    1000,    40,     5000,     1,       1,     500);\n  SetPenColor(clWhite);\n  rectangle(round(xmin - rmax - 1), round(ymin - rmax - 1),\n            round(xmax + rmax + 1), round(ymax + rmax + 1));\n  q:= fish.create(xmin + 10, ymax - 10, rmax, 0, nil, nil);\n  p:= fish.create(xmin + 10, ymin + 10, rmax, 1, q, q);\n  q.next:= p; q.prev:= p;\n  StartAkula:= q; KonAkula:= q;\n  StartKilka:= p; KonKilka:= p;\n  p:= fish.create(xmax - 10, ymin + 10, rmax, 2, KonKilka, StartAkula);\n  StartAkula.prev:= p;\n  KonKilka.next:= p; KonKilka:= p;\n  p:= fish.create(xmax - 10, ymax - 10, rmax, 3, KonKilka, StartAkula);\n  StartAkula.prev:= p;\n  KonKilka.next:= p; KonKilka:= p;\n  for i:= 0 to types do opisanie[i].ShowKol(i*40 + 20);\n  tek:= StartKilka;\n  repeat\n   tek:= tek.next;\n   tek.step(tek, StartAkula, KonAkula, StartKilka, KonKilka);\n  until (tek = nil);\nend."
  },
  {
    "instruction": "Implement performance benchmarking using Utils module in PascalABC.NET",
    "output": "uses Utils;\n\nprocedure Test1;\nbegin\n  var n := 1000000;\n  var s := 0.0;\n  for var i:=1 to n do\n    s += Sin(i);\nend;\n\nbegin\n  Benchmark(Test1).Println;\n\n  var n := 100000000;\n  var Sq := ArrRandomInteger(n,0,MaxInt-1);\n  Benchmark(()->\n  begin\n    var Min := Sq.Min;\n  end,1).Println;\nend."
  },
  {
    "instruction": "Demonstrate BigInteger literals and calculations in PascalABC.NET",
    "output": "begin\n  Println(25bi ** 25 + 17bi ** 17);\n  \n  var p := 1bi;\n  for var i:=2 to 50 do\n    p *= i;\n  Println($'50! = {p}');  \nend."
  },
  {
    "instruction": "Calculate factorial of 100 using BigInteger in PascalABC.NET",
    "output": "begin\n  var n := 100;\n  var f: BigInteger := 1;\n  for var i:=2 to n do\n    f := f * i;\n  Print($'{n}! = {f}');\nend."
  },
  {
    "instruction": "Use Sum, Average and Product methods with BigInteger sequences in PascalABC.NET",
    "output": "begin\n  var s := SeqGen(10,i->BigInteger(i)**i);\n  Print(s.Sum,s.Product,s.Average);\nend."
  },
  {
    "instruction": "Implement ball reflection simulation in console mode using CRT module in PascalABC.NET",
    "output": "uses CRT;\n\nconst \n  w = 80; \n  h = 24;\n\nvar\n  ax,ay: integer;\n  vx,vy: integer;\n  a: array [1..w,1..h] of char;\n\nprocedure CleanA;\nbegin\n  for var j := 1 to h do\n  for var i := 1 to w do\n    A[i,j] := ' '\nend;\n\nprocedure HorizWall(x,y,L: integer);\nbegin\n  for var i := x to x+L-1 do\n    A[i,y] := '*'\nend;\n\nprocedure VertWall(x,y,L: integer);\nbegin\n  for var j := y to y+L-1 do\n    A[x,j] := '*'\nend;\n\nprocedure Fill;\nbegin\n  CleanA;\n  HorizWall(1,1,w);\n  HorizWall(1,h,w);\n  VertWall(1,1,h);\n  VertWall(w,1,h);\n  HorizWall(49,9,31);\n  HorizWall(49,14,31);\nend;\n\nprocedure DrawScreen;\nbegin\n  TextColor(White);\n  ClrScr;\n  for var j := 1 to h do\n  for var i := 1 to w do\n    write(A[i,j])\nend;\n\nfunction FilledInFront: boolean;\nbegin\n  Result := (A[ax+vx,ay]<>' ') or (A[ax,ay+vy]<>' ') or (A[ax+vx,ay+vy]<>' ')\nend;\n\nprocedure ChangeDirection;\nbegin\n  if A[ax+vx,ay]<>' ' then \n    vx := -vx;\n  if A[ax,ay+vy]<>' ' then \n    vy := -vy;\n  if (A[ax+vx,ay]=' ') and (A[ax,ay+vy]=' ') and (A[ax+vx,ay+vy]<>' ') then\n  begin\n    vx := -vx;\n    vy := -vy\n  end;\n  Sleep(10);\nend;\n\nprocedure ShowBall;\nbegin\n  GotoXY(ax,ay);\n  write('B');\nend;\n\nprocedure HideBall;\nbegin\n  GotoXY(ax,ay);\n  write(' ');\nend;\n\nprocedure SetBallCoords(x,y: integer);\nbegin\n  ax := x;\n  ay := y\nend;\n\nprocedure SetBallVeloc(vx0,vy0: integer);\nbegin\n  vx := vx0;\n  vy := vy0\nend;\n\nprocedure MoveTo(x,y: integer);\nbegin\n  HideBall;\n  SetBallCoords(x,y);\n  ShowBall\nend;\n\nprocedure MoveBy(dx,dy: integer);\nbegin\n  MoveTo(ax+dx,ay+dy);\nend;\n\nBEGIN\n  SetWindowTitle('Billiard (CRT nostalgia)');\n  HideCursor;\n  Fill;\n  DrawScreen;\n  SetBallCoords(70,13);\n  SetBallVeloc(1,1);\n  TextColor(Yellow);\n  ShowBall;\n  repeat\n    Delay(20);\n    if FilledInFront then \n      ChangeDirection;\n    MoveBy(vx,vy);\n  until KeyPressed;\nEND."
  },
  {
    "instruction": "Implement bisection method for root finding in PascalABC.NET",
    "output": "function f(x: real) := exp(x) - 4;\n\nfunction BisectionMethod(a, b, eps: real): real;\nbegin\n  var fa := f(a);\n  while abs(b - a) > eps do\n  begin\n    var c := (a + b) / 2;\n    var fc := f(c);\n    if fc = 0 then\n      break;\n    if fa * fc < 0 then\n      b := c\n    else\n      (a, fa) := (c, fc);\n  end;\n  Result := (a + b) / 2;\nend;\n\nbegin\n  var (a, b) := (0.0, 3.0);\n  var eps := 0.000001;\n  var root := BisectionMethod(a, b, eps);\n  Println('Equation root:', root);\nend."
  },
  {
    "instruction": "Show how to swap values of two variables using a temporary variable in PascalABC.NET",
    "output": "// Swapping values of two variables using a third variable\n\nbegin\n  var (x,y) := ReadReal2('Enter x,y:');\n  \n  var v := x; // auxiliary variable\n  x := y;\n  y := v;\n  \n  Println($'New values x,y: {x} {y}');\nend."
  },
  {
    "instruction": "Compare performance of block variables vs global variables in PascalABC.NET",
    "output": "begin\n  var s := 0.0;\n  var i: real := 1;\n  while i<1000000000 do\n  begin\n    s += 1/i;\n    i += 1;\n  end;  \n  writeln(s);\n  writeln('Calculation time = ',Milliseconds/1000,' s');\nend."
  },
  {
    "instruction": "Implement word game with letter boards and word validation in PascalABC.NET using GraphABC",
    "output": "uses GraphABC,ABCObjects,ABCButtons;\n\nconst \n  freqcharstr='аааааааааааааааааааааааааабббббввввввввггггдддддддееееееееееееееееееееежжззззииииииииииииииииииийккккккккккккккклллллллллллммммммнннннннннннннннннооооооооооооооооооооооооппппппппрррррррррррррррррссссссссссссстттттттттттттттууууууффххцццчччшшщыыьььььэюяяяя';\n\nconst\n  MaxWordLen = 12;\n  scorehits: array [1..MaxWordLen] of integer = (0,1,2,4,7,11,16,22,29,37,46,56);\n\ntype \n  MySquareABC = class(SquareABC) end;\n\nvar\n  MainBoard: ObjectBoardABC;\n  WordBoard: ObjectBoardABC;\n  cur: integer;\n  moves: integer;\n  score: integer;\n  Status: RectangleABC;\n\nfunction WordExists(s: string): boolean;\nvar\n  f: text;\n  str: string;\nbegin\n  s := LowerCase(s);\n  Result := False;\n  assign(f,'words.txt');\n  reset(f);\n  while not eof(f) do\n  begin\n    readln(f,str);\n    if s=str then\n    begin\n      Result := True;\n      break;\n    end;\n  end;\n  close(f);\nend;\n\nprocedure MyMouseDown(x,y,mb: integer);\nbegin\n  if mb=1 then\n  begin\n    if cur>WordBoard.DimX then\n      exit;\n    var ob := ObjectUnderPoint(x,y);\n    if (ob is MySquareABC) and ob.Visible then\n    begin\n      var ob1 := WordBoard[cur,1];\n      ob1.Visible := True;\n      ob1.Text := ob.Text;\n      Inc(cur);\n      ob.Visible := False;\n      var s := '';\n      for var i:=1 to cur-1 do\n        s := s + WordBoard[i,1].Text;\n      if WordExists(s) then\n        WordBoard.Color := clYellow\n      else WordBoard.Color := clSkyBlue\n    end;\n  end\n  else\n  begin\n    for var xx:=1 to cur-1 do\n      WordBoard[xx,1].Visible := False;\n    for var xx:=1 to MainBoard.DimX do\n    for var yy:=1 to MainBoard.DimY do\n      MainBoard[xx,yy].Visible:=True;\n    cur := 1;\n    WordBoard.Color := clSkyBlue\n  end;\nend;\n\nprocedure BtNewClick;\nbegin\n  score := 0;\n  moves := 0;\n  Status.Text := 'Moves: '+IntToStr(moves)+'   Score: '+IntToStr(score);\n  MyMouseDown(1,1,2);\n  for var xx:=1 to MainBoard.DimX do\n  for var yy:=1 to MainBoard.DimY do\n    MainBoard[xx,yy].Text := UpCase(freqcharstr[Random(255)+1]);\nend;\n\nprocedure BtWordClick;\nbegin\n  if WordBoard.Color<>clYellow then\n    exit;\n  Inc(score,scorehits[cur-1]);\n  Inc(moves);\n  for var xx:=1 to cur-1 do\n    WordBoard[xx,1].Visible:=False;\n  for var xx:=1 to MainBoard.DimX do\n  for var yy:=1 to MainBoard.DimY do\n    if not MainBoard[xx,yy].Visible then\n    begin\n      MainBoard[xx,yy].Visible:=True;\n      MainBoard[xx,yy].Text:=UpCase(freqcharstr[Random(255)+1]);\n    end;\n  cur := 1;\n  WordBoard.Color := clSkyBlue;\n  Status.Text := 'Moves: '+IntToStr(moves)+'   Score: '+IntToStr(score);\nend;\n\nprocedure BtPleaseClick;\nvar\n  f: text;\n  str,maxstr: string;\n  arr,work: array ['а'..'я'] of integer;\n  maxlen: integer;\n\n  function CanConstructWord(s: string): boolean;\n  begin\n    work := arr;\n    Result := True;\n    for var i:=1 to Length(s) do\n    begin\n      Dec(work[s[i]]);\n      if work[s[i]]<0 then\n      begin\n        Result := False;\n        break;\n      end;\n    end;\n  end;\n\nbegin\n  maxlen := 0;\n  maxstr := '';\n  for var c:='а' to 'я' do\n    arr[c]:=0;\n  for var xx:=1 to MainBoard.DimX do\n  for var yy:=1 to MainBoard.DimY do\n    Inc(arr[LowCase(MainBoard[xx,yy].Text[1])]);\n  assign(f,'words.txt');\n  reset(f);\n  while not eof(f) do\n  begin\n    readln(f,str);\n    if CanConstructWord(str) and (Length(str)>maxlen) and (Length(str)<=MaxWordLen) then\n    begin\n      maxlen := Length(str);\n      maxstr := str;\n    end;\n  end;\n  close(f);\n  writeln(maxstr);\nend;\n\nprocedure InitWindow;\nbegin\n  SetWindowSize(640,480);\n  Window.IsFixedSize := True;\n  Window.Title := 'Know Russian Words!';\n  Brush.Color := clMoneyGreen;\n  FillRect(0,0,WindowWidth,WindowHeight);\nend;\n\nprocedure InitGameVars;\nbegin\n  cur := 1;\n  moves := 0;\n  score := 0;\nend;\n\nprocedure InitButtons;\nbegin\n  var btword := new ButtonABC(70,410,180,30,'Say Word',clGray);\n  var btnew := new ButtonABC(280,410,100,30,'New Game',clLightGray);\n  var btplease := new ButtonABC(410,410,160,30,'Hint',clGray);\n  btword.OnClick := BtWordClick;\n  btnew.OnClick := BtNewClick;\n  btplease.OnClick := BtPleaseClick;\nend;\n\nprocedure InitInterface;\nbegin\n  Status := new RectangleABC(70,350,500,30,clSkyBlue);\n  Status.Text := 'Moves: 0   Score: 0';\n  WordBoard := new ObjectBoardABC(20,40,MaxWordLen,1,50,50,clSkyBlue);\n  MainBoard := new ObjectBoardABC(220,120,4,4,50,50,clMoneyGreen);\n  MainBoard.BorderColor := clGreen;\n  for var x:=1 to WordBoard.DimX do\n  begin\n    WordBoard[x,1] := new SquareABC(0,0,WordBoard.CellSizeX-6,clWhite);\n    WordBoard[x,1].Visible := False;\n  end;\n  for var x:=1 to MainBoard.DimX do\n  for var y:=1 to MainBoard.DimY do\n  begin\n    MainBoard[x,y] := new MySquareABC(0,0,MainBoard.CellSizeX-6,clWhite);\n    MainBoard[x,y].Text := UpCase(freqcharstr[Random(freqcharstr.Length)+1]);\n  end;\nend;\n\nbegin\n  SetConsoleIO;\n  InitWindow;\n  InitGameVars;\n  InitInterface;\n  InitButtons;\n  OnMouseDown := MyMouseDown;\nend."
  },
  {
    "instruction": "Demonstrate boolean type and logical expressions with and, or, not operators in PascalABC.NET",
    "output": "// Boolean type. Logical expressions with and, or and not\n\nbegin\n  var x: integer := ReadInteger('Enter x (from 1 to 9):');\n  var b: boolean := x=5;\n  Println('x=5?',b);\n  b := (x>=3) and (x<=5);\n  Println('x=3,4 or 5?',b);\n  b := (x=3) or (x=4) or (x=5);\n  Println('x=3,4 or 5?',b);\n  b := not Odd(x);\n  Println('x - even?',b);\nend."
  },
  {
    "instruction": "Explain boxing and unboxing of value types in PascalABC.NET with exception handling",
    "output": "// Boxing-unboxing of value types\nvar \n  i: integer := 2;\n  r: real := 3.14;\n  o: object;\n\nbegin\n  o := i; // Boxing: object of value type integer is boxed into object of reference type, \n          // which is assigned to variable o\n          // Type conversion during boxing - implicit\n  Println(integer(o)); // Unboxing: value is extracted from boxed object        \n                       // Type conversion during unboxing - explicit\n  o := r;\n  Println(real(o));\n  \n  try // When type conversion is incorrect, InvalidCastException is generated\n    Println(shortint(o));\n  except\n    on e: Exception do\n      Println(e.GetType);\n  end;\nend."
  },
  {
    "instruction": "Demonstrate function caching using Cache attribute in PascalABC.NET",
    "output": "[Cache]\nfunction fib(n: integer): integer := \n  if n in 1..2 then 1 \n  else fib(n-1) + fib(n-2);\n\nfunction fib1(n: integer): integer := \n  if n in 1..2 then 1 \n  else fib1(n-1) + fib1(n-2);\n  \nbegin\n  Println(fib(42),MillisecondsDelta/1000);\n  Println(fib1(42),MillisecondsDelta/1000);\nend."
  },
  {
    "instruction": "Create integral calculator with GUI using FormsABC in PascalABC.NET",
    "output": "uses FormsABC;\n\ntype Fun = function (x: real): real;\n  \nvar funs: array of Fun := (sin,cos,sqr);\n\nfunction CalcIntegral(a,b: real; N: integer; f: Fun): real;\nbegin\n  Result := 0;\n  var x := a;\n  var h := (b-a)/N;\n  for var i:=0 to N-1 do\n  begin\n    Result += f(x);\n    x += h;\n  end;\n  Result *= h;\nend;\n\nvar \n  a := new RealField('a:');\n  f1 := new FlowBreak;\n  b := new RealField('b:');\n  f2 := new FlowBreak;\n  N := new IntegerField('N:');\n  f3 := new FlowBreak;\n  tl := new TextLabel('Function: ');\n  f4 := new FlowBreak;\n  cb := new ComboBox;\n  f5 := new FlowBreak(50);\n  s1 := new Space(20);\n  ok := new Button('Calculate');\n  tb: TextBox;\n\nprocedure MyClick;\nbegin\n  var f := funs[cb.SelectedIndex];\n  var res := CalcIntegral(a.Value,b.Value,N.Value,f);\n  tb.AddLine(Format('Integral({0},{1},{2},{3}) = {4}',a.Value,b.Value,N.Value,cb.SelectedValue,res.ToString));\nend;\n\nprocedure InitControls;\nbegin\n  MainForm.Title := 'Definite Integral Calculation';\n  MainForm.SetSize(500,350);\n  MainForm.CenterOnScreen;\n  b.Value := 1;\n  N.Value := 10;\n  cb.Items.Add('sin');\n  cb.Items.Add('cos');\n  cb.Items.Add('x^2');\n  cb.SelectedIndex := 0;\n  ok.Click += MyClick;\n  mainPanel.Dock := DockStyle.Left;\n  mainPanel.Width := 150;\n  ParentControl := MainForm;\n  tb := new TextBox;\n  tb.Dock := DockStyle.Fill;\nend;\n\nbegin\n  InitControls;\nend."
  },
  {
    "instruction": "Show different ways to perform calculations and output results in PascalABC.NET using constants and direct values",
    "output": "// Output of calculation results\nbegin\n  Println('Calculations:');\n// Output empty string\n  Println;\n  Println('121 + 363 =',121+363);\n  Println('121 - 363 =',121-363);\n  Println('121 * 363 =',121*363);\n  Println('121 / 363 =',121/363);\nend.\n\n// Output of calculation results. Named constants are used\nconst \n  a = 121;\n  b = 363;\n\nbegin\n  Println('Calculations:');\n  Println;\n  Println(a,'+',b,'=',a+b);\n  Println(a,'-',b,'=',a-b);\n  Println(a,'*',b,'=',a*b);\n  Println(a,'/',b,'=',a/b);\nend."
  },
  {
    "instruction": "Show how to use assignment operators += -= *= /= in PascalABC.NET",
    "output": "// Assignments += -= *= /=\n\nbegin\n  var i: integer := 1;\n  Println('i := 1; i = ',i);\n  i += 2; // Increase by 2\n  Println('i += 2; i = ',i);\n  i *= 3; // Multiply by 3\n  Println('i *= 3; i = ',i);\n  Println;\n  var r: real := 6;\n  Println('r := 6; r = ',r);\n  r /= 2;\n  Println('r /= 2; r = ',r);\nend."
  },
  {
    "instruction": "Explain how to use interpolated strings with formatting options in PascalABC.NET",
    "output": "/// Using interpolated strings\nbegin\n  var Pi := 3.1415;\n  // Setting output field width\n  Println($'{Pi,10:f}');\n  // Left alignment in output field\n  Println($'{Pi,-10:f}|');\n  // Setting number of decimal places for real number\n  Println($'{Pi:f3}');\n  // Output curly braces\n  Println($'{{}}Output curly braces in interpolated string {Pi}');\nend."
  },
  {
    "instruction": "Create auto class Point with methods and implicit conversion in PascalABC.NET",
    "output": "type \n  Point = auto class\n    x,y: integer;\n    procedure MoveBy(dx,dy: integer) := (x,y) := (x+dx,y+dy);\n    function Distance(p: Point) := sqrt(sqr(x-p.x)+sqr(y-p.y));\n    class function operator implicit(t: (integer,integer)): Point := new Point(t[0],t[1]);\n  end;\n  \nbegin\n  var p: Point;\n  p := (2,3);\n  Println(p);\nend."
  },
  {
    "instruction": "Create a non-recursive solution to the 8 queens problem in PascalABC.NET using LINQ-style operations with permutations and combinations to find valid queen placements.",
    "output": "## (1..8).Permutations\n.Where(v->v.Numerate.Combinations(2)\n       .All(\\(\\(a,b),\\(c,d)) -> abs(a-c)<>abs(b-d)))\n.PrintLines"
  },
  {
    "instruction": "Create a type compatibility matrix in PascalABC.NET that shows the result types of ternary conditional operations between different numeric types including shortint, byte, smallint, word, integer, longword, int64, uint64, BigInteger, single, real, and decimal.",
    "output": "begin\n  var i0: shortint;\n  var i1: byte;\n  var i2: smallint;\n  var i3: word;\n  var i4: integer;\n  var i5: longword;\n  var i6: int64;\n  var i7: uint64;\n  var i8: BigInteger;\n  var i9: single;\n  var ia: real;\n  var ib: decimal;\n  \n  var n := 12;\n  \n  var b := new string[12,12];\n  \n  b[0,0] := (True ? i0 : i0).GetType.ToString.Substring(7).ToWords('.').Last.PadLeft(n);\n  b[0,1] := (True ? i0 : i1).GetType.ToString.Substring(7).ToWords('.').Last.PadLeft(n);\n  b[0,2] := (True ? i0 : i2).GetType.ToString.Substring(7).ToWords('.').Last.PadLeft(n);\n  b[0,3] := (True ? i0 : i3).GetType.ToString.Substring(7).ToWords('.').Last.PadLeft(n);\n  b[0,4] := (True ? i0 : i4).GetType.ToString.Substring(7).ToWords('.').Last.PadLeft(n);\n  b[0,5] := (True ? i0 : i5).GetType.ToString.Substring(7).ToWords('.').Last.PadLeft(n);\n  b[0,6] := (True ? i0 : i6).GetType.ToString.Substring(7).ToWords('.').Last.PadLeft(n);\n  b[0,7] := (True ? i0 : i7).GetType.ToString.Substring(7).ToWords('.').Last.PadLeft(n);\n  b[0,8] := (True ? i0 : i8).GetType.ToString.Substring(7).ToWords('.').Last.PadLeft(n);\n  b[0,9] := (True ? i0 : i9).GetType.ToString.Substring(7).ToWords('.').Last.PadLeft(n);\n  b[0,10] := (True ? i0 : ia).GetType.ToString.Substring(7).ToWords('.').Last.PadLeft(n);\n  b[0,11] := (True ? i0 : ib).GetType.ToString.Substring(7).ToWords('.').Last.PadLeft(n);\n  b.Println(8);\nend."
  },
  {
    "instruction": "Implement the QuickSort algorithm in PascalABC.NET using the classic Hoare partitioning method with recursive sorting of subarrays.",
    "output": "function Partition(a: array of integer; l,r: integer): integer;\nbegin\n  var i := l - 1;\n  var j := r + 1;\n  var x := a[l];\n  while True do\n  begin\n    repeat\n      i += 1;\n    until a[i]>=x;\n    repeat\n      j -= 1;\n    until a[j]<=x;\n    if i<j then \n      Swap(a[i],a[j])\n    else \n    begin\n      Result := j;\n      exit;\n    end;\n  end;\nend;\n  \nprocedure QuickSort(a: array of integer; l,r: integer);\nbegin\n  if l>=r then exit;\n  var j := Partition(a,l,r);\n  QuickSort(a,l,j);\n  QuickSort(a,j+1,r);\nend;\n\nconst n = 20;\n\nbegin\n  var a := ArrRandom(n);\n  Println('До сортировки: ');\n  Println(a);\n  QuickSort(a,0,a.Length-1);\n  Println('После сортировки: ');\n  Println(a);\nend."
  },
  {
    "instruction": "Create a functional-style QuickSort implementation in PascalABC.NET using array slicing and filtering operations for educational purposes.",
    "output": "function QS(a: array of integer): array of integer := \n  if a.Length < 2 then \n    a\n  else \n    QS(a[1:].FindAll(y->y<=a[0])) + a[:1] + QS(a[1:].FindAll(y->y>a[0]));\n\nbegin\n  var a := ArrRandom(20);\n  a.Println;\n  var b := QS(a);\n  b.Println;\nend."
  },
  {
    "instruction": "Create a LINQ-style QuickSort implementation in PascalABC.NET using sequence operations with Where, Skip, and First methods.",
    "output": "function QuickSort(a: sequence of integer): sequence of integer;\nbegin\n  if a.Count = 0 then\n    Result := a\n  else \n  begin\n    var head := a.First();\n    var tail := a.Skip(1);\n    Result := QuickSort(tail.Where(x->x<=head)) + \n              head + \n              QuickSort(tail.Where(x->x>head));\n  end;\nend; \n\nbegin\n  var a := ArrRandom(20);\n  a.Println;\n  QuickSort(a).Println;\nend."
  },
  {
    "instruction": "Solve the N-Queens problem in PascalABC.NET using backtracking with recursive placement and safety checking for diagonal conflicts.",
    "output": "function IsSafe(board: array of integer; row, col: integer): boolean;\nbegin\n  Result := True;\n  for var i := 0 to row - 1 do\n    if (board[i] = col) or\n       (board[i] - i = col - row) or\n       (board[i] + i = col + row) then\n    begin\n      Result := False;\n      exit; \n    end;\nend;\n\nprocedure SolveNQueens(board: array of integer; row: integer);\nbegin\n  if row = 8 then\n    board.Println\n  else\n    for var col := 0 to 7 do\n      if IsSafe(board, row, col) then\n      begin\n        board[row] := col;\n        SolveNQueens(board, row + 1);\n      end;\nend;\n\nbegin\n  var board := [0] * 8; \n  SolveNQueens(board, 0);\nend."
  },
  {
    "instruction": "Create a raindrop ripple animation in PascalABC.NET using GraphABC that simulates expanding circles from random drop positions.",
    "output": "uses GraphABC;\n\nconst speed = 2;\n\nprocedure Kaplia(x0,y0: integer);\nbegin\n  var r := 1;\n  for var i:=0 to 63 do\n  begin\n    Pen.Color := RGB(i*4,i*4,i*4);\n    Circle(x0,y0,r);\n    if i mod speed = 0 then Sleep(10);\n    Pen.Color := clWhite;\n    Circle(x0,y0,r);\n    r += 2;    \n  end;\nend;\n\nconst z=50;\n\nbegin\n  Window.Title := 'Капли дождя';\n  SetWindowSize(800,600);\n  while True do\n    Kaplia(Random(z,WindowWidth-z),Random(z,WindowHeight-z));\nend."
  },
  {
    "instruction": "Show random number generation and dice throwing simulation in PascalABC.NET",
    "output": "// Random number generation\n\nbegin\n  var i := Random(100);\n  Println('Random integer in range 0..99:', i);\n  i := Random(2,5);\n  Println('Random integer in range 2..5:', i);\n  var r := Random;\n  Println('Random real in range [0,1):', r);\nend.\n\n// Dice throwing\n\nbegin\n  var (k1,k2) := Random2(1,6);\n  Println($'Dice points: {k1} {k2}');\n  Println($'Sum of points: {k1+k2}');\nend."
  },
  {
    "instruction": "Generate random numbers in specific ranges in PascalABC.NET including integers, reals, and characters using range syntax.",
    "output": "begin\n  Random(1..9).Println;\n  Random(1.0..2.0).Println;\n  Random('a'..'z').Println;\nend."
  },
  {
    "instruction": "Create a vector record type Vec3 in PascalABC.NET with arithmetic operators, normalization, and cross product for 3D graphics applications.",
    "output": "type\n  Vec3 = record\n    x, y, z: real;\n    class function operator+(v1, v2: Vec3): Vec3 := new Vec3(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);\n    class function operator-(v1, v2: Vec3): Vec3 := new Vec3(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);\n    class function operator-(v: Vec3): Vec3 := new Vec3(-v.x, -v.y, -v.z);\n    class function operator*(v: Vec3; r: real): Vec3 := new Vec3(v.x * r, v.y * r, v.z * r);\n    class function operator/(v: Vec3; r: real): Vec3 := new Vec3(v.x / r, v.y / r, v.z / r);\n    class function operator*(r: real; v: Vec3): Vec3 := new Vec3(v.x * r, v.y * r, v.z * r);\n    class function operator*(v1, v2: Vec3): real := v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n    function norm := Sqrt(x * x + y * y + z * z);\n    function normalize(l: real := 1): Vec3 := Self/norm;\n    function cross(v: Vec3): Vec3 := new Vec3(y * v.z - z * v.y, z * v.x - x * v.z, x * v.y - y * v.x);\n    constructor(xx,yy,zz: real); begin x := xx; y := yy; z := zz end;\n  end;"
  },
  {
    "instruction": "Create a sphere-ray intersection function in PascalABC.NET for ray tracing that calculates if and where a ray intersects a sphere.",
    "output": "type\n  TSphere = auto class \n    center: vec3;\n    radius: real;\n    material: TMaterial;\n    function RayIntersect(orig, dir: vec3; var t0: real): boolean;\n    begin\n      var L := center - orig;\n      var tca := L * dir;\n      var d2 := L * L - tca * tca;\n      if d2 > radius * radius then\n        begin Result := false; exit end;\n      var thc := Sqrt(radius * radius - d2);\n      t0 := tca - thc;\n      if t0 < 1e-3 then\n        t0 := tca + thc;\n      if t0 < 1e-3 then\n        Result := false\n      else Result := true;\n    end;\n  end;"
  },
  {
    "instruction": "Create a reflection function in PascalABC.NET for ray tracing that calculates the reflection direction of a vector off a surface normal.",
    "output": "function Reflect(I, N: vec3) := I - N * 2 * (I * N);"
  },
  {
    "instruction": "Create a refraction function in PascalABC.NET for ray tracing using Snell's law to calculate the refracted ray direction.",
    "output": "function Refract(I, N: vec3; eta_t: real; eta_i: real := 1): vec3;\nbegin\n  var cosi := -max(-1.0, min(1.0, I * N));\n  if cosi < 0 then\n    begin Result := Refract(I, -N, eta_i, eta_t); exit end;\n  var eta := eta_i / eta_t;\n  var k := 1 - eta * eta * (1 - cosi * cosi);\n  Result := if k < 0 then v3(1, 0, 0) else I * eta + N * (eta * cosi - Sqrt(k));\nend;"
  },
  {
    "instruction": "Create a scene intersection function in PascalABC.NET for ray tracing that finds the closest intersection point between a ray and objects in the scene.",
    "output": "function scene_intersect(orig, dir: vec3; spheres: array of TSphere; var hit, N: vec3; var material: TMaterial): boolean;\nbegin\n  var spheres_dist := real.MaxValue;\n  foreach var s in spheres do \n  begin\n    var dist_i: real;\n    if s.RayIntersect(orig, dir, dist_i) and (dist_i < spheres_dist) then\n    begin\n      spheres_dist := dist_i;\n      hit := orig + dir * dist_i;\n      N := (hit - s.center).normalize();\n      material := s.material;\n    end;\n  end;\n  \n  var checkerboard_dist := real.MaxValue;\n  if abs(dir.y) > 1e-3 then \n  begin\n    var d := -(orig.y + 4) / dir.y;\n    var pt := orig + dir * d;\n    if (d > 1e-3) and (abs(pt.x) < 10) and (pt.z < -10) and (pt.z > -30) and (d < spheres_dist) then \n    begin\n      checkerboard_dist := d;\n      hit := pt;\n      N := v3(0, 1, 0);\n      material.diffuse_color := if (Trunc(0.5 * hit.x + 1000) + Trunc(0.5 * hit.z)) and 1 = 1 then v3(0.3, 0.3, 0.3) else v3(0.3, 0.2, 0.1);\n    end;\n  end;\n  Result := min(spheres_dist, checkerboard_dist) < 1000;\nend;"
  },
  {
    "instruction": "Create a ray casting function in PascalABC.NET for ray tracing that calculates the color of a pixel by tracing rays through the scene with reflection and refraction.",
    "output": "function cast_ray(orig, dir: vec3; spheres: array of TSphere; lights: array of TLight; depth: integer := 0): vec3;\nbegin\n  var point,N: Vec3;\n  var material := new TMaterial;\n  \n  if (depth > 4) or not scene_intersect(orig, dir, spheres, point, N, material) then\n    begin Result := v3(0.2, 0.7, 0.8); exit end;\n  \n  var reflect_dir := Reflect(dir, N).normalize();\n  var refract_dir := Refract(dir, N, material.refractive_index).normalize();\n  var reflect_color := cast_ray(point, reflect_dir, spheres, lights, depth + 1);\n  var refract_color := cast_ray(point, refract_dir, spheres, lights, depth + 1);\n  \n  var (diffuse_light_intensity, specular_light_intensity) := (0.0, 0.0);\n  foreach var light in lights do\n  begin\n    var light_dir := (light.position - point).normalize;\n    \n    var shadow_pt, trashnrm: vec3;\n    var trashmat: TMaterial;\n    if scene_intersect(point, light_dir, spheres, shadow_pt, trashnrm, trashmat) and\n                ((shadow_pt - point).norm < (light.position - point).norm) then\n      continue;\n    \n    diffuse_light_intensity += light.intensity * max(0, light_dir * N);\n    specular_light_intensity += max(0, -Reflect(-light_dir, N) * dir) ** material.specular_exponent * light.intensity;\n  end;\n  Result := material.diffuse_color * diffuse_light_intensity * material.albedo.x0 + \n      v3(1.0, 1.0, 1.0) * specular_light_intensity * material.albedo.x1 + reflect_color * material.albedo.x2 + refract_color * material.albedo.x3;\nend;"
  },
  {
    "instruction": "Create an enhanced ray casting function in PascalABC.NET with colored lighting, emission effects, gradient sky, and light attenuation.",
    "output": "function cast_ray(orig, dir: vec3; spheres: array of TSphere; lights: array of TLight; depth: integer := 0): vec3;\nbegin\n  var point,N: Vec3;\n  var material := new TMaterial;\n  \n  if (depth > 5) or not scene_intersect(orig, dir, spheres, point, N, material) then\n  begin\n    var t := 0.5 * (dir.y + 1.0);\n    Result := (1.0 - t) * v3(1.0, 1.0, 1.0) + t * v3(0.3, 0.7, 1.0);\n    exit;\n  end;\n  \n  var emission_intensity := 1.0;\n  if material.emission.norm > 0 then\n  begin\n    var found_sphere: TSphere := nil;\n    foreach var s in spheres do\n    begin\n      var dist_to_center := (point - s.center).norm;\n      if dist_to_center <= s.radius + 0.001 then\n      begin\n        found_sphere := s;\n        break;\n      end;\n    end;\n    \n    if found_sphere <> nil then\n    begin\n      var dist_from_center := (point - found_sphere.center).norm;\n      var radius_ratio := dist_from_center / found_sphere.radius;\n      emission_intensity := 1.0 - radius_ratio * radius_ratio;\n      emission_intensity := max(0.1, emission_intensity);\n    end;\n  end;\n  \n  var result_color := material.emission * emission_intensity;\n  \n  var reflect_dir := Reflect(dir, N).normalize();\n  var refract_dir := Refract(dir, N, material.refractive_index).normalize();\n  var reflect_color := cast_ray(point, reflect_dir, spheres, lights, depth + 1);\n  var refract_color := cast_ray(point, refract_dir, spheres, lights, depth + 1);\n  \n  var (diffuse_light_intensity, specular_light_intensity) := (0.0, 0.0);\n  var color_influence := new Vec3(0, 0, 0);\n  \n  foreach var light in lights do\n  begin\n    var light_dir := (light.position - point).normalize;\n    var light_distance := (light.position - point).norm;\n    \n    var shadow_pt, trashnrm: vec3;\n    var trashmat: TMaterial;\n    if scene_intersect(point, light_dir, spheres, shadow_pt, trashnrm, trashmat) and\n                ((shadow_pt - point).norm < light_distance) then\n      continue;\n    \n    var attenuation := 1.0 / (1.0 + 0.01 * light_distance);\n    \n    diffuse_light_intensity += light.intensity * max(0, light_dir * N) * attenuation;\n    specular_light_intensity += max(0, -Reflect(-light_dir, N) * dir) ** material.specular_exponent * light.intensity * attenuation;\n    \n    var light_contrib := light.color * light.intensity * max(0, light_dir * N) * attenuation;\n    color_influence := color_influence + light_contrib;\n  end;\n  \n  var diffuse_component := v3(material.diffuse_color.x * color_influence.x, \n                              material.diffuse_color.y * color_influence.y, \n                              material.diffuse_color.z * color_influence.z) * material.albedo.x0;\n  \n  result_color := result_color + diffuse_component + \n      v3(1.0, 1.0, 1.0) * specular_light_intensity * material.albedo.x1 + \n      reflect_color * material.albedo.x2 + \n      refract_color * material.albedo.x3;\n  \n  Result := result_color;\nend;"
  },
  {
    "instruction": "Create a render function in PascalABC.NET for ray tracing that generates an image by casting rays for each pixel with parallel processing.",
    "output": "function render(width,height: integer; spheres: array of TSphere; lights: array of TLight): array [,] of Color;\nbegin\n  Result := new Color[width,height];  \n  {$omp parallel for}\n  for var j := 0 to height - 1 do\n  begin\n    for var i := 0 to width - 1 do\n    begin\n      var dir_x := (i + 0.5) - width / 2;\n      var dir_y := -(j + 0.5) + height / 2;\n      var dir_z := -height / (2 * tan(PI / 6));\n      var c := cast_ray(v3(0, 0, 0), v3(dir_x, dir_y, dir_z).normalize(), spheres, lights);\n      var max := max(c.x, c.y, c.z);\n      if max > 1 then\n        c := c / max;\n      Result[i,j] := RGB(Trunc(255*c.x),Trunc(255*c.y),Trunc(255*c.z));\n    end;\n  end;\nend;"
  },
  {
    "instruction": "Create an enhanced render function in PascalABC.NET with supersampling anti-aliasing for better image quality in ray tracing.",
    "output": "function render(width,height: integer; spheres: array of TSphere; lights: array of TLight): array [,] of Color;\nbegin\n  Result := new Color[width,height];  \n  var samples := 3;\n  var inv_samples := 1.0 / (samples * samples);\n  \n  {$omp parallel for}\n  for var j := 0 to height - 1 do\n  begin\n    for var i := 0 to width - 1 do\n    begin\n      var final_color := v3(0, 0, 0);\n      \n      for var sy := 0 to samples - 1 do\n        for var sx := 0 to samples - 1 do\n        begin\n          var offset_x := (sx + 0.5) / samples;\n          var offset_y := (sy + 0.5) / samples;\n          \n          var dir_x := (i + offset_x) - width / 2;\n          var dir_y := -(j + offset_y) + height / 2;\n          var dir_z := -height / (2 * tan(PI / 6));\n          \n          var sample_color := cast_ray(v3(0, 0, 0), v3(dir_x, dir_y, dir_z).normalize(), spheres, lights);\n          final_color := final_color + sample_color;\n        end;\n      \n      var c := final_color * inv_samples;\n      var max_val := max(c.x, max(c.y, c.z));\n      if max_val > 1 then\n        c := c / max_val;\n      \n      c.x := c.x.Clamp(0.0, 1.0);\n      c.y := c.y.Clamp(0.0, 1.0);\n      c.z := c.z.Clamp(0.0, 1.0);\n      \n      Result[i,j] := RGB(Trunc(255*c.x),Trunc(255*c.y),Trunc(255*c.z));\n    end;\n  end;\nend;"
  },
  {
    "instruction": "Create material definition functions in PascalABC.NET for ray tracing with different material properties like refractive index, albedo, and specular exponent.",
    "output": "function Material(ri: real; alb: vec4; dif: vec3; spec: real) := new TMaterial(ri, alb, dif, spec); \n\nfunction Material(ri: real; alb: vec4; dif: vec3; spec: real; em: vec3 := new Vec3(0,0,0)) := new TMaterial(ri, alb, dif, spec, em); \n\nfunction Sphere(center: vec3; radius: real; material: TMaterial) := new TSphere(center, radius, material);\n\nfunction Light(position: Vec3; intensity: real) := new TLight(position, intensity); \n\nfunction Light(position: Vec3; intensity: real; color: Vec3) := new TLight(position, intensity, color);"
  },
  {
    "instruction": "Create an enhanced scene intersection function in PascalABC.NET with wavy checkerboard pattern and improved material handling for ray tracing.",
    "output": "function scene_intersect(orig, dir: vec3; spheres: array of TSphere; var hit, N: vec3; var material: TMaterial): boolean;\nbegin\n  var spheres_dist := real.MaxValue;\n  foreach var s in spheres do \n  begin\n    var dist_i: real;\n    if s.RayIntersect(orig, dir, dist_i) and (dist_i < spheres_dist) then\n    begin\n      spheres_dist := dist_i;\n      hit := orig + dir * dist_i;\n      N := (hit - s.center).normalize();\n      material := s.material;\n    end;\n  end;\n  \n  var checkerboard_dist := real.MaxValue;\n  if abs(dir.y) > 1e-3 then \n  begin\n    var d := -(orig.y + 4) / dir.y;\n    var pt := orig + dir * d;\n    if (d > 1e-3) and (abs(pt.x) < 15) and (pt.z < -8) and (pt.z > -35) and (d < spheres_dist) then \n    begin\n      checkerboard_dist := d;\n      hit := pt;\n      N := v3(0, 1, 0);\n      \n      material := new TMaterial;\n      var wave := 0.1 * sin(pt.x * 0.5) * sin(pt.z * 0.3);\n      var checker := (Trunc(0.5 * hit.x + 1000) + Trunc(0.5 * hit.z)) and 1;\n      \n      if checker = 1 then\n        material.diffuse_color := v3(0.4 + wave, 0.4 + wave, 0.4 + wave)\n      else\n        material.diffuse_color := v3(0.2 + wave, 0.15 + wave, 0.1 + wave);\n      \n      material.albedo := v4(0.8, 0.2, 0.0, 0.0);\n      material.specular_exponent := 20;\n      material.refractive_index := 1.0;\n      material.emission := v3(0, 0, 0);\n    end;\n  end;\n  \n  Result := min(spheres_dist, checkerboard_dist) < 1000;\nend;"
  },
  {
    "instruction": "Create a Robot programming example in PascalABC.NET for educational purposes that demonstrates basic movement and painting operations.",
    "output": "uses Robot;\n\nbegin\n  Task('a1');\n  Right; Right; Right; Right; \n  Up;\n  Left; Paint;\n  Left; Paint;\n  Left; Paint;\n  Left; Paint;\n  Left; \nend."
  },
  {
    "instruction": "Show basic input/output operations and calculations with user input in PascalABC.NET",
    "output": "// Output of calculation results. Variables and input procedure are used\n\nbegin\n  var (a,b) := ReadlnInteger2('Enter a and b:');\n  Println;\n  Println(a,'+',b,'=',a+b);\n  Println(a,'-',b,'=',a-b);\n  Println(a,'*',b,'=',a*b);\n  Println(a,'/',b,'=',a/b);\nend.\n\n// First program\n\nprogram HelloWorld; // This line is optional\n\nbegin\n  Println('Hello, world!');\nend.\n\n// String input\n\nbegin\n  var имя := ReadString('Enter your name:');\n  Println($'Hello, {имя}!');\nend."
  },
  {
    "instruction": "Demonstrate that real division by zero doesn't cause runtime errors in PascalABC.NET",
    "output": "// With real division by 0 no error occurs \n\nbegin\n  var r: real := 0;\n  Print(1/r); // Output: Infinity\nend."
  },
  {
    "instruction": "Create record type examples in PascalABC.NET with enumerated types, record assignment, and field initialization using with statement.",
    "output": "type\n  SexType = (Male, Female);\n  Person = record\n    Name: string;\n    Age, Weight: integer;\n    Sex: SexType;\n  end;\n  \nprocedure WritePerson(const p: Person);\nbegin\n  writelnFormat('Фамилия: {0}   Пол: {1}   Возраст: {2}   Вес: {3}',p.Name,p.Sex,p.Age,p.Weight);\nend;\n  \nvar \n  p: Person := (Name: 'Иванов'; Age: 20; Weight: 64; Sex: Male);\n  p1: Person;  \nbegin\n  p1 := p;\n  var p2: Person;\n  p2.Name := 'Петрова';\n  p2.Age := 18;\n  p2.Weight := 50;\n  p2.Sex := Female;\n  WritePerson(p2);\n  \n  var p3: Person;\n  with p3 do\n  begin\n    Name := 'Сидоров';\n    Age := 24;\n    Weight := 80;\n    Sex := Male;\n  end;\n  WritePerson(p3);\nend."
  },
  {
    "instruction": "Create a class with properties in PascalABC.NET that demonstrates read-only and read-write properties with validation in setter methods.",
    "output": "type \n  Person = class\n  private\n    nm: string;\n    ag: integer;\n    procedure SetAge(a: integer);\n    begin\n      if a<0 then\n        a := 0;\n      ag := a;  \n    end;\n  public\n    constructor (n: string; a: integer);\n    begin\n      nm := n; ag := a;\n    end;\n    property Name: string read nm;\n    property Age: integer read ag write SetAge;\n    procedure Print;\n    begin\n      writeln('Имя: ',nm,'  Возраст: ',ag);\n    end;\n  end;\n\nvar p: Person := new Person('Иванов', 20);\n\nbegin\n  writeln('Имя: ',p.Name);\n  p.Age := -1;\n  writeln('Возраст: ',p.Age);\nend."
  },
  {
    "instruction": "Create a 3D pyramid animation in PascalABC.NET using Graph3D with rotation animation.",
    "output": "uses Graph3D;\n\nbegin\n  var p := Pyramid(0,0,0,5,2,2,Colors.Red);\n  p.AnimRotate(OrtZ,360,5).Begin\nend."
  },
  {
    "instruction": "Create a numerical integration example in PascalABC.NET using Quanc8 adaptive quadrature to compute the integral of sin(x)/x.",
    "output": "uses NumLibABC;\n\nbegin\n  var f:real->real := x->x=0?1.0:sin(x)/x;\n  var oL := new Quanc8(f,0,2,1e-7,0);\n  Writeln(oL.Value);\nend."
  },
  {
    "instruction": "Create a singly linked list using references instead of pointers in PascalABC.NET",
    "output": "type \n  Node = class\n    data: integer;\n    next: Node;\n    constructor (d: integer; n: Node);\n    begin\n      data := d;\n      next := n;\n    end;\n  end;\n\nvar first: Node;\n  \nbegin\n  first := nil;\n  first := new Node(3,first);\n  first := new Node(7,first);\n  first := new Node(5,first);\n  \n  writeln('Singly linked list contents (using references instead of pointers): ');\n  var p := first;\n  while p<>nil do\n  begin\n    write(p.data,' ');\n    p := p.next;\n  end;\n  \n  first := nil;\nend."
  },
  {
    "instruction": "Demonstrate type reflection in PascalABC.NET by showing all members of DateTime type",
    "output": "// Type reflection. All members of DateTime type are displayed\nuses System,System.Reflection;\n\nbegin\n  var bf := BindingFlags.Public or BindingFlags.NonPublic or BindingFlags.Instance or BindingFlags.Static;\n  var t: &Type := typeof(DateTime);\n  var mi := t.GetMembers(bf);\n  foreach var m: MemberInfo in mi do\n    Println(m);\nend."
  },
  {
    "instruction": "Create a 3D scene with boxes and spheres using Graph3D in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin\n  var b := Box(0,0,0,3,1,2,Colors.Blue);\n  var s := Sphere(0,0,2,1,Colors.Green);\n  var b1 := b.Clone;\n  var s1 := s.Clone;\n \n  var g := Group(b,s);\n  var g1 := Group(b1,s1);\n  g1.MoveByY(3);\n  g.AddChild(g1[0]);\n  b1.MoveByY(3);\nend."
  },
  {
    "instruction": "Create another 3D scene with grouped objects using Graph3D in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin\n  var b := Box(0,0,0,3,1,2,Colors.Blue);\n  var s := Sphere(0,0,2,1,Colors.Green);\n  var b1 := Box(0,-3,0,3,1,2,Colors.Blue);\n  var s1 := Sphere(0,-3,2,1,Colors.Green);\n \n  var g := Group(b,s);\n  var g1 := Group(b1,s1);\n  g.AddChild(g1[0]);\n  Sleep(1000);\n  g.MoveByX(3);\n  Sleep(1000);\n  g1.MoveByY(4);\nend."
  },
  {
    "instruction": "Show repeat loop for input validation in PascalABC.NET",
    "output": "// Repeat loop. Input control\nbegin\n  var mark: integer;\n  repeat\n    Println('Enter grade (2..5):');\n    mark := ReadInteger;\n    if (mark < 2) or (mark > 5) then\n      Println('Grade is incorrect. Repeat input');\n  until (mark >= 2) and (mark <= 5);\n  Println('You entered grade', mark);\nend."
  },
  {
    "instruction": "Show while and repeat loops for implementing Euclidean algorithm in PascalABC.NET",
    "output": "// While loop. Euclidean algorithm for finding greatest common divisor\nbegin\n  var (A, B) := ReadInteger2('Enter two integers:');\n  while B <> 0 do\n    (A, B) := (B, A mod B);\n  Println('Greatest common divisor =', A);\nend.\n\n// Repeat loop. Euclidean algorithm for finding greatest common divisor\nbegin\n  Print('Enter two integers:');\n  var A := ReadInteger;\n  var B := ReadInteger;\n  repeat\n    var C := A mod B;\n    A := B;\n    B := C;\n  until B = 0;\n  Println('Greatest common divisor =', A);\nend."
  },
  {
    "instruction": "Isolate roots of equation using table method in PascalABC.NET with NumLibABC",
    "output": "uses NumLibABC;\n\nbegin\n  var f:real->real:=t->sin(t)/(1+Sqr(Exp(t)))-0.1;\n  var (a,b,h):=(-10,5,0.5);\n  var oL:=new RootsIsolation(f,a,b,h);\n  Println(oL.Value)\nend."
  },
  {
    "instruction": "Create a Rubik's cube simulation with 3D graphics - cube creation procedure in PascalABC.NET",
    "output": "uses Graph3D;\n\nvar InnerColor := RGB(70,70,70);\nvar sec := 0.5;\nvar g := new Object3D[3,3,3];\n\nprocedure CreateCube;\nbegin\n  var a := 1.03;\n\n  for var x := 0 to 2 do\n  for var y := 0 to 2 do\n  for var z := 0 to 2 do\n    if (x,y,z) <> (1,1,1) then\n    begin\n      var b := Box(0+x*a-a,0+y*a-a,-0.5+z*a-a,1,1,0.01,z=0 ? Colors.White : InnerColor);\n      var b3 := Box(0+x*a-a,0+y*a-a,0.5+z*a-a,1,1,0.01,z=2 ? Colors.Yellow : InnerColor);\n      \n      var b1 := Box(0.5+x*a-a,0+y*a-a,0+z*a-a,0.01,1,1,x=2 ? Colors.Red : InnerColor);\n      var b4 := Box(-0.5+x*a-a,0+y*a-a,0+z*a-a,0.01,1,1,x=0 ? Colors.Orange : InnerColor);\n    \n      var b2 := Box(0+x*a-a,0.5+y*a-a,0+z*a-a,1,0.01,1,y=2 ? Colors.Green : InnerColor);\n      var b5 := Box(0+x*a-a,-0.5+y*a-a,0+z*a-a,1,0.01,1,y=0 ? Colors.Blue : InnerColor);\n    \n      g[x,y,z] := Group(b,b1,b2,b3,b4,b5);\n    end;  \nend;"
  },
  {
    "instruction": "Implement generic shift procedures for Rubik's cube rotation in PascalABC.NET",
    "output": "procedure ShiftLeft<T>(var a,b,c,d: T);\nbegin\n  var v := a;\n  a := b;\n  b := c;\n  c := d;\n  d := v;\nend;\n\nprocedure ShiftRight<T>(var a,b,c,d: T);\nbegin\n  var v := d;\n  d := c;\n  c := b;\n  b := a;\n  a := v;\nend;"
  },
  {
    "instruction": "Implement right rotation procedure for Rubik's cube in PascalABC.NET",
    "output": "procedure RightRotate(n: integer := 1);\nbegin\n  IsAnimated := True;\n  var y := 2;\n  if n = 0 then exit;\n  for var x := 0 to 2 do\n  for var z := 0 to 2 do\n    g[x,y,z].AnimRotateAtAbsolute(OrtY,-90*n,Origin,sec*Abs(n),EndAnim).Begin;\n  \n  if n>0 then\n    loop Abs(n) do\n    begin  \n      ShiftLeft(g[1,y,0],g[0,y,1],g[1,y,2],g[2,y,1]);\n      ShiftLeft(g[2,y,0],g[0,y,0],g[0,y,2],g[2,y,2]);\n    end\n  else   \n    loop Abs(n) do\n    begin  \n      ShiftRight(g[1,y,0],g[0,y,1],g[1,y,2],g[2,y,1]);\n      ShiftRight(g[2,y,0],g[0,y,0],g[0,y,2],g[2,y,2]);\n    end\nend;"
  },
  {
    "instruction": "Implement scene initialization for Rubik's cube in PascalABC.NET",
    "output": "procedure InitScene;\nbegin\n  View3D.ShowGridLines := False;\n  Camera.Position := P3D(10,6,6);\n  Camera.LookDirection := V3D(-10,-6,-6);\n  Window.Title := 'Rubik''s Cube';\n  View3D.Title := 'Face rotation:';\n  View3D.SubTitle := 'F,B - front-back'#10'U,D - up-down'#10'L,R - left-right';\n  Lights.AddDirectionalLight(Colors.DarkGray,V3D(-2.0,0,0));\n  Lights.AddDirectionalLight(Colors.Gray,V3D(2.0,0,0));\n  Lights.AddDirectionalLight(RGB(150,150,150),V3D(0,0,2));\n  Lights.AddDirectionalLight(RGB(50,50,50),V3D(0,0,-2));\n  Lights.AddDirectionalLight(Colors.Gray,V3D(0,2,0));\nend;"
  },
  {
    "instruction": "Define Vec3 record with mathematical operations for ray tracing in PascalABC.NET",
    "output": "type\n  Vec3 = record\n    x, y, z: real;\n    class function operator+(v1, v2: Vec3): Vec3 := new Vec3(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);\n    class function operator-(v1, v2: Vec3): Vec3 := new Vec3(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);\n    class function operator-(v: Vec3): Vec3 := new Vec3(-v.x, -v.y, -v.z);\n    class function operator*(v: Vec3; r: real): Vec3 := new Vec3(v.x * r, v.y * r, v.z * r);\n    class function operator/(v: Vec3; r: real): Vec3 := new Vec3(v.x / r, v.y / r, v.z / r);\n    class function operator*(r: real; v: Vec3): Vec3 := new Vec3(v.x * r, v.y * r, v.z * r);\n    class function operator*(v1, v2: Vec3): real := v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n    function norm := Sqrt(x * x + y * y + z * z);\n    function normalize(l: real := 1): Vec3 := Self/norm;\n    function cross(v: Vec3): Vec3 := new Vec3(y * v.z - z * v.y, z * v.x - x * v.z, x * v.y - y * v.x);\n    constructor(xx,yy,zz: real); begin x := xx; y := yy; z := zz end;\n  end;"
  },
  {
    "instruction": "Implement sphere-ray intersection function for ray tracing in PascalABC.NET",
    "output": "type\n  TSphere = auto class \n    center: vec3;\n    radius: real;\n    material: TMaterial;\n    function RayIntersect(orig, dir: vec3; var t0: real): boolean;\n    begin\n      var L := center - orig;\n      var tca := L * dir;\n      var d2 := L * L - tca * tca;\n      if d2 > radius * radius then\n        begin Result := false; exit end;\n      var thc := Sqrt(radius * radius - d2);\n      t0 := tca - thc;\n      if t0 < 1e-3 then\n        t0 := tca + thc;\n      if t0 < 1e-3 then\n        Result := false\n      else Result := true;\n    end;\n  end;"
  },
  {
    "instruction": "Implement reflection and refraction functions for ray tracing in PascalABC.NET",
    "output": "function Reflect(I, N: vec3) := I - N * 2 * (I * N);\n\nfunction Refract(I, N: vec3; eta_t: real; eta_i: real := 1): vec3;\nbegin\n  var cosi := -max(-1.0, min(1.0, I * N));\n  if cosi < 0 then\n    begin Result := Refract(I, -N, eta_i, eta_t); exit end;\n  var eta := eta_i / eta_t;\n  var k := 1 - eta * eta * (1 - cosi * cosi);\n  Result := if k < 0 then v3(1, 0, 0) else I * eta + N * (eta * cosi - Sqrt(k));\nend;"
  },
  {
    "instruction": "Implement scene intersection function for ray tracing with checkerboard pattern in PascalABC.NET",
    "output": "function scene_intersect(orig, dir: vec3; spheres: array of TSphere; var hit, N: vec3; var material: TMaterial): boolean;\nbegin\n  var spheres_dist := real.MaxValue;\n  foreach var s in spheres do \n  begin\n    var dist_i: real;\n    if s.RayIntersect(orig, dir, dist_i) and (dist_i < spheres_dist) then\n    begin\n      spheres_dist := dist_i;\n      hit := orig + dir * dist_i;\n      N := (hit - s.center).normalize();\n      material := s.material;\n    end;\n  end;\n  \n  var checkerboard_dist := real.MaxValue;\n  if abs(dir.y) > 1e-3 then \n  begin\n    var d := -(orig.y + 4) / dir.y;\n    var pt := orig + dir * d;\n    if (d > 1e-3) and (abs(pt.x) < 15) and (pt.z < -8) and (pt.z > -35) and (d < spheres_dist) then \n    begin\n      checkerboard_dist := d;\n      hit := pt;\n      N := v3(0, 1, 0);\n      \n      material := new TMaterial;\n      var wave := 0.1 * sin(pt.x * 0.5) * sin(pt.z * 0.3);\n      var checker := (Trunc(0.5 * hit.x + 1000) + Trunc(0.5 * hit.z)) and 1;\n      \n      if checker = 1 then\n        material.diffuse_color := v3(0.4 + wave, 0.4 + wave, 0.4 + wave)\n      else\n        material.diffuse_color := v3(0.2 + wave, 0.15 + wave, 0.1 + wave);\n      \n      material.albedo := v4(0.8, 0.2, 0.0, 0.0);\n      material.specular_exponent := 20;\n      material.refractive_index := 1.0;\n      material.emission := v3(0, 0, 0);\n    end;\n  end;\n  \n  Result := Min(spheres_dist, checkerboard_dist) < 1000;\nend;"
  },
  {
    "instruction": "Implement main ray casting function with lighting and materials in PascalABC.NET",
    "output": "function cast_ray(orig, dir: vec3; spheres: array of TSphere; lights: array of TLight; depth: integer := 0): vec3;\nbegin\n  var point,N: Vec3;\n  var material := new TMaterial;\n  \n  if (depth > 5) or not scene_intersect(orig, dir, spheres, point, N, material) then\n  begin\n    var t := 0.5 * (dir.y + 1.0);\n    Result := (1.0 - t) * v3(1.0, 1.0, 1.0) + t * v3(0.3, 0.7, 1.0);\n    exit;\n  end;\n  \n  var emission_intensity := 1.0;\n  if material.emission.norm > 0 then\n  begin\n    var found_sphere: TSphere := nil;\n    foreach var s in spheres do\n    begin\n      var dist_to_center := (point - s.center).norm;\n      if dist_to_center <= s.radius + 0.001 then\n      begin\n        found_sphere := s;\n        break;\n      end;\n    end;\n    \n    if found_sphere <> nil then\n    begin\n      var dist_from_center := (point - found_sphere.center).norm;\n      var radius_ratio := dist_from_center / found_sphere.radius;\n      emission_intensity := 1.0 - radius_ratio * radius_ratio;\n      emission_intensity := max(0.1, emission_intensity);\n    end;\n  end;\n  \n  var result_color := material.emission * emission_intensity;\n  \n  var reflect_dir := Reflect(dir, N).normalize();\n  var refract_dir := Refract(dir, N, material.refractive_index).normalize();\n  var reflect_color := cast_ray(point, reflect_dir, spheres, lights, depth + 1);\n  var refract_color := cast_ray(point, refract_dir, spheres, lights, depth + 1);\n  \n  var (diffuse_light_intensity, specular_light_intensity) := (0.0, 0.0);\n  var color_influence := new Vec3(0, 0, 0);\n  \n  foreach var light in lights do\n  begin\n    var light_dir := (light.position - point).normalize;\n    var light_distance := (light.position - point).norm;\n    \n    var shadow_pt, trashnrm: vec3;\n    var trashmat: TMaterial;\n    if scene_intersect(point, light_dir, spheres, shadow_pt, trashnrm, trashmat) and\n                ((shadow_pt - point).norm < light_distance) then\n      continue;\n    \n    var attenuation := 1.0 / (1.0 + 0.01 * light_distance);\n    \n    diffuse_light_intensity += light.intensity * max(0, light_dir * N) * attenuation;\n    specular_light_intensity += max(0, -Reflect(-light_dir, N) * dir) ** material.specular_exponent * light.intensity * attenuation;\n    \n    var light_contrib := light.color * light.intensity * max(0, light_dir * N) * attenuation;\n    color_influence := color_influence + light_contrib;\n  end;\n  \n  var diffuse_component := v3(material.diffuse_color.x * color_influence.x, \n                              material.diffuse_color.y * color_influence.y, \n                              material.diffuse_color.z * color_influence.z) * material.albedo.x0;\n  \n  result_color := result_color + diffuse_component + \n      v3(1.0, 1.0, 1.0) * specular_light_intensity * material.albedo.x1 + \n      reflect_color * material.albedo.x2 + \n      refract_color * material.albedo.x3;\n  \n  Result := result_color;\nend;"
  },
  {
    "instruction": "Fix integer division by zero runtime error with proper validation",
    "output": "// See what runtime error looks like with integer division by 0\n\nbegin\n  var i: integer := 0;\n  if i <> 0 then\n    Print(2 div i)\n  else\n    Println('Error: Division by zero is not allowed');\nend."
  },
  {
    "instruction": "Show that real division by zero doesn't cause runtime error in PascalABC.NET",
    "output": "var r: real := 0;\n\nbegin\n  Write(1/r);\nend."
  },
  {
    "instruction": "Show that working with real numbers cannot cause runtime errors in PascalABC.NET",
    "output": "// When working with real numbers it's impossible to get runtime error \nbegin\n  Println(Sqrt(-1)); // Output: NaN (Not a Number)\nend."
  },
  {
    "instruction": "Implement selection sort algorithm for real numbers in PascalABC.NET",
    "output": "procedure SelectionSort(a: array of real);\nbegin\n  for var i:=0 to a.Length-2 do\n  begin\n    var (min,ind) := (a[i],i); \n    for var j:=i+1 to a.Length-1 do\n      if a[j]<min then\n        (min,ind) := (a[j],j); \n    a[ind] := a[i];\n    a[i] := min;\n  end;\nend;\n\nbegin\n  var a := SeqRandomReal(20).Select(r->r.Round(2)).ToArray;\n  Println('Array contents: ');\n  a.Println;\n  SelectionSort(a);\n  Println('After selection sort: ');\n  a.Println;\nend."
  },
  {
    "instruction": "Create a sequence and print it in PascalABC.NET",
    "output": "begin\n  Seq(1,5,3,2,4).Print;\nend."
  },
  {
    "instruction": "Serialize and deserialize objects in PascalABC.NET",
    "output": "type \n  [Serializable]\n  Node = auto class\n    x: integer;\n    next: Node;\n  end;\n\nconst fname = 'a.dat';\n\nbegin\n  var m := new Node(5,new Node(3,new Node(4,nil)));\n  Serialize(fname,m);\n  var m1 := Deserialize(fname) as Node;\n  Print(m1);\nend."
  },
  {
    "instruction": "Serialize multiple objects to binary file in PascalABC.NET",
    "output": "type \n  [Serializable]\n  My = auto class\n    x,y: integer;\n  end;\n  IntArray = array of integer;\n\nconst fname = 'a.dat';\n\nbegin\n  var f := CreateBinary(fname);\n  f.Serialize(new My(444,555));\n  f.Serialize(|1,2,3|);\n  f.Serialize(Lst(1..9));\n  f.Close;\n  \n  f := OpenBinary(fname);\n  var m: My := f.Deserialize as My;\n  var a: array of integer := f.Deserialize as IntArray;\n  var l: List<integer> := f.Deserialize as List<integer>;\n  f.Close;\n  \n  Print(m,a,l);\nend."
  },
  {
    "instruction": "Show records with constructors and overridden ToString method in PascalABC.NET",
    "output": "// Illustration of constructors and methods in records\n// If ToString method is overridden, it's called when outputting object of this type by writeln procedure\ntype\n  SexType = (Male, Female);\n  Person = record\n    Name: string;\n    Age, Weight: integer;\n    Sex: SexType;\n    constructor (Name: string; Age, Weight: integer; Sex: SexType);\n    begin\n      Self.Name := Name;\n      Self.Age := Age;\n      Self.Sex := Sex;\n      Self.Weight := Weight;\n    end;\n    function ToString: string; override;\n    begin\n      Result := $'Name: {Name}   Sex: {Sex}   Age: {Age}   Weight: {Weight}';\n    end;\n  end;\n  \nbegin\n  var p: Person := new Person('Ivanov',20,70,SexType.Male);\n\n  Println(p);\nend."
  },
  {
    "instruction": "Create a simple shooter game with player, monsters and bullets using WPFObjects in PascalABC.NET",
    "output": "uses WPFObjects,Timers;\n\ntype \n  BulletWPF = class(CircleWPF) end;\n  MonsterWPF = class(SquareWPF) end;\n  PlayerWPF = class(EllipseWPF) end;\n\nbegin\n  var Player := new PlayerWPF(GraphWindow.Center, 30, 50, RandomColor);\n  Player.Velocity := 100;\n  Player.Number := 0;\n  \n  loop 5 do\n  begin\n    var m := new MonsterWPF(750,Random(10,550),30,RandomColor);\n    m.Velocity := 50;\n  end;  \n  \n  OnMouseMove := (x,y,mb) -> Player.RotateToPoint(x,y);\n  \n  OnMouseDown := (x,y,mb) -> begin\n    var cc := new BulletWPF(Player.CenterTop,5,Colors.Red);\n    cc.Direction := (x-Player.Center.X,y-Player.Center.Y);\n    cc.Velocity := 300;\n  end;\n  \n  var kl,kr,ku,kd: boolean;\n\n  OnDrawFrame := dt -> begin\n    Window.Title := 'Object count: '+Objects.Count;\n    if kr then \n      Player.Dx := 1\n    else if kl then \n      Player.Dx := -1\n    else Player.Dx := 0;  \n    if ku then \n      Player.Dy := -1\n    else if kd then \n      Player.Dy := 1\n    else Player.Dy := 0; \n    \n    for var i:=Objects.Count-1 downto 0 do\n    begin\n      var o := Objects[i];\n      if o is MonsterWPF then \n        o.Direction := (Player.Center.X - o.Center.X,Player.Center.Y-o.Center.Y);\n      o.MoveTime(dt);\n    end;\n    \n    if Player.IntersectionList.Any(o -> o is MonsterWPF) then\n    begin\n      // Game over\n    end;\n  end;\n  \n  CreateTimerAndStart(100,procedure ->\n  begin\n    for var i:=Objects.Count-1 downto 0 do\n    begin\n      var o := Objects[i];\n      if o.OutOfGraphWindow and not (o is PlayerWPF) then \n        o.Destroy;   \n      if o is BulletWPF then\n        foreach var x in o.IntersectionList do\n          if x is MonsterWPF then\n          begin\n            x.Destroy;\n            o.Destroy;\n            Player.Number += 1;\n            break;\n          end;\n    end;\n  end);\n  \n  CreateTimerAndStart(1000,procedure ->\n  begin\n    var x := if Random(2)=0 then 750 else 50;\n    var m := new MonsterWPF(x,Random(10,550),30,RandomColor);\n    m.Velocity := 50;\n  end);\n  \n  OnKeyDown := k ->\n  begin\n    case k of\n      Key.w,Key.Up: begin ku := true; kd := false; end; \n      Key.s,Key.Down: begin kd := true; ku := false; end;\n      Key.a,Key.Left: begin kl := true; kr := false; end;\n      Key.d,Key.Right: begin kr := true; kl := false end;\n    end;  \n  end;\n\n  OnKeyUp := k ->\n  begin\n    case k of\n      Key.w,Key.Up: ku := false;\n      Key.s,Key.Down: kd := false;\n      Key.a,Key.Left: kl := false;\n      Key.d,Key.Right: kr := false;\n    end;  \n  end;\nend."
  },
  {
    "instruction": "Create an enhanced shooter game with interface, game states and controls in PascalABC.NET",
    "output": "uses WPFObjects, Timers, Controls;\n\ntype\n  BulletWPF = class(CircleWPF) end;\n  MonsterWPF = class(SquareWPF) end;\n  PlayerWPF = class(EllipseWPF) end;\n  TGameState = (Paused, Started, EndOfGame);\n\nvar\n  GameState: TGameState := Paused;\n  sb: StatusBarWPF;\n  bstart, bstop, bnewgame: ButtonWPF;\n  Player: PlayerWPF;\n  kl, kr, ku, kd: boolean;\n\nprocedure InitGame;\nbegin\n  Player := new PlayerWPF(GraphWindow.Center, 30, 50, RandomColor);\n  Player.Velocity := 100;\n  Player.Number := 0;\n  \n  loop 10 do\n  begin\n    var m := new MonsterWPF(750, Random(10, 550), 30, RandomColor);\n    m.Velocity := 50;\n  end;\nend;\n\nprocedure NewGame;\nbegin\n  sb.Text := '';\n  Objects.Clear;\n  InitGame;\nend;\n\nprocedure GameOver;\nbegin\n  sb.Text := 'Player died';\n  GameState := EndOfGame;\n  bstart.Enabled := False;\n  bstop.Enabled := False;\n  bnewgame.Enabled := True;\n  Player.Color := Colors.Black;\nend;\n\nprocedure GameOverWin;\nbegin\n  sb.Text := 'Victory!';\n  GameState := EndOfGame;\n  bstart.Enabled := False;\n  bstop.Enabled := False;\n  bnewgame.Enabled := True;\n  Player.Color := Colors.Yellow;\nend;"
  },
  {
    "instruction": "Implement interface initialization and game procedures for shooter game in PascalABC.NET",
    "output": "procedure InitInterface;\nbegin\n  Window.SetSize(1000, 600);\n  LeftPanel(200, Colors.Orange);\n  bstart := Button('Start');\n  bstop := Button('Stop');\n  bnewgame := Button('New game');\n  bstop.Enabled := False;\n  bstart.Enabled := False;\n  bstart.Click := procedure → begin\n    GameState := Started;\n    bstart.Enabled := False;\n    bstop.Enabled := True;\n  end;\n  bstop.Click := procedure → begin\n    GameState := Paused;\n    bstart.Enabled := True;\n    bstop.Enabled := False;\n  end;\n  bNewGame.Click := procedure → begin\n    GameState := Started;\n    bnewgame.Enabled := False;\n    bstart.Enabled := False;\n    bstop.Enabled := True;\n    NewGame;\n  end;\n  sb := StatusBar;\nend;\n\nprocedure KillMonstersHandler;\nbegin\n  if GameState <> Started then \n    exit;\n  Objects.DestroyAll(o → o.OutOfGraphWindow and not (o is PlayerWPF));\n  foreach var o in Objects do\n  begin\n    if o is BulletWPF then\n      foreach var x in o.IntersectionList do\n        if x is MonsterWPF then\n        begin\n          x.Destroy;\n          o.Destroy;\n          Player.Number += 1;\n          break;\n        end;\n  end;\nend;\n\nprocedure DrawFrame(dt: real);\nbegin\n  if GameState <> Started then exit;\n  Window.Title := 'Object count: ' + Objects.Count;\n  \n  if kr then \n    Player.Dx := 1\n  else if kl then \n    Player.Dx := -1\n  else Player.Dx := 0;  \n  if ku then \n    Player.Dy := -1\n  else if kd then \n    Player.Dy := 1\n  else Player.Dy := 0; \n  \n  foreach var o in Objects do\n  begin\n    if o is MonsterWPF then \n      o.Direction := (Player.Center.X - o.Center.X, Player.Center.Y - o.Center.Y);\n    o.MoveTime(dt);\n  end;\n  \n  if Player.IntersectionList.Any(o → o is MonsterWPF) then\n    GameOver;\n\n  if Player.Number >= 10 then\n    GameOverWin;\nend;"
  },
  {
    "instruction": "Demonstrate usage of generic types with short type names in template parameters in PascalABC.NET",
    "output": "begin\n  var q := new Queue<(integer,integer)>;\n  q.Enqueue((1,2));\n  q.Enqueue((2,5));\n  q.Println;\n  Println(q);\n  \n  var l := new List<integer->integer>;\n  l.Add(x->x);\n  l.Add(x->x*x);\n  l.ForEach(f->Print(f(5)));\n  Println;\n  \n  var l1 := new List<(integer,integer)->integer>;\n  l1.Add((x,y)->x+y);\n  l1.Add((x,y)->x-y);\n  l1.Add((x,y)->x*y);\n  l1.ForEach(f->Print(f(2,3)));\nend."
  },
  {
    "instruction": "Demonstrate simple new language features in PascalABC.NET including variable initialization and type inference",
    "output": "// Simple new features of PascalABC.NET language\n\n// Variable initialization at declaration \nvar i: integer := 1; \n\n// Automatic variable type inference at initialization\nvar r := 2.5;\n\nbegin\n  // In-block variable declarations\n  var s: real := 1.0;\n  \n  // Variable declaration in loop header (variable lifetime - until end of loop body)\n  for var j: integer := 1 to 10 do\n    s += j; // += operation for numbers\n\n  var p := 1;\n  \n  // Variable declaration in loop header with automatic type inference\n  for var j := 1 to 10 do\n    p *= j; // *= operation\n    \n  var str := '';\n  for var c: char := 'a' to 'z' do\n    str += c; // += operation for strings\n  \nend."
  },
  {
    "instruction": "Create a simple text editor using CRT in PascalABC.NET",
    "output": "uses CRT;\n\nbegin\n  SetWindowTitle('Text editor (Enter - new line, Esc - exit)');\n  clrScr;\n  repeat\n    var c := ReadKey;\n    case c of\n  #13: writeln;\n  #27: break;\n  #32..#255: write(c);\n  #0: c := ReadKey;\n    end;\n  until false;\nend."
  },
  {
    "instruction": "Solve system of linear equations using NumLibABC in PascalABC.NET",
    "output": "uses NumLibABC;\n\nbegin\n  var A:=new Matrix(3,3,2,3,-1,1,-2,1,1,0,2);\n  var B:=new Vector(9,3,2);\n  var cond:real;\n  var x:=A.SLAU(B,cond);\n  x.Println;\n  Writeln('Condition number = ',cond)\nend."
  },
  {
    "instruction": "Implement selection sort algorithm with helper procedures in PascalABC.NET",
    "output": "procedure SortByChoice(a: array of real);\nbegin\n  for var i:=0 to a.Length-2 do\n  begin\n    var min := a[i]; \n    var ind := i;\n    for var j:=i+1 to a.Length-1 do\n      if a[j]<min then\n      begin\n        min := a[j];\n        ind := j;\n      end;\n    a[ind] :=a [i];\n    a[i] := min;\n  end;\nend;\n\nprocedure WriteArr(a: array of real); \nbegin\n  foreach x: real in a do\n    write(x,' ');\n  writeln;\nend;\n\nfunction CreateRandomArr(n: integer): array of real; \nbegin\n  Result := new real[n];\n  for var i:=0 to Result.Length-1 do\n    Result[i] := Random(100);\nend;\n\nvar a: array of real;\n\nbegin\n  a := CreateRandomArr(20);\n  writeln('Array contents: ');\n  WriteArr(a);\n  SortByChoice(a);\n  writeln('After selection sort: ');\n  WriteArr(a);\nend."
  },
  {
    "instruction": "Sort array of tuples using key projection in PascalABC.NET",
    "output": "begin\n  var pp := |('Sidorov',21),('Petrov',23), ('Popov',20),('Ivanov',22)|;\n  Sort(pp, p->p[0]);\n  Println('By last name');\n  pp.Println;\n  Sort(pp, p->p[1]);\n  Println('By age');\n  pp.Println;\nend."
  },
  {
    "instruction": "Create 3D spheres animation using Graph3D in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin\n  Window.Title := 'Creation of objects... wait!';\n  HideObjects;\n  View3D.ShowGridLines := False;\n  View3D.ShowViewCube := False;\n  View3D.ShowCoordinateSystem := False;\n  \n  var l := new List<SphereT>;\n  \n  var w := 1;\n  for var x := -5 to 5 do\n  for var y := -5 to 5 do\n  for var z := -5 to 5 do\n     l.Add(Sphere(x*w,y*w,z*w,w*0.5,RandomColor));\n  ShowObjects;\n\n  Window.Title := 'Spheres animation';\n  \n  foreach var x in l do\n    x.AnimMoveBy(Random,Random,Random).AutoReverse.Forever.Begin;\nend."
  },
  {
    "instruction": "Perform cubic spline interpolation using NumLibABC in PascalABC.NET",
    "output": "uses NumLibABC;\n\nbegin\n  var f:real->real:=x->(3*x-8)/(8*x-4.1);\n  var pt:=PartitionPoints(1.0,10.0,18).Select(x->new Point(x,f(x))).ToArray;\n  var oL:=new Spline(pt);\n  var r:=oL.Value(4.8);\n  Writeln('Value of approximated function for x=4.8: ',r);\n  var (d1,d2):=oL.Diff(4.8);\n  Writeln('Values of 1st and 2nd derivatives at this point: ',d1,' ',d2)\nend."
  },
  {
    "instruction": "Calculate square root using iterative method in PascalABC.NET",
    "output": "var x := 2.0;\nSeqGen(6,x,a → (a + x/a) / 2).Last.Println;\nx.Sqrt.Print;"
  },
  {
    "instruction": "Demonstrate array and set operations with square brackets in PascalABC.NET",
    "output": "begin\n  var a := [1,2,3];\n  Println(a,TypeName(a));\n  var s := [2..4];\n  Println(s,TypeName(s));\n  var s1: set of byte := [3,4,5];\n  Println(s1,TypeName(s1));\n  Println(s + [1,2,3], s * [1,2,3], [1,2,3] - s, s - [1,2,3]); \n  Println(a + [7,8,9], a * 3);\n  Println(5 in [3,5,7], 5 in [3..5,7]);\nend."
  },
  {
    "instruction": "Use pattern matching to calculate areas of different shapes in PascalABC.NET",
    "output": "type\n  Line = class\n  end;\n  Rectangle = auto class\n    X,Y,Width,Height: real;\n  end;\n  Circle = auto class\n    X,Y,Radius: real;\n  end;\n  \nbegin\n  var l := new List<Object>;\n  l.Add(new Line);\n  l.Add(new Circle(10,10,5));\n  l.Add(new Rectangle(10,10,20,10));\n  foreach var x in l do\n    match x with\n  Line(var ll): Println('Line S =',0);\n  Circle(var c): Println('Circle S =',c.Radius*c.Radius*Pi);\n  Rectangle(var r): Println('Rectangle S =',r.Width*r.Height);\n    end;\nend."
  },
  {
    "instruction": "Implement a generic stack class using arrays in PascalABC.NET",
    "output": "type\n  Stack<T> = class\n  private\n    a: array of T;\n    last: integer;\n  public  \n    constructor Create(sz: integer);\n    begin\n      SetLength(a,sz);\n      last := 0;\n    end;\n    constructor Create;\n    begin\n      Create(100);\n    end;\n    procedure push(i: T);\n    begin\n      a[last] := i;\n      Inc(last);\n    end;\n    function pop: T;\n    begin\n      Dec(last);\n      pop := a[last];\n    end;\n    function top: T;\n    begin\n      top := a[last-1];\n    end;\n    function empty: boolean;\n    begin\n      Result := (last=0);\n    end;\n    function ToString: string; override;\n    begin\n      Result := '';\n      for var i:=0 to last-1 do\n        Result += a[i]+' ';\n    end;\n  end;\n  \nvar s: Stack<integer>;\n\nbegin\n  s := new Stack<integer>;\n  s.push(7);\n  s.push(2);\n  s.push(5);\n  s.push(4);\n  writeln(s);\n  while not s.empty do\n    write(s.pop,' ');\nend."
  },
  {
    "instruction": "Serialize and deserialize a single object in PascalABC.NET",
    "output": "type \n  [Serializable]\n  My = auto class\n    x,y: integer;\n  end;\n\nconst fname = 'a.dat';\n\nbegin\n  var m := new My(2,3);\n  Serialize(fname,m);\n  var m1 := Deserialize(fname) as My;\n  Print(m1);\nend."
  },
  {
    "instruction": "Draw pixels using SetPixel function in GraphABC in PascalABC.NET",
    "output": "uses GraphABC;\n\nbegin\n  for var x:=0 to Window.Width-1 do\n  for var y:=0 to Window.Height-1 do\n    SetPixel(x,y,RGB(2*x-y,x-3*y,x+y));\nend."
  },
  {
    "instruction": "Draw pixels using SetPixel function in GraphWPF in PascalABC.NET",
    "output": "uses GraphWPF;\n\nbegin\n  Window.SetSize(640, 480);\n  for var x := 0 to Window.Width.Round do\n  for var y := 0 to Window.Height.Round do\n    SetPixel(x, y, RGB(2 * x - y, x - 3 * y, x + y));\n  Milliseconds.Println;  \nend."
  },
  {
    "instruction": "Draw pixels using SetPixels function for better performance in GraphWPF in PascalABC.NET",
    "output": "uses GraphWPF;\n\nbegin\n  Window.SetSize(640, 480);\n  SetPixels(0,0,640,480,(x, y)->RGB(2 * x - y, x - 3 * y, x + y));\n  Milliseconds.Println;  \nend."
  },
  {
    "instruction": "Show how to work with sets of strings in PascalABC.NET including union, intersection, and difference operations",
    "output": "// Working with sets\n// Base type for set can be arbitrary\n\nbegin\n  var s1: set of string := ['Ivanov','Popov','Sidorova','Petrov'];\n  var s2: set of string := ['Kozlov','Petrov','Ivanov'];\n  Println('Set s1:',s1);\n  Println('Set s2:',s2);\n  Println('Union of sets s1 and s2:',s1+s2);\n  Println('Intersection of sets s1 and s2:',s1*s2);\n  Println('Difference of sets s1 and s2:',s1-s2);\n  Include(s1,'Umnov');\n  Exclude(s1,'Ivanov');\n  Println('Set s1:',s1);\nend."
  },
  {
    "instruction": "Demonstrate shl (shift left) operation to calculate powers of 2 in PascalABC.NET",
    "output": "begin\n  Writeln('Powers of two');\n  Writeln(' n         2^n');\n  for var i:=0 to 30 do\n    Writeln(i:2,(1 shl i):12);\nend."
  },
  {
    "instruction": "Create a text stamp class with move functionality in PascalABC.NET",
    "output": "uses GraphABC;\n\ntype \n  TextStamp = auto class\n    x,y,pt: integer;\n    Text: string;\n    procedure Stamp;\n    begin\n      Font.Size := pt;\n      TextOut(x,y,text);\n    end;\n    procedure MoveOn(dx,dy: integer);\n    begin\n      x += dx; y += dy;\n    end;\n  end;\n  \nbegin\n  var txt := new TextStamp(200,200,14,'Привет!');\n  txt.Stamp;\n  txt.MoveOn(0,40);\n  txt.Text := 'До свидания!';\n  txt.Stamp;\nend."
  },
  {
    "instruction": "Create a cross stamp class with cloning and relative movement in PascalABC.NET",
    "output": "uses GraphABC;\n\ntype \n  CrossStamp = class\n    x,y,w: integer;\n    constructor (xx,yy,ww: integer);\n    begin\n      x := xx; y := yy;\n      w := ww; \n    end;\n    procedure Stamp;\n    begin\n      MoveTo(x,y);\n      LineTo(x+w,y);\n      LineTo(x+w,y+w);\n      LineTo(x+2*w,y+w);\n      LineTo(x+2*w,y);\n      LineTo(x+3*w,y);\n      LineTo(x+3*w,y-w);\n      LineTo(x+2*w,y-w);\n      LineTo(x+2*w,y-2*w);\n      LineTo(x+w,y-2*w);\n      LineTo(x+w,y-w);\n      LineTo(x,y-w);\n      LineTo(x,y);\n    end;\n    procedure MoveOn(dx,dy: integer);\n    begin\n      x += dx; y += dy;\n    end;\n    procedure MoveOnRel(a,b: integer);\n    begin\n      MoveOn(a*w,b*w);\n    end;\n    function Clone := new CrossStamp(x,y,w);\n  end;\n  \nbegin\n  var r := new CrossStamp(100,150,20);\n  for var k:=1 to 2 do\n  begin\n    var r1 := r.Clone;\n    for var i:=1 to 8 do\n    begin\n      r1.Stamp;\n      r1.MoveOnRel(2,1);\n    end;\n    r.MoveOnRel(-1,2);\n  end;\nend."
  },
  {
    "instruction": "Create a compound stamp class combining rectangle and text in PascalABC.NET",
    "output": "uses GraphABC;\n\ntype \n  TextStamp = class\n    x,y,pt: integer;\n    Text: string;\n    constructor (xx,yy,ppt: integer; t: string);\n    begin\n      x := xx; y := yy;\n      pt := ppt; \n      text := t;\n    end;\n    procedure Stamp;\n    begin\n      Font.Size := pt;\n      Brush.Color := clWhite;\n      TextOut(x,y,text);\n    end;\n    procedure MoveOn(dx,dy: integer);\n    begin\n      x += dx; y += dy;\n    end;\n  end;\n  \n  RectangleStamp = class\n    x,y,w,h: integer;\n    constructor (xx,yy,ww,hh: integer);\n    begin\n      x := xx; y := yy;\n      w := ww; h := hh;\n    end;\n    procedure Stamp;\n    begin\n      Brush.Color := clRandom;\n      Rectangle(x,y,x+w,y+h);\n    end;\n    procedure MoveOn(dx,dy: integer);\n    begin\n      x += dx; y += dy;\n    end;\n  end;\n  \n  RectWithTextStamp = class\n    x,y,w,h: integer;\n    Text: string;\n    constructor (xx,yy,ww,hh: integer; t: string);\n    begin\n      x := xx; y := yy;\n      w := ww; h := hh;\n      text := t;\n    end;\n    procedure Draw;\n    begin\n      var r := new RectangleStamp(x,y,w,-h);\n      var t := new TextStamp(x,y+3,10,Text);\n      r.Stamp;\n      t.Stamp;\n    end;\n    procedure MoveOn(dx,dy: integer);\n    begin\n      x += dx; y += dy;\n    end;\n  end;"
  },
  {
    "instruction": "Create a function stamp class for plotting mathematical functions in PascalABC.NET",
    "output": "uses GraphABC;\n\ntype \n  FuncType = function (r: real): real;\n  FuncStamp = class\n    xs0,ys0,ws,hs: integer;\n    xf0,yf0,wf,hf: real;\n    f: FuncType;\n    constructor (xs0p,ys0p,xs1p,ys1p: integer; xf0p,yf0p,xf1p,yf1p: real; ff: FuncType);\n    begin\n      SetScreenWindow(xs0p,ys0p,xs1p,ys1p);\n      SetFuncWindow(xf0p,yf0p,xf1p,yf1p);\n      f := ff;\n    end;\n    function WorldToScreenX(xf: real): integer;\n    begin\n      var a := ws/wf;\n      var b := xs0-a*xf0;\n      Result := Round(a * xf + b);\n    end;\n    function WorldToScreenY(yf: real): integer;\n    begin\n      var c := hs/hf;\n      var d := ys0-c*yf0;\n      Result := hs + 2*ys0 - Round(c * yf + d);\n    end;\n    procedure Stamp;\n    const n = 100;\n    begin\n      Pen.Color := Color.Gray;\n      Rectangle(xs0,ys0,xs0+ws,ys0+hs);\n      Pen.Color := Color.Black;\n      var x := xf0;\n      var y := f(x);\n      var h := wf/n;\n      var xs := WorldToScreenX(x);\n      var ys := WorldToScreenY(y);\n      MoveTo(xs,ys);\n      for var i:=1 to n do\n      begin\n        x += h;\n        y := f(x);\n        xs := WorldToScreenX(x);\n        ys := WorldToScreenY(y);\n        LineTo(xs,ys);\n      end;  \n    end;\n    procedure SetScreenWindow(xs0p,ys0p,xs1p,ys1p: integer);\n    begin\n      xs0 := xs0p; ys0 := ys0p;\n      ws := xs1p-xs0p; hs := ys1p-ys0p;\n    end;\n    procedure SetFuncWindow(xf0p,yf0p,xf1p,yf1p: real);\n    begin\n      xf0 := xf0p; yf0 := yf0p;\n      wf := xf1p-xf0p; hf := yf1p-yf0p;\n    end;\n    procedure MoveOn(dx,dy: integer);\n    begin\n      xs0 += dx; ys0 += dy;\n    end;\n  end;"
  },
  {
    "instruction": "Create a regular polygon stamp class with cloning in PascalABC.NET",
    "output": "uses GraphABC;\n\ntype \n  RegularPolygonStamp = class\n    x,y,r: real;\n    n: integer;\n    constructor (xx,yy,rr: real; nn: integer);\n    begin\n      x := xx; y := yy;\n      r := rr; n := nn;\n    end;\n    procedure Stamp;\n    begin\n      var t := 0.0;\n      var xr := r*cos(t);\n      var yr := r*sin(t);\n      MoveTo(Round(x + xr),Round(y + yr));\n      for var i:=1 to n do\n      begin\n        t += 2*Pi/n;\n        xr := Round(r*cos(t));\n        yr := Round(r*sin(t));\n        LineTo(Round(x + xr),Round(y + yr));\n      end;  \n    end;\n    procedure MoveOn(dx,dy: real);\n    begin\n      x += dx; y += dy;\n    end;\n    function Clone: RegularPolygonStamp;\n    begin\n      Result := new RegularPolygonStamp(x,y,r,n);\n    end;\n  end;\n  \nbegin\n  var r := new RegularPolygonStamp(Window.Center.X,Window.Center.Y,50,6);\n  r.Stamp;\n  var t := 2*Pi/12;\n  var rr := r.r*sqrt(3)+10;\n  for var i:=1 to 6 do\n  begin\n    var r1 := r.Clone;\n    r1.MoveOn(rr*cos(t),rr*sin(t));\n    r1.Stamp;\n    t += 2*Pi/6;\n  end;\nend."
  },
  {
    "instruction": "Display sizes of standard data types in PascalABC.NET",
    "output": "var \n  i: integer;\n  j: shortint;\n  k: smallint;\n  l: longint;\n  i64: int64;\n  b: byte;\n  w: word;\n  lw: longword;\n  car: cardinal;\n  ui64: uint64;\n  r: real;\n  d: double;\n  sn: single;\n  c: char;\n  \nbegin\n  writeln('sizeof(integer) = ':20, sizeof(integer));\n  writeln('sizeof(shortint) = ':20,sizeof(shortint));\n  writeln('sizeof(smallint) = ':20,sizeof(smallint));\n  writeln('sizeof(longint) = ':20, sizeof(longint));\n  writeln('sizeof(int64) = ':20,   sizeof(int64));\n  writeln('sizeof(byte) = ':20,    sizeof(byte));\n  writeln('sizeof(word) = ':20,    sizeof(word));\n  writeln('sizeof(longword) = ':20,sizeof(longword));\n  writeln('sizeof(cardinal) = ':20,sizeof(cardinal));\n  writeln('sizeof(uint64) = ':20,  sizeof(uint64));\n  writeln('sizeof(real) = ':20,    sizeof(real));\n  writeln('sizeof(double) = ':20,  sizeof(double));\n  writeln('sizeof(single) = ':20,  sizeof(single));\n  writeln('sizeof(char) = ':20,    sizeof(char));\nend."
  },
  {
    "instruction": "Show standard mathematical functions and string concatenation in PascalABC.NET",
    "output": "// Standard functions\n\nbegin\n  var x := ReadReal('Enter x:');\n  Println('Square of', x, 'equals', Sqr(x));\n  Println(x, 'to power 5 equals', Power(x, 5));\n  Println('Square root of', x, 'equals', Sqrt(x));\n  Println('Absolute value of', x, 'equals', Abs(x));\n  Println('Natural logarithm of', x, 'equals', Ln(x));\n  Println('Sine of', x, 'equals', Sin(x));\n  Println('Cosine of', x, 'equals', Cos(x));\nend.\n\n// String concatenation\n\nbegin\n  var s1 := 'Pascal';\n  var s2 := 'NET';\n  Writeln(s2, '-', s1);\n  Writeln(s1, '.', s2);\nend."
  },
  {
    "instruction": "Draw a star using polar coordinates in PascalABC.NET",
    "output": "uses GraphABC;\n\nconst \n  n = 17;\n  n1 = 7;\n\nbegin\n  var a := -Pi/2;\n  var Center := Window.Center;\n  var Radius := Window.Height/2.2;\n  MoveTo(Round(Center.X+Radius*cos(a)),Round(Center.Y+Radius*sin(a)));\n  for var i:=1 to n do\n  begin\n    a += n1*2*Pi/n;\n    LineTo(Round(Center.X+Radius*cos(a)),Round(Center.Y+Radius*sin(a)));\n  end;\nend."
  },
  {
    "instruction": "Create object movement and rotation controls using WPFObjects in PascalABC.NET",
    "output": "uses Controls,WPFObjects;\n\nbegin\n  Window.Title := 'Controls module - StatusBar';\n  var l := LeftPanel(180,Colors.Orange);\n  \n  var c := new RectangleWPF(50,200,80,50,Colors.Green);\n  c.Direction := (1,0);\n  c.Velocity := 0;\n  c.Tag := 0;\n  \n  OnDrawFrame := dt -> begin\n    c.MoveTime(dt);  \n    c.RotateAngle += integer(c.Tag) * dt;\n  end;\n\n  Button('Start movement').Click := procedure -> begin\n    c.Velocity := 30;\n  end;\n  Button('Stop movement').Click := procedure -> begin\n    c.Velocity := 0;\n  end;\n  Button('Start rotation').Click := procedure -> begin\n    c.Tag := 30;\n  end;\n  Button('Stop rotation').Click := procedure -> begin\n    c.Tag := 0;\n  end;\nend."
  },
  {
    "instruction": "Use high-precision Stopwatch for timing measurements in PascalABC.NET",
    "output": "begin\n  var stopWatch := new System.Diagnostics.Stopwatch;\n  stopWatch.Start;\n \n  Sleep(123);\n \n  stopWatch.Stop;\n  var ts := stopWatch.Elapsed;\n  writelnFormat('Elapsed time: {0:00}:{1:00}:{2:00}.{3:000}',ts.Hours, ts.Minutes, ts.Seconds, ts.Milliseconds);\nend."
  },
  {
    "instruction": "Create a basic rectangle stamp class in PascalABC.NET",
    "output": "uses GraphABC;\n\ntype \n  RectangleStamp = auto class\n    x,y,w,h: integer;\n    procedure Stamp;\n    begin\n      Rectangle(x,y,x+w,y+h);\n    end;\n  end;\n\nbegin\n  var r := new RectangleStamp(30,30,50,50);\n  r.Stamp;\n  for var i:=1 to 10 do\n  begin\n    r.x := r.x + r.w +5;\n    r.Stamp;\n  end;\nend."
  },
  {
    "instruction": "Create a row of rectangles stamp class in PascalABC.NET",
    "output": "uses GraphABC;\n\ntype \n  RectangleStamp = auto class\n    x,y,w,h: integer;\n    procedure Stamp;\n    begin\n      Rectangle(x,y,x+w,y+h);\n    end;\n  end;\n  \n  RowRectanglesStamp = auto class\n    x,y,w,h,n: integer;\n    procedure Stamp;\n    begin\n      var r := new RectangleStamp(x,y,w,h);\n      r.Stamp;\n      for var i:=1 to n-1 do\n      begin\n        r.x += r.w + 5;\n        r.Stamp;\n      end;\n    end;\n  end;  \n\nconst n=8;\n\nbegin\n  var r := new RowRectanglesStamp(30,30,50,50,n);\n  r.Stamp;\n  for var i:=1 to n-1 do\n  begin\n    r.y += r.h + 5;\n    r.Stamp;\n  end;\nend."
  },
  {
    "instruction": "Create a rectangle stamp with increase/decrease methods in PascalABC.NET",
    "output": "uses GraphABC;\n\ntype \n  RectangleStamp = auto class\n    x,y,w,h: integer;\n    procedure Stamp := Rectangle(x,y,x+w,y+h);\n    procedure Increase(dw,dh: integer);\n    begin\n      w += dw; h += dh;    \n    end;\n    procedure Decrease(dw,dh: integer) := Increase(-dw,-dh);      \n    procedure MoveOn(dx,dy: integer);\n    begin\n      x += dx; y += dy;\n    end;\n  end;\n  \nbegin\n  var r := new RectangleStamp(100,100,300,300);\n  r.Stamp;\n  while r.w>2 do\n  begin\n    r.Decrease(8,8);\n    r.MoveOn(4,4);\n    r.Stamp;\n  end;\nend."
  },
  {
    "instruction": "Create a rectangle stamp with center-based resizing in PascalABC.NET",
    "output": "uses GraphABC;\n\ntype \n  RectangleStamp = class\n    x,y,w,h: integer;\n    constructor (xx,yy,ww,hh: integer);\n    begin\n      x := xx; y := yy;\n      w := ww; h := hh;\n    end;\n    procedure Stamp;\n    begin\n      Rectangle(x,y,x+w,y+h);\n    end;\n    procedure IncreaseFromCenter(dw: integer);\n    begin\n      w += dw*2; h += dw*2;\n      x -= dw; y -= dw;\n    end;\n    procedure DecreaseFromCenter(dw: integer);\n    begin\n      IncreaseFromCenter(-dw);      \n    end;\n    procedure MoveOn(dx,dy: integer);\n    begin\n      x += dx; y += dy;\n    end;\n  end;\n  \nbegin\n  var r := new RectangleStamp(100,100,300,300);\n  r.Stamp;\n  while r.w>2 do\n  begin\n    r.DecreaseFromCenter(4);\n    r.Stamp;\n  end;\nend."
  },
  {
    "instruction": "Create a triangle stamp with orientation in PascalABC.NET",
    "output": "uses GraphABC;\n\ntype \n  TriangleStamp = auto class\n    x,y,w,orient: integer;\n    procedure Stamp;\n    begin\n      MoveTo(x,y);\n      var dx := w;\n      var dy := w;\n      case orient of\n     2: dx := -dx;\n     3: dy := -dy;\n     4: begin dx := -dx; dy := -dy; end;\n      end;\n      LineTo(x+dx,y);\n      LineTo(x,y+dy);\n      LineTo(x,y);      \n    end;\n    procedure MoveOn(dx,dy: integer);\n    begin\n      x += dx; y += dy;\n    end;\n  end;\n  \nbegin\n  var r := new TriangleStamp(200,200,100,1);\n  r.Stamp;\n  r.orient := 2;\n  r.Stamp;\n  r.orient := 3;\n  r.Stamp;\n  r.orient := 4;\n  r.Stamp;\nend."
  },
  {
    "instruction": "Work with static arrays - basic usage in PascalABC.NET",
    "output": "const n=10;\n\nvar a: array [1..n] of real;\n\nbegin\n  for var i:=1 to n do\n    a[i] := Random*10;\n  writeln('Contents of random real array: ');  \n  foreach x: real in a do\n    write(x:4:2,'  ');\nend."
  },
  {
    "instruction": "Work with static arrays as procedure parameters in PascalABC.NET",
    "output": "const n=10;\n\ntype RealArr = array [1..n] of real;\n\nprocedure FillArrByRandom(var a: RealArr; n: integer);\nbegin\n  for var i:=1 to n do\n    a[i] := Random*10;\nend;\n\nprocedure PrintArr(const a: RealArr; n: integer);\nbegin\n  foreach x: real in a do\n    write(x:4:2,'  ');\nend;\n\nvar a: RealArr;\n\nbegin\n  FillArrByRandom(a,n);\n  writeln('Contents of random real array: ');  \n  PrintArr(a,n);\nend."
  },
  {
    "instruction": "Use exit procedure to exit from subroutines in PascalABC.NET",
    "output": "const n=10;\n\ntype IntArr = array [1..n] of integer;\n\nprocedure FillArrByRandom(var a: IntArr; n: integer);\nbegin\n  for var i:=1 to n do\n    a[i] := Random(10);\nend;\n\nprocedure PrintArr(const a: IntArr; n: integer);\nbegin\n  foreach x: integer in a do\n    write(x,' ');\n  writeln;  \nend;\n\nfunction IndexOf(const a: IntArr; n: integer; k: integer): integer;\nbegin\n  Result := 0;\n  for var i := 1 to n do\n    if a[i]=k then\n    begin\n      Result := i;\n      exit;\n    end;  \nend;\n\nvar a: IntArr;\n\nbegin\n  FillArrByRandom(a,n);\n  writeln('Random integer array: ');\n  PrintArr(a,n);\n  \n  var ind := IndexOf(a,n,7);\n  if ind>0 then\n    writeln('Index of first element 7 equals ', ind)\n  else writeln('Element 7 not found');\nend."
  },
  {
    "instruction": "Show how to create a simple generic Stack class based on arrays in PascalABC.NET",
    "output": "// Demonstration of creating simple stack class based on array\ntype\n  Stack<T> = class\n  private\n    a: array of T;\n    last: integer;\n  public  \n    constructor Create(sz: integer);\n    begin\n      SetLength(a,sz);\n      last := 0;\n    end;\n    constructor Create;\n    begin\n      Create(100);\n    end;\n    procedure Push(i: T);\n    begin\n      a[last] := i;\n      Inc(last);\n    end;\n    function Pop: T;\n    begin\n      Dec(last);\n      Result := a[last];\n    end;\n    function Top: T;\n    begin\n      Result := a[last-1];\n    end;\n    function Empty: boolean;\n    begin\n      Result := last=0;\n    end;\n    function ToString: string; override;\n    begin\n      Result := '';\n      for var i:=0 to last-1 do\n        Result += a[i]+' ';\n    end;\n  end;\n  \nbegin\n  var s := new Stack<integer>;\n  s.Push(7);\n  s.Push(2);\n  s.Push(5);\n  s.Push(4);\n  Println(s);\n  while not s.Empty do\n    Print(s.Pop);\nend."
  },
  {
    "instruction": "Demonstrate string concatenation and character access in PascalABC.NET",
    "output": "var s: string := 'Pascal';\n\nbegin\n  writeln(s);\n  s := s + '.';\n  writeln(s);\n  s += 'NET';\n  writeln(s);\n  writeln(s[1],' ',s[2],' ',s[3],' ',s[4],' ',s[5],' ',s[6]);\nend."
  },
  {
    "instruction": "Demonstrate string length manipulation using SetLength and Length in PascalABC.NET",
    "output": "var s: string;\n\nbegin\n  writeln('Length(s) = ',Length(s));\n  SetLength(s,3);\n  s[1] := 'N';\n  s[2] := 'E';\n  s[3] := 'T';\n  writeln(s,'     Length(s) = ',Length(s));\n  for var i:= 1 to s.Length do\n    write(s[i],' ');\nend."
  },
  {
    "instruction": "Demonstrate dynamic string length capabilities in PascalABC.NET",
    "output": "var s: string;\n    \nbegin\n  s := 'abcdefghijklmnopqrstuvwxyz';\n  s := s + Uppercase(s);\n  s += s; \n  s += s; \n  s += s;\n  writeln('String length = ',s.Length);\n  writeln('String: ',s);\nend."
  },
  {
    "instruction": "Demonstrate fixed-length strings and shortstring in PascalABC.NET",
    "output": "var \n  s: string[9];\n  s1: shortstring;\n  slong: string;\n    \nbegin\n  slong := 'PascalABC.NET';\n  writeln('Variable length string: ',slong);\n  s := slong;\n  writeln('Fixed length string gets truncated: ',s);\nend."
  },
  {
    "instruction": "Use standard string procedures for string manipulation in PascalABC.NET",
    "output": "var \n  s: string := '  Pascal__NET  ';\n  s1: string := 'NET';\n    \nbegin\n  writeln('Original string: ''',s,'''');\n  s := Trim(s);\n  writeln('After Trim function: ''',s,'''');\n  var p := Pos(s1,s);\n  writelnFormat('Position of substring ''{0}'' in string ''{1}'' equals {2}',s1,s,p);\n  Delete(s,7,2);\n  writeln('After deleting __ characters: ',s);\n  Insert('ABC.',s,7);\n  writeln('After inserting substring ''ABC.'': ',s);\n  writeln('First part of string: ',Copy(s,1,9));\n  writeln('Last part of string: ',Copy(s,11,3));\nend."
  },
  {
    "instruction": "Show various string methods available in PascalABC.NET including trimming, searching, and manipulation",
    "output": "// Strings. Methods of string class\nvar \n  s: string := '  Pascal__NET  ';\n  s1: string := 'NET';\n    \nbegin\n  Println($'Original string: ''{s}''');\n  s := s.Trim;\n  Println($'After calling s.Trim: ''{s}''');\n  var p := s.IndexOf(s1); // Indexing - from zero\n  Println($'Position of substring ''{s1}'' in string ''{s}'' equals {p}');\n  s := s.Remove(6,2);\n  Println('After removing characters __:',s);\n  s := s.Insert(6,'ABC.');\n  Println('After inserting substring ''ABC.'':',s);\n  Println('First part of string:',s.Substring(0,9));\n  Println('Last part of string:',s.Substring(10,3));\nend."
  },
  {
    "instruction": "Convert between strings and numbers using TryParse in PascalABC.NET",
    "output": "begin\n  var s := '123,3443';\n  var r: real;\n  if not real.TryParse(s, r) then\n    Writeln('String s is not a valid real number representation')\n  else Writeln(r);\n     \n  var i: integer;\n  if not integer.TryParse(s, i) then\n    Writeln('String s is not a valid integer representation');\n     \n  i := 10;\n  s := i.ToString;\n  Writeln(s);\n  \n  s := '';\n  for i:=1 to 9 do\n    s += i.ToString;\n  Writeln(s);\nend."
  },
  {
    "instruction": "Demonstrate string-integer conversion using modern style methods in PascalABC.NET",
    "output": "// Integer <-> string conversion in new style \n\nbegin\n  // Integer to string conversion\n  var i: integer := 234;\n  var s: string := i.ToString;\n  Println($'Integer: {i}. After conversion to string: ''{s}''');\n  \n  // String to integer conversion\n  s := '567';\n  if integer.TryParse(s,i) then\n    Println($'String: ''{s}''. After conversion to integer: {i}');\nend."
  },
  {
    "instruction": "Convert between integers and strings using IntToStr and StrToInt in PascalABC.NET",
    "output": "var \n  s: string;\n  i: integer;\n\nbegin\n  i := 234;\n  s := IntToStr(i);\n  writelnFormat('Integer: {0}. After conversion to string: ''{1}''',i,s);\n  \n  s := '567';\n  i := StrToInt(s);\n  writelnFormat('String: ''{0}''. After conversion to integer: {1}',s,i);\nend."
  },
  {
    "instruction": "Convert between integers and strings using Val and Str procedures in PascalABC.NET",
    "output": "var \n  s: string;\n  i: integer;\n\nbegin\n  i := 234;\n  Str(i,s);\n  writelnFormat('Integer: {0}. After conversion to string: ''{1}''',i,s);\n  \n  s := '567';\n  var err: integer;\n  Val(s,i,err);\n  if err=0 then\n    writelnFormat('String: ''{0}''. After conversion to integer: {1}',s,i);\nend."
  },
  {
    "instruction": "Convert between real numbers and strings in PascalABC.NET",
    "output": "var \n  s: string;\n  r: real;\n\nbegin\n  r := 3.1415;\n  s := FloatToStr(r);\n  writelnFormat('Real: {0}. After conversion to string: ''{1}''',r,s);\n  \n  s := '3.1415';\n  r := StrToFloat(s);\n  writelnFormat('String: ''{0}''. After conversion to real: {1}',s,r);\nend."
  },
  {
    "instruction": "Demonstrate various string methods including length and comparison in PascalABC.NET",
    "output": "begin\n  var s1 := 'ABCDEFGH';\n  Writeln(s1.Length);\n\n  s1 := 'AAA';\n  var s2 := 'aaa';\n  if String.Compare(s1, s2, true) = 0 then\n    Writeln('Strings match ignoring case');\n  \n  s1 := 'Long string';\n  s2 := 'string';\n  if s1.EndsWith(s2) then\n    Writeln('String s1 ends with substring s2');\n    \n  Writeln(s1.IndexOf(s2));\n    \n  s1 := 'ABCDEFGH';\n  s2 := s1.Substring(3);\n  Writeln(s2);\n  \n  s2 := s1.Substring(3, 2);\n  Writeln(s2);\nend."
  },
  {
    "instruction": "Demonstrate string manipulation methods including insert, replace and remove in PascalABC.NET",
    "output": "begin\n  var s1 := 'ABCDEFGH';\n  var s2 := s1.Substring(3);\n  Writeln(s2);\n  \n  s2 := s1.Substring(3, 2);\n  Writeln(s2);\n  \n  s1 := 'ABCDEFGH';\n  s2 := s1.Insert(2, 'xxx');\n  Writeln(s2);\n  \n  s2 := s2.Replace('x', '!');\n  Writeln(s2);\n  \n  s2 := s2.Remove(2, 3);\n  Writeln(s2);\n  \n  s1 := 'слово слово слово';\n  s2 := s1.Replace('слов', 'молок');\n  Writeln(s2);\n  \n  s1 := '    xxx  xxx    ';\n  Writeln('|', s1, '|');\n  s1 := s1.Trim;\n  Writeln('|', s1, '|');\n  \n  s1 := 'абвгд';\n  s1 := s1.ToUpper;\n  Writeln(s1);\nend."
  },
  {
    "instruction": "Demonstrate string concatenation with plus operator in PascalABC.NET",
    "output": "var s1: string := 'Pascal';\nvar s2: string := 'NET';\n\nbegin \n  Writeln(s2+'-'+s1);\n  Writeln(s1+'.'+s2);\nend."
  },
  {
    "instruction": "Split string into array and process numeric values in PascalABC.NET",
    "output": "begin\n  var s: string := '12 765 765 76';\n  var str_arr: array of string := s.Split;\n  \n  s := str_arr.JoinToString(' + ');\n  Write(s, ' = ');\n  \n  var int_arr := new integer[str_arr.Length];\n  for var i:=0 to int_arr.Length-1 do\n    integer.TryParse(str_arr[i], int_arr[i]);\n  \n  var sum := 0;\n  foreach var v: integer in int_arr do\n    sum += v;\n  Writeln(sum);\nend."
  },
  {
    "instruction": "Explain different string types in PascalABC.NET: string, string[n], and shortstring with memory characteristics",
    "output": "// Strings string, string[n], shortstring\nvar \n  s: string; // memory occupied by s depends on its length\n  s10: string[10]; // memory for ss is fixed\n  ss: shortstring := s;\n  f: file of string[10];\n  // f: file of string; - error\n\nbegin\n  s := '12345678901234567890';\n  s10 := s; // truncation\n  Println(s10);\n  s += s; s += s;\n  s += s; s += s;\n  Println(s);\n  Println('String length =',s.Length);\nend."
  },
  {
    "instruction": "Demonstrate structural type equivalence in PascalABC.NET",
    "output": "var \n  a: array of integer;\n  a1: array of integer;\n  s: set of real;\n  s1: set of real;\n  p: procedure (i: integer);\n  p1: procedure (i: integer);\n  r: ^integer;\n  r1: ^integer;\n\nprocedure proc(aa: array of integer; ss: set of real; pp: procedure (i: integer); rr: ^integer);\nbegin\n  \nend;\n\nbegin\n  a := a1;\n  s := s1;\n  p := p1;\n  r := r1;\n  proc(a,s,p,r);\nend."
  },
  {
    "instruction": "Compare string parameter passing by value vs by reference performance in PascalABC.NET",
    "output": "var ss:int64 := 0;\n\nprocedure p(s: string);\nbegin\n  s[1] := '1';\nend;\n\nprocedure q(var s: string);\nbegin\n  s[1] := '1';\nend;\n\nbegin\n  var n := 100000000;\n  var s := 'a'*n;\n  MillisecondsDelta;\n  loop 10 do\n    p(s);\n  Println(s[:3]);\n  MillisecondsDelta.Println;\n  loop 10 do\n    q(s);\n  Println(s[:3]);\n  MillisecondsDelta.Println;\nend."
  },
  {
    "instruction": "Demonstrate generic functions with type inference from parameter types in PascalABC.NET using Swap<T> as example",
    "output": "// Generic functions\n// Type T inference from parameter types\n\nprocedure Swap<T>(var a,b: T);\nbegin\n  var v := a;\n  a := b;\n  b := v;\nend;\n\nbegin\n  var a := 2;\n  var b := 3;\n  Println($'Before Swap a={a}, b={b}');\n  Swap(a,b);\n  Println($'After Swap a={a}, b={b}');\n  var c := 2.5;\n  var d := 3.3;\n  Println;\n  Println($'Before Swap c={c}, d={d}');\n  Swap(c,d);\n  Println($'After Swap c={c}, d={d}');\nend."
  },
  {
    "instruction": "Use System.Timers.Timer with event handlers in PascalABC.NET",
    "output": "uses System;\n\nvar\n  Timer: System.Timers.Timer;\n  x: integer;\n  exit: boolean;\n\nprocedure OnTimer2(sender: object; e: System.Timers.ElapsedEventArgs);\nbegin\n  Writeln(x);\n  x := x + 1;\n  exit := x >= 10;\nend;\n\nprocedure OnTimer1(sender: object; e: System.Timers.ElapsedEventArgs);\nbegin\n  Writeln(e.SignalTime);\n  x := x + 1;\n  if x >= 5 then begin\n    Timer.Elapsed -= OnTimer1;\n    Timer.Elapsed += OnTimer2;\n  end;\nend;\n\nbegin\n  Exit := false;\n  Timer := System.Timers.Timer.Create(1000);\n  Timer.Elapsed += OnTimer1;\n  Timer.Start;\n  while not exit do \n    Sleep(Round(Timer.Interval));\nend."
  },
  {
    "instruction": "Explain name resolution order in PascalABC.NET when using System unit and how it affects access to PABCSystem functions",
    "output": "// Illustration of name search first from right to left in uses section, then in system module PABCSystem \nuses System;\n\nbegin\n  // Name Random, defined in System namespace, overrides name Random \n  // in PABCSystem module, which is implicitly connected first\n  var r: Random := new Random();\n  Println(r.Next(10));\n  // That's why before this Random it's necessary to explicitly specify module name where it's located\n  var i: integer := PABCSystem.Random(10);\n  Println(i);\nend."
  },
  {
    "instruction": "Create a tentacles animation using trigonometric functions in PascalABC.NET",
    "output": "uses GraphABC;\n\nconst\n  S = 14;\n  N = 18;\n  W = 2;\n\nvar\n  i, j: Integer;\n  x, y: Real;\n  tx, ty: Real;\n  k, d: Real;\n  a: array [1..N] of Real;\n  len: Real;\n\nbegin\n  Pen.Width := W;\n  SetWindowSize(320, 320);\n  SetWindowTitle('Tentacles');\n  \n  if Window.Width > Window.Height then\n    len := Window.Height / 1.8 / N\n  else\n    len := Window.Width / 1.8 / N;\n  k := random(360) * pi / 180;\n  d := pi * 2 / S;\n  \n  var k1 := 1;\n  \n  repeat\n    if Window.Width > Window.Height then\n      len := Window.Height / 1.8 / N\n    else\n      len := Window.Width / 1.8 / N;\n    \n    LockDrawing();\n    ClearWindow(ClBlack);\n    \n    if random(50) = 0 then\n      k := random(360) * pi / 180;\n    \n    a[1] := a[1] + sin(k) / 15;\n\n    for i := 2 to N do \n      a[i] := a[i] + (a[i - 1] - a[i]) * 0.1;\n    for j := 0 to S - 1 do\n    begin\n      x := 0.5 * Window.Width;\n      y := 0.5 * Window.Height;\n      for i := 2 to N do \n      begin\n        SetPenColor(Color.FromArgb(255, trunc(255 - 255 * i / N), 255));\n        tx := x + cos(j * d + a[i]) * len;\n        ty := y + sin(j * d + a[i]) * len;\n        Line(trunc(x), trunc(y), trunc(tx), trunc(ty));\n        x  := tx;\n        y  := ty;\n      end;\n    end;\n    Redraw();\n\n    k1 += 1;\n    SetWindowTitle('Tentacles( Avg. FPS ' + Format('{0,5:f2}',k1/Milliseconds*1000)+')');\n    \n    sleep(5);\n  until false;\n  \nend."
  },
  {
    "instruction": "Read and display text from the program's own source file in PascalABC.NET",
    "output": "var \n  f: Text;\n\nbegin\n  assign(f,'Text1.pas');\n  reset(f);\n  while not eof(f) do\n  begin\n    var s: string;\n    readln(f,s);\n    writeln(s);\n  end;\n  close(f);\nend."
  },
  {
    "instruction": "Write text array to file in PascalABC.NET",
    "output": "var \n  f: Text;\n  a: array of string := ('Каждый','охотник','желает','знать','где','сидит','фазан');\n\nbegin\n  assign(f,'a.txt');\n  rewrite(f);\n  for var i:=0 to a.Length-1 do \n    writeln(f,a[i]);\n  close(f);\n  writeln('Text written to file a.txt');\nend."
  },
  {
    "instruction": "Write multiplication table to text file in PascalABC.NET",
    "output": "const \n  n = 30;\n  filename = 'pifagor.txt';\n\nvar f: Text;\n\nbegin\n  assign(f,filename);\n  rewrite(f);\n  for var i:=1 to n do \n  begin\n    for var j:=1 to n do \n      write(f,i*j:4);\n    writeln(f);  \n  end;    \n  close(f);\n  writeln('Multiplication table written to file '+filename);\nend."
  },
  {
    "instruction": "Create a simple text editor with file operations in PascalABC.NET",
    "output": "{$apptype windows}\n{$reference 'System.Windows.Forms.dll'}\n{$reference 'System.Drawing.dll'}\n{$resource 'Open.png'}\n{$resource 'Save.png'}\n\nuses System.Windows.Forms;\n\nconst \n  TextFileExt = 'txt';\n  TextFileFilter = 'Text files (*.'+TextFileExt+')|*.'+TextFileExt;\n\nvar\n  myForm: Form;\n  TextBox1: TextBox;\n\nprocedure SaveFile(FileName: string);\nbegin\n  var f := new System.IO.StreamWriter(FileName, false, System.Text.Encoding.Default);\n  f.Write(TextBox1.Text);\n  f.Close;\nend;\n\nprocedure OpenFile(FileName: string);\nbegin\n  var f := new System.IO.StreamReader(FileName, System.Text.Encoding.Default);\n  TextBox1.Text := f.ReadToEnd;\n  f.Close;\nend;\n\nprocedure FormClose(sender: object; args: System.EventArgs);\nbegin\n  myForm.Close;  \nend;\n\nprocedure MenuSaveClick(sender:object; args:System.EventArgs);\nbegin\n  var sd := new SaveFileDialog;\n  sd.DefaultExt := TextFileExt;\n  sd.Filter := TextFileFilter;\n  if sd.ShowDialog=DialogResult.OK then \n    SaveFile(sd.FileName);\nend;\n\nprocedure MenuOpenClick(sender:object; args:System.EventArgs);\nbegin\n  var sd := new OpenFileDialog;\n  sd.DefaultExt := TextFileExt;\n  sd.Filter := TextFileFilter;\n  if sd.ShowDialog = DialogResult.OK then \n    OpenFile(sd.FileName);\nend;\n\nbegin\n  myForm := new Form;\n  myForm.Text := 'Simple text editor';\n\n  TextBox1 := new TextBox;\n  TextBox1.Multiline := True;\n  TextBox1.Height := 100;\n  TextBox1.Dock := DockStyle.Fill;\n  TextBox1.ScrollBars := ScrollBars.Both;\n  TextBox1.Font := new System.Drawing.Font('Courier New',10);\n\n  myForm.Controls.Add(TextBox1);\n  \n  var toolStrip1 := new ToolStrip;\n  toolStrip1.GripStyle := System.Windows.Forms.ToolStripGripStyle.Hidden;\n  var miFile := new ToolStripMenuItem('File');  \n  miFile.DropDownItems.Add(new ToolStripMenuItem('Open', new System.Drawing.Bitmap(GetResourceStream('Open.png')),MenuOpenClick));\n  miFile.DropDownItems.Add(new ToolStripMenuItem('Save as...',new System.Drawing.Bitmap(GetResourceStream('Save.png')),MenuSaveClick));\n  miFile.DropDownItems.Add(new ToolStripMenuItem('Exit',nil,FormClose));\n  toolStrip1.Items.Add(miFile);\n  myForm.Controls.Add(toolStrip1);\n  \n  if CommandLineArgs.Length = 1 then \n    OpenFile(CommandLineArgs[0]);\n      \n  Application.Run(myForm);\nend."
  },
  {
    "instruction": "Count word frequency in a text file using Dictionary in PascalABC.NET",
    "output": "begin\n  var d := new Dictionary<string,integer>;\n  foreach var s in ReadLines('TextFileCount.pas') do\n    foreach var word in s.ToWords(AllDelimiters) do\n      d[word] := d.Get(word) + 1;\n  d.PrintLines;    \nend."
  },
  {
    "instruction": "Count word frequency using Dict initialization in PascalABC.NET",
    "output": "begin\n  var d := Dict('begin' to 0);\n  var words := ReadAllText('TextFileCount1.pas').ToWords(AllDelimiters); \n  foreach var word in words do\n    d[word] := d.Get(word) + 1;\n  d.Print(NewLine);    \nend."
  },
  {
    "instruction": "Display text at mathematical coordinates in GraphWPF in PascalABC.NET",
    "output": "uses GraphWPF;\n\nbegin\n  SetMathematicCoords;\n  var (p1,p2,p3) := (Pnt(0,0),Pnt(2,3),Pnt(4,-1));\n  Circle(p1,0.1);\n  Circle(p2,0.1);\n  Circle(p3,0.1);\n  TextOut(p1,p1);\n  TextOut(p2,p2);\n  TextOut(p3,p3);\nend."
  },
  {
    "instruction": "Use FontOptions for text formatting in GraphWPF in PascalABC.NET",
    "output": "uses GraphWPF;\n\nbegin\n  Window.Title := 'Using FontOptions';\n  TextOut(10,10,'Normal');\n  TextOut(10,40,'Bold',Font.WithStyle(FontStyle.Bold));\n  TextOut(10,70,'20 points',Font.WithSize(20));\n  TextOut(10,110,'Italic blue',Font.WithColor(Colors.Blue).WithStyle((FontStyle.Italic)));\nend."
  },
  {
    "instruction": "Apply texture material to 3D object in Graph3D in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin\n  var m := ImageMaterial('Cells1.png',0.2,0.2);\n  var c := Cube(0,0,2,4,m);\n  c.Rotate(OrtZ,35)\nend."
  },
  {
    "instruction": "Chain animations using WhenCompleted in Graph3D in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin\n  var s := Sphere(Origin,1,Colors.Green);\n  s.AnimMoveByX(5).WhenCompleted(procedure->s.AnimMoveByY(5).Begin).Begin;\n  var s1 := s.Clone;\n  s1.Color := Colors.Blue;\n  s1.AnimMoveByX(-5).WhenCompleted(procedure->s1.AnimMoveByY(-5).Begin).Begin;\nend."
  },
  {
    "instruction": "Overload comparison operators for Student class in PascalABC.NET",
    "output": "type \n  Student = auto class\n    Name: string;\n    Height: integer;\n  public\n    class function operator<(left,right: Student): boolean := left.Height < right.Height;\n    class function operator>(left,right: Student): boolean := left.Height > right.Height;\n    function ToString: string; override := string.Format('{0} ({1})', Name, Height);\n  end;\n\nbegin\n  var s1 := new Student('Stepa Morkovkin',188);\n  var s2 := new Student('Petya Pomidorov',180);\n  Writeln('s1: ',s1);\n  Writeln('s2: ',s2);\n  Writeln;\n  Writeln('s1<s2: ',s1<s2);\n  Writeln('Student.operator>(s1,s2): ',Student.operator>(s1,s2));\nend."
  },
  {
    "instruction": "Compare performance of Substring vs slice operations in PascalABC.NET",
    "output": "begin\n  var s := Range(#32,#1000).JoinIntoString;\n  var s1: string;\n  Milliseconds;\n  var n := 100000000;\n  loop n do\n    s1 := s.Substring(10,10);\n  MillisecondsDelta.Println;\n  loop n do\n    s1 := s[1:11];\n  MillisecondsDelta.Println;\nend."
  },
  {
    "instruction": "Compare performance of LINQ vs traditional loop for sum calculation in PascalABC.NET",
    "output": "begin\n  var n := 100000000;\n  var q := Range(1,n).Select(x->1/x).Sum();\n  Println(q,MillisecondsDelta);\n    \n  var s := 0.0;\n  for var i:=1 to n do\n    s += 1.0/i;\n\n  Println(s,MillisecondsDelta);\nend."
  },
  {
    "instruction": "Swap halves of an array using LINQ operations in PascalABC.NET",
    "output": "var a := Arr(1,3,5,7);\n\nbegin\n  a.Skip(2).Concat(a.Take(2)).Print;\nend."
  },
  {
    "instruction": "Work with arrays using System.Array methods in PascalABC.NET",
    "output": "const Size = 10;\n\nbegin\n  var a := ArrRandomInteger(Size);\n  a.Println;\n  Sort(a);\n  a.Println;\n  Reverse(a);\n  a.Println;\n  var i := a.IndexOf(99);\n  Println(i);\nend."
  },
  {
    "instruction": "Split string into words using custom delimiters in PascalABC.NET",
    "output": "begin\n  var s := '123.4, 6.6; 67';\n  s.ToWords(' ,;').PrintLines  \nend."
  },
  {
    "instruction": "Draw a recursive tree using Turtle graphics in PascalABC.NET",
    "output": "uses Turtle;\n\nprocedure DrawTree(length: real; depth: integer);\nbegin\n  if depth > 0 then\n  begin\n    forw(length);\n    turn(-35);\n    DrawTree(length*0.65, depth-1);\n    turn(70);\n    DrawTree(length*0.65, depth-1);\n    turn(-35);\n    forw(-length);\n  end;\nend;\n\nbegin\n  toPoint(0, -8);\n  down;\n  \n  DrawTree(6, 11);\nend."
  },
  {
    "instruction": "Draw a binary tree recursively using GraphWPF in PascalABC.NET",
    "output": "uses GraphWPF;\n\nconst \n  LevelHeight = 50;\n  Levels = 8;\n  delay = 10;\n\nprocedure DrawTree(x,y,dx: real; level: integer);\nbegin\n  if level>0 then \n  begin\n    DrawTree(x-dx,y+LevelHeight,dx / 2,level-1);\n    Line(x,y,x-dx,y+LevelHeight);\n    Line(x,y,x+dx,y+LevelHeight);\n    Sleep(delay);\n    DrawTree(x+dx,y+LevelHeight,dx / 2,level-1);\n  end;\nend;\n\nbegin\n  Window.Title := 'Recursive binary tree drawing';\n  Window.SetSize(800,30+Levels*LevelHeight);\n  DrawTree(Window.Width / 2,10,Window.Width / 5,Levels);\nend."
  },
  {
    "instruction": "Implement basic exception handling for input errors in PascalABC.NET",
    "output": "var a: integer;\n\nbegin\n  try \n    writeln('Enter number: ');\n    readln(a);\n    writeln('Number entered correctly');\n  except\n    writeln('Input error');\n  end;\n  writeln('Program execution continues');\nend."
  },
  {
    "instruction": "Handle multiple specific exceptions in PascalABC.NET",
    "output": "var x: integer;\n\nbegin\n  try \n    writeln('Enter number (1 - division by zero error): ');\n    readln(x);\n    x := 10 div (x-1);\n  except\n    on System.FormatException do\n      writeln('Input error');\n    on System.DivideByZeroException do\n      writeln('Division by zero');  \n  end;\nend."
  },
  {
    "instruction": "Demonstrate finally block in exception handling in PascalABC.NET",
    "output": "var x: integer := 0;\n\nbegin\n  try \n    if Random(2)=0 then\n      x := 10 div x;\n    writeln('Execution continues');   \n  finally\n    writeln('Finally block executed'); \n  end;\n  writeln('After finally block'); \nend."
  },
  {
    "instruction": "Create a starfield animation through space in PascalABC.NET",
    "output": "uses GraphABC;\n \n type\n   TStar = record\n     X, Y, Z : real;\n   end;\n\n const\n   MAX_STARS = 1000;\n   SPEED = 200;\n\n var\n   i     : Integer;\n   Stars : array [1..MAX_STARS] of TStar;\n   scr_W : Integer;\n   scr_H : Integer;\n   time, dt : Integer;\n\n   procedure SetPix(c: Integer);\n   var\n     sx, sy : Integer;\n   begin\n   try\n     sx := trunc(scr_W / 2 + Stars[i].X * 200 / (Stars[i].Z + 200));\n     sy := trunc(scr_H / 2 - Stars[i].Y * 200 / (Stars[i].Z + 200));\n     except\n     end;\n     \n     try\n      SetPixel(sx, sy, Color.FromArgb(c, c, c));\n     except\n     end;\n   end;\n\n begin\n   MaximizeWindow();\n   scr_W := Window.Width;  \n   scr_H := Window.Height;\n\n   randomize;\n   for i := 1 to MAX_STARS do\n   begin\n     Stars[i].X := random(scr_W * 4) - scr_W * 2;\n     Stars[i].Y := random(scr_H * 4) - scr_H * 2;\n     Stars[i].Z := random(1900);\n   end;\n   \n   ClearWindow(Color.Black); \n   \n   time := Milliseconds;\n   repeat\n     scr_W := Window.Width;  \n     scr_H := Window.Height;\n     dt   := Milliseconds - time;\n     time := Milliseconds;\n     for i := 1 to MAX_STARS do\n       begin\n       SetPix(0);\n       Stars[i].Z := Stars[i].Z - SPEED * dt/1000;\n       if Stars[i].Z <= -200 then\n       begin\n         Stars[i].X := random(scr_W * 4) - scr_W * 2;\n         Stars[i].Y := random(scr_H * 4) - scr_H * 2;\n         Stars[i].Z := 1900;\n       end;\n       SetPix(trunc(255 - 255 * (Stars[i].Z + 200) / 2100));\n     end;\n     sleep(10);\n   until false;\n end."
  },
  {
    "instruction": "Measure execution time of nested loops in PascalABC.NET",
    "output": "begin\n  var n := 60000;\n  var t1 := Milliseconds;\n  var sm := 0.0;\n  var i := 1.0;\n  while i < n do\n  begin\n    var j := 1.0;\n    while j < n do\n    begin\n      sm += 1.0 / i / j;\n      j += 1;\n    end;\n    i += 1;\n  end;\n  var t2 := Milliseconds;\n  print(t2 - t1);\nend."
  },
  {
    "instruction": "Create a program that uses two timers: one prints '!' every 200ms and another prints '?' every 300ms. Run them for 10 seconds.",
    "output": "uses Timers;\n\nprocedure OnTimer1 := Write('!');\n\nprocedure OnTimer2 := Write('?');\n\nbegin\n  var t1 := new Timer(200, OnTimer1);\n  var t2 := new Timer(300, OnTimer2);\n  t1.Start;\n  t2.Start;\n  Sleep(10000);\nend."
  },
  {
    "instruction": "Create a program that implements a 'puppy' animation where a black circle follows the mouse cursor with smooth movement using a timer.",
    "output": "uses GraphWPF, Timers;\n\nvar\n  xx,yy,px,py: real;\n\nprocedure Draw;\nbegin\n  FillCircle(xx,yy,11);\nend;\n\nprocedure TimerProc;\nbegin\n  if (xx<>px) or (yy<>py) then\n  begin\n    var t := 1/10;\n    var newx := round((1-t)*xx+t*px);\n    var newy := round((1-t)*yy+t*py);\n    (xx,yy) := (newx,newy);\n  end;\nend;\n\nbegin\n  Window.Title := '\"Puppy\"';\n  Brush.Color := Colors.Black;\n\n  xx := 100; yy := 100;\n\n  OnMouseMove := procedure(x,y,mb) -> (px,py) := (x,y);\n\n  OnDrawFrame := dt -> begin\n    FillCircle(xx,yy,11);\n  end;\n\n  var t := new Timer(20,TimerProc);\n  t.Start;\nend."
  },
  {
    "instruction": "Create a turtle graphics program that draws different fractal patterns using L-system rules. Include implementations for Dragon curve, Koch curve, Quadratic Koch Island, and Gosper hexagonal curve.",
    "output": "uses Turtle,GraphWPF;\n\nvar \n  Atom,FStr,XStr,YStr: string;\n  angle,len,x0,y0: real;\n  n: integer;\n\nprocedure Init1; // Dragon\nbegin\n  (Atom,FStr,XStr,YStr) := ('fx','f','x+yf+','-fx-y');\n  (angle,len,n,x0,y0) := (90,3,15,300,450);\nend;\n\nprocedure Init2; // Koch curve\nbegin\n  (Atom,FStr,XStr,YStr) := ('F', 'F-F++F-F', '', '');\n  (angle,len,n,x0,y0) := (60,5,7,10,550);\nend;\n\nprocedure Init3; // Quadratic Koch Island\nbegin\n  (Atom,FStr,XStr,YStr) := ('F+F+F+F', 'F+F-FF+F+F-F', '', '');\n  (angle,len,n,x0,y0) := (90,0.15,4,8,-1);\nend;\n\nprocedure Init4; // Gosper hexagonal curve\nbegin\n  (Atom,FStr,XStr,YStr) := ('XF', 'F', 'X+YF++YF-FX--FXFX-YF+','-FX+YFYF++YF+FX--FX-Y');\n  (angle,len,n,x0,y0) := (60,4,5,580,56);\nend;\n\nprocedure RunStr(s: string; n: integer);\nbegin\n  foreach var c in s do\n    case c of\n      '+': Turn(angle);\n      '-': Turn(-angle);\n      'f','F': if n>0 then RunStr(FStr,n-1) else Forw(len);\n      'x','X': if n>0 then RunStr(XStr,n-1);\n      'y','Y': if n>0 then RunStr(YStr,n-1);\n      else Print('error')\n    end;\nend;\n\nbegin\n  Init3;\n  ToPoint(x0,y0);\n  SetWidth(0.5);\n  Down;\n  RunStr(Atom,n);\n  Up;\nend."
  },
  {
    "instruction": "Create a turtle graphics program that draws a colorful spiral pattern with changing colors.",
    "output": "uses Turtle,GraphWPF;\n\nbegin\n  SetWidth(5);\n  ToPoint(-10,0);\n  loop 70 do\n  begin\n    SetColor(RandomColor);\n    Down;\n    Forw(5);\n    Up;\n    Back(5);\n    TurnRight(90);\n    Forw(0.3);\n    TurnLeft(90);\n  end;\nend."
  },
  {
    "instruction": "Create a turtle graphics program that draws a Hilbert curve using recursion.",
    "output": "uses Turtle;\n\nprocedure Hilbert(level: integer; angle,step: real);\nbegin\n  if level = 0 then\n    exit;\n  TurnRight(angle);\n  Hilbert(level-1, -angle, step);\n\n  Forw(step);\n  TurnLeft(angle);\n  Hilbert(level-1, angle, step);\n\n  Forw(step);\n  Hilbert(level-1, angle, step);\n\n  TurnLeft(angle);\n  Forw(step);\n  Hilbert(level-1, -angle, step);\n  TurnRight(angle);\nend;\n\nbegin\n  SetWidth(2);\n  ToPoint(-9,-9);\n  Down;\n  Hilbert(6,90,0.3);\nend."
  },
  {
    "instruction": "Create a turtle graphics program that draws a colorful spiral with gradually changing colors.",
    "output": "uses TurtleWPF;\n\nbegin\n  Down;\n  SetSpeed(11);\n  SetColor(Colors.Red);\n  for var i:=1 to 450 do\n  begin\n    SetColor(RGB(128+i,0,i));\n    Forw(i);\n    Turn(96);\n  end;\nend."
  },
  {
    "instruction": "Create a program that demonstrates the use of external units by calculating Fibonacci sequence and factorials for numbers 1 to 10.",
    "output": "Uses unit_example;\n\nconst N: integer = 10;\n\nbegin\n    println('Fibonacci sequence:');\n    for var i := 1 to N do\n        println('F(' + i + ')=', fibonacci(i));\n    println();\n\n    println('Factorial sequence:');\n    for var i := 1 to N do\n        println(i + '!=', factorial(i));\n    println();\nend."
  },
  {
    "instruction": "Create a turtle graphics program that draws different fractal patterns using L-system rules. Include implementations for Dragon curve, Koch curve, Quadratic Koch Island, and Gosper hexagonal curve with configurable parameters.",
    "output": "uses Turtle;\n\nvar \n  Atom,FStr,XStr,YStr: string;\n  angle,len,x0,y0: real;\n  n: integer;\n\nprocedure Init1; // Dragon\nbegin\n  (Atom,FStr,XStr,YStr) := ('fx','f','x+yf+','-fx-y');\n  (angle,len,n,x0,y0) := (90,0.1,15,7,0);\nend;\n\nprocedure Init2; // Koch curve\nbegin\n  (Atom,FStr,XStr,YStr) := ('F', 'F-F++F-F', '', '');\n  (angle,len,n,x0,y0) := (60,5,7,10,550);\nend;\n\nprocedure Init3; // Quadratic Koch Island\nbegin\n  (Atom,FStr,XStr,YStr) := ('F+F+F+F', 'F+F-FF+F+F-F', '', '');\n  (angle,len,n,x0,y0) := (90,4,4,250,450);\nend;\n\nprocedure Init4; // Gosper hexagonal curve\nbegin\n  (Atom,FStr,XStr,YStr) := ('XF', 'F', 'X+YF++YF-FX--FXFX-YF+','-FX+YFYF++YF+FX--FX-Y');\n  (angle,len,n,x0,y0) := (60,4,5,580,56);\nend;\n\nprocedure RunStr(s: string; n: integer);\nbegin\n  foreach var c in s do\n    case c of\n      '+': Turn(angle);\n      '-': Turn(-angle);\n      'f','F': if n>0 then RunStr(FStr,n-1) else Forw(len);\n      'x','X': if n>0 then RunStr(XStr,n-1);\n      'y','Y': if n>0 then RunStr(YStr,n-1);\n      else Print('error')\n    end;\nend;\n\nbegin\n  Sleep(100);\n  Init1;\n  ToPoint(x0,y0);\n  SetWidth(0.5);\n  Down;\n  RunStr(Atom,n);\n  Up;\nend."
  },
  {
    "instruction": "Create a turtle graphics program that draws a Koch curve using L-system rules with specific starting position and rotation.",
    "output": "uses Turtle;\n\nvar \n  Atom,FStr,XStr,YStr: string;\n  angle,len,x0,y0: real;\n  n: integer;\n\nprocedure Init1; // Dragon\nbegin\n  (Atom,FStr,XStr,YStr) := ('fx','f','x+yf+','-fx-y');\n  (angle,len,n,x0,y0) := (90,0.1,15,7,0);\nend;\n\nprocedure Init2; // Koch curve\nbegin\n  (Atom,FStr,XStr,YStr) := ('F', 'F-F++F-F', '', '');\n  (angle,len,n,x0,y0) := (60,0.012,7,-13,0);\nend;\n\nprocedure Init3; // Quadratic Koch Island\nbegin\n  (Atom,FStr,XStr,YStr) := ('F+F+F+F', 'F+F-FF+F+F-F', '', '');\n  (angle,len,n,x0,y0) := (90,4,4,250,450);\nend;\n\nprocedure Init4; // Gosper hexagonal curve\nbegin\n  (Atom,FStr,XStr,YStr) := ('XF', 'F', 'X+YF++YF-FX--FXFX-YF+','-FX+YFYF++YF+FX--FX-Y');\n  (angle,len,n,x0,y0) := (60,4,5,580,56);\nend;\n\nprocedure RunStr(s: string; n: integer);\nbegin\n  foreach var c in s do\n    case c of\n      '+': Turn(angle);\n      '-': Turn(-angle);\n      'f','F': if n>0 then RunStr(FStr,n-1) else Forw(len);\n      'x','X': if n>0 then RunStr(XStr,n-1);\n      'y','Y': if n>0 then RunStr(YStr,n-1);\n      else Print('error')\n    end;\nend;\n\nbegin\n  Init2;\n  ToPoint(x0,y0);\n  SetWidth(0.5);\n  Down;\n  Turn(90);\n  RunStr(Atom,n);\n  Up;\nend."
  },
  {
    "instruction": "Create a program that demonstrates exception handling by raising an exception when a function receives zero as input parameter.",
    "output": "function f(x: integer): integer;\nbegin\n  if x=0 then\n    raise new System.Exception('Function f argument cannot be zero');\n  Result := 10 mod x;\nend;\n\nbegin\n  writeln(f(0));    \nend."
  },
  {
    "instruction": "Create a program that demonstrates tuple creation and access to tuple elements using both index notation and named properties.",
    "output": "begin\n  var a := ('Ivanov',24);\n  Println(a[0],a[1]);\n\n  var b := ('Petrov',17,1,11);\n  Println(b.Item1,b.Item2,b.Item3,b.Item4);\nend."
  },
  {
    "instruction": "Create a program that demonstrates working with untyped files by writing and reading data of different types (real, char, integer) to/from a file.",
    "output": "const filename = 'u.dat';\n\nvar \n  f: file;\n  r: real;\n  s: string[10];\n  k: integer;\n  c: char;\n\nbegin\n  if not FileExists(filename) then\n  begin\n    assign(f,filename);\n    rewrite(f);\n    writeln('Writing to file ',filename);\n    \n    r := random*10; \n    for var i:=0 to 10 do\n      s := s + Chr(Ord('A')+Random(26));\n    c := Chr(Ord('A')+Random(26));\n    k := Random(100);\n    \n    writeln(r);\n    writeln(c);\n    writeln(k);\n    write(f,r);\n    write(f,c);\n    write(f,k);\n    close(f);  \n  end\n  else \n  begin\n    assign(f,filename);\n    reset(f);\n    writeln('Reading from file ',filename);\n    read(f,r,c,k);\n    writeln(r);\n    writeln(c);\n    writeln(k);\n    close(f);  \n    erase(f);\n  end;  \nend."
  },
  {
    "instruction": "Show how to use untyped files for writing and reading different data types in PascalABC.NET",
    "output": "// Untyped files\n\nbegin\n  var f: file := CreateBinary('a.dat');\n  // Write data of any types to file\n  f.Write(1,2.5,'Hello');  \n  f.Close;\n  f.Reset;\n  // Read this data from file\n  var i: integer;\n  var r: real;\n  var s: string;\n  Read(f,i,r,s);\n  Print(i,r,s);\n  f.Close;\nend."
  },
  {
    "instruction": "Create a program that demonstrates the use of UpperCase and LowerCase functions for both English and Russian characters.",
    "output": "var c: char;\n\nbegin\n  for c:='a' to 'z' do\n    write(UpperCase(c));\n  writeln;\n  for c:='A' to 'Z' do\n    write(LowerCase(c));\n  writeln;\n  for c:='А' to 'Я' do\n    write(UpperCase(c));\n  writeln;\n  for c:='а' to 'я' do\n    write(LowerCase(c));\n  writeln;\n  var s := 'Папа у Васи силён в математике';\n  s := UpperCase(s);\n  writeln(s);\n  s := LowerCase(s);\n  writeln(s);\nend."
  },
  {
    "instruction": "Create a class with a custom deconstructor and demonstrate its usage with pattern matching.",
    "output": "type\n  Person = class\n    name: string;\n    age: integer;\n    \n    constructor(name: string; age: integer);\n    begin\n      self.name := name;\n      self.age := age;\n    end;\n    \n    procedure Deconstruct(var name: string; var age: integer);\n    begin\n      name := self.name;\n      age := self.age;\n    end;\n  end;\n\nbegin\n  var p := new Person('Петр', 25);\n  if p is Person(var name, var age) then\n    Println(name, age);\n    \n  match p with\n    Person(name,age): Println(name,age);\n  end;\nend."
  },
  {
    "instruction": "Create an extension method deconstructor for integer type that splits a number into tens and units.",
    "output": "procedure Deconstruct(Self: integer; var a: integer; var b: integer); extensionmethod;\nbegin\n  a := Self div 10;\n  b := Self mod 10;\nend;\n\nbegin\n  var i := 25;\n  if i is integer(var a, var b) then\n    Println(a,b); \n    \n  i := 9;\n  match i with\n    integer(a,b) when i>=10: Println(a,b);\n    integer(a): Println(a);\n  end;\nend."
  },
  {
    "instruction": "Create a short program that uses modules in compact syntax to create a 3D sphere.",
    "output": "uses Graph3D;\nSphere(Origin,1);"
  },
  {
    "instruction": "Create a program that demonstrates vector algebra operations using NumLibABC module.",
    "output": "uses NumLibABC;\n\nbegin\n  var a:=new Vector(3,-4,1);\n  var b:=new Vector(-1,0,5);\n  Writeln((2*a-b).ModV);\n  \n  var p:=Arr(3.0,0.0,-4.0);\n  a:=new Vector(p);\n  a.Ort.Println;\n\n  a:=new Vector(2,-1,1);\n  b:=new Vector(2,3,6);\n  Writeln(a*b/(a.ModV*b.ModV))\nend."
  },
  {
    "instruction": "Create a program that uses WebClient to download web page content and files from the internet.",
    "output": "uses System.Net;\n\nbegin\n  var w := new WebClient();\n  w.Encoding := System.Text.Encoding.UTF8;\n  var s := w.DownloadString('http://pascalabc.net');\n  writeln(s);\n  w.DownloadFile('http://pascalabc.net/images/logo/LogoPABCNET2010_Rus.png','LogoPABCNET2010_Rus.png');\nend."
  },
  {
    "instruction": "Show how to use the 'where' clause for generic type constraints in PascalABC.NET",
    "output": "// Where clause - constraint on type parameters\nuses System;\n\ntype\n   MyClass<T,T1> = class \n   where T: System.Array,ICloneable;\n   where T1: constructor;\n     procedure p(obj1: T; var obj2: T1);\n     begin\n       obj1.Clone();\n       obj2 := new T1;\n     end;\n   end;\n   IntArr = array of integer;\n   \nvar \n  m: MyClass<IntArr,integer>;\n  //m1: MyClass<integer>; // error\n\nbegin\nend."
  },
  {
    "instruction": "Show while loop examples for generating sequences and calculating digit sums in PascalABC.NET",
    "output": "// While loop. Output numbers with step 3\nconst n = 60;\n\nbegin\n  Println($'Numbers from 1 to {n}, multiples of 3');\n  var x := 3;\n  while x <= n do\n  begin\n    Print(x);\n    x += 3;\n  end;\n  Println;\nend.\n\n// While loop. Powers of 2\nbegin\n  Println('Powers of 2');\n  var i := 1;\n  var p := 1;\n  while i < 32 do\n  begin\n    Println($'{i,2}{p,12}');\n    i += 1;\n    p *= 2;\n  end;\nend.\n\n// While loop. Sum of digits of positive number\n\nbegin\n  var m := ReadlnInteger('Enter positive number:');\n\n  Print('Digits of number in reverse order:');\n  var s := 0;\n  while m>0 do\n  begin\n    var digit := m mod 10;\n    Print(digit);\n    s += digit;\n    m := m div 10;\n  end;\n  \n  Println;\n  Println('Sum of digits =',s);\nend."
  },
  {
    "instruction": "Show how to create a Windows Forms application with a button in PascalABC.NET",
    "output": "// Creating window application\n{$apptype windows}\n{$reference System.Windows.Forms.dll}\n\nuses \n  System,\n  System.Windows.Forms;\n\nvar myForm: Form;\n  \nprocedure MyButtonClick(sender: Object; e: EventArgs);\nbegin\n  myForm.Close;\nend;\n\nbegin\n  myForm := new Form;\n  myForm.Text := 'Window application';\n  var myButton := new Button;\n  myButton.Text := '  Close window  ';\n  myButton.AutoSize := True;\n  myButton.Left := 90;\n  myButton.Top := 110;\n  myForm.Controls.Add(myButton);\n  myButton.Click += MyButtonClick;\n  Application.Run(myForm);\nend."
  },
  {
    "instruction": "Create a 3D wireframe prism with labeled points using Graph3D module.",
    "output": "uses Graph3D;\n\nbegin\n  HideObjects;\n  var p := PrismWireFrame(Origin,13,3,5);\n  var pp := p.Points;\n  foreach var x in pp do\n    p.AddChild(Sphere(x,0.1,Colors.Gray));\n  var m := 'A';  \n  foreach var x in pp do\n  begin\n    var b := Text3D(x.Move(0.3,0.3,0.4),m,0.5);\n    p.AddChild(b);\n    Inc(m);\n  end;\n  var p1 := p.Clone;\n  p1.MoveByX(-5);\n  ShowObjects;\n  p1.AnimRotate(OrtZ,360,10).Forever.Begin;\nend."
  },
  {
    "instruction": "Create a WPF calculator application with basic arithmetic operations using procedural approach.",
    "output": "uses WPF;\n\nbegin\n  MainWindow.Title := 'Calculator';\n  var mainpanel := Panels.StackPanel.AsMainContent;\n  var panel1 := Panels.StackPanel(Margin := 10, Horizontal := True)\n    .With(Background := Brushes.LightBlue)\n    .AddTo(mainpanel);\n  \n  var tb := CreateTextBox('0', Width := 120);\n  var lb := CreateLabel('+',Width := 35);\n  var tb1 := CreateTextBox('0', Width := 120);\n  var lb1 := CreateLabel('=',Width := 55);\n  panel1.AddElements(tb,lb,tb1,lb1);\n  \n  var panel2 := Panels.StackPanel(Margin := |10,0,10,10|, Horizontal := True)\n    .With(Background := Brushes.LightBlue)\n    .AddTo(mainpanel);\n  panel2.HorizontalAlignment := HA.Right;\n\n  var Handler: EventHandler := (o,e) -> begin\n    var b := o as Button;\n    var Left := tb.Text.ToReal;\n    var Right := tb1.Text.ToReal;\n    case b.Text of\n      $'+': lb1.Content := '= ' + (Left + Right);\n      $'-': lb1.Content := '= ' + (Left - Right);\n      $'*': lb1.Content := '= ' + (Left * Right);\n      $'/': lb1.Content := '= ' + (Left / Right);\n    end;\n  end;\n  \n  var bb := CreateButtons(|$'+',$'-',$'*',$'/'|); \n  panel2.AddElements(bb, Width := 35, Margin := |10,0|, Padding := 5);\n\n  for var i:=0 to bb.Length-1 do\n    bb[i].Click += Handler;\n  \n  MainWindow.SizeToContent := SizeToContent.WidthAndHeight;\nend."
  },
  {
    "instruction": "Create a WPF calculator application using class-based approach with proper encapsulation.",
    "output": "uses WPF;\n\ntype Main = class\n  mainpanel,panel1,panel2: StackPanel;\n  tb,tb1: TextBox;\n  lb,lb1: TLabel;\n  bb: array of Button;\n  \n  procedure ButtonClick(o: Object; e: RoutedEventArgs);\n  begin\n    var b := o as Button;\n    var Left := tb.Text.ToReal;\n    var Right := tb1.Text.ToReal;\n    case b.Text of\n      $'+': lb1.Content := '= ' + (Left + Right);\n      $'-': lb1.Content := '= ' + (Left - Right);\n      $'*': lb1.Content := '= ' + (Left * Right);\n      $'/': lb1.Content := '= ' + (Left / Right);\n    end;\n  end;\n  \n  procedure InitControls;\n  begin\n    MainWindow.Title := 'Calculator';\n    mainpanel := Panels.StackPanel.AsMainContent;\n    panel1 := Panels.StackPanel(Margin := 10, Horizontal := True)\n      .With(Background := Brushes.LightBlue)\n      .AddTo(mainpanel);\n    \n    tb := CreateTextBox('0', Width := 120);\n    lb := CreateLabel('+',Width := 35);\n    tb1 := CreateTextBox('0', Width := 120);\n    lb1 := CreateLabel('=',Width := 55);\n    panel1.AddElements(tb,lb,tb1,lb1);\n    \n    panel2 := Panels.StackPanel(Margin := |10,0,10,10|, Horizontal := True)\n      .With(Background := Brushes.LightBlue)\n      .AddTo(mainpanel);\n    panel2.HorizontalAlignment := HA.Right;\n    \n    bb := CreateButtons(|$'+',$'-',$'*',$'/'|); \n    panel2.AddElements(bb, Width := 35, Margin := |10,0|, Padding := 5);\n\n    for var i:=0 to bb.Length-1 do\n      bb[i].Click += ButtonClick;\n    \n    MainWindow.SizeToContent := SizeToContent.WidthAndHeight;\n  end;\nend;\n\nbegin\n  Main.Create.InitControls; \nend."
  },
  {
    "instruction": "Create programs that demonstrate tuple unpacking for different scenarios: range tuples, dictionary key-value pairs, and ValueTuple types.",
    "output": "begin\n  var t := 2 to 3.5;\n  var (a,b) := t;\n  Println(a,b);\n  foreach var (a1,b1) in Dict(1 to 7, 22 to 555) do\n    Println(a1,b1);\nend.\n\nbegin\n  var s := Seq(('Умнова',16),('Иванов',23),\n               ('Попова',17),('Козлов',24));\n  Println('Adults:');\n  s.Where(\\(name,age) -> age >= 18).Println;\n  Println('Sort by last name:');\n  s.OrderBy(\\(name,age) -> name).Println;\nend.\n\nbegin\n  var (n,s) := System.ValueTuple.Create(2,'ab');\n  Print(n,s);\nend."
  },
  {
    "instruction": "Create a generic Node class for a circular linked list and demonstrate creating two nodes that reference each other.",
    "output": "type \n  Node<T> = class\n  public\n    data: T;\n    next: Node<T>;\n    constructor (d: T; n: Node<T>);\n    begin\n      data := d;\n      next := n;\n    end;\n  end;\n\nbegin\n  var n1 := new Node<integer>(5,nil);\n  var n2 := new Node<integer>(6,n1);\n  writeln(n2);\n  n1.next := n2;\n  writeln(n2);\nend."
  },
  {
    "instruction": "Create programs that demonstrate various formatting options using WritelnFormat function, including reverse order output, escaping curly braces, field width specification, and decimal precision.",
    "output": "begin\n  WritelnFormat('{2},{1},{0}',1,2,3);\n  WritelnFormat('{{}}{0}','Output curly braces in format string');\n  WritelnFormat('{0,10:f}',3.1415);\n  WritelnFormat('{0:f3}',3.1415);\nend.\n\nbegin\n  WritelnFormat('{2},{1},{0}',1,2,3);\n  WritelnFormat('{{}}{0}','Output curly braces in format string');\n  WritelnFormat('{0:f3}',3.1415);\n  WritelnFormat('{0,10:f}',3.1415);\nend."
  },
  {
    "instruction": "Create a program that demonstrates zero-based string indexing directive and its effect on string slices and indexing.",
    "output": "{$zerobasedstrings}\nbegin\n  var s := '0123456789';\n  Println(s[0:5],s[5:8],s[8:]);\n  Print(s[^1]);\nend."
  },
  {
    "instruction": "Create a program that finds real zeros of a function on isolation intervals using NumLibABC module.",
    "output": "uses NumLibABC;\n\nbegin\n   var f:real->real := t->sin(t)/(1+Sqr(Exp(t)))-0.1;\n   var oL:=new Zeroin(f,1e-12);\n   Println(oL.Value(-10,-9.5), oL.Value(-6.5,-6), oL.Value(-3.5,-3),\n        oL.Value(0,0.5),oL.Value(1,1.5))\nend."
  },
  {
    "instruction": "Create programs that demonstrate Zip function usage for element-wise operations on sequences and Cartesian product operations.",
    "output": "begin\n  var a := Seq(1,5,3,2,4);\n  var b := Seq(2,3,4,1,6);\n  a.Zip(b,(x,y)->x*y).Print;\nend.\n\nbegin\n  var a := Seq(1,5,3,2,4);\n  a.Zip(a.Skip(1),(x,y)->y-x).Print;\nend.\n\nbegin\n  Zip(1..5,2..6).Println;\n  Zip(1..5,2..6,(x,y) -> x+y).Println;\n  Zip(1..5,2..6,3..7).Println;\n  Zip(1..5,2..6,3..7,(x,y,z) -> x+y+z).Println;\n\n  Cartesian(1..4,3..5).Println;\n  Cartesian(1..4,3..5,(x,y) -> x*y).Println;\n  Cartesian(1..2,4..5,6..7).Println;\n  Cartesian(1..2,4..5,6..7,(x,y,z) -> x*y*z).Println;\n\n  foreach var (a,b) in Cartesian(1..2,3..5) do\n    Print($'{a}+{b}')\nend."
  },
  {
    "instruction": "Create a procedure that draws lines connecting all points of a regular polygon using Cartesian product.",
    "output": "uses GraphWPF;\n\nprocedure ВсеТочкиМногоугольника(x0,y0,r: real; n: integer);\nbegin\n  var q := PartitionPoints(0,2*Pi,n).Select(a->Pnt(x0 + r * Cos(a), y0 - r * Sin(a)));\n  q.Cartesian(q).ForEach(p->Line(p[0].x,p[0].y,p[1].x,p[1].y,RandomColor));\nend;\n\nbegin\n  Pen.Width := 0.5;\n  ВсеТочкиМногоугольника(400,300,290,30)\nend."
  },
  {
    "instruction": "Create programs that demonstrate different text alignment options in GraphWPF for both rectangle areas and point coordinates.",
    "output": "uses GraphWPF;\n\nbegin\n  Window.Title := 'Font alignment';\n  Font.Size := 20;\n  var (x,y) := (200,200);\n  var (w,h) := (400,200);\n  DrawRectangle(x,y,w,h);\n  DrawText(x,y,w,h,'LeftTop',Alignment.LeftTop);\n  DrawText(x,y,w,h,'LeftCenter',Alignment.LeftCenter);\n  DrawText(x,y,w,h,'LeftBottom',Alignment.LeftBottom);\n  DrawText(x,y,w,h,'CenterTop',Alignment.CenterTop);\n  DrawText(x,y,w,h,'Center');\n  DrawText(x,y,w,h,'CenterBottom',Alignment.CenterBottom);\n  DrawText(x,y,w,h,'RightTop',Alignment.RightTop);\n  DrawText(x,y,w,h,'RightCenter',Alignment.RightCenter);\n  DrawText(x,y,w,h,'RightBottom',Alignment.RightBottom);\n  TextOut(150,100,'PointRightBottom',Alignment.RightBottom);\n  TextOut(150,100,'PointRightTop',Alignment.RightTop);\n  TextOut(150,100,'PointLeftTop',Alignment.LeftTop);\n  TextOut(150,100,'PointLeftBottom',Alignment.LeftBottom);\n  FillCircle(150,100,5,Colors.Red);\n  TextOut(600,100,'PointCenterTop',Alignment.CenterTop);\n  TextOut(600,100,'PointCenterBottom',Alignment.CenterBottom);\n  FillCircle(600,100,5,Colors.Red);\n  TextOut(400,500,'PointLeftCenter',Alignment.LeftCenter);\n  TextOut(400,500,'PointRightCenter',Alignment.RightCenter);\n  FillCircle(400,500,5,Colors.Red);\nend.\n\nuses GraphWPF;\n\nbegin\n  Window.Title := 'Font alignment';\n  Font.Size := 20;\n  \n  var sc := 40;\n  SetMathematicCoords;\n  \n  var (x,y) := (-5,-2);\n  var (w,h) := (10,4);\n  DrawRectangle(x,y,w,h);\n  DrawText(x,y,w,h,'LeftTop',Alignment.LeftTop);\n  DrawText(x,y,w,h,'LeftCenter',Alignment.LeftCenter);\n  DrawText(x,y,w,h,'LeftBottom',Alignment.LeftBottom);\n  DrawText(x,y,w,h,'CenterTop',Alignment.CenterTop);\n  DrawText(x,y,w,h,'Center');\n  DrawText(x,y,w,h,'CenterBottom',Alignment.CenterBottom);\n  DrawText(x,y,w,h,'RightTop',Alignment.RightTop);\n  DrawText(x,y,w,h,'RightCenter',Alignment.RightCenter);\n  DrawText(x,y,w,h,'RightBottom',Alignment.RightBottom);\n  TextOut(-5,5,'PointRightBottom',Alignment.RightBottom);\n  TextOut(-5,5,'PointRightTop',Alignment.RightTop);\n  TextOut(-5,5,'PointLeftTop',Alignment.LeftTop);\n  TextOut(-5,5,'PointLeftBottom',Alignment.LeftBottom);\n  FillCircle(-5,5,0.1,Colors.Red);\n  TextOut(5,5,'PointCenterTop',Alignment.CenterTop);\n  TextOut(5,5,'PointCenterBottom',Alignment.CenterBottom);\n  FillCircle(5,5,0.1,Colors.Red);\n  TextOut(5,-5,'PointLeftCenter',Alignment.LeftCenter);\n  TextOut(5,-5,'PointRightCenter',Alignment.RightCenter);\n  FillCircle(5,-5,0.1,Colors.Red);\nend."
  },
  {
    "instruction": "Create a WPF application with checkboxes that mix RGB colors to change the background color dynamically.",
    "output": "uses WPF;\n\nfunction MixColor(r,g,b: boolean): Color;\nbegin\n  var ri := integer(r);\n  var gi := integer(g);\n  var bi := integer(b);\n  Result := RGB(ri*255,gi*255,bi*255);\nend;\n\ntype Main = class\n  MainPanel: StackPanel;\n  cbr,cbg,cbb: CheckBox;\n  constructor;\n  begin\n    MainPanel := Panels.StackPanel(Margin := 10, Horizontal := True)\n      .With(Background := Brushes.LightBlue).AsMainContent;\n    cbr := CreateCheckBox('Red', Margin := 5);\n    cbg := CreateCheckBox('Green', Margin := 5, IsChecked := True);\n    cbb := CreateCheckBox('Blue', Margin := 5);\n    mainpanel.AddElements(cbr,cbg,cbb);\n    cbr.Click += Handler;\n    cbg.Click += Handler;\n    cbb.Click += Handler;\n    Handler(nil,nil);\n  end;\n  procedure Handler(o: object; e: RoutedEventArgs);\n  begin\n    var (r,g,b) := (cbr.IsChecked,cbg.IsChecked,cbb.IsChecked);\n    mainpanel.Background := GBrush(MixColor(r.Value,g.Value,b.Value));\n  end;\nend;\n\nbegin\n  Main.Create;\nend."
  },
  {
    "instruction": "Create a WPF application with a combobox that displays standard colors and changes a rectangle's fill color when selected.",
    "output": "uses WPF;\n\nbegin\n  var colorNames := typeof(Colors).GetProperties\n    .ToDictionary(pi -> pi.Name, pi -> GBrush(Color(pi.GetValue(nil,nil))));\n  MainWindow.Title := 'Standard Colors';\n  MainWindow.WindowStartupLocation := WindowStartupLocation.CenterScreen;\n  var mainpanel := CreateStackPanel(Margin := 10, Horizontal := True).AsMainContent;\n  var panel1 := CreateStackPanel(Width := 250).AddTo(mainpanel);\n  var cb := CreateComboBox.AddTo(panel1);\n  cb.ItemsSource := colorNames.Keys;\n  var rect := CreateRectangle(Height := 200, Margin := |0,10|).AddTo(panel1);\n  rect.Fill := Brushes.Blue;\n  \n  cb.SelectionChanged += procedure(o,e) -> (rect.Fill := colorNames[cb.SelectedValue as string]);\n  \n  MainWindow.SizeToContent := SizeToContent.WidthAndHeight;\nend."
  },
  {
    "instruction": "Create WPF applications that demonstrate DockPanel layout with buttons docked to different sides.",
    "output": "uses WPF;\n\nbegin\n  var dpanel := Panels.DockPanel.AsMainContent;\n  var b := Controls.Button('One');\n  var b1 := Controls.Button('Two');\n  var b2 := Controls.Button('Three');\n  var b3 := Controls.Button('Four');\n  var b4 := Controls.Button('Five');\n  dpanel.Children.Add(b);\n  dpanel.Children.Add(b1);\n  dpanel.Children.Add(b2);\n  dpanel.Children.Add(b3);\n  dpanel.Children.Add(b4);\n  DockPanel.SetDock(b,Dock.Left);\n  DockPanel.SetDock(b1,Dock.Right);\n  DockPanel.SetDock(b2,Dock.Top);\n  DockPanel.SetDock(b3,Dock.Bottom);\nend.\n\nuses WPF;\n\nbegin\n  var dpanel := Panels.DockPanel.AsMainContent;\n  var b := Controls.Button('One',Width := 100).AddTo(dpanel,Dock.Left);\n  var b1 := Controls.Button('Two',Width := 100).AddTo(dpanel,Dock.Right);\n  var b2 := Controls.Button('Three',Height := 50).AddTo(dpanel,Dock.Top);\n  var b3 := Controls.Button('Four',Height := 50).AddTo(dpanel,Dock.Bottom);\n  var b4 := Controls.Button('Five').AddTo(dpanel);\n  b.Click += (o,e) -> begin\n    MainWindow.Close\n  end;\nend."
  },
  {
    "instruction": "Create a WPF application that demonstrates dynamic font property changes including font size, font family, italic, and bold styles using sliders and checkboxes.",
    "output": "uses WPF;\n\nbegin\n  MainWindow.FontSize := 16;\n  MainWindow.Title := 'Font properties';\n  var dpanel := CreateDockPanel(Margin := 10).AsMainContent;\n  var toppanel := Panels.StackPanel(Horizontal := True, Margin := 0);\n  var TextLabel := CreateLabel('PascalABC.NET').With(HA := HA.Center, VA := VA.Center);\n  TextLabel.FontSize := 100;\n  dpanel.Add(toppanel,Dock.Top);\n  dpanel.Add(TextLabel);\n  \n  CreateLabel('Font size', Margin := 0).AddTo(toppanel);\n  var fontsizeslider := CreateSlider(20,100,10,10,Width := 100, Value := 100).AddTo(toppanel);\n  fontsizeslider.ValueChanged += procedure(o,e) -> TextLabel.FontSize := fontsizeslider.Value;\n  \n  CreateLabel('Font name',Margin := |20,0|).AddTo(toppanel);\n  var cb := CreateComboBox(|'Segoe UI','Arial','Times New Roman','Courier New'|).AddTo(toppanel);\n  cb.SelectionChanged += procedure(o,e) -> TextLabel.FontFamily := cb.SelectedValue.ToString;\n\n  var chb := CreateCheckBox('Italic',Margin := |20,5,0,0|).AddTo(toppanel);\n  chb.Click += procedure(o,e) -> (TextLabel.FontStyle := \n    chb.IsChecked.Value ? FontStyles.Italic : FontStyles.Normal);\n  var chb2 := CreateCheckBox('Bold',Margin := |20,5,0,0|).AddTo(toppanel);\n  chb2.Click += procedure(o,e) -> (TextLabel.FontWeight := \n    chb2.IsChecked.Value ? FontWeights.Bold : FontWeights.Normal);\nend."
  },
  {
    "instruction": "Create a WPF application that demonstrates dynamic rectangle property changes including width, height, and corner radius using sliders with data binding.",
    "output": "uses WPF;\n\nbegin\n  MainWindow.Title := 'Rectangle properties';\n  MainWindow.FontSize := 14;\n  MainWindow.WindowStartupLocation := WindowStartupLocation.CenterScreen;\n  var mainpanel := CreateDockPanel(Margin := 5).AsMainContent;\n  var leftpanel := CreateStackPanel(Margin := 0, Width := 150)\n    .With(Background := Brushes.Bisque).AddTo(mainpanel,Dock.Left);\n  var rect := CreateRectangle(Width := 300, Height := 200).With(HA := HA.Center, VA := VA.Center).AddTo(mainpanel);\n  rect.Fill := Brushes.Blue;\n  var widthslider := CreateSlider(50,500,10,50);\n  var tbwidth := CreateTextBlock();\n  var heightslider := CreateSlider(50,500,10,50);\n  var tbHeight := CreateTextBlock();\n  var radiusslider := CreateSlider(0,50,10,50);\n  var tbRadius := CreateTextBlock();\n  \n  leftpanel.AddElements(widthslider, tbwidth, heightslider, tbHeight, radiusslider, tbRadius);\n\n  widthslider.ValueChanged += procedure(o,e) -> tbwidth.Text := 'Width: ' + widthslider.Value.ToString(0);\n  heightslider.ValueChanged += procedure(o,e) -> tbheight.Text := 'Height: ' + heightslider.Value.ToString(0);\n  radiusslider.ValueChanged += procedure(o,e) -> begin\n    tbRadius.Text := 'Corner radius: ' + radiusslider.Value.ToString(0);\n    rect.RadiusX := radiusslider.Value;\n    rect.RadiusY := radiusslider.Value;\n  end; \n  radiusslider.Value := 10;\n\n  widthslider.SetBinding(Slider.ValueProperty, rect, 'Width');\n  heightslider.SetBinding(Slider.ValueProperty, rect, 'Height');\nend."
  },
  {
    "instruction": "Show how to output various data types using the write procedure in PascalABC.NET",
    "output": "/// Output of various types using write procedure\nbegin\n  // Output of integer, string, real\n  Writeln(1,'  ',2.5);\n  // Output of set\n  Writeln([1..10]);\n  // Output of boolean\n  Writeln(True);\n  var a: array [1..10] of integer;\n  // Output of static array\n  Writeln(a);\n  // Output of dynamic array\n  Writeln([2,3,5]);\n  // Output of tuple\n  Writeln(('Ivanov',16));\n  // Output of dictionary\n  Writeln(Dict('Ivanov' to 4.7, 'Petrova' to 4.9, 'Kozlov' to 3.8));\nend."
  },
  {
    "instruction": "Create a traffic light drawing procedure using GraphWPF that draws a gray rectangle with three colored circles (red, yellow, green) in vertical arrangement.",
    "output": "uses GraphWPF;\n\nprocedure Светофор(x,y,r: real);\nbegin\n  Rectangle(x,y,4*r,10*r,Colors.LightGray);\n  x += 2*r;\n  y += 2*r;\n  var dy := 3*r;\n\n  Circle(x,y,r,Colors.Red);\n  Circle(x,y + dy,r,Colors.Yellow);\n  Circle(x,y + 2*dy,r,Colors.Green);\nend;\n\nbegin\n  Pen.Width := 2;\n  Window.Title := 'Traffic Light';\n  Светофор(150,40,50);\nend."
  },
  {
    "instruction": "Create a mathematical coordinate system using GraphWPF with grid lines and a polygon with labeled vertices.",
    "output": "uses GraphWPF;\n\nbegin\n  Window.Title := 'Coordinate System';\n  Font.Size := 20;\n\n  SetMathematicCoords(-10,10,-9.2);\n  DrawGrid;\n \n  Print('Visible coordinates:',XMin,XMax,YMin,YMax);\n  \n  Polygon(Arr((-3,2),(2,1),(-2,-4)),ARGB(100,255,228,196));\n  TextOut(-3,2,'A(-3,2)',Alignment.RightBottom);\n  TextOut(2,1,'B(2,1)',Alignment.LeftBottom);\n  TextOut(-2,-4,'C(-2,-4)',Alignment.CenterTop);\nend."
  },
  {
    "instruction": "Create a 3D scene with interactive color changing where clicking on objects changes their color to a random color.",
    "output": "uses Graph3D;\n\nbegin \n  var s := Sphere(3,0,1,1);\n  var b := Box(0,2,0.5,3,2,1);\n  var t := Text3D(-5,0,1,'Graph3D',2);\n  OnMouseDown += procedure (x,y,mb) -> begin\n    if mb<>1 then exit;\n    var v := FindNearestObject(x,y);\n    if v<>nil then\n      v.Color := RandomColor;\n  end;\nend."
  },
  {
    "instruction": "Create a multiplication table display using GraphWPF that shows a 9x9 grid with multiplication results.",
    "output": "uses GraphWPF;\n\nbegin\n  Window.Title := 'Multiplication Table';\n  Font.Size := 16;\n  var n := 9;\n  var w := 40;\n  var (x0,y0) := (50,50);\n  for var i:=0 to n-1 do\n  for var j:=0 to n-1 do\n  begin\n    var (xx,yy) := (x0+i*w,y0+j*w);\n    Rectangle(xx,yy,w,w);\n    DrawText(xx,yy,w,w,(i+1)*(j+1));\n  end;  \nend."
  },
  {
    "instruction": "Create an animated 3D clock with rotating second and minute hands using Graph3D.",
    "output": "uses Graph3D;\n\nbegin\n  View3D.ShowGridLines := False;\n  var Циферблат := Cylinder(0,0,-0.4,0.2,6,Colors.DeepPink);\n  var Сек := Arrow(0,0,0,0,-5.5,0,0.2,Colors.Yellow);\n  var Мин := Arrow(0,0,0,0,-6.0,0,0.3,Colors.Red);\n  \n  var a := 0;\n  var r := 5.8;\n  loop 60 do\n  begin\n    Sphere(r*cos(a*Pi/180),r*sin(a*Pi/180),-0.2,0.1,Colors.White);\n    a += 6;\n  end;\n  \n  while True do\n  begin\n    Sleep(10);\n    Сек.Rotate(v3D(0,0,1),-6);\n    Мин.Rotate(v3D(0,0,1),-6/60);\n  end;\nend."
  },
  {
    "instruction": "Create a 3D castle structure using cloning and grouping of 3D objects with random colors and save it to a file.",
    "output": "uses Graph3D;\n\nfunction MultipleClones(c: Object3D; N: integer): Group3D;\nbegin\n  var g := Group(c);\n  loop N-1 do\n  begin\n    c := c.Clone;\n    c.MoveByX(-1.5);\n    if c is ObjectWithMaterial3D then \n      (c as ObjectWithMaterial3D).Color := RandomColor;\n    g.AddChild(c);\n  end;\n  Result := g;\nend;\n\nbegin\n  HideObjects;\n  var b := Box(0,0,2,14.5,1,4,Colors.Orange);\n  var c := Cube(6.75,0,4.5,1,RandomColor);\n  var c1 := Cone(6.75,0,5,1.5,0.4,RandomColor);\n  var g := MultipleClones(c,10);\n  var gp := MultipleClones(c1,10);\n  var gg := Group(g,b,gp);\n  var g1 := gg.Clone.MoveByY(6);\n  var g2 := gg.Clone.MoveByY(-6);\n  gg.Rotate(OrtZ,90);\n  var g3 := gg.Clone.MoveByX(-6);\n  gg.MoveByX(6);\n  var ggg := Group(gg,g1,g2,g3);\n  ShowObjects;\n\n  ggg.Save('Замок.xaml');\nend."
  },
  {
    "instruction": "Create procedures to draw regular polygons with different numbers of sides using GraphWPF.",
    "output": "uses GraphWPF;\n\nprocedure Многоугольник(x0,y0,r: real; n: integer);\nbegin\n  var a := Pi / 2;\n  MoveTo(x0 + r * Cos(a), y0 - r * Sin(a));\n  loop n do \n  begin\n    a += 2 * Pi / n;\n    LineTo(x0 + r * Cos(a), y0 - r * Sin(a));\n  end;\nend;\n\nbegin\n  var (x0,y0) := (400.0,300.0);\n  var r := 30.0;\n  for var n := 3 to 11 do\n    Многоугольник(x0,y0,r+(n-3)*30,n)\nend.\n\nuses GraphWPF;\n\nbegin\n  var (n,r) := (9,250);\n  var a := ArrGen(n, i -> Window.Center + r * Vect(Cos(i*2*Pi/n),Sin(i*2*Pi/n)));\n  foreach var p in a.Combinations(2) do\n    Line(p[0], p[1]);\nend."
  },
  {
    "instruction": "Demonstrate arithmetic calculations with user input using ReadlnInteger2 in PascalABC.NET",
    "output": "begin\n  var (a,b) := ReadlnInteger2('Enter a and b:');\n  Writeln;\n  Writeln(a,' + ',b,' = ',a+b);\n  Writeln(a,' - ',b,' = ',a-b);\n  Writeln(a,' * ',b,' = ',a*b);\n  Writeln(a,' / ',b,' = ',a/b);\nend."
  },
  {
    "instruction": "Call static method from C# class library in PascalABC.NET",
    "output": "{$reference ClassLibrary1.dll}\nuses ClassLibrary1;\n\nbegin\n  writeln(Class1.add(2,3));  \nend."
  },
  {
    "instruction": "Call native DLL function from PascalABC.NET with platform target specification",
    "output": "{$platformtarget x86}\nfunction add(a,b: integer): integer; external 'NativeDll.dll' name 'add';\n\nbegin\n  writeln(add(2,3));\nend."
  },
  {
    "instruction": "Demonstrate string permutations, combinations and Cartesian operations in PascalABC.NET",
    "output": "begin\n  'abc'.Permutations.Println;\n  'abc'.Permutations(2).Println;\n  'abc'.Combinations(2).Println;\n  'abc'.CartesianPower(2).Println;\n  'abc'.Cartesian('def').Println;\nend."
  },
  {
    "instruction": "Implement case statement for grade evaluation in PascalABC.NET",
    "output": "var x: integer;\n\nbegin\n  writeln('Enter grade (1..5): ');\n  readln(x);\n  case x of\n    1: writeln('One');\n    2: writeln('Two');\n    3: writeln('Three');\n    4: writeln('Four');\n    5: writeln('Five');  \n  else writeln('No such grade');\n  end;\nend."
  },
  {
    "instruction": "Use case statement with ranges for weekday classification in PascalABC.NET",
    "output": "var day: integer;\n\nbegin\n  writeln('Enter day of week number (1..7): ');\n  readln(day);\n  case day of\n    1..5: writeln('Weekday');\n    6,7: writeln('Weekend');\n  else writeln('Invalid day of week');\n  end;\nend."
  },
  {
    "instruction": "Implement character classification using case statement in PascalABC.NET",
    "output": "var c: char;\n\nbegin\n  writeln('Enter character: ');\n  readln(c);\n  case c of\n    '0'..'9': writeln('This is digit');\n    'a'..'z','A'..'Z': writeln('This is English letter');\n    'а'..'я','А'..'Я': writeln('This is Russian letter');\n  end;\nend."
  },
  {
    "instruction": "Generate random geometric shapes using case statement with GraphABC in PascalABC.NET",
    "output": "uses GraphABC;\n\nbegin\n  SetWindowSize(400,300);\n  var t := Random(1,5);\n  case t of\n    1: Circle(200,150,100);\n    2: Rectangle(100,100,300,200);\n    3: Ellipse(100,100,300,200);\n    4: RoundRect(100,100,300,200,20,20);\n    5: Line(100,100,300,200);\n  end;\nend."
  },
  {
    "instruction": "Demonstrate efficient real to integer casting in PascalABC.NET",
    "output": "begin\n  var i: integer := integer(2.7);\n  Print(i);\nend."
  },
  {
    "instruction": "Create comprehensive UI with all Controls module elements in GraphWPF using PascalABC.NET",
    "output": "uses GraphWPF,Controls;\n\nbegin\n  Window.Title := 'Controls module - all UI elements';\n  LeftPanel(160,Colors.Orange);\n \n  Button('Button');\n  CheckBox('Checkbox');\n  RadioButton('Radio button 1');\n  RadioButton('Radio button 2');\n  TextBox('Text input field');\n  var ib := IntegerBox('Integer input',0,10);\n  ib.Tooltip := 'Use mouse wheel to change value';\n  var l := ListBox('Country list');\n  l.Height := 110;\n  l.Add('Russia');\n  l.Add('USA');\n  l.Add('China');\n  l.Add('Germany');\n  l.Add('France');\n  var cb := ComboBox('Dropdown list');\n  cb.AddRange('Russia','USA','China','Germany','France');\n  \n  Slider('Slider:',0,10);\n  TextBlock('Text block');\n  IntegerBlock('Integer block:',64);\n  RealBlock('Real block:',3.5);\n\n  var s := StatusBar;\n  s.Text := 'Status bar';\nend."
  },
  {
    "instruction": "Implement 3D sphere dragging with mouse interaction using Graph3D in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin \n  View3D.Title := 'Drag sphere with mouse';\n  var s := Sphere(0,0,0,1);\n  var obj: Object3D;\n  OnMouseDown += procedure (x,y,mb) -> begin\n    obj := FindNearestObject(x,y);\n    if obj=s then View3D.Title := '';\n  end;\n\n  OnMouseUp += procedure (x,y,mb) -> begin\n    obj := nil\n  end;\n  \n  OnMouseMove += procedure (x,y,mb) -> begin\n    if obj = nil then exit;\n    var pp := PlaneXY.PointOnPlane(x,y);\n    if pp<>BadPoint then\n    begin\n      if pp.X<-5 then pp.X := -5;\n      if pp.X>5 then pp.X := 5;\n      if pp.Y<-5 then pp.Y := -5;\n      if pp.Y>5 then pp.Y := 5;\n      obj.Position := pp;\n      View3D.SubTitle := $'X={pp.x.ToString(2)} Y={pp.y.ToString(2)}';\n    end;\n  end;\nend."
  },
  {
    "instruction": "Create UI with constructor-based control creation and right panel in PascalABC.NET",
    "output": "uses GraphWPF,Controls;\n\nbegin\n  Window.Title := 'Controls module - constructor creation + right panel';\n  new RightPanelWPF(160,Colors.Orange);\n \n  new ButtonWPF('Button');\n  new CheckBoxWPF('Checkbox');\n  new RadioButtonWPF('Radio button 1');\n  new RadioButtonWPF('Radio button 2');\n  new TextBoxWPF('Text input field');\n  var ib := new IntegerBoxWPF('Integer input',0,10);\n  ib.Tooltip := 'Use mouse wheel to change value';\n  var l := new ListBoxWPF('Country list');\n  l.Height := 110;\n  l.Add('Russia');\n  l.Add('USA');\n  l.Add('China');\n  l.Add('Germany');\n  l.Add('France');\n  var cb := new ComboBoxWPF('Dropdown list');\n  cb.AddRange('Russia','USA','China','Germany','France');\n  \n  new SliderWPF('Slider:',0,10);\n  new TextBlockWPF('Text block');\n  new IntegerBlockWPF('Integer block:',64);\n  new RealBlockWPF('Real block:',3.5);\n\n  var s := new StatusBarWPF;\n  s.Text := 'Status bar';\nend."
  },
  {
    "instruction": "Implement button click handlers with different actions in Controls module using PascalABC.NET",
    "output": "uses GraphWPF,Controls;\n\nbegin\n  Window.Title := 'Controls module - buttons and their handlers';\n  var p := LeftPanel;\n  p.Color := Colors.Orange;\n \n  Button('Random color').Click := () -> begin\n    Window.Clear(RandomColor);\n  end;\n  \n  var b2 := Button('Plus');\n  b2.Click := procedure -> \n    if b2.Text = 'Plus' then b2.Text = 'Minus' else b2.Text = 'Plus';\n\n  var b1 := Button('Close window');\n  b1.Click := procedure -> Window.Close;\nend."
  },
  {
    "instruction": "Implement checkbox controls with programmatic toggling in PascalABC.NET",
    "output": "uses GraphWPF,Controls;\n\nbegin\n  Window.Title := 'Controls module - checkboxes';\n  \n  var p := LeftPanel(170,Colors.Orange);\n \n  var b1 := Button('Toggle checkbox 1');\n  var b2 := Button('Toggle checkbox 2');\n  var b3 := Button('Toggle checkbox 3');\n\n  var cb1 := new CheckBoxWPF('Checkbox 1');\n  var cb2 := new CheckBoxWPF('Checkbox 2');\n  var cb3 := new CheckBoxWPF('Checkbox 3');\n  \n  b1.Click := procedure -> cb1.Checked := not cb1.Checked;\n  b2.Click := procedure -> cb2.Checked := not cb2.Checked;\n  b3.Click := procedure -> cb3.Checked := not cb3.Checked;\nend."
  },
  {
    "instruction": "Create circle customization interface with checkboxes using WPFObjects in PascalABC.NET",
    "output": "uses WPFObjects,Controls;\n\nbegin\n  Window.Title := 'Controls module - checkboxes';\n  \n  LeftPanel(170);\n \n  var tb := TextBlock('Circle parameters:'); \n  tb.Margin := 12;\n  \n  var cb1 := new CheckBoxWPF('Fill');\n  var cb2 := new CheckBoxWPF('Bold border');\n  var cb3 := new CheckBoxWPF('With text');\n  \n  var c := new CircleWPF(GraphWindow.Center,60,Colors.White,1);\n  \n  cb1.Click := procedure -> begin\n    if cb1.Checked then \n      c.Color := Colors.Green\n    else c.Color := Colors.White\n  end;\n  cb2.Click := procedure -> begin\n    if cb2.Checked then \n      c.BorderWidth := 4\n    else c.BorderWidth := 1\n  end;\n  cb3.Click := procedure -> begin\n    if cb3.Checked then \n      c.Text := 'Text'\n    else c.Text := ''\n  end;\nend."
  },
  {
    "instruction": "Implement color selection using radio buttons with WPFObjects in PascalABC.NET",
    "output": "uses WPFObjects,Controls;\n\nbegin\n  Window.Title := 'Controls module - radio buttons';\n  LeftPanel(150,Colors.Beige);\n \n  var tb := TextBlock('Circle color:'); \n  \n  var rb1 := new RadioButtonWPF('Red');\n  var rb2 := new RadioButtonWPF('Green');\n  var rb3 := new RadioButtonWPF('Blue');\n  \n  var c := new CircleWPF(GraphWindow.Center,60,Colors.White,1);\n  \n  rb1.Click := procedure -> begin\n    c.Color := Colors.Red;\n  end;\n  rb2.Click := procedure -> begin\n    c.Color := Colors.Green;\n  end;\n  rb3.Click := procedure -> begin\n    c.Color := Colors.Blue;\n  end;\nend."
  },
  {
    "instruction": "Implement 3D object movement along lines with mouse interaction using Graph3D in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin \n  var d := new Dictionary<Object3D,Line3D>;\n  \n  var pp := Arr(p3D(2,3,0),p3D(-3,0,0),p3D(2,-2,0));\n  var p := p3D(0,0,5);\n  foreach var x in pp do\n  begin\n    var lin := Line(x,p);\n    Segment3D(x,p);\n    var s := Sphere(x,0.2);\n    d[s] := lin;\n  end;\n  \n  var tr := Polygon3D(Arr(pp));\n  \n  var obj: Object3D;\n  OnMouseDown += procedure (x,y,mb) -> begin\n    obj := FindNearestObject(x,y);\n    if obj=nil then exit;\n    if not d.ContainsKey(obj) then\n      obj := nil;\n  end;\n\n  OnMouseUp += procedure (x,y,mb) -> begin\n    obj := nil\n  end;\n\n  OnMouseMove += procedure (x,y,mb) -> begin\n    if mb<>1 then exit;\n    if obj=nil then exit;\n    \n    obj.Position := d[obj].NearestPointOnLine(x,y);\n    \n    var pp := d.Keys.Select(o->o.Position).ToArray;\n    tr.Points := Arr(pp[0],pp[1],pp[1],pp[2],pp[2],pp[0]);\n  end;\nend."
  },
  {
    "instruction": "Create UI with controls positioned manually on main panel in PascalABC.NET",
    "output": "uses GraphWPF,Controls;\n\nbegin\n  Window.Title := 'Controls module - manually positioned controls';\n\n  var x := 10;\n  var w := 140;\n  Button(x,10,'Button',w);\n  CheckBox(x,43,'Checkbox');\n  RadioButton(x,70,'Radio button 1');\n  RadioButton(x,97,'Radio button 2');\n  TextBox(x,120,'Text input field',w);\n  var ib0 := IntegerBox(x,172,'Integer input',0,10,w);\n  ib0.Tooltip := 'Use mouse wheel to change value';\n  var l0 := ListBox(x,221,'Country list',w);\n  l0.Height := 110;\n  l0.Add('Russia');\n  l0.Add('USA');\n  l0.Add('China');\n  l0.Add('Germany');\n  l0.Add('France');\n  var cb0 := ComboBox(x,362,'Dropdown list',w);\n  cb0.AddRange('Russia','USA','China','Germany','France');\n  \n  Slider(x,414,'Slider:',0,10,w);\n  TextBlock(x,469,'Text block',w);\n  IntegerBlock(x,497,'Integer block:',w,64);\n  RealBlock(x,526,'Real block:',w,3.5);\n\n  LeftPanel(160,Colors.Orange);\n \n  Button('Button');\n  CheckBox('Checkbox');\n  RadioButton('Radio button 1');\n  RadioButton('Radio button 2');\n  TextBox('Text input field');\n  var ib := IntegerBox('Integer input',0,10);\n  ib.Tooltip := 'Use mouse wheel to change value';\n  var l := ListBox('Country list');\n  l.Height := 110;\n  l.Add('Russia');\n  l.Add('USA');\n  l.Add('China');\n  l.Add('Germany');\n  l.Add('France');\n  var cb := ComboBox('Dropdown list');\n  cb.AddRange('Russia','USA','China','Germany','France');\n  \n  Slider('Slider:',0,10);\n  TextBlock('Text block');\n  IntegerBlock('Integer block:',64);\n  RealBlock('Real block:',3.5);\n\n  var s := StatusBar;\n  s.Text := 'Status bar';\nend."
  },
  {
    "instruction": "Implement 3D line-constrained sphere movement with Graph3D in PascalABC.NET",
    "output": "uses Graph3D;\n\nbegin \n  View3D.Title := 'Drag sphere with mouse';\n  \n  var p1 := p3D(2,3,0);\n  var p := p3D(0,0,5);\n  var lin := Line(p,p1);\n  Segment3D(p,p1);\n  var s := Sphere(p1,0.2);\n\n  var obj: Object3D;\n  OnMouseDown += procedure (x,y,mb) -> begin\n    obj := FindNearestObject(x,y);\n    if obj=s then View3D.Title := '';\n  end;\n\n  OnMouseUp += procedure (x,y,mb) -> begin\n    obj := nil;\n  end;\n\n  OnMouseMove += procedure (x,y,mb) -> begin\n    if mb<>1 then exit;\n    if obj=nil then exit;\n    \n    obj.Position := lin.NearestPointOnLine(x,y);\n  end;\nend."
  },
  {
    "instruction": "Create a menu system with file operations using Controls module in PascalABC.NET",
    "output": "uses Controls,GraphWPF;\n\nbegin\n  LeftPanel(150, Colors.Orange);\n  var m := new MenuWPF;\n  var mi1 := m.Add('File');\n  mi1.Add('New');\n  mi1.Add('Open');\n  mi1.Add('Save');\n  mi1.AddSeparator;\n  mi1.Add('Exit').Click := procedure->Window.Close;\n  m.Add('Edit');\n  m.Add('Options');\n  var mi := m.Add('Help');\nend."
  },
  {
    "instruction": "Create a compact menu using AddRange method in Controls module with PascalABC.NET",
    "output": "uses Controls,GraphWPF;\n\nbegin\n  LeftPanel(150, Colors.Orange);\n  var m := new MenuWPF;\n  m.AddRange('File','Edit','Options','Help');\n  m[0].AddRange('New','Open','Save','-','Exit');\n  m[0][3].Click := procedure->Window.Close;\nend."
  },
  {
    "instruction": "Implement file dialogs for opening and saving text files with menu integration in PascalABC.NET",
    "output": "uses Controls,GraphWPF;\n\nbegin\n  Window.Title := 'Controls module - OpenFileDialog and SaveFileDialog';\n  LeftPanel(150, Colors.Orange);\n  var tb := SetMainControl.AsTextBox;\n  tb.FontSize := 16;\n  tb.ReadOnly := False;\n  tb.FontName := 'Courier new Cyr';\n  \n  var dopen := new OpenFileDialogWPF('c:\\PABCWork.NET','Programs|*.pas');\n  var dSave := new SaveFileDialogWPF('c:\\PABCWork.NET','Programs|*.pas');\n  \n  var OpenHandler: procedure := procedure -> begin\n    var res := dopen.ShowDialog;\n    if res then\n      tb.Text := ReadAllText(dopen.FileName);\n  end;\n  var SaveHandler: procedure := procedure -> begin\n    var res := dSave.ShowDialog;\n    if res then\n      WriteAllText(dSave.FileName,tb.Text);\n  end;\n  \n  var bOpen := Button('Open');\n  bOpen.Click := OpenHandler;\n  \n  var bSave := Button('Save');\n  bSave.Click := SaveHandler;\n  \n  var m := Menu;\n  var m1 := m.Add('File');\n  var mm1 := m1.Add('Open');\n  mm1.Click := OpenHandler;\n  m1.Add('Save',SaveHandler);\n  m1.AddSeparator;\n  m1.Add('Exit',procedure->Window.Close);\nend."
  },
  {
    "instruction": "Demonstrate different MessageBox types with button handlers in PascalABC.NET",
    "output": "uses GraphWPF,Controls;\n\nbegin\n  Window.Title := 'Controls module - MessageBox';\n  LeftPanel(150, Colors.Orange);\n  Button('MsgBoxOK').Click := () -> MessageBox.Show('Message','Title');\n  Button('MsgBoxYesNo').Click := () -> begin\n    if MessageBox.Show('Message','Title',MessageBoxButton.YesNo) = MessageBoxResult.Yes then\n      Print('Yes')\n    else Print('No');\n  end;  \n  Button('MsgBoxWithQuestion').Click := () -> begin\n    if MessageBox.Show('Are you sure?','Title',MessageBoxButton.YesNo,MessageBoxImage.Question) \n      = MessageBoxResult.Yes then\n        Print('Sure')\n    else Print('No');\n  end;  \nend."
  },
  {
    "instruction": "Create 3D sphere generator with button control using Graph3D in PascalABC.NET",
    "output": "uses Graph3D,Controls;\n\nfunction R := Random(-7,7);\n\nbegin\n  Window.Title := 'Random spheres';\n  LeftPanel(150,Colors.Orange);\n  var b := new ButtonWPF('Create sphere');\n  b.Click := () → begin\n    Sphere(P3D(R,R,R),1);\n  end; \nend."
  },
  {
    "instruction": "Implement RGB color mixer with sliders and real-time updates in PascalABC.NET",
    "output": "uses GraphWPF,Controls;\n\nbegin\n  Window.Title := 'Colors';\n  Font.Size := 40;\n  LeftPanel(150);\n\n  var r := Slider('Red: ',0,255,255,16);\n  var g := Slider('Green: ',0,255,255,16);\n  var b := Slider('Blue: ',0,255,255,16);\n  \n  Button('Exit').Click := procedure → Window.Close;\n\n  var p: procedure := () → begin\n    var c := RGB(r.Value,g.Value,b.Value);\n    Window.Clear(c);\n    DrawText(GraphWindow.ClientRect,$'R={c.R}, G={c.G}, B={c.B}');\n  end;\n  r.ValueChanged := p;\n  g.ValueChanged := p;\n  b.ValueChanged := p;\n  p;\nend."
  },
  {
    "instruction": "Create object movement controls with keyboard and button handlers in PascalABC.NET",
    "output": "uses WPFObjects,Controls;\n\nbegin\n  Window.Title := 'Controls module - movement buttons + keyboard';\n\n  LeftPanel;\n\n  var c := new CircleWPF(GraphWindow.Center,30,Colors.Blue);\n  \n  OnKeyDown := k -> begin\n    case k of\n      Key.Left: c.MoveBy(-2,0);\n      Key.Right: c.MoveBy(2,0);\n      Key.Up: c.MoveBy(0,-2);\n      Key.Down: c.MoveBy(0,2);\n    end;\n  end;\n  \n  var l := Button('Left');\n  var r := Button('Right');\n  var u := Button('Up');\n  var d := Button('Down');\n  l.Click := ()->c.MoveBy(-2,0);\n  r.Click := ()->c.MoveBy(2,0);\n  u.Click := ()->c.MoveBy(0,-2);\n  d.Click := ()->c.MoveBy(0,2);\nend."
  },
  {
    "instruction": "Implement object positioning with IntegerBox and IntegerBlock synchronization in PascalABC.NET",
    "output": "uses WPFObjects,Controls;\n\nbegin\n  Window.Title := 'Controls module - IntegerBlock, IntegerBox and object movement';\n\n  LeftPanel;\n\n  var c := new CircleWPF(300,300,30,Colors.Blue);\n  \n  var X := IntegerBox('X:',0,600);\n  X.Value := 300;\n  var Y := IntegerBox('Y:',0,600);\n  Y.Value := 300;\n\n  var XX := IntegerBlock('X:',300);\n  var YY := IntegerBlock('Y:',300);\n  \n  X.ValueChanged := procedure → begin\n    c.Center := Pnt(X.Value,Y.Value);\n    XX.Value := X.Value;\n  end;\n  Y.ValueChanged := procedure → begin\n    c.Center := Pnt(X.Value,Y.Value);\n    YY.Value := Y.Value;\n  end;\nend."
  },
  {
    "instruction": "Create country-capital dictionary application with ListBox selection in PascalABC.NET",
    "output": "uses Controls,GraphWPF;\n\nbegin\n  Window.Title := 'Country capitals';\n  LeftPanel(150,Colors.Orange);\n  var l := ListBox('Country list');\n  l.Height := 110;\n  l.Add('Russia');\n  l.Add('USA');\n  l.Add('China');\n  l.Add('Germany');\n  l.Add('France');\n  \n  var d := Dict(('Russia','Moscow'),\n    ('USA','Washington'),\n    ('China','Beijing'),\n    ('Germany','Berlin'),\n    ('France','Paris')\n  );\n  \n  Font.Size := 70;\n  l.SelectionChanged := procedure -> begin\n    Window.Clear;\n    DrawText(GraphWindow.ClientRect,'Capital:'+#10+d[l.SelectedText]);\n  end;\nend."
  },
  {
    "instruction": "Implement country-capital selector using ComboBox with dictionary in PascalABC.NET",
    "output": "uses Controls,GraphWPF;\n\nbegin\n  Window.Title := 'Country capitals';\n  LeftPanel(150,Colors.Orange);\n  var l := ComboBox('Country list');\n  l.Tooltip := 'Select country - capital will be displayed';\n  l.Add('Russia');\n  l.Add('USA');\n  l.Add('China');\n  l.Add('Germany');\n  l.Add('France');\n  \n  var d := Dict(('Russia','Moscow'),\n    ('USA','Washington'),\n    ('China','Beijing'),\n    ('Germany','Berlin'),\n    ('France','Paris')\n  );\n  \n  Font.Size := 70;\n  l.SelectionChanged := procedure -> begin\n    Window.Clear;\n    DrawText(GraphWindow.ClientRect,d[l.SelectedText]);\n  end;\nend."
  },
  {
    "instruction": "Create function graph selector using ComboBox with dynamic redrawing in PascalABC.NET",
    "output": "uses GraphWPF,Controls;\n\nbegin\n  Window.Title := 'Controls module - ComboBox and function graphs';\n  LeftPanel(150, Colors.Orange);\n  var cb := ComboBox('Function graphs');\n  cb.AddRange('x*sin(x)','exp(x)','x*x','sin(x)-cos(2.5*x)');\n  \n  var Redraw: procedure := () -> begin\n    case cb.SelectedIndex of\n      0: DrawGraph(x->x*sin(x));\n      1: DrawGraph(x->exp(x));\n      2: DrawGraph(x->x*x);\n      3: DrawGraph(x->sin(x)-cos(2.5*x));\n    end;\n  end;\n  \n  cb.SelectionChanged := Redraw;\n  OnResize := Redraw;\n  Redraw;\nend."
  },
  {
    "instruction": "Demonstrate text wrapping functionality in TextBlock controls using PascalABC.NET",
    "output": "uses GraphWPF,Controls;\n\nbegin\n  Window.Title := 'Controls module - TextBlock wrapping mode';\n  LeftPanel(150,Colors.Orange);\n  var b := Button('No Wrap');\n  b.Tooltip := 'Click to change word wrap mode';\n  \n  var tb1 := TextBlock('This text does not fit on one line and in Wrapping mode automatically wraps');\n  b.Click := procedure → begin\n    tb1.Wrapping := not tb1.Wrapping;\n    b.Text := if tb1.Wrapping then 'Wrap' else 'No Wrap';\n  end;\n  var tb := TextBlock('This text is truncated,'#10'but you can explicitly'#10'split into lines');\nend."
  },
  {
    "instruction": "Implement toggle for control titles visibility in PascalABC.NET UI",
    "output": "uses Controls, GraphWPF;\n\nbegin\n  Window.Title := 'Controls module - controls with titles';\n  LeftPanel(170, Colors.Orange);\n  \n  var b := Button('Titles enabled');\n  \n  var tb := new TextBoxWPF('TextBox');\n  tb.Height := 40;\n  tb.Text := 'Multiple lines of text';\n  tb.Wrapping := True;\n  \n  var ib := new IntegerBoxWPF('IntegerBox', 0, 10);\n  var lb := new ListBoxWPF('ListBox',100);\n  lb.AddRange('1 2 3 4 5'.ToWords);\n  var cb := new ComboBoxWPF('ComboBox');\n  cb.AddRange('1 2 3 4 5'.ToWords);\n  var sl := new SliderWPF('Slider:');\n  \n  b.Click := procedure -> begin\n    if b.Text = 'Titles enabled' then\n      b.Text = 'Titles disabled'\n    else b.Text = 'Titles enabled';\n    tb.TitleVisible := not tb.TitleVisible;\n    ib.TitleVisible := not ib.TitleVisible;\n    lb.TitleVisible := not lb.TitleVisible;\n    cb.TitleVisible := not cb.TitleVisible;\n    sl.TitleVisible := not sl.TitleVisible;\n  end;\nend."
  },
  {
    "instruction": "Demonstrate Canvas control usage for custom element positioning in PascalABC.NET",
    "output": "uses Controls,GraphWPF;\n\nbegin\n  Window.Title := 'Controls module - replacing graphic panel with Canvas control';\n  var left := LeftPanel(150,Colors.Orange);\n  var can := SetMainControl.AsCanvas;\n  can.Color := Colors.AntiqueWhite;\n\n  Button(100,100,'On Canvas you can place elements');\n  Button(50,300,'in any location,');\n  TextBlock(150,500,'specifying their coordinates');\n  \n  SetActivePanel(left);\n  Button('Close').Click := procedure → Window.Close;\nend."
  },
  {
    "instruction": "Implement ListView control with custom class data binding in PascalABC.NET",
    "output": "uses Controls,GraphWPF;\n\ntype My = class\npublic\n  auto property Field1: integer;\n  auto property Field2: integer;\n  constructor (f1,f2: integer) := (Field1,Field2) := (f1,f2);\nend;\n\nbegin\n  Window.Title := 'Controls module - replacing graphic window with ListView element';\n  LeftPanel(150,Colors.Orange);\n  \n  var l := SetMainControl.AsListView;\n  \n  l.Fill(Arr(new My(2,5),new My(4,6)));\n  \n  Button('Clear list').Click := procedure -> l.Clear;\n  Button('Fill with data').Click := procedure -> l.Fill(|('Ivanov',20),('Petrov',19)|);\n  Button('Fill headers').Click := procedure -> l.SetHeaders('Last Name','Age');\nend."
  },
  {
    "instruction": "Create database query visualization with country data using ListView in PascalABC.NET",
    "output": "uses GraphWPF,Controls,ABCDatabases;\n\nbegin\n  Window.Title := 'Controls module - database query visualization';\n  LeftPanel(150,Colors.Orange);\n  var l := SetMainControl.AsListView;\n\n  var countries := FillCountriesArray;\n  l.Fill(countries);\n\n  Button('All').Click := procedure -> l.Fill(countries);\n  \n  Button('Asia').Click := procedure -> \n    l.Fill(countries.Where(country -> country.Continent='Asia'));\n    \n  Button('Sort by population').Click := procedure -> \n    l.Fill(countries.OrderByDescending(s -> s.Population));\nend."
  },
  {
    "instruction": "Implement country-capital selector with database integration in PascalABC.NET",
    "output": "uses GraphWPF, Controls, ABCDatabases;\n\nbegin\n  Window.Title := 'Country capitals';\n  LeftPanel(220, Colors.LightGoldenrodYellow);\n  var countries := FillCountriesArray;\n\n  var a := ListBox('Countries',550);\n  a.AddRange(countries.ConvertAll(country -> country.Name));\n  \n  var d := DictStr;\n  foreach var country in countries do\n    d[country.Name] := country.Capital;\n   \n  Font.Size := 70;\n  a.SelectionChanged := procedure -> begin\n    Window.Clear;\n    DrawText(GraphWindow.ClientRect,d[a.SelectedText])\n  end;\nend."
  },
  {
    "instruction": "Create simple calculator interface with IntegerBox controls in PascalABC.NET",
    "output": "uses Controls,GraphWPF;\n\nbegin\n  Window.Title := 'Calculator Light';\n  LeftPanel(150, Colors.Orange);\n  var tb := SetMainControl.AsTextBox;\n  tb.FontSize := 30;\n  var x := IntegerBox('X:',1,9);\n  var y := IntegerBox('Y:',1,9);\n  Button('Sum').Click := procedure -> begin\n    tb.Println($'{x.Value} + {y.Value} = {x.Value + y.Value}');\n  end;\nend."
  },
  {
    "instruction": "Implement full calculator with operation selection and status tracking in PascalABC.NET",
    "output": "uses Controls,GraphWPF;\n\nbegin\n  Window.Title := 'Calculator with TextBox output';\n  LeftPanel(150, Colors.Orange);\n  var tb := SetMainControl.AsTextBox;\n  tb.FontSize := 30;\n  var x := IntegerBox('X:');\n  var y := IntegerBox('Y:');\n  x.Value := Random(0,10);\n  y.Value := Random(0,10);\n  \n  var cb := new ComboBoxWPF('Operation');\n  cb.AddRange('+','-','*','/');\n  \n  var count := 0;\n  var sb := StatusBar;\n  sb.Text := 'Calculation count: ' + count;\n  \n  var b := Button('+');\n  b.Click := procedure -> begin\n    case cb.SelectedText of\n      '+': tb.Println($'{x.Value} + {y.Value} = {x.Value + y.Value}');\n      '-': tb.Println($'{x.Value} - {y.Value} = {x.Value - y.Value}');\n      '*': tb.Println($'{x.Value} * {y.Value} = {x.Value * y.Value}');\n      '/': tb.Println($'{x.Value} / {y.Value} = {x.Value / y.Value}');\n    end;\n    x.Value := Random(0,10);\n    y.Value := Random(0,10);\n    count += 1;\n    sb.Text := 'Calculation count: ' + count;\n  end;\n  \n  Button('Clear').Click := () -> begin\n    count := 0;\n    sb.Text := 'Calculation count: ' + count;\n    tb.Clear;\n  end;\n  \n  cb.SelectionChanged := procedure -> begin\n    b.Text := cb.SelectedText\n  end;\nend."
  },
  {
    "instruction": "Create status bar with window dimension tracking in PascalABC.NET",
    "output": "uses Controls,GraphWPF;\n\nbegin\n  Window.Title := 'Controls module - StatusBar';\n  var l := LeftPanel(150,Colors.Orange);\n  l.Tooltip := 'Change window size';\n  var sb := StatusBar(24,55);\n  sb.AddText('',55);\n  Button('Clear W field').Click := procedure -> sb.ItemText[0] := '';\n  Button('Clear H field').Click := procedure -> sb.ItemText[1] := '';\n  OnResize := () -> begin\n    sb.ItemText[0] := 'W=' + Window.Width.Round;\n    sb.ItemText[1] := 'H=' + Window.Height.Round;\n  end;\n  OnResize();\nend."
  },
  {
    "instruction": "Show how to use the CountOf method for counting substring occurrences in strings with and without overlap in PascalABC.NET",
    "output": "begin\n  var s := 'arara';\n  s.CountOf('ara').Println;\n  s.CountOf('ara',allowOverlap := True).Println;\nend."
  },
  {
    "instruction": "Write a procedure in PascalABC.NET that fills an integer array with random numbers in the range from minValue to maxValue",
    "output": "procedure FillByRandom(a: array of integer; minValue, maxValue: integer);\nbegin\n  for var i := 0 to a.Length - 1 do\n    a[i] := PABCSystem.Random(minValue, maxValue);\nend;"
  },
  {
    "instruction": "Write a procedure in PascalABC.NET that fills a real array with random numbers in the range from minValue to maxValue",
    "output": "procedure FillByRandom(a: array of real; minValue, maxValue: real);\nbegin\n  for var i := 0 to a.Length - 1 do\n    a[i] := PABCSystem.Random * (maxValue - minValue);\nend;"
  },
  {
    "instruction": "Write a procedure in PascalABC.NET that fills an array with a specified value",
    "output": "procedure FillByValue<T>(a: array of T; x: T);\nbegin\n  for var i := 0 to a.Length - 1 do\n    a[i] := x;\nend;"
  },
  {
    "instruction": "Write a function in PascalABC.NET that creates and returns an integer array of size n filled with random numbers in the range from minValue to maxValue",
    "output": "function CreateRandomIntegerArray(n: integer; minValue, maxValue: integer): array of integer;\nbegin\n  SetLength(Result, n);\n  FillByRandom(Result, minValue, maxValue);\nend;"
  },
  {
    "instruction": "Write a function in PascalABC.NET that creates and returns a real array of size n filled with random numbers in the range from minValue to maxValue",
    "output": "function CreateRandomRealArray(n: integer; minValue, maxValue: real): array of real;\nbegin\n  SetLength(Result, n);\n  FillByRandom(Result, minValue, maxValue);\nend;"
  },
  {
    "instruction": "Write a procedure in PascalABC.NET that reads an integer array from input",
    "output": "procedure ReadArray(a: array of integer);\nbegin\n  for var i := 0 to a.Length - 1 do\n    read(a[i]);\n  readln;  \nend;"
  },
  {
    "instruction": "Write a procedure in PascalABC.NET that reads a real array from input",
    "output": "procedure ReadArray(a: array of real);\nbegin\n  for var i := 0 to a.Length - 1 do\n    read(a[i]);\n  readln;  \nend;"
  },
  {
    "instruction": "Write a procedure in PascalABC.NET that reads a string array from input",
    "output": "procedure ReadArray(a: array of string);\nbegin\n  for var i := 0 to a.Length - 1 do\n    read(a[i]);\n  readln;  \nend;"
  },
  {
    "instruction": "Write a procedure in PascalABC.NET that writes an array using delimiter as a separator for values",
    "output": "procedure WriteArray<T>(a: array of T; delimiter: string := ' ');\nbegin\n  if (a=nil) or (a.Length=0) then\n    exit;\n  for var i := 0 to a.Length - 2 do\n    write(a[i], delimiter);\n  write(a[a.Length - 1]);  \nend;"
  },
  {
    "instruction": "Write a procedure in PascalABC.NET that writes an array using delimiter as a separator for values and moves to a new line",
    "output": "procedure WritelnArray<T>(a: array of T; delimiter: string := ' ');\nbegin\n  WriteArray(a, delimiter);\n  writeln;\nend;"
  },
  {
    "instruction": "Write a procedure in PascalABC.NET that sorts an array in ascending order",
    "output": "procedure Sort<T>(a: array of T);\nbegin\n  System.Array.Sort(a);\nend;"
  },
  {
    "instruction": "Write a procedure in PascalABC.NET that sorts an array in descending order",
    "output": "procedure SortDescending<T>(a: array of T);\nbegin\n  System.Array.Sort(a);\n  System.Array.Reverse(a);\nend;"
  },
  {
    "instruction": "Write a procedure in PascalABC.NET that fills a two-dimensional integer array with random numbers in the range from minValue to maxValue",
    "output": "procedure FillByRandom(a: array [,] of integer; minValue, maxValue: integer);\nbegin\n  for var i := 0 to a.GetLength(0) - 1 do\n    for var j := 0 to a.GetLength(1) - 1 do\n      a[i, j] := PABCSystem.Random(minValue, maxValue);\nend;"
  },
  {
    "instruction": "Write a procedure in PascalABC.NET that fills a two-dimensional real array with random numbers in the range from minValue to maxValue",
    "output": "procedure FillByRandom(a: array [,] of real; minValue, maxValue: real);\nbegin\n  for var i := 0 to a.GetLength(0) - 1 do\n    for var j := 0 to a.GetLength(1) - 1 do\n      a[i, j] := PABCSystem.Random * (maxValue - minValue);\nend;"
  },
  {
    "instruction": "Write a procedure in PascalABC.NET that fills a two-dimensional array with a specified value",
    "output": "procedure FillByValue<T>(a: array [,] of T; x: T);\nbegin\n  for var i := 0 to a.GetLength(0) - 1 do\n    for var j := 0 to a.GetLength(1) - 1 do\n      a[i, j] := x\nend;"
  },
  {
    "instruction": "Write a function in PascalABC.NET that creates and returns a two-dimensional integer array of size m x n filled with random numbers in the range from minValue to maxValue",
    "output": "function CreateRandomIntegerMatrix(m, n: integer; minValue, maxValue: integer): array [,] of integer;\nbegin\n  SetLength(Result, m, n);  \n  FillByRandom(Result, minValue, maxValue);\nend;"
  },
  {
    "instruction": "Write a function in PascalABC.NET that creates and returns a two-dimensional real array of size m x n filled with random numbers in the range from minValue to maxValue",
    "output": "function CreateRandomRealMatrix(m, n: integer; minValue, maxValue: real): array [,] of real;\nbegin\n  SetLength(Result, m, n);  \n  FillByRandom(Result, minValue, maxValue);\nend;"
  },
  {
    "instruction": "Write a procedure in PascalABC.NET that writes a two-dimensional array with specified width formatting",
    "output": "procedure WriteMatrix<T>(a: array [,] of T; width: integer := 0);\nbegin\n  for var i := 0 to a.GetLength(0) - 1 do\n  begin\n    for var j := 0 to a.GetLength(1) - 1 do\n      write(a[i, j]:width, ' ');\n    writeln;  \n  end;\nend;"
  },
  {
    "instruction": "Write a procedure in PascalABC.NET that writes a two-dimensional real array with specified width and decimal places formatting",
    "output": "procedure WriteMatrix(a: array [,] of real; width: integer := 0; digitsafterpoint: integer := 2);\nbegin\n  for var i := 0 to a.GetLength(0) - 1 do\n  begin\n    for var j := 0 to a.GetLength(1) - 1 do\n      write(a[i, j]:width:digitsafterpoint, ' ');\n    writeln;  \n  end;\nend;"
  },
  {
    "instruction": "Write an extension method in PascalABC.NET that writes an array using delimiter as separator",
    "output": "procedure &Array.Write(delimiter: string);\nbegin\n  if Self.Rank = 1 then\n    for var i := 0 to Self.Length - 1 do\n    begin\n      PABCSystem.write(Self.GetValue(i));\n      if i < Self.Length - 1 then\n        PABCSystem.write(delimiter);\n    end\n  else if Self.Rank = 2 then \n    for var i := 0 to Self.GetLength(0) - 1 do\n    begin\n      for var j := 0 to Self.GetLength(1) - 1 do\n        PABCSystem.write(Self.GetValue(i, j), delimiter);\n      PABCSystem.writeln;\n    end;\nend;"
  },
  {
    "instruction": "Write an extension method in PascalABC.NET that writes an array using delimiter as separator and moves to a new line",
    "output": "procedure &Array.Writeln(delimiter: string);\nbegin\n  Self.Write(delimiter);\n  PABCSystem.writeln;\nend;"
  },
  {
    "instruction": "Write a SingleNode class in PascalABC.NET that represents a node with one link field",
    "output": "type\n  SingleNode<T> = class\n  private \n    fData: T;\n    fNext: SingleNode<T>;\n  public \n    constructor Create(pData: T; pNext: SingleNode<T>);\n    begin\n      fData := pData;\n      fNext := pNext;\n    end;\n    \n    property Data: T read fData write fData;\n    property Next: SingleNode<T> read fNext write fNext;\n  end;"
  },
  {
    "instruction": "Write a complete Stack class template in PascalABC.NET with all methods implemented",
    "output": "type\n  Stack<T> = class\n  private \n    fTop: SingleNode<T> := nil; \n  public \n    constructor Create;\n    begin\n      fTop := nil;\n    end;\n    \n    procedure Push(x: T);\n    begin\n      fTop := new SingleNode<T>(x, fTop);\n    end;\n    \n    function Pop: T;\n    begin\n      if IsEmpty then \n        raise new Exception('Attempt to pop element from empty stack');\n      \n      Result := fTop.data;\n      fTop := fTop.next;  \n    end;\n    \n    function Top: T;\n    begin\n      if IsEmpty then \n        raise new Exception('Attempt to get element from empty stack');\n      \n      Result := fTop.data;\n    end;\n    \n    function IsEmpty: boolean;\n    begin\n      Result := (fTop = nil);\n    end;\n    \n    function ToString: string; override;\n    begin\n      Result := '';\n      var curElem := fTop;\n      while curElem <> nil do\n      begin\n        Result += curElem.data.ToString + ' ';\n        curElem := curElem.next;\n      end;\n    end;\n    \n    procedure Print;\n    begin\n      write(ToString);\n    end;\n    \n    procedure Println;\n    begin\n      writeln(ToString);\n    end;\n  end;"
  },
  {
    "instruction": "Write a complete Queue class template in PascalABC.NET with all methods implemented",
    "output": "type\n  Queue<T> = class\n  private \n    head: SingleNode<T>;\n    tail: SingleNode<T>;\n  public \n    constructor Create;\n    begin\n      head := nil;\n      tail := nil;\n    end;\n    \n    procedure Enqueue(x: T);\n    begin\n      if IsEmpty then\n      begin\n        head := new SingleNode<T>(x, nil);\n        tail := head;\n      end\n      else\n      begin\n        tail.next := new SingleNode<T>(x, nil);\n        tail := tail.next;\n      end;\n    end;\n    \n    function Dequeue: T;\n    begin\n      if IsEmpty then \n        raise new Exception('Attempt to remove element from empty queue');\n      \n      Result := head.data;\n      head := head.next;\n      if head = nil then\n        tail := nil;\n    end;\n    \n    function Top: T;\n    begin\n      if IsEmpty then \n        raise new Exception('Attempt to get element from empty queue');\n      Result := head.data;\n    end;\n    \n    function IsEmpty: boolean;\n    begin\n      Result := (head = nil);\n      if Result then\n        Assert(tail = nil);\n    end;\n    \n    function ToString: string; override;\n    begin\n      Result := '';\n      var curElem := head;\n      while curElem <> nil do\n      begin\n        Result += curElem.data + ' ';\n        curElem := curElem.next;\n      end;\n    end;\n    \n    procedure Print;\n    begin\n      write(ToString);\n    end;\n    \n    procedure Println;\n    begin\n      writeln(ToString);\n    end;\n  end;"
  },
  {
    "instruction": "Write a complete DynArray class template in PascalABC.NET for dynamic array with all methods implemented",
    "output": "type\n  DynArray<T> = class\n  private \n    fData: array of T;\n    fSize: integer;\n    fCap: integer;\n    \n    procedure SetElem(index: integer; x: T);\n    begin\n      if (index < 0) or (index > fSize - 1) then \n        raise new Exception('Attempt to set value to element outside array bounds with index ' + index.ToString);\n      \n      fData[index] := x;\n    end;\n    \n    function GetElem(index: integer): T;\n    begin\n      if (index < 0) or (index > fSize - 1) then \n        raise new Exception('Attempt to get value from element outside array bounds with index ' + index.ToString);\n      \n      Result := fData[index];\n    end;\n    \n  public \n    constructor Create;\n    begin\n      Create(0);\n    end;\n    \n    constructor Create(pSize: integer);\n    begin\n      if pSize < 0 then\n        raise new Exception('Attempt to set negative value to array size ' + pSize.ToString);\n      \n      fSize := pSize;\n      fCap := 2 * pSize + 4;\n      SetLength(fData, fCap);\n    end;\n    \n    procedure Reserve(newCap: integer);\n    begin\n      if newCap > fCap then \n      begin\n        SetLength(fData, newCap);\n        fCap := newCap;\n      end;\n    end;\n    \n    procedure Resize(newSize: integer);\n    begin\n      if newSize < 0 then\n        raise new Exception('Attempt to set negative value to array size ' + newSize.ToString);\n      \n      if newSize > fCap then\n      begin\n        Reserve(2 * newSize);\n        for var i := fSize to newSize - 1 do\n          fData[i] := default(T);\n      end;\n      fSize := newSize;\n    end;\n    \n    procedure Add(x: T);\n    begin\n      Resize(fSize + 1);\n      fData[fSize - 1] := x;\n    end;\n    \n    procedure Insert(pos: integer; x: T);\n    begin\n      if (pos < 0) or (pos > fSize - 1) then \n        raise new Exception('Attempt to insert outside array bounds at position ' + pos.ToString);\n      \n      Resize(fSize + 1);\n      for var i := fSize - 2 downto pos do\n        fData[i + 1] := fData[i];\n      fData[pos] := x;\n    end;\n    \n    procedure Remove(pos: integer);\n    begin\n      if (pos < 0) or (pos > fSize - 1) then \n        raise new Exception('Attempt to remove outside array bounds from position ' + pos.ToString);\n      \n      for var i := pos to fSize - 2 do\n        fData[i] := fData[i + 1];\n      Resize(fSize - 1);\n    end;\n    \n    function Find(x: T): integer;\n    begin\n      Result := -1;\n      for var i := 0 to fSize - 1 do\n        if fData[i] = x then\n        begin\n          Result := i;\n          exit;\n        end;\n    end;\n    \n    property Count: integer read fSize write Resize;\n    property Capacity: integer read fCap write Reserve;\n    property Elem[index: integer]: T read GetElem write SetElem; default;\n    \n    function ToString: string; override;\n    begin\n      Result := '';\n      for var i := 0 to fSize - 1 do\n        Result += fData[i].ToString + ' '; \n    end;\n    \n    procedure Print;\n    begin\n      write(ToString);\n    end;\n    \n    procedure Println;\n    begin\n      writeln(ToString);\n    end;\n  end;"
  },
  {
    "instruction": "Write a complete SimpleSet class template in PascalABC.NET based on dynamic array with all methods implemented",
    "output": "type\n  SimpleSet<T> = class \n  private \n    data: DynArray<T>;\n  public \n    constructor Create;\n    begin\n      data := new DynArray<T>;\n    end;\n    \n    procedure Add(x: T);\n    begin\n      if data.Find(x) = -1 then \n        data.Add(x);\n    end;\n    \n    procedure Remove(x: T);\n    begin\n      var xPos := data.Find(x);\n      if xPos <> -1 then\n        data.Remove(xPos);\n    end;\n    \n    function Contains(x: T): boolean;\n    begin\n      Result := (data.Find(x) <> -1);\n    end;\n    \n    function ToString: string; override;\n    begin\n      Result := data.ToString;\n    end;\n    \n    procedure Print;\n    begin\n      write(ToString);\n    end;\n    \n    procedure Println;\n    begin\n      writeln(ToString);\n    end;\n  end;"
  },
  {
    "instruction": "Write a complete AssocArray class template in PascalABC.NET for associative array with all methods implemented",
    "output": "type\n  AssocArray<KeyType, ValueType> = class\n  private \n    keys: DynArray<KeyType>;\n    values: DynArray<ValueType>;\n    \n    procedure SetElem(key: KeyType; value: ValueType);\n    begin\n      var ind := Keys.Find(key);\n      if ind <> -1 then\n        Values[ind] := value\n      else\n      begin\n        Keys.Add(key);\n        Values.Add(value);\n      end;\n    end;\n    \n    function GetElem(key: KeyType): ValueType;\n    begin\n      var ind := Keys.Find(key);\n      if ind <> -1 then\n        Result := Values[ind]\n      else Result := default(ValueType);\n    end;\n    \n  public \n    constructor Create;\n    begin\n      keys := new DynArray<KeyType>;\n      values := new DynArray<ValueType>;\n    end;\n    \n    property Elem[key: KeyType]: ValueType read GetElem write SetElem; default;\n    \n    function ToString: string; override;\n    const\n      NewLine = #13#10;\n    begin\n      Result := '';\n      for var i := 0 to keys.Count - 1 do\n        Result += keys[i].ToString + ' ' + values[i].ToString + NewLine;\n    end;\n    \n    procedure Print;\n    begin\n      write(ToString);\n    end;\n    \n    procedure Println;\n    begin\n      write(ToString);\n    end;\n  end;"
  },
  {
    "instruction": "Write a complete LinkedListNode class in PascalABC.NET that represents a node with two link fields",
    "output": "type\n  LinkedListNode<T> = class\n  private \n    fData: T;\n    fPrev: LinkedListNode<T>;\n    fNext: LinkedListNode<T>;\n  public \n    constructor Create(data: T; prev, next: LinkedListNode<T>);\n    begin\n      fData := data;\n      fNext := next;\n      fPrev := prev;\n    end;\n    property Value: T read fData write fData;\n    property Prev: LinkedListNode<T> read fPrev;\n    property Next: LinkedListNode<T> read fNext;\n  end;"
  },
  {
    "instruction": "Write a complete LinkedList class template in PascalABC.NET for doubly linked linear list with all methods implemented",
    "output": "type\n  LinkedList<T> = class\n  private \n    fFirst: LinkedListNode<T>;\n    fLast: LinkedListNode<T>;\n  public \n    constructor Create;\n    begin\n    end;\n    \n    property First: LinkedListNode<T> read fFirst;\n    property Last: LinkedListNode<T> read fLast;\n    \n    procedure AddFirst(x: T);\n    begin\n      var val := new LinkedListNode<T>(x, nil, fFirst);\n      if fFirst <> nil then\n        fFirst.fPrev := val;\n      \n      fFirst := val;\n      if fLast = nil then\n        fLast := fFirst;\n    end;\n    \n    procedure AddLast(x: T);\n    begin\n      var val := new LinkedListNode<T>(x, fLast, nil);\n      if fLast <> nil then\n        fLast.fNext := val;\n      \n      fLast := val;\n      if fFirst = nil then\n        fFirst := fLast;\n    end;\n    \n    procedure RemoveFirst();\n    begin\n      if fFirst = nil then\n        raise new Exception('Attempt to remove from empty list');\n      \n      fFirst := fFirst.fNext;\n      if fFirst = nil then\n        fLast := nil\n      else\n        fFirst.fPrev := nil;\n    end;\n    \n    procedure RemoveLast();\n    begin\n      if fLast = nil then\n        raise new Exception('Attempt to remove from empty list');\n      \n      fLast := fLast.fPrev;\n      if fLast = nil then\n        fFirst := nil\n      else\n        fLast.fNext := nil;\n    end;\n    \n    procedure AddBefore(node: LinkedListNode<T>; x: T);\n    begin\n      if node = nil then\n        raise new Exception('Parameter node is null reference');\n      \n      if node = fFirst then\n        AddFirst(x)\n      else\n      begin\n        var val := new LinkedListNode<T>(x, node.fPrev, node);\n        node.fPrev.fNext := val;\n        node.fPrev := val;\n      end;\n    end;\n    \n    procedure AddAfter(node: LinkedListNode<T>; x: T);\n    begin\n      if node = nil then\n        raise new Exception('Parameter node is null reference');\n      \n      if node = fLast then\n        AddLast(x)\n      else\n      begin\n        var val := new LinkedListNode<T>(x, node, node.fNext);\n        node.fNext.fPrev := val;\n        node.fNext := val;\n      end;\n    end;\n    \n    procedure Remove(node: LinkedListNode<T>);\n    begin\n      if node = nil then\n        raise new Exception('Parameter node is null reference');\n      \n      if node = fFirst then\n        RemoveFirst\n      else if node = fLast then\n        RemoveLast\n      else\n      begin\n        node.fPrev.fNext := node.fNext;\n        node.fNext.fPrev := node.fPrev;\n      end;\n    end;\n    \n    function ToString: string; override;\n    begin\n      Result := '';\n      var cur := fFirst;\n      while cur <> nil do\n      begin\n        Result := cur.Value.ToString + ' ';\n        cur := cur.Next;\n      end;\n    end;\n    \n    procedure Print;\n    begin\n      write(ToString);\n    end;\n    \n    procedure Println;\n    begin\n      writeln(ToString);\n    end;\n  end;"
  },
  {
    "instruction": "Write a PascalABC.NET class for Chebyshev polynomial approximation of tabular function using least squares method",
    "output": "type\n  ApproxCheb=class\n  private\n  nt:integer;\n  a:array[,] of real;\n  \n  procedure MatrCreate;\n  begin\n    a:=new real[r+1,r+2];\n    var p,s:real;\n    for var i:=0 to r do begin\n      (p,s):=(1.0,x[i]); a[i,r+1]:=f[i];\n      for var j:=0 to r do begin a[i,j]:=p; p*=s end\n      end\n  end;\n  \n  procedure Gauss;\n  begin\n    var n1:=r+1;\n    c:=new real[n1];\n    var p,s:real;   \n    for var k:=0 to r do begin\n      var k1:=k+1; s:=a[k,k]; var jj:=k; \n      for var i:=k1 to r do begin\n        p:=a[i,k]; \n        if Abs(r)>Abs(s) then (s,jj):=(p,i)\n        end; \n      if jj<>k then\n        for var i:=k to n1 do Swap(a[k,i],a[jj,i]);\n      for var j:=k1 to n1 do a[k,j]/=s; \n      for var i:=k1 to r do begin\n        p:=a[i,k];\n        for var j:=k1 to n1 do a[i,j]-=a[k,j]*p\n        end\n      end; \n    for var i:=r downto 0 do begin\n      s:=a[i,n1];\n      for var j:=i+1 to r do s-=a[i,j]*c[j];\n      c[i]:=s\n      end\n  end;\n  \n  public\n  x:array of real;\n  y:array of real;\n  tol:real;\n  r:integer;\n  f:array of real;\n  c:array of real;\n  \n  constructor (x,y:array of real; eps:real);\n  begin\n    nt:=x.Length;\n    Assert(nt=y.Length,'Approx: point count mismatch in argument and function');\n    Self.x:=x;\n    Self.y:=y;\n    f:=ArrFill(nt,0.0);\n    Cheb(eps)\n  end;\n  \n  procedure Cheb(e:real);\n  begin\n    r:=0;\n    var n:=nt-1;\n    var f1:=ArrFill(nt,0.0);\n    var f2:=ArrFill(nt,1.0);\n    var eps:=ArrFill(nt,0.0);\n    while true do begin\n      var sum1:=y.Zip(f2,(p,q)->p*q).Sum;\n      var sum2:=f2.Select(p->p*p).Sum;\n      var al:=sum1/sum2;\n      f:=f.Zip(f2,(p,q)->p+al*q).ToArray;\n      for var i:=0 to n do eps[i]:=Abs(y[i]-f[i]);\n      tol:=Sqrt((eps.Select(t->t*t).Sum)/n);\n      if (tol<e) or (r>=n+1) then break;\n      sum1:=x.Zip(f2,(p,q)->p*q*q).Sum;\n      sum2:=f2.Select(p->p*p).Sum;\n      var be:=-(sum1/sum2);\n      var g:real;\n      if r<>0 then begin\n        (sum1,sum2):=(0.0,0.0);\n        for var i:=0 to n do begin sum1+=x[i]*f1[i]*f2[i]; sum2+=Sqr(f1[i]) end;\n        g:=-(sum1/sum2);\n        end;\n      r+=1;\n      for var i:=0 to n do begin\n        var a:=f1[i]; f1[i]:=f2[i]; f2[i]:=(x[i]+be)*f1[i]+g*a\n        end\n      end\n  end;\n  \n  procedure MakeCoef;\n  begin\n    MatrCreate;\n    Gauss\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for LU decomposition of real matrix for solving linear equation systems",
    "output": "type\n  Decomp=class\n  private\n  n:integer;\n  \n  procedure Decomp;\n  begin\n    Assert(a.RowCount=a.ColCount,'DECOMP: matrix is not square');\n    ipvt[n]:=1;\n    if n=0 then begin\n      if a[0,0]<>0 then cond:=1\n      else cond:=MaxReal;\n      Exit\n      end;\n    var anorm:=a.Cols.Select(r->r.Select(x->Abs(x)).Sum).Max;\n    for var k:=0 to n-1 do begin\n      var m:=k;\n      for var i:=k+1 to n do\n        if Abs(a[i,k])>Abs(a[m,k]) then m:=i;\n      ipvt[k]:=m;\n      if m<>k then ipvt[n]:=-ipvt[n];\n      Swap(a[m,k],a[k,k]);\n      if a[k,k]<>0 then begin\n        for var i:=k+1 to n do a[i,k]:=-a[i,k]/a[k,k];\n        for var j:=k+1 to n do begin\n          Swap(a[m,j],a[k,j]);\n          if a[k,j]<>0 then\n            for var i:=k+1 to n do a[i,j]+=a[i,k]*a[k,j]\n          end\n        end\n      end;\n    var work:=new real[n+1];\n    for var k:=0 to n do begin\n      var t:=0.0;\n      if k<>0 then\n        for var i:=0 to k-1 do t+=a[i,k]*work[i];\n      var ek:=1.0;\n      if t<0.0 then ek:=-1.0;\n      if a[k,k]=0.0 then begin cond:=MaxReal; Exit end;\n      work[k]:=-(ek+t)/a[k,k];\n      end;\n    for var kb:=0 to n-1 do begin\n      var k:=n-kb-1;\n      var t:=0.0;\n      for var i:=k+1 to n do t+=a[i,k]*work[k];\n      work[k]:=t;\n      var m:=ipvt[k];\n      if m<>k then Swap(work[m],work[k])\n      end;\n    var ynorm:=work.Select(x->Abs(x)).Sum;\n    Self.Solve(work);\n    var znorm:=work.Select(x->Abs(x)).Sum;\n    cond:=Max(anorm*znorm/ynorm,1.0);\n    det:=real(ipvt.Last);\n    for var i:=0 to a.RowCount-1 do det*=a[i,i];\n  end;\n  \n  public\n  a:array[,] of real;\n  cond:real;\n  ipvt:array of integer;\n  det:real;\n  \n  constructor(a:array[,] of real);\n  begin\n    n:=a.RowCount-1;\n    Assert((n=a.ColCount-1) and (n>=0),'DECOMP: source matrix is not square');\n    Self.a:=new real[n+1,n+1];\n    for var i:=0 to n do\n      for var j:=0 to n do\n        Self.a[i,j]:=a[i,j];\n    Self.ipvt:=new integer[n+1];\n    Decomp\n  end;\n  \n  procedure Solve(b:array of real);\n  begin\n    Assert(b.Length-1=n,'DECOMP/SOLVE: wrong length of right-hand side vector');\n    for var k:=0 to n-1 do begin\n      var m:=ipvt[k];\n      Swap(b[m],b[k]);\n      for var i:=k+1 to n do b[i]+=a[i,k]*b[k]\n      end;\n    for var k:=n downto 1 do begin\n      b[k]/=a[k,k];\n      var t:=-b[k];\n      for var i:=0 to k-1 do begin\n        b[i]+=a[i,k]*t;\n        end\n      end;\n    b[0]/=a[0,0]\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for factoring polynomial with integer coefficients into rational linear factors",
    "output": "type\n  Factors=class\n  private\n  a:array of integer;\n  n:integer;\n  \n  public\n  \n  constructor(params a:array of integer);\n  begin\n    Self.a:=a;\n    Self.n:=a.Length-1;\n  end;\n\n  function Factorize:array[,] of integer;\n  begin\n    var f,g,q:integer;\n    var (r,c):=(0,1);\n    Result:=new integer[n+1,2];\n    var b:=a.Reverse.ToArray;\n    while b[n]=1 do begin\n      n-=1; r+=1;\n      (Result[r,0],Result[r,1]):=(1,0);\n      end;\n    var Fin:=false;\n    for var p:=1 to Abs(b[0]) do\n      if b[0] mod p=0 then\n        for var q1:=1 to Abs(b[n]) do begin\n          q:=q1;\n          if q<>1 then begin\n            var flag:=true;\n            for var j:=0 to n do\n              if b[j] mod q<>0 then begin flag:=false; break end;\n            if flag then\n              for var j:=0 to n do b[j]:=b[j] div q\n            end;\n          repeat\n            (f,g):=(b[0],1);\n            for var i:=1 to n do begin g*=p; f:=f*q+g*b[i] end;\n            if f=0 then begin\n              r+=1;\n              (Result[r,0],Result[r,1]):=(p,q);\n              for var i:=0 to n do begin f:=(b[i]+f) div p; b[i]:=f; f*=q end;\n              n-=1;\n              if n<>0 then continue;\n              Fin:=true\n              end;\n            if not Fin then q:=-q;\n          until (q>0) or Fin;\n          if Fin then break;\n          end;\n      if n=0 then c*=b[0];\n      (Result[0,0],Result[0,1]):=(r,c);\n      SetLength(Result,r+1,2)\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for finding function minimum on given interval using Brent's method",
    "output": "type\n  FMin=class\n  private\n  a,b,t:real;\n  f:real->real;\n  \n  procedure FMin;\n  begin\n    var d,fu,u,tol1:real;\n    var c:=0.5*(3-Sqrt(5.0));\n    var(sa,sb):=(a,b);\n    x:=sa+c*(b-a);\n    var w:=x;\n    var (v,e,fx):=(w,0.0,f(x));\n    var fw:=fx;\n    var fv:=fw;\n    var eps:=1.0;\n    repeat\n      eps:=0.5*eps;\n      tol1:=1.0+eps\n    until tol1<=1.0;\n    eps:=Sqrt(eps);\n    repeat\n      var m:=0.5*(sa+sb);\n      var tol:=eps*Abs(x)+t;\n      var t2:=2*tol;\n      if Abs(x-m) <= t2-0.5*(sb-sa) then break;\n      var r:=0.0;\n      var q:=r;\n      var p:=q;\n      if tol<Abs(e) then begin\n        r:=(x-w)*(fx-fv); q:=(x-v)*(fx-fw);\n        p:=(x-v)*q-(x-w)*r; q:=2.0*(q-r);\n        if q>0.0 then p:=-p;\n        q:=Abs(q); r:=e; e:=d\n        end;\n      if (Abs(p)<Abs(0.5*q*r)) and (q*(sa-x)<p) and (p<q*(sb-x)) then begin\n        d:=p/q; u:=x+d;\n        if ((u-sa)<t2) or ((sb-u)<t2) then d:=x<m?tol:-tol;\n        end\n      else begin\n        e:=x<m?sb-x:sa-x; d:=c*e\n        end;\n      if tol<=Abs(d) then u:=x+d\n      else if d>0.0 then u:=x+tol\n      else u:=x-tol;\n      fu:=f(u);\n      if fu<=fx then begin\n        if u<x then sb:=x else sa:=x;\n        (v,fv):=(w,fw);\n        (w,fw):=(x,fx);\n        (x,fx):=(u,fu)\n        end\n      else begin\n        if u<x then sa:=u else sb:=u;\n        if (fu<=fw) or (w=x) then begin\n          (v,fv):=(w,fw);\n          (w,fw):=(u,fu)\n          end\n        else\n          if (fu<=fv) or (v=x) or (v=w) then (v,fv):=(u,fu)\n        end\n    until false;\n    Value:=fx\n  end;\n  \n  public\n  x:real;\n  Value:real;\n  \n  constructor(f:real->real; a,b:real; t:real:=1.05e-8);\n  begin\n    Self.a:=a;\n    Self.b:=b;\n    Self.t:=t;\n    Self.f:=f;\n    FMin\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for minimization of multivariable function using Hooke-Jeeves direct search method",
    "output": "type\n  FMinN=class\n  private\n  delta:array of real;\n  fbefore:real;\n  newx:array of real;\n  fun:function(x:array of real):real;\n  \n  function BestNearby:real;\n  begin\n    Result:=fbefore;\n    var z:=Copy(newx);\n    for var i:=0 to n-1 do begin\n    z[i]:=newx[i]+delta[i];\n    var ftmp:=fun(z);\n    if ftmp<Result then Result:=ftmp\n    else begin\n      delta[i]:=-delta[i];\n      z[i]:=newx[i]+delta[i];\n      ftmp:=fun(z);\n      if ftmp<Result then Result:=ftmp\n      else z[i]:=newx[i]\n      end\n    end;\n    newx:=Copy(z);\n  end;\n  \n  public\n  n:integer;\n  iter:integer;\n  x:array of real;\n  \n  constructor (px:array of real; f:function(x:array of real):real);\n  begin\n    n:=px.Length;\n    x:=Copy(px);\n    fun:=f;\n    iter:=0;\n    Randomize;\n  end;\n  \n  function HJ(eps:real:=1e-6; rho:real:=0.5; itermax:integer:=5000):array of real;\n  begin\n  newx:=Copy(x);\n  var xbefore:=Copy(x);\n  delta:=x.Select(t->t=0?rho:rho*Abs(t)).ToArray;\n  var steplength:=rho;\n  iter:=0;\n  fbefore:=fun(newx);\n  var newf:=fbefore;\n  while (iter<itermax) and (eps<steplength) do begin\n    iter+=1;\n    newx:=Copy(xbefore);\n    newf:=BestNearby;\n    var keep:=1;\n    while (newf<fbefore) and (keep=1) do begin\n      for var i:=0 to n-1 do begin\n        if newx[i]<=xbefore[i] then delta[i]:=-Abs(delta[i])\n        else delta[i]:=Abs(delta[i]);\n        var tmp:=xbefore[i];\n        xbefore[i]:=newx[i];\n        newx[i]+=newx[i]-tmp\n        end;\n      fbefore:=newf;\n      newf:=BestNearby;\n      if fbefore<=newf then break;\n      keep:=0;\n      for var i:=0 to n-1 do\n        if 0.5*Abs(delta[i])<Abs(newx[i]-xbefore[i]) then begin\n          keep:=1; break\n          end;\n      end;\n    if (eps<=steplength) and (fbefore<=newf) then begin\n      steplength*=rho;\n      delta.Transform(x->x*rho);\n      end\n    end;\n  Result:=Copy(xbefore);\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for arbitrary precision fractions with arithmetic operations",
    "output": "type\n  Fraction=class\n  private\n  class function GCD(a, b: BigInteger): BigInteger;\n  begin\n    if a < 0 then\n      a := -a;\n    while b <> 0 do\n      (a, b) := (b, a mod b);\n    Result := a\n  end;\n\n  public\n  numerator:BigInteger;\n  denominator:BigInteger;\n  \n  constructor (num:BigInteger:=0; denom:BigInteger:=1);\n  begin\n    Assert(denom>0,'Fraction: denominator must be positive');\n    var n:=GCD(num,denom);\n    numerator:=num div n;\n    denominator:=denom div n\n  end;\n  \n  class function operator +(a,b:fraction):fraction;\n  begin\n    var n:=GCD(a.denominator,b.denominator);\n    Result:=new fraction(a.numerator*(b.denominator div n)+\n        b.numerator*(a.denominator div n),a.denominator div n*b.denominator);\n  end;\n  \n  class function operator -(a,b:fraction):fraction;\n  begin\n    var n:=GCD(a.denominator,b.denominator);\n    Result:=new fraction(a.numerator*(b.denominator div n)-\n        b.numerator*(a.denominator div n),a.denominator div n*b.denominator);\n  end;\n  \n  class function operator *(a,b:fraction):fraction;\n  begin\n    Result:=new fraction(a.numerator*b.numerator,a.denominator*b.denominator);\n    var n:=GCD(Result.numerator,Result.denominator);\n    if n<>1 then begin\n      Result.numerator:=Result.numerator div n;\n      Result.denominator:=Result.denominator div n\n      end\n  end;\n  \n  class function operator /(a,b:fraction):fraction;\n  begin\n    Result:=new fraction(a.numerator*b.denominator,a.denominator*b.numerator);\n    var n:=GCD(Result.numerator,Result.denominator);\n    if n<>1 then begin\n      Result.numerator:=Result.numerator div n;\n      Result.denominator:=Result.denominator div n\n      end\n  end;\n  \n  function Inv:fraction;\n  begin\n    Result:=new fraction;\n    Result.numerator:=denominator;\n    Result.denominator:=numerator\n  end;\n  \n  function Abs:fraction;\n  begin\n    Result:=new fraction;\n    Result.numerator:=PABCSystem.Abs(numerator);\n    Result.denominator:=denominator\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for vector operations including cross product and mixed product",
    "output": "type\n  Vector=class\n  public\n    Value:array of real;\n    Length:integer;\n  \n  constructor (params px:array of real);\n  begin\n    Value:=PABCSystem.Copy(px);\n    Length:=Value.Length;\n    Assert(Value.Length<>0,'Vector: zero length prohibited')\n  end;\n  \n  class function operator + (va,vb:Vector):Vector;\n  begin\n    Assert(va.Length=vb.Length,'Vector: lengths incompatible');\n    Result:=new Vector(va.Value.Zip(vb.Value,(p,q)->p+q).ToArray);\n  end;\n  \n  class function operator - (va,vb:Vector):Vector;\n  begin\n    Assert(va.Length=vb.Length,'Vector: lengths incompatible');\n    Result:=new Vector(va.Value.Zip(vb.Value,(p,q)->p-q).ToArray);\n  end;\n  \n  class function operator * (va,vb:Vector):real;\n  begin\n    Assert(va.Length=vb.Length,'Vector: lengths incompatible');\n    Result:=va.Value.Zip(vb.Value,(p,q)->p*q).Sum;\n  end;\n  \n  function VP(vb:Vector):Vector;\n  begin\n    Result:=new Vector(3);\n    Assert(Length=vb.Length,'Vector.VP: vector lengths incompatible');\n    if (Length=2) or (Length=3) then begin\n      var r:=new real[3,3] ((1,1,1),(0,0,0),(0,0,0));\n      for var j:=0 to Length-1 do begin\n        r[1,j]:=Value[j];\n        r[2,j]:=vb.Value[j]\n        end;\n      Result.Value[0]:=r[1,1]*r[2,2]-r[1,2]*r[2,1];\n      Result.Value[1]:=-r[1,0]*r[2,2]+r[1,2]*r[2,0];\n      Result.Value[2]:=r[1,0]*r[2,1]-r[1,1]*r[2,0]\n      end       \n    else begin\n      Assert(false,'Vector.VP: Vectors must be 2D or 3D');\n      Result.Value:=ArrFill(3,MaxReal)\n      end\n  end;\n  \n  function MP(vb,vc:Vector):real;\n  begin\n    Assert((Length=vb.Length) or (Length=vc.Length),\n        'Vector.MP: vector lengths incompatible');\n    if (Length=2) or (Length=3) then begin\n      var r:=new real[3,3];\n      for var j:=0 to Length-1 do begin\n        r[0,j]:=Value[j];\n        r[1,j]:=vb.Value[j];\n        r[2,j]:=vc.Value[j]\n        end;\n      Result:=r[0,0]*(r[1,1]*r[2,2]-r[1,2]*r[2,1])-\n          r[0,1]*(r[1,0]*r[2,2]-r[1,2]*r[2,0])+\n          r[0,2]*(r[1,0]*r[2,1]-r[1,1]*r[2,0])\n      end       \n    else begin\n      Assert(false,'Vector.VP: Vectors must be 2D or 3D');\n      Result:=MaxReal\n      end\n  end;\n  \n  function ModV:real; \n  begin\n    Result:=Sqrt(Value.Select(t->t*t).Sum);\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for matrix operations including determinant, inverse and linear system solution",
    "output": "type\n  Matrix=class\n  public\n    Value: array[,] of real;\n    RowCount:  integer;\n    ColCount:  integer;\n  \n  constructor (pa:array[,] of real);\n  begin\n    (RowCount,ColCount):=(pa.RowCount,pa.ColCount);\n    Value:=new real[RowCount,ColCount];\n    for var i:=0 to RowCount-1 do\n      for var j:=0 to ColCount-1 do\n        Value[i,j]:=pa[i,j]\n  end;\n  \n  class function operator + (pa,pb:Matrix):Matrix;\n  begin\n    Assert((pa.RowCount=pb.RowCount) and (pa.ColCount=pb.ColCount),\n        'Matrix addition: size mismatch');\n    Result:=new Matrix(pa.RowCount,pa.ColCount);\n    for var i:=0 to pa.RowCount-1 do\n      for var j:=0 to pa.ColCount-1 do\n        Result.Value[i,j]:=pa.Value[i,j]+pb.Value[i,j]\n  end;\n  \n  class function operator * (pa,pb:Matrix):Matrix;\n  begin\n    Assert(pa.ColCount=pb.RowCount,\n        'Matrix: matrix multiplication. Size mismatch');\n    Result:=new Matrix(pa.RowCount,pb.ColCount);\n    for var i:=0 to pa.RowCount-1 do\n      for var j:=0 to pb.ColCount-1 do begin\n        var s:=0.0;\n        for var k:=0 to pa.ColCount-1 do\n          s+=pa.Value[i,k]*pb.Value[k,j];\n        Result.Value[i,j]:=s\n        end\n  end;\n  \n  function Det:real;\n  begin\n    var r:=new Decomp(Value);\n    Result:=r.det\n  end;\n  \n  function Inv:Matrix;\n  begin\n    Assert(RowCount=ColCount,'Matrix.Inv: matrix is not square');\n    Result:=new Matrix(RowCount,ColCount);\n    var r:=new Decomp(Value);\n    if r.cond<MaxReal then begin\n      for var j:=0 to ColCount-1 do begin\n        var v:=ArrGen(RowCount,i->i=j?1.0:0.0);\n        r.Solve(v);\n        for var i:=0 to RowCount-1 do Result.Value[i,j]:=v[i]\n        end\n      end\n    else Result.Value:=MatrFill(RowCount,ColCount,MaxReal);  \n  end;\n  \n  function SLAU(vb:Vector; var cond:real):Vector;\n  begin\n    Assert(vb.Length=ColCount,\n        'Matrix.SLAU: vector vb length incompatible with matrix size');\n    var r:=new Decomp(Value);\n    cond:=r.cond;\n    Result:=new Vector(vb.Length);\n    Result.Value:=PABCSystem.Copy(vb.Value);\n    r.Solve(Result.Value);\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for polynomial arithmetic including differentiation and integration",
    "output": "type\n  Polynom=class\n  public\n    a:array of real;\n    n:integer;\n    eps:real;\n  \n  constructor(params p:array of real);\n  begin\n    a:=PABCSystem.Copy(p);\n    n:=a.Length\n  end;\n\n  function Value(x:real):real;\n  begin\n    Result:=a[0];\n    var k:=1.0;\n    for var i:=1 to n-1 do begin\n      k*=x;\n      Result+=a[i]*k\n      end;\n  end;\n  \n  function PDif:Polynom;\n  begin\n    Result:=new Polynom(n-1);\n    for var i:=0 to n-2 do Result.a[i]:=a[i+1]*(i+1)\n  end;\n  \n  function PInt:Polynom;\n  begin\n    Result:=new Polynom(Arr(0.0)+a);\n    for var i:=1 to Result.n-1 do Result.a[i]/=i\n  end;\n  \n  class function operator + (p,q:Polynom):Polynom;\n  begin\n    var m:=Max(p.n,q.n);\n    Result:=new Polynom(m);\n    if p.n>q.n then begin\n      for var i:=0 to q.n-1 do Result.a[i]:=p.a[i]+q.a[i];\n      for var i:=q.n to m-1 do Result.a[i]:=p.a[i]\n      end\n    else begin\n      for var i:=0 to p.n-1 do Result.a[i]:=p.a[i]+q.a[i];\n      for var i:=p.n to m-1 do Result.a[i]:=q.a[i]\n      end\n  end;\n  \n  class function operator * (p,q:Polynom):Polynom;\n  begin\n    var m:=p.n+q.n-1;\n    Result:=new Polynom(m);\n    for var i:=0 to p.n-1 do\n      for var j:=0 to q.n-1 do\n        Result.a[i+j]+=p.a[i]*q.a[j]\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for finding all roots of polynomial with real coefficients using Newton-Raphson method",
    "output": "type\n  PolRt=class\n  private\n    p:Polynom;\n  \n  public\n    ier:integer;\n  \n  constructor(p:Polynom);\n  begin\n    Self.p:=p;\n  end;\n\n  function Value:array of complex;\n  begin\n    var m:=p.n-2;\n    if m>35 then begin ier:=2; Exit end;\n    if p.a[m+1]=0 then begin ier:=4; Exit end;\n    if m<=0 then begin ier:=1; Exit end;\n    var SSq:complex->real:=x->Sqr(x.Real)+Sqr(x.Imaginary);\n    ier:=0;\n    Result:=new complex[m+1];\n    var sumsq,temp,alpha:real;\n    var x:complex;\n    var L50, L60, L100, L135: boolean;\n    var (ifit,n2,n,nx,nxx):=(0,0,m,m,m+1);\n    var kj1:=nxx;\n    var cof:=p.a.Reverse.ToArray;\n    while n>=0 do begin\n      var xo:=cplx(0.00500101,0.01000101);\n      var ini:=0;\n      (L50,L60,L135):=(false,false,false);\n      while true do begin\n        if not l60 then begin\n          xo:=cplx(-10*xo.Imaginary,-10*xo.Real); x:=xo; ini+=1\n          end;\n        L100:=false;\n        var xpr:=cplx(0.0,0.0);\n        for var ict:=1 to 500 do begin\n          var u:=cplx(cof[n+1],0.0);\n          var xt:=cplx(1.0,0.0);\n          var ux:=cplx(0.0,0.0);\n          if u.Real=0 then begin\n            (x,L50,L135):=(0.0,true,true); nx-=1; nxx-=1;\n            break\n            end;\n          for var i:=1 to n+1 do begin\n            temp:=cof[n-i+1];\n            var xt2:=x*xt;\n            u+=temp*xt2; ux+=Conjugate(i*temp*xt);\n            xt:=xt2\n            end;\n          sumsq:=SSq(ux);\n          if sumsq=0.0 then\n            if ifit=0 then begin L60:=false; continue end\n            else begin x:=xpr; L50:=true; break end;\n          var dx:=-u*ux/sumsq; x+=dx;\n          if Abs(dx.Imaginary)+Abs(dx.Real)<1e-12 then begin\n            L100:=true; break\n            end\n          end;\n        if not L50 then begin  \n          L100:=L100 or (ifit<>0);\n          if not L100 then\n            if ini>=5 then begin ier:=3; Exit end\n            else begin L60:=false; continue end;\n          for var l:=0 to nxx do Swap(p.a[kj1-l],cof[l]);\n          Swap(n,nx);\n          if ifit=0 then begin\n            (ifit,xpr,L60):=(1,x,true);\n            continue\n            end\n          else break\n          end\n        end;\n      L50:=false;\n      if L135 then begin\n        x:=cplx(x.Real,0.0); (sumsq,alpha,L135):=(0.0,x.Real,false); n-=1;\n        end\n      else begin\n        ifit:=0;\n        if Abs(x.Imaginary)-1e-10*Abs(x.Real)>=0 then begin\n          alpha:=2*x.Real; sumsq:=SSq(x); n-=2\n          end\n        else begin\n          x:=cplx(x.Real,0.0); (sumsq,alpha):=(0.0,x.Real); n-=1\n          end\n        end;\n      cof[1]:=cof[1]+alpha*cof[0];\n      for var l:=1 to n do cof[l+1]+=alpha*cof[l]-sumsq*cof[l-1];\n      Result[n2]:=x; n2+=1;\n      if sumsq<>0.0 then begin\n        Result[n2]:=Conjugate(x); n2+=1\n        end\n      end\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for adaptive quadrature numerical integration using QUANC8 algorithm",
    "output": "type\n  Quanc8=class\n  private\n  fun:real->real;\n  a,b,abserr,relerr:real;\n  \n  public\n  \n  constructor(f:real->real; a,b,abserr,relerr:real);\n  begin\n    fun:=f;\n    Self.a:=a;\n    Self.b:=b;\n    Self.abserr:=abserr;\n    Self.relerr:=relerr;\n  end;\n\n  function Value:(real,real,real,integer);\n  begin\n    var (res,errest,flag):=(0.0,0.0,0.0);\n    var nofun:=0;\n    var (levmin,levmax,levout,nomax):=(1,30,6,5000);\n    var nofin:=nomax-8*(levmax-levout+128);\n    var k:=14175.0;\n    var (w0,w1,w2,w3,w4):=(3956.0/k,23552.0/k,-3712.0/k,41984.0/k,-18160.0/k);\n    var (area,cor11):=(0.0,0.0);\n    if(a=b) then begin Result:=(0.0,0.0,0.0,0); Exit end;\n    var (lev,nim):=(0,1);\n    var x:=new real[17];\n    (x[0],x[16]):=(a,b);\n    var qprev:=0.0;\n    var f:=new real[17];\n    f[0]:=fun(x[0]);\n    var stone:=(b-a)/16;\n    x[8]:=(x[0]+x[16])/2;\n    x[4]:=(x[0]+x[8])/2;\n    x[12]:=(x[8]+x[16])/2;\n    x[2]:=(x[0]+x[4])/2;\n    x[6]:=(x[4]+x[8])/2;\n    x[10]:=(x[8]+x[12])/2;\n    x[14]:=(x[12]+x[16])/2;\n    var j:=2;\n    while j<=16 do begin f[j]:=fun(x[j]); j+=2 end;\n    nofun:=9;\n    var qright:=new real[32];\n    var fsave:=new real[9,31];\n    var xsave:=new real[9,31];\n    while True do begin\n      x[1]:=(x[0]+x[2])/2; f[1]:=fun(x[1]);\n      j:=3;\n      while j<=15 do begin\n        x[j]:=(x[j-1]+x[j+1])/2; f[j]:=fun(x[j]); j:=j+2\n        end;\n      nofun+=8;\n      var step:=(x[16]-x[0])/16;\n      var qleft:=(w0*(f[0]+f[8])+w1*(f[1]+f[7])+w2*(f[2]+f[6])+w3*(f[3]+f[5])+\n          w4*f[4])*step;\n      qright[lev+1]:=(w0*(f[8]+f[16])+w1*(f[9]+f[15])+w2*(f[10]+f[14])+\n          w3*(f[11]+f[13])+w4*f[12])*step;\n      var qnow:=qleft+qright[lev+1];\n      var qdiff:=qnow-qprev; area+=qdiff;\n      var esterr:=Abs(qdiff)/1023;\n      var tolerr:=Max(abserr,relerr*Abs(area))*(step/stone);\n      var L70:=false;\n      if lev>=levmin then begin;\n        if lev>=levmax then begin\n          flag+=1; L70:=true\n          end\n        else if nofun>nofin then begin\n          nofin*=2; levmax:=levout; flag+=(b-x[0])/(b-a); L70:=true\n          end\n        else if esterr<=tolerr then L70:=true;\n        end;\n      if not L70 then begin\n        nim*=2; lev+=1;\n        for var i:=1 to 8 do begin\n          fsave[i,lev]:=f[i+8];\n          xsave[i,lev]:=x[i+8]\n          end;\n        qprev:=qleft;\n        for var i:=8 downto 1 do begin\n          f[2*i]:=f[i];\n          x[2*i]:=x[i]\n          end;\n        continue\n        end;\n      res+=qnow; errest+=esterr; cor11+=qdiff/1023;\n      while nim.IsOdd do begin\n        nim:=nim div 2;\n        lev-=1\n      end;\n      nim+=1;\n      if lev<=0 then break;\n      qprev:=qright[lev]; x[0]:=x[16]; f[0]:=f[16];\n      for var i:=1 to 8 do begin\n        f[2*i]:=fsave[i,lev];\n        x[2*i]:=xsave[i,lev]\n        end;\n      end;\n    res+=cor11;\n    if errest=0 then begin\n      Result:=(res,errest,flag,nofun); Exit\n      end;\n    repeat\n      var temp:=Abs(res)+errest;\n      if temp<>Abs(res) then begin\n        Result:=(res,errest,flag,nofun); Exit\n        end;\n      errest*=2;\n    until false;\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for Runge-Kutta-Fehlberg 4th-5th order method for solving ordinary differential equations",
    "output": "type\n  RKF45=class\n  private\n  neqn:integer;\n  abserr_save:real;\n  relerr_save:real;\n  h:real;\n  epsilon:=1.2e-15;\n  flag_save:integer;\n  init:integer;\n  kflag:integer;\n  kop:integer;\n  nfe:integer;\n  f1:array of real;\n  f2:array of real;\n  f3:array of real;\n  f4:array of real;\n  f5:array of real;\n  p:procedure(x:real; y,yp:array of real);\n  \n  procedure Fehl(s:array of real; t,h:real);\n  begin\n    var ch:=h/4.0;\n    for var i:=0 to neqn-1 do f5[i]:=y[i]+ch*yp[i];\n    p(t+ch,f5,f1); ch:=3.0*h/32.0;\n    for var i:=0 to neqn-1 do f5[i]:=y[i]+ch*(yp[i]+3.0*f1[i]);\n    p(t+3.0*h/8.0,f5,f2); ch:=h/2197.0;\n    for var i:=0 to neqn-1 do \n      f5[i]:=y[i]+ch*(1932.0*yp[i]+7296.0*f2[i]-7200.0*f1[i]);\n    p(t+12.0*h/13.0,f5,f3); ch:=h/4104.0;\n    for var i:=0 to neqn-1 do\n      f5[i]:=y[i]+ch*(8341.0*yp[i]-845.0*f3[i]+29440.0*f2[i]-32832.0*f1[i]);\n    p(t+h,f5,f4); ch:=h/20520.0;\n    for var i:=0 to neqn-1 do\n      f1[i]:=y[i]+ch*(-6080.0*yp[i]+9295.0*f3[i]-5643.0*f4[i]+41040.0*f1[i]-\n          28352.0*f2[i]);\n    p(t+h/2.0,f1,f5); ch:=h/7618050.0;\n    for var i:=0 to neqn-1 do\n      s[i]:=y[i]+ch*(902880.0*yp[i]+3855735.0*f3[i]-1371249.0*f4[i]+\n          3953664.0*f2[i]+277020.0*f5[i])\n  end;\n  \n  public\n  flag:integer;\n  relerr:real;\n  abserr:real;\n  y:array of real;\n  yp:array of real;\n  MsgOn:boolean;\n  \n  constructor (f:procedure(x:real; y,yp:array of real);\n      y:array of real; abserr,relerr:real; MsgOn:boolean:=true);\n  begin\n    neqn:=y.Length;\n    Self.y:=Copy(y);\n    yp:=new real[neqn];\n    f1:=new real[neqn];\n    f2:=new real[neqn];\n    f3:=new real[neqn];\n    f4:=new real[neqn];\n    f5:=new real[neqn];\n    Self.epsilon:=epsilon;\n    flag:=1;\n    Self.abserr:=abserr;\n    Self.relerr:=relerr;\n    Self.MsgOn:=MsgOn;\n    (abserr_save,relerr_save,h):=(-1.0,-1.0,-1.0);\n    (flag_save,init,kflag,kop,nfe):=(-1000,-1000,-1000,-1,-1);\n    p:=f;\n  end;\n  \n  procedure Solve(var t:real; tout:real);\n  begin\n    var maxnfe:=3000;\n    var remin:=1.0E-12;\n    var eps:=Self.epsilon;\n    if (neqn<1) then begin\n      flag:=8; Exit\n      end;\n    if (relerr<0.0) or (abserr<0.0) then begin\n      flag:=8; Exit\n      end;\n    if (flag=0) or (flag<-2) or (flag>8) then begin\n      flag:=8; Exit\n        end;\n    var mflag:=Abs(flag);\n    if mflag<>1 then begin\n      if (t=tout) and (kflag<>3) then begin\n        flag:=8; Exit\n        end;\n      if mflag=2 then begin\n        if kflag=3 then begin\n          flag:=flag_save; mflag:=Abs(flag)\n          end\n        else if init=0 then flag:=flag_save\n        else if kflag=4 then nfe:=0\n        else if (kflag=5) and (abserr=0.0) then begin\n          flag:=-5; Exit\n          end\n        else if (kflag=6) and (relerr<=relerr_save) and\n            (abserr<=abserr_save) then begin\n              flag:=-4; Exit\n              end\n        end\n      else\n        if flag=3 then begin\n          flag:=flag_save;\n          if kflag=3 then mflag:=Abs(flag);\n          end\n        else if flag=4 then begin\n          nfe:=0; flag:=flag_save;\n          if kflag=3 then mflag:=Abs(flag)\n          end\n        else if (flag=5) and (abserr>0.0) then begin\n          flag:=flag_save;\n          if kflag=3 then mflag:=Abs(flag)\n          end\n        else begin\n          flag:=-3; Exit\n          end\n        end;\n    flag_save:=flag; kflag:=0;\n    relerr_save:=relerr; abserr_save:=abserr;\n    relerr_min:=2.0*epsilon+remin;\n    if relerr<relerr_min then begin\n      relerr:=relerr_min; flag:=3; kflag:=3;\n      Exit\n      end;\n    dt:=tout-t;\n    if mflag=1 then begin\n      init:=0; kop:=0;\n      p(t,y,yp);\n      nfe:=1;\n      if t=tout then begin\n        flag:=2; Exit\n        end\n      end;\n    if init=0 then begin\n      init:=1; h:=Abs(dt); toln:=0.0;\n      for var k:=0 to neqn-1 do begin\n        tol:=relerr*Abs(y[k])+abserr;\n        if tol>0.0 then begin\n          toln:=tol; ypk:=Abs(yp[k]);\n          if tol<ypk*Power(h,5) then h:=Power(tol/ypk,0.2)\n          end\n        end;\n      if toln<=0.0 then h:=0.0;\n      h:=Max(h,26.0*eps*Max(Abs(t),Abs(dt)));\n      flag_save:=flag<0?-2:2\n      end;\n    if dt<0 then h:=-h;\n    if 2.0*Abs(dt)<=Abs(h) then kop+=1;\n    if kop=10000 then begin kop:=0; flag:=7; Exit end;\n    if Abs(dt)<=26.0*eps*Abs(t) then begin\n      t:=tout;\n      for var i:=0 to neqn-1 do y[i]+=dt*yp[i];\n      p(t,y,yp);\n      nfe+=1; flag:=2;\n      Exit\n    end;\n    output:=false; scale:=2.0/relerr; ae:=scale*abserr;\n    repeat\n      hfaild:=false; hmin:=26.0*eps*Abs(t); dt:=tout-t;\n      if 2.0*Abs(h)>Abs(dt) then begin\n        if Abs(dt)<=Abs(h) then begin output:=true; h:=dt end\n        else h:=0.5*dt\n        end;\n      while true do begin\n        if maxnfe<nfe then begin (flag,kflag):=(4,4); Exit end;\n        Fehl(f1,t,h);\n        nfe+=5; eeoet:=0.0;\n        for var k:=0 to neqn-1 do begin\n          et:=Abs(y[k])+Abs(f1[k])+ae;\n          if et<=0.0 then begin flag:=5; Exit end;\n          ee:=Abs((-2090.0*yp[k]+(21970.0*f3[k]-15048.0*f4[k]))+\n              (22528.0*f2[k]-27360.0*f5[k]));\n          eeoet:=Max(eeoet,ee/et)\n          end;\n        esttol:=Abs(h)*eeoet*scale/752400.0;\n        if esttol<=1.0 then Break;\n        hfaild:=true; output:=false;\n        if esttol<59049.0 then s:=0.9/Power(esttol,0.2)\n        else s:=0.1;\n        h*=s;\n        if Abs(h)<hmin then begin (flag,kflag):=(6,6); Exit end;\n        end;\n      t+=h; y:=Copy(f1);\n      p(t,y,yp);\n      nfe+=1;\n      if esttol>0.0001889568 then s:=0.9/Power(esttol,0.2)\n      else s:=5.0;\n      if hfaild then s:=Min(s,1.0);\n      h:=Sign(Max(s*Abs(h),hmin),h);\n      if output then begin t:=tout; flag:=2; Exit end;\n    until flag<=0;    \n    flag:=-2;\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for root isolation of equation y(x)=0 on given interval",
    "output": "type\n  RootsIsolation=class\n  private\n    f:real->real;\n    a,b,h:real;\n  \n  public\n  \n  constructor(f:real->real; a,b,h:real);\n  begin\n    Self.f:=f;\n    Self.a:=a;\n    Self.b:=b;\n    Self.h:=h\n  end;\n\n  function Value:array of (real,real);\n  begin\n    var r:=new List<(real,real)>;\n    var h2:=h/2;\n    var eps:=1e-7;\n    var (xa,ya,bk):=(a,f(a),b+h2);\n    if Abs(ya)<eps then begin\n      r.Add((xa-h2,xa+h2));\n      xa+=h2; ya:=f(xa)\n      end;\n    var xb:=xa+h;\n    while xb<=bk do begin\n      var yb:=f(xb);\n      if Abs(yb)<eps then begin\n        r.Add((xb-h2,xb+h2));\n        xa:=xb+h2; ya:=f(xa);\n        xb:=xa+h\n        end\n      else if ya*yb<0 then begin\n        r.Add((xa,xb));\n        (xa,ya):=(xb,yb);\n        xb:=xa+h\n        end\n      else begin\n        (xa,ya):=(xb,yb);\n        xb:=xa+h\n        end\n      end;\n    Result:=r.ToArray\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for cubic spline interpolation of tabular function",
    "output": "type\n  Spline=class\n  private\n  n:integer;\n  aK:array[,] of real;\n  P:array of Point;\n  \n  procedure Spline;\n  begin\n    if n<2 then Exit;\n    if n=2 then begin\n      aK[0,0]:=(P[1].y-P[0].y)/(P[1].x-P[0].x); aK[0,1]:=aK[0,0];\n      (aK[1,0],aK[1,1],aK[2,0],aK[2,1]):=(0,0,0,0);\n      Exit\n      end;\n    aK[2,0]:=P[1].x-P[0].x; aK[1,1]:=(P[1].y-P[0].y)/aK[2,0];\n    for var i:=1 to n-2 do begin\n      aK[2,i]:=P[i+1].x-P[i].x;\n      aK[0,i]:=2*(aK[2,i-1]+aK[2,i]);\n      aK[1,i+1]:=(P[i+1].y-P[i].y)/aK[2,i];\n      aK[1,i]:=aK[1,i+1]-aK[1,i]\n      end;\n    aK[0,0]:=-aK[2,0]; aK[0,n-1]:=-aK[2,n-2];\n    aK[1,0]:=0; aK[1,n-1]:=0;\n    if n<>3 then begin\n      aK[1,0]:=aK[1,2]/(P[3].x-P[1].x)-aK[1,1]/(P[2].x-P[0].x);\n      aK[1,n-1]:=aK[1,n-2]/(P[n-1].x-P[n-3].x)-aK[1,n-3]/(P[n-2].x-P[n-4].x);\n      aK[1,0]:=aK[1,0]*Sqr(aK[2,0])/(P[3].x-P[0].x);\n      aK[1,n-1]:=-aK[1,n-1]*Sqr(aK[2,n-2])/(P[n-1].x-P[n-4].x)\n      end;\n    for var i:=1 to n-1 do begin\n      var t:=aK[2,i-1]/aK[0,i-1];\n      aK[0,i]:=aK[0,i]-t*aK[2,i-1];\n      aK[1,i]:=aK[1,i]-t*aK[1,i-1]\n      end;\n    aK[1,n-1]:=aK[1,n-1]/aK[0,n-1];\n    for var i:=n-2 downto 0 do\n      aK[1,i]:=(aK[1,i]-aK[2,i]*aK[1,i+1])/aK[0,i];\n    aK[0,n-1]:=(P[n-1].y-P[n-2].y)/aK[2,n-2]+\n        aK[2,n-2]*(aK[1,n-2]+2*aK[1,n-1]);\n    for var i:=0 to n-2 do begin\n      aK[0,i]:=(P[i+1].y-P[i].y)/aK[2,i]-\n          aK[2,i]*(aK[1,i+1]+2*aK[1,i]);\n      aK[2,i]:=(aK[1,i+1]-aK[1,i])/aK[2,i];\n      aK[1,i]:=3*aK[1,i]\n      end;\n    aK[1,n-1]:=3*aK[1,n-1]; aK[2,n-1]:=aK[2,n-2]\n  end;\n  \n  public\n  \n  constructor (pts:array of Point);\n  begin\n    n:=pts.Length;\n    P:=pts;\n    SetLength(aK,3,n);\n    Spline;\n  end;\n  \n  function Value(u:real):real;\n  begin\n    var i,j:integer;\n    if u<P[0].x then i:=0\n    else if u>P[n-1].x then i:=n-2\n    else begin\n      j:=n-1;\n      repeat\n        var k:=(i+j) div 2;\n        if u<P[k].x then j:=k else i:=k\n      until j-i<=1\n      end;  \n    var dx:=u-P[i].x;\n    Result:=P[i].y+dx*(aK[0,i]+dx*(aK[1,i]+dx*aK[2,i]))\n  end;\n  \n  function Diff(u:real):(real,real);\n  begin\n    var i,j:integer;\n    if u<P[0].x then i:=0\n    else if u>P[n-1].x then i:=n-2\n    else begin\n      j:=n-1;\n      repeat\n        var k:=(i+j) div 2;\n        if u<P[k].x then j:=k else i:=k\n      until j-i<=1\n      end;  \n    var dx:=u-P[i].x;\n    Result:=(aK[0,i]+dx*(2*aK[1,i]+3*dx*aK[2,i]),2*ak[1,i]+6*dx*aK[2,i])\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for finding initial uncertainty interval for unimodal function minimization using Svenn's method",
    "output": "type\n  Svenn=class\n  private\n  f:real->real;\n  xn,t:real;\n  \n  public\n  \n  constructor(f:real->real; xn,t:real);\n  begin\n    Self.f:=f;\n    Self.xn:=xn;\n    Self.t:=t\n  end;\n  \n  function Value:(real,real,integer);\n  begin\n    var k:=0;\n    var (x1,x2,x3):=(xn-t,xn,xn+t);\n    var (y1,y2,y3):=(f(x1),f(x2),f(x3));\n    var d,a,b:real;\n    if (y1>=y2) and (y2<=y3) then begin\n      Result:=(x1,x3,0);\n      Exit\n      end\n    else if (y1<=y2) and (y2>=y3) then begin\n      Result:=(x1,x3,1);\n      Exit\n      end\n    else if (y1>=y2) and (y2>=y3) then (d,a,x2,k):=(t,x2,x2+t,1)\n    else (d,b,x2,k):=(-t,x2,x2-t,1);\n    repeat\n      x1:=x2+Power(2,k)*d;\n      (y1,y2):=(f(x1),f(x2));\n      if (y1<y2) then begin\n        if d=t then a:=x2 else b:=x2;\n        k+=1; x2:=x1\n        end\n    until y1>=y2;\n    if d=t then Result:=(a,x1,0)\n    else Result:=(x1,b,0)\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET class for finding real zero of function on isolation interval using Brent's method",
    "output": "type\n  Zeroin=class\n  private\n  tol:real;\n  f:real->real;\n  \n  public\n  \n  constructor(f:real->real; tol:real);\n  begin\n    Self.tol:=tol;\n    Self.f:=f;\n  end;  \n  \n  function Value(ax,bx:real):real;\n  begin\n    var Sign:real->real:=x->(x=0?0.0:x<0?-1.0:1.0);\n    var eps:=1.0;\n    var tol1:real;\n    repeat\n      eps:=eps/2; tol1:=1.0+eps\n    until tol1<=1.0;\n    var (fa,fb,a,b):=(f(ax),f(bx),ax,bx);\n    repeat\n      var (c,d,fc):=(a,b-a,fa);\n      var e:=d;\n      repeat\n        if Abs(fc)<Abs(fb) then\n          begin (a,b):=(b,c); c:=a; (fa,fb):=(fb,fc); fc:=fa end;\n        tol1:=2*eps*Abs(b)+0.5*tol;\n        var xm:=0.5*(c-b);\n        if (Abs(xm)<tol1) or (fb=0) then begin Result:=b; Exit end;\n        if (Abs(e)<tol1) or (Abs(fa)<=Abs(fb)) then (d,e):=(xm,d)\n        else begin\n          var p,q,s:real;\n          if a=c then begin s:=fb/fa; p:=2*xm*s; q:=1-s end\n          else begin\n            var r:=fb/fc; q:=fa/fc; s:=fb/fa; p:=s*(2*xm*q*(q-r)-(b-a)*(r-1));\n            q:=(q-1)*(r-1)*(s-1)\n            end;\n          if p>0 then q:=-q;\n          p:=Abs(p);\n          if (2*p >= 3*xm*q-Abs(tol1*q)) or (p>=Abs(0.5*e*q)) then (d,e):=(xm,d)\n          else (e,d):=(d,p/q)\n          end;\n        (a,fa):=(b,fb);\n        if abs(d)>tol1 then  b:=b+d\n        else b+=Abs(tol1)*Sign(xm);\n        fb:=f(b);\n      until fb*Sign(fc)>0;\n    until false\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET function to get the current locale from configuration, defaulting to 'ru' if not specified",
    "output": "function GetCurrentLocale: string;\nbegin\n  var locale: object;\n  if __CONFIG__.TryGetValue('locale', locale) then\n    Result := locale as string\n  else\n    Result := 'ru';\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET function to get translated message based on current locale. Messages are separated by '!!' with Russian first and English second",
    "output": "function GetTranslation(message: string): string;\nbegin\n  var cur_locale := GetCurrentLocale();\n  var arr := message.Split(new string[1]('!!'), System.StringSplitOptions.None);\n  if (cur_locale = 'en') and (arr.Length > 1) then\n    Result := arr[1]\n  else\n    Result := arr[0]\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET procedure to correct 'from' and 'to' indices based on step direction and situation for string slicing",
    "output": "procedure CorrectFromTo(situation: integer; Len: integer; var from, &to: integer; step: integer);\nbegin\n  if step > 0 then\n  begin\n    case situation of\n      1: from := 0;\n      2: &to := Len;\n      3: (from, &to) := (0, Len)\n    end;  \n  end\n  else\n  begin\n    case situation of\n      1: from := Len - 1;\n      2: &to := -1;\n      3: (from, &to) := (Len - 1, -1);\n    end;\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET function to check and correct from/to parameters and calculate count for system slice operation",
    "output": "function CheckAndCorrectFromToAndCalcCountForSystemSlice(situation: integer; Len: integer; var from, &to: integer; step: integer): integer;\nbegin\n  if step = 0 then\n    raise new System.ArgumentException(GetTranslation(PARAMETER_STEP_MUST_BE_NOT_EQUAL_0));\n  \n  if (situation = 0) or (situation = 2) then\n    if (from < 0) or (from > Len - 1) then\n      raise new System.ArgumentException(GetTranslation(PARAMETER_FROM_OUT_OF_RANGE));\n  \n  if (situation = 0) or (situation = 1) then\n    if (&to < -1) or (&to > Len) then\n      raise new System.ArgumentException(GetTranslation(PARAMETER_TO_OUT_OF_RANGE));\n  \n  CorrectFromTo(situation, Len, from, &to, step);\n  \n  var count: integer;\n  \n  if step > 0 then\n  begin\n    var cnt := &to - from;\n    if cnt <= 0 then \n      count := 0\n    else count := (cnt - 1) div step + 1;\n  end\n  else\n  begin\n    var cnt := from - &to;\n    if cnt <= 0 then \n      count := 0\n    else count := (cnt - 1) div (-step) + 1;\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET procedure for system slice assignment implementation for strings",
    "output": "procedure SystemSliceAssignmentStringImpl(var Self: string; rightValue: string; situation: integer; \n  from, &to: SystemIndex; step: integer; baseIndex: integer := 1);\nbegin\n  from.IndexValue := from.IndexValue - baseIndex;\n  &to.IndexValue := &to.IndexValue - baseIndex;\n  \n  var fromValue := from.IndexValue;\n  var toValue := &to.IndexValue;\n  var count := CheckAndCorrectFromToAndCalcCountForSystemSlice(situation, Self.Count, fromValue, toValue, step);\n  if count <> rightValue.Length then\n    raise new System.ArgumentException(GetTranslation(SLICE_SIZE_AND_RIGHT_VALUE_SIZE_MUST_BE_EQUAL));\n    \n  var f := fromValue + 1;\n  \n  var strInd := 1;\n  loop count do\n  begin\n    Self[f] := rightValue[strInd];\n    f += step;\n    strInd += 1;\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET function to open a binary file and return file variable",
    "output": "function OpenBinary(fname: string): file;\nbegin\n  PABCSystem.Reset(Result, fname);\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET function to create or truncate a binary file and return file variable",
    "output": "function CreateBinary(fname: string): file;\nbegin\n  PABCSystem.Rewrite(Result, fname);\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET function to check if a type contains reference types recursively",
    "output": "function ContainsReferenceTypes(t: System.Type): boolean;\nbegin\n  if t.IsPrimitive then\n    Result := False\n  else if t.IsValueType then \n  begin\n    var fa := t.GetFields(System.Reflection.BindingFlags.GetField or System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Public or System.Reflection.BindingFlags.NonPublic);\n    Result := fa.Any(x->ContainsReferenceTypes(x.FieldType));\n  end\n  else Result := True;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET function to open a typed file with validation for reference types",
    "output": "function OpenFile<T>(fname: string): file of T;\nbegin\n  if ContainsReferenceTypes(typeof(T)) then\n    raise new System.SystemException(GetTranslation(BAD_TYPE_IN_TYPED_FILE));\n  PABCSystem.Reset(Result, fname);\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET function to create a typed file with validation for reference types",
    "output": "function CreateFile<T>(fname: string): file of T;\nbegin\n  if ContainsReferenceTypes(typeof(T)) then\n  begin\n    raise new System.SystemException(GetTranslation(BAD_TYPE_IN_TYPED_FILE));\n  end;  \n  var res: file of T;\n  PABCSystem.Rewrite(res, fname);\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET procedure to write sequence elements to a typed file",
    "output": "procedure WriteElements<T>(fname: string; ss: sequence of T);\nbegin\n  var f := CreateFile&<T>(fname);\n  foreach var x in ss do\n    f.Write(x);\n  f.Close\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET extension method to seek to position in typed file",
    "output": "function Seek<T>(Self: file of T; n: int64): file of T; extensionmethod;\nbegin\n  PABCSystem.Seek(Self, n);\n  Result := Self;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET extension method to read next element from typed file",
    "output": "function Read<T>(Self: file of T): T; extensionmethod;\nbegin\n  PABCSystem.Read(Self, Result);\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET extension method to read two elements from typed file as tuple",
    "output": "function Read2<T>(Self: file of T): (T,T); extensionmethod;\nbegin\n  var a,b: T;\n  PABCSystem.Read(Self, a);\n  PABCSystem.Read(Self, b);\n  Result := (a,b);\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET extension method to read three elements from typed file as tuple",
    "output": "function Read3<T>(Self: file of T): (T,T,T); extensionmethod;\nbegin\n  var a,b,c: T;\n  PABCSystem.Read(Self, a);\n  PABCSystem.Read(Self, b);\n  PABCSystem.Read(Self, c);\n  Result := (a,b,c);\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET extension method to get sequence of elements from current position to end of typed file",
    "output": "function ReadElements<T>(Self: file of T): sequence of T; extensionmethod;\nbegin\n  while not Self.Eof do\n  begin\n    var x := Self.Read;\n    yield x;\n  end;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET extension method to get all elements of typed file as sequence",
    "output": "function Elements<T>(Self: file of T): sequence of T; extensionmethod;\nbegin\n  Reset(Self);\n  Result := Self.ReadElements;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET function to read elements from typed file by filename as sequence",
    "output": "function ReadElements<T>(fname: string): sequence of T;\nbegin\n  var f := OpenFile&<T>(fname);\n  while not f.Eof do\n  begin\n    var x := f.Read;\n    yield x;\n  end;\n  f.Close\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET extension method to write multiple values to typed file",
    "output": "procedure Write<T>(Self: file of T; params vals: array of T); extensionmethod;\nbegin\n  foreach var x in vals do\n    PABCSystem.Write(Self, x);\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET operator to repeat procedure n times",
    "output": "function operator*(p: procedure; n: integer): procedure; extensionmethod;\nbegin\n  Result := () -> for var i:=1 to n do p\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET implicit conversion operator from integer set to byte set with range validation",
    "output": "function operator implicit(n: set of integer): set of byte; extensionmethod;\nbegin\n  foreach var x in n._hs do\n    if (x >= byte.MinValue) and (x <= byte.MaxValue) then\n      Result._hs.Add(x)\n    else raise new System.ArgumentException(GetTranslation(OUT_OF_TYPE_RANGE_IN_SET_ASSIGNMENT));\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET equality operator for integer set and byte set",
    "output": "function operator=(a: set of integer; b: set of byte); extensionmethod \n  := (a.Count = b.Count) and b.All(x -> x in a);"
  },
  {
    "instruction": "Write a PascalABC.NET set union operator for integer set and byte set",
    "output": "function operator+(a: set of integer; b: set of byte): set of integer; extensionmethod;\nbegin\n  Result.hs.UnionWith(a); \n  Result.hs.UnionWith(b.Select(x -> integer(x)));\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET set intersection operator for integer set and byte set",
    "output": "function operator*(a: set of integer; b: set of byte): set of integer; extensionmethod;\nbegin\n  Result := a;\n  Result.hs.IntersectWith(b.Select(x -> integer(x)));\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET set difference operator for integer set and byte set",
    "output": "function operator-(a: set of integer; b: set of byte): set of integer; extensionmethod;\nbegin\n  Result.hs.UnionWith(a); \n  Result.hs.ExceptWith(b.Select(x -> integer(x)));\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET 'in' operator to check if int64 value exists in byte array with range validation",
    "output": "function operator in(x: int64; a: array of byte): boolean; extensionmethod\n  := (x >= byte.MinValue) and (x <= byte.MaxValue) and a.Contains(byte(x));"
  },
  {
    "instruction": "Write a PascalABC.NET function to open a binary file with specified encoding and return file variable",
    "output": "function OpenBinary(fname: string; en: Encoding): file;\nbegin\n  PABCSystem.Reset(Result, fname, en);\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET function to create or truncate a binary file with specified encoding and return file variable",
    "output": "function CreateBinary(fname: string; en: Encoding): file;\nbegin\n  PABCSystem.Rewrite(Result, fname, en);\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET function to open a typed file with specified encoding and validation for reference types",
    "output": "function OpenFile<T>(fname: string; en: Encoding): file of T;\nbegin\n  if ContainsReferenceTypes(typeof(T)) then\n    raise new System.SystemException(GetTranslation(BAD_TYPE_IN_TYPED_FILE));\n  PABCSystem.Reset(Result, fname, en);\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET function to create a typed file with specified encoding and validation for reference types",
    "output": "function CreateFile<T>(fname: string; en: Encoding): file of T;\nbegin\n  if ContainsReferenceTypes(typeof(T)) then\n    raise new System.SystemException(GetTranslation(BAD_TYPE_IN_TYPED_FILE));\n  var res: file of T;\n  PABCSystem.Rewrite(res, fname, en);\n  Result := res;\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET function to open a file of integers",
    "output": "function OpenFileInteger(fname: string): file of integer;\nbegin\n  Result := OpenFile&<integer>(fname);\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET function to open a file of real numbers",
    "output": "function OpenFileReal(fname: string): file of real;\nbegin\n  Result := OpenFile&<real>(fname);\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET function to create a file of integers",
    "output": "function CreateFileInteger(fname: string): file of integer;\nbegin\n  Result := CreateFile&<integer>(fname);\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET function to create a file of real numbers",
    "output": "function CreateFileReal(fname: string): file of real;\nbegin\n  Result := CreateFile&<real>(fname);\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET extension method to reset a typed file",
    "output": "procedure Reset<T>(Self: file of T); extensionmethod;\nbegin\n  PABCSystem.Reset(Self);\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET extension method to rewrite a typed file",
    "output": "procedure Rewrite<T>(Self: file of T); extensionmethod;\nbegin\n  PABCSystem.Rewrite(Self);\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET operator to repeat procedure n times with integer first",
    "output": "function operator*(n: integer; p: procedure): procedure; extensionmethod;\nbegin\n  Result := () -> for var i:=1 to n do p\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET implicit conversion operator from integer set to shortint set with range validation",
    "output": "function operator implicit(n: set of integer): set of shortint; extensionmethod;\nbegin\n  foreach var x in n._hs do\n    if (x >= shortint.MinValue) and (x <= shortint.MaxValue) then\n      Result._hs.Add(x)\n    else raise new System.ArgumentException(GetTranslation(OUT_OF_TYPE_RANGE_IN_SET_ASSIGNMENT));\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET implicit conversion operator from integer set to smallint set with range validation",
    "output": "function operator implicit(n: set of integer): set of smallint; extensionmethod;\nbegin\n  foreach var x in n._hs do\n    if (x >= smallint.MinValue) and (x <= smallint.MaxValue) then\n      Result._hs.Add(x)\n    else raise new System.ArgumentException(GetTranslation(OUT_OF_TYPE_RANGE_IN_SET_ASSIGNMENT));\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET implicit conversion operator from integer set to word set with range validation",
    "output": "function operator implicit(n: set of integer): set of word; extensionmethod;\nbegin\n  foreach var x in n._hs do\n    if (x >= word.MinValue) and (x <= word.MaxValue) then\n      Result._hs.Add(x)\n    else raise new System.ArgumentException(GetTranslation(OUT_OF_TYPE_RANGE_IN_SET_ASSIGNMENT));\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET implicit conversion operator from integer set to longword set with range validation",
    "output": "function operator implicit(n: set of integer): set of longword; extensionmethod;\nbegin\n  foreach var x in n._hs do\n    if (x >= longword.MinValue) and (x <= longword.MaxValue) then\n      Result._hs.Add(x)\n    else raise new System.ArgumentException(GetTranslation(OUT_OF_TYPE_RANGE_IN_SET_ASSIGNMENT));\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET implicit conversion operator from integer set to int64 set",
    "output": "function operator implicit(n: set of integer): set of int64; extensionmethod;\nbegin\n  foreach var x in n._hs do\n    Result._hs.Add(x)\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET implicit conversion operator from integer set to uint64 set with range validation",
    "output": "function operator implicit(n: set of integer): set of uint64; extensionmethod;\nbegin\n  foreach var x in n._hs do\n    if x >= 0 then\n      Result._hs.Add(x)\n    else raise new System.ArgumentException(GetTranslation(OUT_OF_TYPE_RANGE_IN_SET_ASSIGNMENT));\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET implicit conversion operator from integer array to byte set with range validation",
    "output": "function operator implicit(n: array of integer): set of byte; extensionmethod;\nbegin\n  foreach var x in n do\n    if (x >= byte.MinValue) and (x <= byte.MaxValue) then\n      Result._hs.Add(x)\n    else raise new System.ArgumentException(GetTranslation(OUT_OF_TYPE_RANGE_IN_SET_ASSIGNMENT));\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET implicit conversion operator from integer array to int64 set",
    "output": "function operator implicit(a: array of integer): set of int64; extensionmethod;\nbegin\n  foreach var x in a do\n    Result._hs.Add(x);\nend;"
  },
  {
    "instruction": "Write a PascalABC.NET function to convert byte set to sequence of integers",
    "output": "function NSToInts(ns: set of byte) := ns._hs.Select(x -> integer(x));"
  },
  {
    "instruction": "Write a PascalABC.NET function to convert integer set to sequence of bytes with range validation",
    "output": "function NSToBytes(ns: set of integer): sequence of byte;\nbegin\n  var res := new List<byte>;\n  foreach var x in ns._hs do\n    if (x >= byte.MinValue) and (x <= byte.MaxValue) then\n      res.Add(x)\n    else raise new System.ArgumentException(GetTranslation(OUT_OF_TYPE_RANGE_IN_SET_OPERATION));\n  Result := res;  \nend;"
  },
  {
    "instruction": "Write a PascalABC.NET inequality operator for integer set and byte set",
    "output": "function operator<>(a: set of integer; b: set of byte); extensionmethod := not(a = b);"
  },
  {
    "instruction": "Write a PascalABC.NET subset operator for integer set and byte set",
    "output": "function operator<(a: set of integer; b: set of byte); extensionmethod \n  := (a.Count < b.Count) and a.All(x -> (x >= 0) and (x <= byte.MaxValue) and (x in b));"
  },
  {
    "instruction": "Write a PascalABC.NET superset operator for integer set and byte set",
    "output": "function operator>(a: set of integer; b: set of byte); extensionmethod \n  := b < a;"
  },
  {
    "instruction": "Write a PascalABC.NET subset or equal operator for integer set and byte set",
    "output": "function operator<=(a: set of integer; b: set of byte); extensionmethod \n  := (a.Count <= b.Count) and a.All(x -> (x >= 0) and (x <= byte.MaxValue) and (x in b));"
  },
  {
    "instruction": "Write a PascalABC.NET superset or equal operator for integer set and byte set",
    "output": "function operator>=(a: set of integer; b: set of byte); extensionmethod \n  := b <= a;"
  },
  {
    "instruction": "Write a PascalABC.NET set intersection assignment operator for byte set and integer set",
    "output": "procedure operator*=(a: set of byte; b: set of integer); extensionmethod \n  := a *= NewSet&<byte>(b);"
  },
  {
    "instruction": "Write a PascalABC.NET set union assignment operator for byte set and integer set",
    "output": "procedure operator+=(a: set of byte; b: set of integer); extensionmethod \n  := a += NewSet&<byte>(b);"
  },
  {
    "instruction": "Write a PascalABC.NET set difference assignment operator for byte set and integer set",
    "output": "procedure operator-=(a: set of byte; b: set of integer); extensionmethod \n  := a -= NewSet&<byte>(b);"
  },
  {
    "instruction": "Write a PascalABC.NET array concatenation operator for byte array and integer array",
    "output": "function operator+(a: array of byte; b: array of integer): array of integer; extensionmethod \n  := a.ConvertAll(x -> integer(x)) + b;"
  },
  {
    "instruction": "Write a PascalABC.NET 'in' operator to check if int64 value exists in shortint array with range validation",
    "output": "function operator in(x: int64; a: array of shortint): boolean; extensionmethod\n  := (x >= shortint.MinValue) and (x <= shortint.MaxValue) and a.Contains(shortint(x));"
  },
  {
    "instruction": "Write a PascalABC.NET 'in' operator to check if int64 value exists in smallint array with range validation",
    "output": "function operator in(x: int64; a: array of smallint): boolean; extensionmethod\n  := (x >= smallint.MinValue) and (x <= smallint.MaxValue) and a.Contains(smallint(x));"
  },
  {
    "instruction": "Write a PascalABC.NET 'in' operator to check if int64 value exists in word array with range validation",
    "output": "function operator in(x: int64; a: array of word): boolean; extensionmethod\n  := (x >= word.MinValue) and (x <= word.MaxValue) and a.Contains(word(x));"
  },
  {
    "instruction": "Write a PascalABC.NET 'in' operator to check if int64 value exists in longword array with range validation",
    "output": "function operator in(x: int64; a: array of longword): boolean; extensionmethod\n  := (x >= longword.MinValue) and (x <= longword.MaxValue) and a.Contains(longword(x));"
  },
  {
    "instruction": "Write a PascalABC.NET 'in' operator to check if int64 value exists in integer array with range validation",
    "output": "function operator in(x: int64; a: array of integer): boolean; extensionmethod\n  := (x >= integer.MinValue) and (x <= integer.MaxValue) and a.Contains(integer(x));"
  },
  {
    "instruction": "Write a PascalABC.NET 'in' operator to check if int64 value exists in uint64 array with range validation",
    "output": "function operator in(x: int64; a: array of uint64): boolean; extensionmethod\n  := (x >= uint64.MinValue) and a.Contains(uint64(x));"
  },
  {
    "instruction": "Write a PascalABC.NET module initialization procedure",
    "output": "procedure __InitModule__;\nbegin\n  if not __initialized then\n  begin\n    __initialized := true;\n    __InitPABCSystem;\n  end;\nend;"
  },
  {
    "instruction": "Implement a function to get the current locale from configuration with fallback to 'ru'",
    "output": "function GetCurrentLocale: string;\nbegin\n  var locale: object;\n  if __CONFIG__.TryGetValue('locale', locale) then\n    Result := locale as string\n  else\n    Result := 'ru';\nend;"
  },
  {
    "instruction": "Create a function to get translation based on current locale, splitting message by '!!' delimiter",
    "output": "function GetTranslation(message: string): string;\nbegin\n  var cur_locale := GetCurrentLocale();\n  var arr := message.Split(new string[1]('!!'), StringSplitOptions.None);\n  if (cur_locale = 'en') and (arr.Length > 1) then\n    Result := arr[1]\n  else\n    Result := arr[0]\nend;"
  },
  {
    "instruction": "Implement a function to check if running in WDE (Web Development Environment)",
    "output": "function IsWDE: boolean;\nbegin\n  Result := AppDomain.CurrentDomain.GetData('_RedirectIO_SpecialArgs') <> nil;\nend;"
  },
  {
    "instruction": "Create a function to allocate console for non-Unix platforms when not in console application",
    "output": "[System.Security.SecuritySafeCriticalAttribute]\nprocedure AllocConsole;\nbegin\n  if not IsConsoleApplication and (System.Environment.OSVersion.Platform <> PlatformID.Unix) and (AppDomain.CurrentDomain.GetData('_RedirectIO_SpecialArgs') = nil) then\n    WINAPI_AllocConsole;\n  console_alloc := true;\nend;"
  },
  {
    "instruction": "Implement a function to get null-based array from object using reflection",
    "output": "function GetNullBasedArray(arr: object): System.Array;\nvar\n  fi: System.Reflection.FieldInfo;\nbegin\n  fi := arr.GetType.GetField(InternalNullBasedArrayName);\n  if fi <> nil then\n    Result := System.Array(fi.GetValue(arr))\n  else\n    Result := nil;\nend;"
  },
  {
    "instruction": "Create a function to format float number by replacing comma with dot",
    "output": "function FormatFloatNumber(s: string): string;\nbegin\n  Result := s.Replace(',', '.');\nend;"
  },
  {
    "instruction": "Implement Diapason (Range) class with constructors for integer and object bounds",
    "output": "constructor Diapason.Create(_low, _high: integer);\nbegin\n  low := _low;high := _high;\nend;\n\nconstructor Diapason.Create(_low, _high: object);\nbegin\n  clow := _low;chigh := _high;\nend;"
  },
  {
    "instruction": "Implement TypedSet class with basic constructor and element inclusion methods",
    "output": "constructor TypedSet.Create;\nbegin\n  ht := new Hashtable({new TypedSetComparer()});\nend;\n\nconstructor TypedSet.Create(len: integer);\nbegin\n  ht := new Hashtable({new TypedSetComparer()});\n  Self.len := len;\nend;\n\nconstructor TypedSet.Create(low_bound, upper_bound: object);\nbegin\n  ht := new Hashtable({new TypedSetComparer()});\n  Self.low_bound := low_bound;\n  Self.upper_bound := upper_bound;\nend;\n\nprocedure TypedSet.CreateIfNeed;\nbegin\n  if ht = nil then ht := new Hashtable({new TypedSetComparer()});\nend;"
  },
  {
    "instruction": "Implement TypedSet cloning and byte array conversion methods",
    "output": "[System.Diagnostics.DebuggerStepThrough]\nfunction TypedSet.CloneSet: TypedSet;\nbegin\n  Result := new TypedSet();\n  Result.ht := ht.Clone() as Hashtable;\n  Result.low_bound := low_bound;\n  Result.upper_bound := upper_bound;\nend;\n\nfunction TypedSet.GetBytes: array of byte;\nvar\n  ba: System.Collections.BitArray;\n  i: integer;\nbegin\n  ba := new BitArray(256);\n  Result := nil;\n  foreach o: object in ht.Keys do\n  begin\n    try\n      i := Convert.ToInt32(o);\n      if (i < 0) and (i >= -128) and (i <= 127) then\n        ba[i + 128] := true\n      else if (i >= 0) and (i <= 255) then\n        ba[i] := true;\n    \n    except \n      on e: System.Exception do\n      begin\n        Result := nil;\n      end;\n    end;\n  end;\n  SetLength(Result, 256 div 8);\n  i := 0;\n  while i < 256 div 8 do\n  begin\n    Result[i] := Convert.ToByte(ba[i * 8 + 7]) or (Convert.ToByte(ba[i * 8 + 6]) shl 1) or (Convert.ToByte(ba[i * 8 + 5]) shl 2) or (Convert.ToByte(ba[i * 8 + 4]) shl 3)\n    or (Convert.ToByte(ba[i * 8 + 3]) shl 4) or (Convert.ToByte(ba[i * 8 + 2]) shl 5) or (Convert.ToByte(ba[i * 8 + 1]) shl 6) or (Convert.ToByte(ba[i * 8]) shl 7);\n    i := i + 1;\n  end;\nend;"
  },
  {
    "instruction": "Implement set operations (union, subtract, intersect) for TypedSet",
    "output": "function TypedSet.UnionSet(s: TypedSet): TypedSet;\nbegin\n  Result := Union(Self, s);\nend;\n\nfunction TypedSet.SubtractSet(s: TypedSet): TypedSet;\nbegin\n  Result := Subtract(Self, s);\nend;\n\nfunction TypedSet.IntersectSet(s: TypedSet): TypedSet;\nbegin\n  Result := Intersect(Self, s);\nend;\n\n[System.Diagnostics.DebuggerStepThrough]  \nfunction Union(s1, s2: TypedSet): TypedSet;\nbegin\n  Result := s1.CloneSet;\n  var en := s2.ht.GetEnumerator();\n  while en.MoveNext do\n    Result.ht[en.Key] := en.Key;\nend;\n\n[System.Diagnostics.DebuggerStepThrough]\nfunction Subtract(s1, s2: TypedSet): TypedSet;\nbegin\n  Result := s1.CloneSet;\n  var en := s2.ht.GetEnumerator();\n  while en.MoveNext do\n  begin\n    if s1.Contains(en.Key) then \n      Result.ht.Remove(en.Key);\n  end;\nend;\n\n[System.Diagnostics.DebuggerStepThrough]  \nfunction Intersect(s1, s2: TypedSet): TypedSet;\nvar\n  en: System.Collections.IEnumerator;\nbegin\n  Result := new TypedSet();\n  en := s1.ht.GetEnumerator();\n  while en.MoveNext do\n    if s2.Contains((en as IDictionaryEnumerator).Key) then \n      Result.ht[(en as IDictionaryEnumerator).Key] := (en as IDictionaryEnumerator).Key;\nend;"
  },
  {
    "instruction": "Implement element inclusion and exclusion methods for TypedSet",
    "output": "procedure TypedSet.IncludeElement(elem: object);\nvar\n  diap: Diapason;\nbegin\n  if elem = nil then exit;\n  elem := convert_elem(elem);\n  if not IsInDiapason(elem) then Exit;\n  if elem.GetType().IsEnum then\n  begin\n    ht[elem] := elem;\n  end\n  else\n  if not (elem is Diapason) then\n  begin\n    ht[elem] := elem;\n  end\n  else\n  begin\n    diap := Diapason(elem);\n    if diap.clow = nil then\n    begin\n      for var i := diap.low to diap.high do\n      begin\n        ht[i] := i;\n      end\n    end\n    else \n    begin\n      if diap.clow is char then\n      begin\n        for var c := char(diap.clow) to char(diap.chigh) do\n        begin\n          ht[c] := c;\n        end\n      end\n      else if diap.clow is boolean then\n      begin\n        for var b := boolean(diap.clow) to boolean(diap.chigh) do\n          ht[b] := b;\n      end\n      else if diap.clow.GetType().IsEnum then\n      begin\n        for var i := integer(diap.clow) to integer(diap.chigh) do\n        begin\n          var obj := Enum.ToObject(diap.clow.GetType(), i);\n          ht[obj] := obj;\n        end;\n      end;\n    end;\n  end;\nend;\n\nprocedure TypedSet.ExcludeElement(elem: object);\nbegin\n  if elem.GetType().IsEnum then\n  begin\n    ht.Remove(elem);\n  end\n  else\n  begin\n    elem := convert_elem(elem);\n    ht.Remove(elem);\n  end\nend;"
  },
  {
    "instruction": "Implement set comparison operations (equals, not equals, subset, superset) for TypedSet",
    "output": "[System.Diagnostics.DebuggerStepThrough]  \nfunction CompareSetEquals(s1, s2: TypedSet): boolean;\nvar\n  en: System.Collections.IEnumerator;\n  equals: boolean := true;\nbegin\n  if s1.ht.Count <> s2.ht.Count then\n  begin\n    Result := false;\n    Exit;\n  end;\n  en := s1.ht.GetEnumerator();\n  while en.MoveNext do\n  begin\n    var is_in_s1 := s1.Contains((en as IDictionaryEnumerator).Key);\n    var is_in_s2 := s2.Contains((en as IDictionaryEnumerator).Key);\n    if is_in_s1 and not is_in_s2 then \n    begin\n      equals := false;\n      break;\n    end\n    else if not is_in_s1 and is_in_s2 then\n    begin\n      equals := false;\n      break;\n    end\n  end;\n  if equals <> false then \n  begin\n    en := s2.ht.GetEnumerator();\n    en.Reset();\n    while en.MoveNext do\n    begin\n      var is_in_s1 := s1.Contains((en as IDictionaryEnumerator).Key);\n      var is_in_s2 := s2.Contains((en as IDictionaryEnumerator).Key);\n      if is_in_s2 and not is_in_s1 then\n      begin\n        equals := false;\n        break;\n      end\n      else if not is_in_s2 and is_in_s1 then\n      begin\n        equals := false;\n        break;\n      end\n    end;\n  end;\n  Result := equals;\nend;\n\n[System.Diagnostics.DebuggerStepThrough]  \nfunction CompareSetInEquals(s1, s2: TypedSet): boolean;\nbegin\n  Result := not CompareSetEquals(s1, s2);\nend;\n\n[System.Diagnostics.DebuggerStepThrough]  \nfunction CompareSetLess(s1, s2: TypedSet): boolean;\nvar\n  en: System.Collections.IEnumerator;\n  less: boolean := true;\nbegin\n  en := s1.ht.GetEnumerator();\n  en.Reset();\n  while en.MoveNext do\n  begin\n    if not s2.Contains((en as IDictionaryEnumerator).Key) then \n    begin\n      less := false;\n      break;\n    end;\n  end;\n  if less <> false then\n  begin\n    en := s2.ht.GetEnumerator();\n    en.Reset();\n    var b: boolean := false;\n    while en.MoveNext do\n    begin\n      if not s1.Contains((en as IDictionaryEnumerator).Key) then \n      begin\n        b := true;\n        break;\n      end;\n    end;\n    less := b;\n  end;\n  Result := less;\nend;"
  },
  {
    "instruction": "Implement string multiplication operator (string * integer) for repeating strings",
    "output": "function string.operator*(str: string; n: integer): string;\nbegin\n  var sb := new StringBuilder;\n  loop n do\n    sb.Append(str);\n  Result := sb.ToString;\nend;\n\nfunction string.operator*(n: integer; str: string): string;\nbegin\n  var sb := new StringBuilder;\n  loop n do\n    sb.Append(str);\n  Result := sb.ToString;\nend;"
  },
  {
    "instruction": "Implement char multiplication operator (char * integer) for repeating characters",
    "output": "function char.operator*(c: char; n: integer): string;\nbegin\n  if n <= 0 then\n  begin\n    Result := '';\n    exit;\n  end;\n  var sb := new StringBuilder(n, n);\n  loop n do\n    sb.Append(c);\n  Result := sb.ToString;\nend;\n\nfunction char.operator*(n: integer; c: char): string;\nbegin\n  if n <= 0 then\n  begin\n    Result := '';\n    exit;\n  end;\n  var sb := new StringBuilder(n, n);\n  loop n do\n    sb.Append(c);\n  Result := sb.ToString;\nend;"
  },
  {
    "instruction": "Implement array concatenation and multiplication operations",
    "output": "function operator+<T>(a, b: array of T): array of T; extensionmethod;\nbegin\n  Result := new T[a.Length + b.Length];\n  a.CopyTo(Result, 0);\n  b.CopyTo(Result, a.Length);\nend;\n\nfunction operator*<T>(a: array of T; n: integer): array of T; extensionmethod;\nbegin\n  if a.Length=1 then\n    Result := ArrFill(n,a[0])\n  else  \n  begin  \n    Result := new T[a.Length * n];\n    for var i := 0 to n - 1 do\n      a.CopyTo(Result, a.Length * i);\n  end;  \nend;\n\nfunction operator*<T>(n: integer; a: array of T): array of T; extensionmethod := a * n;"
  },
  {
    "instruction": "Implement power operator (**) for various numeric types",
    "output": "function operator**(x: real; n: integer): real; extensionmethod := Power(x, n);\n\nfunction operator**(x: single; n: integer): real; extensionmethod := Power(x, n);\n\nfunction operator**(x, y: integer): real; extensionmethod := Power(real(x), y);\n\nfunction operator**(x, y: real): real; extensionmethod := Power(x, y);\n\nfunction operator**(x, y: Complex): Complex; extensionmethod := Power(x, y);\n\nfunction operator**(x: BigInteger; y: integer): BigInteger; extensionmethod := Power(x, y);"
  },
  {
    "instruction": "Implement Range functions for generating sequences of integers and characters",
    "output": "function Range(a, b: integer): sequence of integer;\nbegin\n  if b < a then \n    Result := System.Linq.Enumerable.Empty&<integer>\n  else Result := System.Linq.Enumerable.Range(a, b - a + 1);\nend;\n\nfunction Range(c1, c2: char): sequence of char;\nbegin\n  Result := Range(integer(c1), integer(c2)).Select(x -> Chr(x));\nend;\n\nfunction Range(c1, c2: char; step: integer): sequence of char;\nbegin\n  Result := Range(integer(c1), integer(c2), step).Select(x -> Chr(x));\nend;\n\nfunction Range(a, b, step: integer): sequence of integer;\nbegin\n  if step = 0 then\n    raise new System.ArgumentException('step=0');\n  if (step > 0) and (b < a) or (step < 0) and (b > a) then\n  begin\n    Result := System.Linq.Enumerable.Empty&<integer>;\n    exit;\n  end;\n  var n := abs((b - a) div step) + 1;\n  var ar: ArithmSeq;\n  ar := new ArithmSeq(a, step);\n  Result := System.Linq.Enumerable.Range(0, n).Select(ar.f);\nend;"
  },
  {
    "instruction": "Implement functions for generating random arrays and sequences",
    "output": "function ArrRandom(n: integer; a: integer; b: integer): array of integer;\nbegin\n  Result := new integer[n];\n  for var i := 0 to Result.Length - 1 do\n    Result[i] := Random(a, b);\nend;\n\nfunction ArrRandomReal(n: integer; a: real; b: real): array of real;\nbegin\n  Result := new real[n];\n  for var i := 0 to Result.Length - 1 do\n    Result[i] := Random() * (b - a) + a;\nend;\n\nfunction SeqRandom(n: integer; a: integer; b: integer): sequence of integer;\nbegin\n  loop n do\n    yield Random(a, b)\nend;\n\nfunction SeqRandomReal(n: integer; a: real; b: real): sequence of real;\nbegin\n  loop n do\n    yield Random() * (b - a) + a\nend;"
  },
  {
    "instruction": "Implement HashSet operations for union, intersection, difference, and set comparison",
    "output": "function operator+<T>(x, y: HashSet<T>): HashSet<T>; extensionmethod;\nbegin\n  var v := new HashSet<T>(x);\n  v.UnionWith(y);\n  Result := v;\nend;\n\nfunction operator-<T>(x, y: HashSet<T>): HashSet<T>; extensionmethod;\nbegin\n  var v := new HashSet<T>(x);\n  v.ExceptWith(y);\n  Result := v;\nend;\n\nfunction operator*<T>(x,y: HashSet<T>): HashSet<T>; extensionmethod;\nbegin\n  var v := new HashSet<T>(x);\n  v.IntersectWith(y);\n  Result := v;\nend;\n\nfunction operator< <T>(x, y: HashSet<T>); extensionmethod := x.IsProperSubsetOf(y);\n\nfunction operator<= <T>(x, y: HashSet<T>); extensionmethod := x.IsSubsetOf(y);\n\nfunction operator> <T>(x, y: HashSet<T>); extensionmethod := x.IsProperSupersetOf(y);\n\nfunction operator>= <T>(x, y: HashSet<T>); extensionmethod := x.IsSupersetOf(y);"
  },
  {
    "instruction": "Implement SortedSet operations with union, intersection, difference and set comparisons",
    "output": "function operator+<T>(x, y: SortedSet<T>): SortedSet<T>; extensionmethod;\nbegin\n  var v := new SortedSet<T>(x);\n  v.UnionWith(y);\n  Result := v;\nend;\n\nfunction operator-<T>(x, y: SortedSet<T>): SortedSet<T>; extensionmethod;\nbegin\n  var v := new SortedSet<T>(x);\n  v.ExceptWith(y);\n  Result := v;\nend;\n\nfunction operator*<T>(x,y: SortedSet<T>): SortedSet<T>; extensionmethod;\nbegin\n  var v := new SortedSet<T>(x);\n  v.IntersectWith(y);\n  Result := v;\nend;\n\nfunction operator< <T>(x, y: SortedSet<T>); extensionmethod := x.IsProperSubsetOf(y);\n\nfunction operator<= <T>(x, y: SortedSet<T>); extensionmethod := x.IsSubsetOf(y);\n\nfunction operator> <T>(x, y: SortedSet<T>); extensionmethod := x.IsProperSupersetOf(y);\n\nfunction operator>= <T>(x, y: SortedSet<T>): boolean; extensionmethod := x.IsSupersetOf(y);"
  },
  {
    "instruction": "Implement List collection operations with concatenation and repetition",
    "output": "function operator+<T>(a, b: List<T>): List<T>; extensionmethod;\nbegin\n  Result := new List<T>(a);\n  Result.AddRange(b);\nend;\n\nfunction operator+=<T>(a, b: List<T>): List<T>; extensionmethod;\nbegin\n  a.AddRange(b);\n  Result := a;\nend;\n\nfunction operator+=<T>(a: List<T>; x: T): List<T>; extensionmethod;\nbegin\n  a.Add(x);\n  Result := a;\nend;\n\nfunction operator*<T>(a: List<T>; n: integer): List<T>; extensionmethod;\nbegin\n  Result := new List<T>();\n  for var i := 1 to n do\n    Result.AddRange(a);\nend;"
  },
  {
    "instruction": "Implement Stack and Queue collection operations with element addition",
    "output": "function operator+=<T>(s: Stack<T>; x: T): Stack<T>; extensionmethod;\nbegin\n  s.Push(x);\n  Result := s;\nend;\n\nfunction operator+=<T>(q: Queue<T>; x: T): Queue<T>; extensionmethod;\nbegin\n  q.Enqueue(x);\n  Result := q;\nend;"
  },
  {
    "instruction": "Implement BigInteger comparison operators with integer values",
    "output": "function BigInteger.operator>(p: BigInteger; q: integer) := p > BigInteger.Create(q);\n\nfunction BigInteger.operator>(p: integer; q: BigInteger) := BigInteger.Create(p) > q;\n\nfunction BigInteger.operator<(p: BigInteger; q: integer) := p < BigInteger.Create(q);\n\nfunction BigInteger.operator<(p: integer; q: BigInteger) := BigInteger.Create(p) < q;\n\nfunction BigInteger.operator>=(p: BigInteger; q: integer) := p >= BigInteger.Create(q);\n\nfunction BigInteger.operator>=(p: integer; q: BigInteger) := BigInteger.Create(p) >= q;\n\nfunction BigInteger.operator<=(p: BigInteger; q: integer) := p <= BigInteger.Create(q);\n\nfunction BigInteger.operator<=(p: integer; q: BigInteger) := BigInteger.Create(p) <= q;"
  },
  {
    "instruction": "Implement Complex number operations with assignment operators",
    "output": "function operator-(Self: Complex): Complex; extensionmethod := Complex.Negate(Self);\n\nprocedure operator+=(var c: Complex; x: Complex); extensionmethod := c := c + x;\n\nprocedure operator*=(var c: Complex; x: Complex); extensionmethod := c := c * x;\n\nprocedure operator-=(var c: Complex; x: Complex); extensionmethod := c := c - x;\n\nprocedure operator/=(var c: Complex; x: Complex); extensionmethod := c := c / x;"
  },
  {
    "instruction": "Implement sequence concatenation operations for generic sequences",
    "output": "function operator+<T>(a, b: sequence of T): sequence of T; extensionmethod;\nbegin\n  Result := a.Concat(b);\nend;\n\nfunction operator+<T>(a: sequence of T; b: T): sequence of T; extensionmethod;\nbegin\n  Result := a.Concat(new T[1](b));\nend;\n\nfunction operator+<T>(b: T; a: sequence of T): sequence of T; extensionmethod;\nbegin\n  Result := new T[1](b);\n  Result := Result.Concat(a);\nend;"
  },
  {
    "instruction": "Implement TypedFile class constructors for file operations with element types",
    "output": "constructor TypedFile.Create(ElementType: System.Type);\nbegin\n  Self.ElementType := ElementType;\n  ElementSize := RuntimeSizeOf(ElementType);\nend;\n\nconstructor TypedFile.Create(ElementType: System.Type; offs: integer; params offsets: array of integer);\nbegin\n  Self.ElementType := ElementType;\n  ElementSize := RuntimeSizeOf(ElementType);\n  Self.offsets := offsets;\n  if offs <> 0 then\n  begin\n    ElementSize := ElementSize + offs;\n    offset := offs;\n  end;\nend;\n\nfunction TypedFile.ToString := Format('file of {0}', ElementType);"
  },
  {
    "instruction": "Implement BinaryFile class with ToString method",
    "output": "function BinaryFile.ToString: string := 'file';"
  },
  {
    "instruction": "Implement GCHandlersController for managing garbage collection handles",
    "output": "constructor GCHandlersController.Create;\nbegin\n  Counters := new Hashtable;\n  Handlers := new Hashtable;\nend;\n\nprocedure GCHandlersController.Add(obj: Object);\nbegin\n  if obj <> nil then begin\n    if Counters.Contains(obj) then\n      Counters[obj] := integer(Counters[obj]) + 1\n    else begin\n      Counters.Add(obj, 1);          \n      Handlers.Add(obj, GCHandle.Alloc(obj, GCHandleType.Pinned));\n    end;\n  end;\nend;\n\nprocedure GCHandlersController.Remove(obj: Object);\nbegin\n  if obj <> nil then begin\n    if Counters.Contains(obj) then begin\n      var Count := integer(Counters[obj]);\n      if Count > 1 then \n        Counters[obj] := Count - 1\n      else begin\n        Counters.Remove(obj);\n        GCHandle(Handlers[obj]).Free;\n        Handlers.Remove(obj);\n      end;\n    end else\n      raise new SystemException('PABCSystem.GCHandleForPointersController not contains object ' + obj.ToString);\n  end;  \nend;"
  },
  {
    "instruction": "Implement structured object to string conversion with recursive formatting",
    "output": "function StructuredObjectToString(o: Object; n: integer := 0): string;\nconst\n  nmax = 100;\n  nmax1 = 30;\nbegin\n  if o = nil then\n    Result := 'nil' \n  else if o is System.Reflection.Pointer then\n    Result := PointerToString(System.Reflection.Pointer.Unbox(o))\n  else if (o.GetType = typeof(real)) or (o.GetType = typeof(decimal)) or (o.GetType = typeof(single)) then\n    Result := FormatFloatNumber(o.ToString)\n  else if (o.GetType = typeof(Complex)) then \n  begin\n    var c := Complex(o);\n    Result := '(' + StructuredObjectToString(c.Real) + ',' + StructuredObjectToString(c.Imaginary) + ')';\n  end\n  else if (o.GetType.IsPrimitive) or (o.GetType = typeof(string)) then\n    Result := o.ToString\n  else if o is System.Array then\n  begin\n    var a := o as System.Array;  \n    Result := ArrNToString(a, new integer[a.Rank], 0); \n  end\n  else if ((o.GetType = typeof(IntRange)) or (o.GetType = typeof(CharRange)) or (o.GetType = typeof(RealRange))) then \n  begin\n    Result := o.ToString\n  end\n  else if o is System.Collections.IEnumerable then\n  begin\n    var sb := new StringBuilder();\n    var g := (o as System.Collections.IEnumerable).GetEnumerator();\n    \n    var otype := o.GetType;\n    var isdictorset := o.GetType.IsGenericType and \n      ((otype.GetGenericTypeDefinition = typeof(Dictionary<,>))\n      or (otype.GetGenericTypeDefinition = typeof(SortedDictionary<,>))\n      or (otype.GetGenericTypeDefinition = typeof(HashSet<>))\n      or (otype.GetGenericTypeDefinition = typeof(SortedSet<>)));\n    isdictorset := isdictorset or (otype = typeof(TypedSet));\n    \n    if isdictorset then\n      sb.Append('{')\n    else sb.Append('[');\n    if g.MoveNext() then\n    begin  \n      sb.Append(StructuredObjectToString(g.Current, n + 1));\n      var cnt := 1;  \n      while g.MoveNext() and (cnt < nmax) do \n      begin\n        sb.Append(',');\n        sb.Append(StructuredObjectToString(g.Current, n + 1));\n        cnt += 1;\n      end;\n      if cnt >= nmax then \n        sb.Append(',...');\n    end;    \n    \n    if isdictorset then\n      sb.Append('}')\n    else sb.Append(']');\n    Result := sb.ToString;\n  end\n  else if o.GetType.GetField('NullBasedArray') <> nil then\n  begin\n    var f := o.GetType.GetField('NullBasedArray');\n    Result := StructuredObjectToString(f.GetValue(o));\n  end\n  else\n  begin\n    var q := RedefinedToString(o);\n    var gg := o.GetType.FullName.StartsWith('System.Tuple');\n    var gg1 := o.GetType.Name.StartsWith('KeyValuePair');\n    if (q <> nil) and q.IsVirtual and not gg and not gg1 then\n      Result := o.ToString\n    else \n    begin\n      var t := o.GetType;\n      var sb := new System.Text.StringBuilder();\n      sb.Append('(');\n      if n > nmax1 then\n        sb.Append('....')\n      else \n        while t <> typeof(object) do\n        begin\n          var ff := t.GetFields(System.Reflection.BindingFlags.Public or System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.DeclaredOnly);\n          var pp := t.GetProperties(System.Reflection.BindingFlags.Public or System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.DeclaredOnly);\n          \n          for var i := ff.Length - 1 downto 0 do\n            sb.Insert(1, StructuredObjectToString(ff[i].GetValue(o), n + 1) + ',');\n          \n          for var i := pp.Length - 1 downto 0 do\n            if pp[i].GetIndexParameters.Length = 0 then\n              sb.Insert(1, StructuredObjectToString(pp[i].GetValue(o, nil), n + 1) + ',');\n          \n          t := t.BaseType;\n        end; \n      if sb.Length > 1 then \n        sb.Length := sb.Length - 1;\n      sb.Append(')');\n      Result := sb.ToString;\n    end;\n  end;\nend;"
  },
  {
    "instruction": "Implement array to string conversion with nested array support",
    "output": "function ArrNToString(a: System.Array; indexes: array of integer; i: integer): string;\nconst\n  nmax = 100;\nbegin\n  var sb := new StringBuilder;\n  if i = a.Rank then\n    sb.Append(StructuredObjectToString(a.GetValue(indexes)))\n  else\n  begin\n    sb.Append('[');\n    for var k := 0 to a.GetLength(i) - 1 do\n    begin\n      indexes[i] := k;\n      sb.Append(ArrNToString(a, indexes, i + 1));\n      if (k >= nmax - 1) and (k < a.GetLength(i) - 1) then \n      begin\n        sb.Append(',...');\n        break\n      end\n      else if k < a.GetLength(i) - 1 then\n        sb.Append(',');            \n    end;\n    sb.Append(']');\n  end;\n  Result := sb.ToString;\nend;"
  },
  {
    "instruction": "Implement IntRange and CharRange methods for sequence generation",
    "output": "function IntRange.GetEnumerator(): IEnumerator<integer> := Range(l,h).GetEnumerator;\n\nfunction IntRange.Step(n: integer): sequence of integer := Range(l,h,n);\n\nfunction IntRange.Reverse: sequence of integer := Range(l,h).Reverse;\n\nfunction CharRange.GetEnumerator(): IEnumerator<char> := Range(l,h).GetEnumerator;\n\nfunction CharRange.Step(n: integer): sequence of char := Range(l,h,n);\n\nfunction CharRange.Reverse: sequence of char := Range(l,h).Reverse;"
  },
  {
    "instruction": "Implement string comparison operators for lexicographical ordering",
    "output": "function string.operator<(left, right: string) := string.CompareOrdinal(left, right) < 0;\n\nfunction string.operator<=(left, right: string) := string.CompareOrdinal(left, right) <= 0;\n\nfunction string.operator>(left, right: string) := string.CompareOrdinal(left, right) > 0;\n\nfunction string.operator>=(left, right: string) := string.CompareOrdinal(left, right) >= 0;"
  },
  {
    "instruction": "Implement string concatenation with numeric types using string conversion",
    "output": "function string.operator+(str: string; n: integer) := str + n.ToString;\n\nfunction string.operator+(n: integer; str: string) := n.ToString + str;\n\nfunction string.operator+(str: string; r: real) := str + r.ToString(nfi);\n\nfunction string.operator+(r: real; str: string) := r.ToString(nfi) + str;\n\nprocedure string.operator+=(var left: string; right: integer);\nbegin\n  left := left + right.ToString;\nend;\n\nprocedure string.operator+=(var left: string; right: real);\nbegin\n  left := left + right.ToString(nfi);\nend;"
  },
  {
    "instruction": "Implement string repetition assignment operator",
    "output": "procedure string.operator*=(var left: string; n: integer);\nbegin\n  var sb := new StringBuilder;\n  loop n do\n    sb.Append(left);\n  left := sb.ToString;\nend;"
  },
  {
    "instruction": "Implement StringBuilder extension methods for string concatenation",
    "output": "procedure operator+=(var left: StringBuilder; right: string); extensionmethod := left.Append(right);\n\nfunction operator implicit(s: string): StringBuilder; extensionmethod := new StringBuilder(s);"
  },
  {
    "instruction": "Implement element existence check for arrays and collections",
    "output": "function operator in<T>(x: T; a: array of T): boolean; extensionmethod := a.Contains(x);\n\nfunction List<T>.operator in(x: T; Self: List<T>): boolean;\nbegin\n  Result := Self.Contains(x);\nend;\n\nfunction operator in<T>(x: T; Self: HashSet<T>): boolean; extensionmethod := Self.Contains(x);\n\nfunction operator in<T>(x: T; Self: SortedSet<T>): boolean; extensionmethod := Self.Contains(x);\n\nfunction Dictionary<K, V>.operator in(key: K; d: Dictionary<K, V>): boolean;\nbegin\n  Result := d.ContainsKey(key);\nend;"
  },
  {
    "instruction": "Implement set creation functions with different parameters",
    "output": "[System.Diagnostics.DebuggerStepThrough]\nfunction CreateSet: TypedSet;\nbegin\n  Result := new TypedSet();\nend;\n\n[System.Diagnostics.DebuggerStepThrough]\nfunction CreateBoundedSet(low, high: object): TypedSet;\nbegin\n  Result := new TypedSet(low, high);\nend;\n\n[System.Diagnostics.DebuggerStepThrough]\nfunction CreateSet(params elems: array of object): TypedSet;\nbegin\n  var chars := false;\n  var strings := false;\n  var others := false;\n  foreach var x in elems do\n  begin\n    if (x is char) or (x is Diapason) and (Diapason(x).clow is char) then\n      chars := true\n    else if x is string then\n      strings := true\n    else \n    begin\n      others := true;\n      break\n    end;  \n  end;\n  \n  Result := new TypedSet();\n  \n  if chars and strings and not others then\n    foreach var x in elems do\n      if x is char then\n        Result.IncludeElement(x.ToString)\n      else if (x is Diapason) and (Diapason(x).clow is char) then\n      begin\n        var c1 := char(Diapason(x).clow);\n        var c2 := char(Diapason(x).chigh);\n        for var cc := c1 to c2 do\n          Result.IncludeElement(cc.ToString)\n      end\n      else Result.IncludeElement(x)\n  else    \n    foreach var x in elems do\n      Result.IncludeElement(x);\nend;"
  },
  {
    "instruction": "Implement range creation functions for different data types",
    "output": "[System.Diagnostics.DebuggerStepThrough]\nfunction CreateDiapason(low, high: integer): Diapason;\nbegin\n  Result.low := low;\n  Result.high := high;\nend;\n\nfunction CreateObjDiapason(low, high: object): Diapason;\nbegin\n  Result.clow := low;\n  Result.chigh := high;\nend;"
  },
  {
    "instruction": "Implement set element inclusion and exclusion procedures",
    "output": "[System.Diagnostics.DebuggerStepThrough]\nprocedure Include(var s: TypedSet; el: object);\nbegin\n  s.IncludeElement(el);\nend;\n\n[System.Diagnostics.DebuggerStepThrough]\nprocedure Exclude(var s: TypedSet; el: object);\nbegin\n  s.ExcludeElement(el);\nend;"
  },
  {
    "instruction": "Implement element existence check in TypedSet",
    "output": "[System.Diagnostics.DebuggerStepThrough]  \nfunction InSet(obj: object; s: TypedSet): boolean;\nbegin\n  Result := (obj <> nil) and s.Contains(obj);\nend;"
  },
  {
    "instruction": "Implement TypedSet comparison methods for equality and inequality",
    "output": "function TypedSet.CompareEquals(s: TypedSet): boolean;\nbegin\n  Result := CompareSetEquals(Self, s);\nend;\n\nfunction TypedSet.CompareInEquals(s: TypedSet): boolean;\nbegin\n  Result := CompareSetInEquals(Self, s);\nend;"
  },
  {
    "instruction": "Implement TypedSet comparison methods for ordering relations",
    "output": "function TypedSet.CompareLess(s: TypedSet): boolean;\nbegin\n  Result := CompareSetLess(Self, s);\nend;\n\nfunction TypedSet.CompareLessEqual(s: TypedSet): boolean;\nbegin\n  Result := CompareSetLessEqual(Self, s);\nend;\n\nfunction TypedSet.CompareGreater(s: TypedSet): boolean;\nbegin\n  Result := CompareSetGreater(Self, s);\nend;\n\nfunction TypedSet.CompareGreaterEqual(s: TypedSet): boolean;\nbegin\n  Result := CompareSetGreaterEqual(Self, s);\nend;"
  },
  {
    "instruction": "Implement TypedSet printing methods with delimiter support",
    "output": "procedure TypedSet.Print(delim: string);\nbegin\n  foreach var x in ht.Keys do\n    Write(x,delim)\nend;\n\nprocedure TypedSet.Println(delim: string);\nbegin\n  var fst := True;\n  foreach var x in ht.Keys do\n  begin\n    if fst then\n    begin\n      fst := False;\n      Write(x);\n    end\n    else Write(delim,x);\n  end;\n  Writeln;  \nend;"
  },
  {
    "instruction": "Implement TypedSet initialization procedures with different bounds",
    "output": "procedure TypedSetInit(var st: TypedSet);\nbegin\n  if st = nil then\n    st := new TypedSet;\nend;\n\nprocedure TypedSetInitWithBounds(var st: TypedSet; low, high: object);\nbegin\n  if st = nil then\n    st := new TypedSet(low, high);\nend;\n\nprocedure TypedSetInitWithShortString(var st: TypedSet; len: integer);\nbegin\n  if st = nil then\n    st := new TypedSet(len);\nend;"
  },
  {
    "instruction": "Implement set assignment procedures with bounds copying",
    "output": "procedure AssignSet(var left: TypedSet; right: TypedSet);\nbegin\n  left := right.CloneSet();\nend;\n\nprocedure AssignSetWithBounds(var left: TypedSet; right: TypedSet; low, high: object);\nbegin\n  left := right.CloneSet();\n  left.low_bound := low;\n  right.upper_bound := high;\nend;"
  },
  {
    "instruction": "Implement set clipping procedures for different bounds",
    "output": "procedure ClipSet(var s: TypedSet; low, high: object);\nbegin\n  s.low_bound := low;\n  s.upper_bound := high;\n  s.Clip;\nend;\n\nfunction ClipSetFunc(s: TypedSet; low, high: object): TypedSet;\nbegin\n  s.low_bound := low;\n  s.upper_bound := high;\n  s.Clip();\n  Result := s;\nend;\n\nfunction ClipShortStringInSet(s: TypedSet; len: integer): TypedSet;\nbegin\n  s.len := len;\n  s.Clip;\n  Result := s;\nend;\n\nprocedure ClipShortStringInSetProcedure(var s: TypedSet; len: integer);\nbegin\n  s.len := len;\n  s.Clip;\nend;"
  },
  {
    "instruction": "Implement TypedSet element conversion helper function",
    "output": "function convert_elem(obj: object): object;\nbegin\n  var t := obj.GetType;\n  if t.IsEnum then\n  begin\n    Result := obj;\n    exit;\n  end;\n  case System.Type.GetTypeCode(t) of\n    TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32:\n    Result := Convert.ToInt32(obj);\n    TypeCode.UInt32:\n      begin\n        var tmp: longword := longword(obj);\n        if tmp <= integer.MaxValue then\n          Result := integer(tmp)\n        else\n          Result := Convert.ToInt64(obj);\n      end;\n    TypeCode.Int64:\n      begin\n        var tmp: int64 := int64(obj);\n        if tmp <= integer.MaxValue then\n          Result := integer(tmp)\n        else\n          Result := obj;\n      end;\n    TypeCode.UInt64:\n      begin\n        var tmp: uint64 := uint64(obj);\n        if tmp <= integer.MaxValue then\n          Result := integer(tmp)\n        else\n        if tmp <= int64.MaxValue then\n          Result := int64(tmp)\n        else\n          Result := obj;\n      end\n  else\n    Result := obj;\n  end;\nend;"
  },
  {
    "instruction": "Implement TypedSet element containment check with type conversion",
    "output": "function TypedSet.Contains(elem: object): boolean;\nbegin\n  if elem.GetType().IsEnum then\n  begin\n    Result := ht[elem] <> nil\n  end\n  else \n  begin\n    elem := convert_elem(elem);\n    Result := ht.ContainsKey(elem);\n    if not Result and (elem is char) then\n      Result := ht.ContainsKey(Convert.ToString(elem));\n  end;\nend;"
  },
  {
    "instruction": "Implement TypedSet range validation method for elements",
    "output": "function TypedSet.IsInDiapason(elem: object): boolean;\nbegin\n  if (low_bound <> nil) and (upper_bound <> nil) and (elem is System.IComparable) then\n  begin\n    case System.Type.GetTypeCode(elem.GetType) of\n      TypeCode.Char:\n        begin\n          if ((elem as System.IComparable).CompareTo(Convert.ToChar(low_bound)) >= 0) and ((elem as System.IComparable).CompareTo(Convert.ToChar(upper_bound)) <= 0) then\n            Result := true\n          else Result := false\n        end;\n      TypeCode.Int32:\n        begin\n          if not (elem is integer) then elem := Convert.ToInt32(elem);\n          if ((elem as System.IComparable).CompareTo(Convert.ToInt32(low_bound)) >= 0) and ((elem as System.IComparable).CompareTo(Convert.ToInt32(upper_bound)) <= 0) then\n            Result := true\n          else Result := false\n        end;\n      TypeCode.Byte:\n        begin\n          if ((elem as System.IComparable).CompareTo(Convert.ToByte(low_bound)) >= 0) and ((elem as System.IComparable).CompareTo(Convert.ToByte(upper_bound)) <= 0) then\n            Result := true\n          else Result := false\n        end;\n      TypeCode.SByte:\n        begin\n          if ((elem as System.IComparable).CompareTo(Convert.ToSByte(low_bound)) >= 0) and ((elem as System.IComparable).CompareTo(Convert.ToSByte(upper_bound)) <= 0) then\n            Result := true\n          else Result := false\n        end;\n      TypeCode.Int16:\n        begin\n          if ((elem as System.IComparable).CompareTo(Convert.ToInt16(low_bound)) >= 0) and ((elem as System.IComparable).CompareTo(Convert.ToInt16(upper_bound)) <= 0) then\n            Result := true\n          else Result := false\n        end;\n      TypeCode.UInt16:\n        begin\n          if ((elem as System.IComparable).CompareTo(Convert.ToUint16(low_bound)) >= 0) and ((elem as System.IComparable).CompareTo(Convert.ToUInt16(upper_bound)) <= 0) then\n            Result := true\n          else Result := false\n        end;\n      TypeCode.UInt32:\n        begin\n          if ((elem as System.IComparable).CompareTo(Convert.ToUInt32(low_bound)) >= 0) and ((elem as System.IComparable).CompareTo(Convert.ToUInt32(upper_bound)) <= 0) then\n            Result := true\n          else Result := false\n        end;\n      TypeCode.Int64:\n        begin\n          if ((elem as System.IComparable).CompareTo(Convert.ToInt64(low_bound)) >= 0) and ((elem as System.IComparable).CompareTo(Convert.ToInt64(upper_bound)) <= 0) then\n            Result := true\n          else Result := false\n        end;\n      TypeCode.UInt64:\n        begin\n          if ((elem as System.IComparable).CompareTo(Convert.ToUInt64(low_bound)) >= 0) and ((elem as System.IComparable).CompareTo(Convert.ToUInt64(upper_bound)) <= 0) then\n            Result := true\n          else Result := false\n        end;\n    else\n      if elem.GetType().IsEnum then \n      begin\n        if ((Convert.ToInt32(elem)).CompareTo(Convert.ToInt32(low_bound)) >= 0) and ((Convert.ToInt32(elem)).CompareTo(Convert.ToInt32(upper_bound)) <= 0) then\n          Result := true\n        else Result := false\n      end\n      else Result := true;\n    end\n  end\n  else Result := true;\nend;"
  },
  {
    "instruction": "Implement TypedSet clipping methods for bounds and string length",
    "output": "procedure TypedSet.Clip;\nbegin\n  if Self.len > 0 then\n  begin\n    Clip(Self.len);\n    exit;\n  end;\n  var tmp_ht := new Hashtable();\n  foreach el: object in ht.Keys do\n  begin\n    if IsInDiapason(el) then \n    begin\n      if (Self.low_bound <> nil) then\n      begin\n        var tmp := convert_elem(el);\n        tmp_ht.Add(tmp, tmp)\n      end\n      else\n        tmp_ht.Add(el, el);\n    end;\n  end;\n  ht := tmp_ht;\nend;\n\nprocedure TypedSet.Clip(len: integer);\nbegin\n  var tmp_ht := new Hashtable();\n  foreach el: object in ht.Keys do\n  begin\n    var str_el := Convert.ToString(el);\n    if str_el.Length > len then\n    begin\n      var s := str_el.Substring(0, len);\n      tmp_ht.Add(s, s);\n    end\n    else\n      tmp_ht.Add(str_el, str_el);\n  end;\n  ht := tmp_ht;\nend;"
  },
  {
    "instruction": "Implement TypedSet initialization from array of objects",
    "output": "procedure TypedSet.Init(params elems: array of object);\nbegin\n  for var i := 0 to elems.Length - 1 do\n    ht[elems[i]] := elems[i];\nend;"
  },
  {
    "instruction": "Implement TypedSet assignment from another set",
    "output": "[System.Diagnostics.DebuggerStepThrough]\nprocedure TypedSet.AssignSetFrom(s: TypedSet);\nbegin\n  ht := s.ht.Clone() as Hashtable;\n  Clip;\nend;"
  },
  {
    "instruction": "Implement TypedSet enumerator for iteration",
    "output": "function TypedSet.GetEnumerator: System.Collections.IEnumerator;\nbegin\n  Result := ht.Keys.GetEnumerator; \nend;"
  },
  {
    "instruction": "Implement string formatting helper for set elements",
    "output": "function FormatStr(obj: object): string;\nbegin\n  if (obj.GetType = typeof(char)) or (obj.GetType = typeof(string)) then\n    Result := '''' + string.Format(System.Globalization.NumberFormatInfo.InvariantInfo, '{0}', new object[](obj)) + ''''\n  else\n    Result := string.Format(System.Globalization.NumberFormatInfo.InvariantInfo, '{0}', new object[](obj))\nend;"
  },
  {
    "instruction": "Implement TypedSet to string conversion with sorted formatting",
    "output": "function TypedSet.ToString: string;\nvar\n  i: System.Collections.IEnumerator;\n  lst: ArrayList;\nbegin\n  i := GetEnumerator;\n  lst := new ArrayList();\n  var t: &Type; \n  var added := false;\n  if i.MoveNext then\n    if not (i.Current is System.IComparable) then\n    begin\n      result := '' + FormatStr(i.Current) + '';\n      added := true;\n    end\n    else \n    begin\n      lst.Add(i.Current);\n      t := i.Current.GetType;\n    end;\n  while i.MoveNext do\n    if not (i.Current is System.IComparable) then\n    begin\n      result := (added ? result + ',' : '') + FormatStr(i.Current);\n      added := true;\n    end\n    else\n    begin\n      if (t <> nil) and (t <> i.Current.GetType) then\n      begin\n        result := (added ? result + ',' : '') + FormatStr(i.Current);\n        added := true;\n      end\n      else\n      begin\n        t := i.Current.GetType;\n        lst.Add(i.Current);\n      end;  \n    end;\n  \n  if lst.Count > 0 then\n  begin\n    lst.Sort;\n    var ind := 1;\n    if not added then\n      result := '' + FormatStr(lst[0]) + ''\n    else\n      ind := 0;\n    for j: integer := ind to lst.Count - 1 do\n    begin\n      result := result + ',' + FormatStr(lst[j]);\n    end;\n  end;\n  result := '[' + result + ']';\nend;"
  },
  {
    "instruction": "Implement BigInteger division and modulus operations with integers",
    "output": "function BigInteger.operator/(p: BigInteger; q: real) := real(p)/q;\n\nfunction BigInteger.operator/(q: real; p: BigInteger) := q/real(p);\n\nfunction BigInteger.operator div(p: BigInteger; q: integer) := BigInteger.Divide(p,q);\n\nfunction BigInteger.operator mod(p: BigInteger; q: integer) := BigInteger.Remainder(p,q);\n\nfunction BigInteger.operator-(p: BigInteger) := BigInteger.Negate(p);"
  },
  {
    "instruction": "Implement BigInteger compound assignment operators",
    "output": "procedure BigInteger.operator+=(var p: BigInteger; q: BigInteger) := p := p + q;\n\nprocedure BigInteger.operator*=(var p: BigInteger; q: BigInteger) := p := p * q;\n\nprocedure BigInteger.operator-=(var p: BigInteger; q: BigInteger) := p := p - q;"
  },
  {
    "instruction": "Implement Complex number implicit conversions from tuples",
    "output": "function operator implicit(c: (real,real)): Complex; extensionmethod := Cplx(c[0],c[1]);\n\nfunction operator implicit(c: (real,integer)): Complex; extensionmethod := Cplx(c[0],c[1]);\n\nfunction operator implicit(c: (integer,real)): Complex; extensionmethod := Cplx(c[0],c[1]);\n\nfunction operator implicit(c: (integer,integer)): Complex; extensionmethod := Cplx(c[0],c[1]);"
  },
  {
    "instruction": "Implement HashSet compound assignment operators for elements and sequences",
    "output": "function operator+=<T>(var Self: HashSet<T>; x: T): HashSet<T>; extensionmethod;\nbegin\n  Self.Add(x);\n  Result := Self;\nend;\n\nfunction operator+=<T>(var Self: HashSet<T>; x: sequence of T): HashSet<T>; extensionmethod;\nbegin\n  Self.UnionWith(x);\n  Result := Self;\nend;\n\nfunction operator-=<T>(var Self: HashSet<T>; x: T): HashSet<T>; extensionmethod;\nbegin\n  Self.Remove(x);\n  Result := Self;\nend;\n\nfunction operator-=<T>(var Self: HashSet<T>; x: sequence of T): HashSet<T>; extensionmethod;\nbegin\n  Self.ExceptWith(x);\n  Result := Self;\nend;"
  },
  {
    "instruction": "Implement SortedSet compound assignment operators for elements and sequences",
    "output": "function operator+=<T>(var Self: SortedSet<T>; x: T): SortedSet<T>; extensionmethod;\nbegin\n  Self.Add(x);\n  Result := Self;\nend;\n\nfunction operator+=<T>(var Self: SortedSet<T>; x: sequence of T): SortedSet<T>; extensionmethod;\nbegin\n  Self.UnionWith(x);\n  Result := Self;\nend;\n\nfunction operator-=<T>(var Self: SortedSet<T>; x: T): SortedSet<T>; extensionmethod;\nbegin\n  Self.Remove(x);\n  Result := Self;\nend;\n\nfunction operator-=<T>(var Self: SortedSet<T>; x: sequence of T): SortedSet<T>; extensionmethod;\nbegin\n  Self.ExceptWith(x);\n  Result := Self;\nend;"
  },
  {
    "instruction": "Implement BigInteger equality and inequality operators with integer values",
    "output": "function BigInteger.operator=(p: BigInteger; q: integer) := p = BigInteger.Create(q);\n\nfunction BigInteger.operator=(p: integer; q: BigInteger) := BigInteger.Create(p) = q;\n\nfunction BigInteger.operator<>(p: BigInteger; q: integer) := p <> BigInteger.Create(q);\n\nfunction BigInteger.operator<>(p: integer; q: BigInteger) := BigInteger.Create(p) <> q;"
  },
  {
    "instruction": "Implement HashSet equality and inequality comparison operators",
    "output": "function operator=<T>(x,y: HashSet<T>): boolean; extensionmethod := InternalEqual(x,y);\n\nfunction operator<><T>(x,y: HashSet<T>); extensionmethod := not InternalEqual(x,y);"
  },
  {
    "instruction": "Implement SortedSet equality and inequality comparison operators",
    "output": "function operator=<T>(x,y: SortedSet<T>): boolean; extensionmethod := InternalEqual(x,y);\n\nfunction operator<><T>(x, y: SortedSet<T>); extensionmethod := not InternalEqual(x,y);"
  },
  {
    "instruction": "Implement HashSet element addition and removal operations",
    "output": "function operator+<T>(x: HashSet<T>; y: T): HashSet<T>; extensionmethod;\nbegin\n  var v := new HashSet<T>(x);\n  v.Add(y);\n  Result := v;\nend;\n\nfunction operator-<T>(x: HashSet<T>; y: T): HashSet<T>; extensionmethod;\nbegin\n  var v := new HashSet<T>(x);\n  v.Remove(y);\n  Result := v;\nend;"
  },
  {
    "instruction": "Implement SortedSet element addition and removal operations",
    "output": "function operator+<T>(x: SortedSet<T>; y: T): SortedSet<T>; extensionmethod;\nbegin\n  var v := new SortedSet<T>(x);\n  v.Add(y);\n  Result := v;\nend;\n\nfunction operator-<T>(x: SortedSet<T>; y: T): SortedSet<T>; extensionmethod;\nbegin\n  var v := new SortedSet<T>(x);\n  v.Remove(y);\n  Result := v;\nend;"
  },
  {
    "instruction": "Implement sequence concatenation with single elements",
    "output": "function operator+<T>(a: sequence of T; b: T): sequence of T; extensionmethod;\nbegin\n  Result := a.Concat(new T[1](b));\nend;\n\nfunction operator+<T>(b: T; a: sequence of T): sequence of T; extensionmethod;\nbegin\n  Result := new T[1](b);\n  Result := Result.Concat(a);\nend;"
  },
  {
    "instruction": "Implement sequence element existence check",
    "output": "function operator in<T>(x: T; Self: sequence of T): boolean; extensionmethod;\nbegin\n  Result := Self.Contains(x);\nend;"
  },
  {
    "instruction": "Implement string substring existence check operator",
    "output": "function string.operator in(substr: string; str: string) := str.Contains(substr);"
  },
  {
    "instruction": "Implement GCHandlersController counter and enumerator methods",
    "output": "function GCHandlersController.GetCounter(obj: Object): integer;\nbegin\n  result := 0;\n  if Counters.Contains(obj) then\n    result := integer(Counters[obj]);      \nend;\n\nfunction GCHandlersController.GetEnumerator: System.Collections.IEnumerator;\nbegin\n  result := Counters.Keys.GetEnumerator; \nend;"
  },
  {
    "instruction": "Implement method to find overridden ToString method in class hierarchy",
    "output": "function RedefinedToString(o: object): System.Reflection.MethodInfo;\nbegin\n  var t := o.GetType;\n  var meth: System.Reflection.MethodInfo := nil;\n  while t <> typeof(Object) do\n  begin\n    meth := t.GetMethod('ToString', System.Reflection.BindingFlags.Public or\n                System.Reflection.BindingFlags.Instance or \n                System.Reflection.BindingFlags.DeclaredOnly, nil, new System.Type[0], nil);\n    if meth <> nil then \n      break;\n    t := t.BaseType;            \n  end;\n  if (t = typeof(Object)) or (t = typeof(System.ValueType)) then\n    Result := nil\n  else Result := meth;   \nend;"
  },
  {
    "instruction": "Implement TypedSet constructors with initialization values",
    "output": "constructor TypedSet.Create(initValue: TypedSet);\nbegin\n  ht := new Hashtable({new TypedSetComparer()});\n  Self.AssignSetFrom(initValue);\n  Self.len := initValue.len;\nend;\n\nconstructor TypedSet.Create(low_bound, upper_bound: object; initValue: TypedSet);\nbegin\n  ht := new Hashtable({new TypedSetComparer()});\n  Self.low_bound := low_bound;\n  Self.upper_bound := upper_bound;\n  Self.AssignSetFrom(initValue);\nend;"
  },
  {
    "instruction": "Implement TypedSet constructor from byte array for bit representation",
    "output": "constructor TypedSet.Create(vals: array of byte);\nvar\n  i: integer;\nbegin\n  ht := new Hashtable({new TypedSetComparer()});\n  i := 0;\n  while i < 256 div 8 do\n  begin\n    if vals[i] and 128 = 128 then ht.Add(i * 8, i * 8);\n    if vals[i] and 64 = 64 then ht.Add(i * 8 + 1, i * 8 + 1);\n    if vals[i] and 32 = 32 then ht.Add(i * 8 + 2, i * 8 + 2);\n    if vals[i] and 16 = 16 then ht.Add(i * 8 + 3, i * 8 + 3);\n    if vals[i] and 8 = 8 then ht.Add(i * 8 + 4, i * 8 + 4);\n    if vals[i] and 4 = 4 then ht.Add(i * 8 + 5, i * 8 + 5);\n    if vals[i] and 2 = 2 then ht.Add(i * 8 + 6, i * 8 + 6);\n    if vals[i] and 1 = 1 then ht.Add(i * 8 + 7, i * 8 + 7);\n    i := i + 1;\n  end;\nend;"
  },
  {
    "instruction": "Implement set comparison functions for greater than or equal and less than or equal",
    "output": "[System.Diagnostics.DebuggerStepThrough]  \nfunction CompareSetGreaterEqual(s1, s2: TypedSet): boolean;\nvar\n  en: System.Collections.IEnumerator;\n  greater: boolean := true;\nbegin\n  en := s2.ht.GetEnumerator();\n  en.Reset();\n  while en.MoveNext do\n  begin\n    if not s1.Contains((en as IDictionaryEnumerator).Key) then \n    begin\n      greater := false;\n      break;\n    end;\n  end;\n  Result := greater;\nend;\n\n[System.Diagnostics.DebuggerStepThrough]  \nfunction CompareSetLessEqual(s1, s2: TypedSet): boolean;\nvar\n  en: System.Collections.IEnumerator;\n  less: boolean := true;\nbegin\n  en := s1.ht.GetEnumerator();\n  en.Reset();\n  while en.MoveNext do\n  begin\n    if not s2.Contains((en as IDictionaryEnumerator).Key) then \n    begin\n      less := false;\n      break;\n    end;\n  end;\n  Result := less;\nend;"
  },
  {
    "instruction": "Implement set comparison function for greater than (proper superset)",
    "output": "[System.Diagnostics.DebuggerStepThrough]  \nfunction CompareSetGreater(s1, s2: TypedSet): boolean;\nvar\n  greater: boolean := true;\n  en: System.Collections.IEnumerator;\nbegin\n  en := s2.ht.GetEnumerator();\n  en.Reset();\n  while en.MoveNext do\n  begin\n    if not s1.Contains((en as IDictionaryEnumerator).Key) then \n    begin\n      greater := false;\n      break;\n    end;\n  end;\n  if greater <> false then\n  begin\n    en := s1.ht.GetEnumerator();\n    en.Reset();\n    var b: boolean := false;\n    while en.MoveNext do\n    begin\n      if not s2.Contains((en as IDictionaryEnumerator).Key) then \n      begin\n        b := true;\n        break;\n      end;\n    end;\n    greater := b;\n  end;\n  Result := greater;\nend;"
  },
  {
    "instruction": "Implement TypedSet implicit conversion operators for HashSet",
    "output": "class function TypedSet.operator implicit<T>(s: TypedSet): HashSet<T>;\nbegin\n  var hs := new HashSet<T>();\n  foreach var key in s.ht.Keys do\n  begin\n    hs.Add(T(key));  \n  end;\n  Result := hs; \nend;\n\nclass function TypedSet.operator implicit<T>(s: HashSet<T>): TypedSet;\nbegin\n  var ts := new TypedSet();\n  foreach key: T in s.ToArray() do\n  begin\n    ts.ht[key] := key;  \n  end;\n  Result := ts; \nend;"
  },
  {
    "instruction": "Implement string compound assignment with concatenation",
    "output": "procedure string.operator+=(var left: string; right: string);\nbegin\n  left := left + right;\nend;"
  },
  {
    "instruction": "Implement SortedDictionary key existence check operator",
    "output": "function SortedDictionary<K, V>.operator in(key: K; d: SortedDictionary<K, V>): boolean;\nbegin\n  Result := d.ContainsKey(key);\nend;"
  },
  {
    "instruction": "Implement SortedList key existence check operator",
    "output": "function SortedList<K, V>.operator in(key: K; d: SortedList<K, V>): boolean;\nbegin\n  Result := d.ContainsKey(key);\nend;"
  },
  {
    "instruction": "Implement BigInteger range generator function",
    "output": "function Range(a, b: BigInteger): sequence of BigInteger := Range(a,b,1);"
  },
  {
    "instruction": "Implement partition points generation for real number ranges",
    "output": "function PartitionPoints(a, b: real; n: integer): sequence of real;\nbegin\n  if n = 0 then\n    raise new System.ArgumentException('Range: n=0');\n  if n < 0 then\n    raise new System.ArgumentException('Range: n<0');\n  var r := a;\n  var h := (b - a) / n;\n  for var i := 0 to n do\n  begin\n    yield r;\n    r += h\n  end;\nend;"
  },
  {
    "instruction": "Implement random array generation functions with different return types",
    "output": "function ArrRandomInteger(n: integer; a: integer; b: integer): array of integer;\nbegin\n  Result := ArrRandom(n, a, b);\nend;\n\nfunction SeqRandomInteger(n: integer; a: integer; b: integer): sequence of integer;\nbegin\n  loop n do\n    yield Random(a, b)\nend;"
  },
  {
    "instruction": "Implement internal equality comparison for HashSet collections",
    "output": "function InternalEqual<T>(x,y: HashSet<T>): boolean;\nbegin\n  var xn := Object.ReferenceEquals(x,nil);\n  var yn := Object.ReferenceEquals(y,nil);\n  if xn then\n    Result := yn\n  else if yn then \n    Result := xn\n  else Result := x.SetEquals(y);\nend;"
  },
  {
    "instruction": "Implement internal equality comparison for SortedSet collections",
    "output": "function InternalEqual<T>(x,y: SortedSet<T>): boolean; \nbegin\n  var xn := Object.ReferenceEquals(x,nil);\n  var yn := Object.ReferenceEquals(y,nil);\n  if xn then\n    Result := yn\n  else if yn then \n    Result := xn\n  else Result := x.SetEquals(y);\nend;"
  },
  {
    "instruction": "Implement ArithmSeq helper type for range generation",
    "output": "type\n  ArithmSeq = auto class\n    a, step: integer;\n    function f(x: integer): integer;\n    begin\n      Result := x * step + a;\n    end;\n  end;"
  },
  {
    "instruction": "Implement string assignment operators with numeric values",
    "output": "procedure string.operator+=(var left: string; right: integer);\nbegin\n  left := left + right.ToString;\nend;\n\nprocedure string.operator+=(var left: string; right: real);\nbegin\n  left := left + right.ToString(nfi);\nend;"
  },
  {
    "instruction": "Implement HashSet internal equality helper function",
    "output": "function InternalEqual<T>(x,y: HashSet<T>): boolean;\nbegin\n  var xn := Object.ReferenceEquals(x,nil);\n  var yn := Object.ReferenceEquals(y,nil);\n  if xn then\n    Result := yn\n  else if yn then \n    Result := xn\n  else Result := x.SetEquals(y);\nend;"
  },
  {
    "instruction": "Implement SortedSet internal equality helper function",
    "output": "function InternalEqual<T>(x,y: SortedSet<T>): boolean; \nbegin\n  var xn := Object.ReferenceEquals(x,nil);\n  var yn := Object.ReferenceEquals(y,nil);\n  if xn then\n    Result := yn\n  else if yn then \n    Result := xn\n  else Result := x.SetEquals(y);\nend;"
  },
  {
    "instruction": "Implement BigInteger range generation with step parameter",
    "output": "function Range(a, b, step: BigInteger): sequence of BigInteger;\nbegin\n  if step = 0 then\n    raise new System.ArgumentException('step=0');\n  if step > 0 then\n    while a<=b do\n    begin\n      yield a;\n      a += step;\n    end\n  else  \n    while a>=b do\n    begin\n      yield a;\n      a += step;\n    end\nend;"
  },
  {
    "instruction": "Implement TypedSet assignment from another set with bounds",
    "output": "procedure AssignSetWithBounds(var left: TypedSet; right: TypedSet; low, high: object);\nbegin\n  left := right.CloneSet();\n  left.low_bound := low;\n  right.upper_bound := high;\nend;"
  },
  {
    "instruction": "Implement TypedSet clipping function for short strings",
    "output": "function ClipShortStringInSet(s: TypedSet; len: integer): TypedSet;\nbegin\n  s.len := len;\n  s.Clip;\n  Result := s;\nend;"
  },
  {
    "instruction": "Implement TypedSet clipping procedure for short strings",
    "output": "procedure ClipShortStringInSetProcedure(var s: TypedSet; len: integer);\nbegin\n  s.len := len;\n  s.Clip;\nend;"
  },
  {
    "instruction": "Implement TypedSet initialization with short string length",
    "output": "procedure TypedSetInitWithShortString(var st: TypedSet; len: integer);\nbegin\n  if st = nil then\n    st := new TypedSet(len);\nend;"
  },
  {
    "instruction": "Implement element conversion helper for TypedSet with enum support",
    "output": "function convert_elem(obj: object): object;\nbegin\n  var t := obj.GetType;\n  if t.IsEnum then\n  begin\n    Result := obj;\n    exit;\n  end;\n  case System.Type.GetTypeCode(t) of\n    TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32:\n    Result := Convert.ToInt32(obj);\n    TypeCode.UInt32:\n      begin\n        var tmp: longword := longword(obj);\n        if tmp <= integer.MaxValue then\n          Result := integer(tmp)\n        else\n          Result := Convert.ToInt64(obj);\n      end;\n    TypeCode.Int64:\n      begin\n        var tmp: int64 := int64(obj);\n        if tmp <= integer.MaxValue then\n          Result := integer(tmp)\n        else\n          Result := obj;\n      end;\n    TypeCode.UInt64:\n      begin\n        var tmp: uint64 := uint64(obj);\n        if tmp <= integer.MaxValue then\n          Result := integer(tmp)\n        else\n        if tmp <= int64.MaxValue then\n          Result := int64(tmp)\n        else\n          Result := obj;\n      end\n  else\n    Result := obj;\n  end;\nend;"
  },
  {
    "instruction": "Implement TypedSet element inclusion with range support for enums",
    "output": "procedure TypedSet.IncludeElement(elem: object);\nvar\n  diap: Diapason;\nbegin\n  if elem = nil then exit;\n  elem := convert_elem(elem);\n  if not IsInDiapason(elem) then Exit;\n  if elem.GetType().IsEnum then\n  begin\n    ht[elem] := elem;\n  end\n  else\n  if not (elem is Diapason) then\n  begin\n    ht[elem] := elem;\n  end\n  else\n  begin\n    diap := Diapason(elem);\n    if diap.clow = nil then\n    begin\n      for var i := diap.low to diap.high do\n      begin\n        ht[i] := i;\n      end\n    end\n    else \n    begin\n      if diap.clow is char then\n      begin\n        for var c := char(diap.clow) to char(diap.chigh) do\n        begin\n          ht[c] := c;\n        end\n      end\n      else if diap.clow is boolean then\n      begin\n        for var b := boolean(diap.clow) to boolean(diap.chigh) do\n          ht[b] := b;\n      end\n      else if diap.clow.GetType().IsEnum then\n      begin\n        for var i := integer(diap.clow) to integer(diap.chigh) do\n        begin\n          var obj := Enum.ToObject(diap.clow.GetType(), i);\n          ht[obj] := obj;\n        end;\n      end;\n    end;\n  end;\nend;"
  },
  {
    "instruction": "Implement TypedSet string representation with sorted formatting",
    "output": "function TypedSet.ToString: string;\nvar\n  i: System.Collections.IEnumerator;\n  lst: ArrayList;\nbegin\n  i := GetEnumerator;\n  lst := new ArrayList();\n  var t: &Type; \n  var added := false;\n  if i.MoveNext then\n    if not (i.Current is System.IComparable) then\n    begin\n      result := '' + FormatStr(i.Current) + '';\n      added := true;\n    end\n    else \n    begin\n      lst.Add(i.Current);\n      t := i.Current.GetType;\n    end;\n  while i.MoveNext do\n    if not (i.Current is System.IComparable) then\n    begin\n      result := (added ? result + ',' : '') + FormatStr(i.Current);\n      added := true;\n    end\n    else\n    begin\n      if (t <> nil) and (t <> i.Current.GetType) then\n      begin\n        result := (added ? result + ',' : '') + FormatStr(i.Current);\n        added := true;\n      end\n      else\n      begin\n        t := i.Current.GetType;\n        lst.Add(i.Current);\n      end;  \n    end;\n  \n  if lst.Count > 0 then\n  begin\n    lst.Sort;\n    var ind := 1;\n    if not added then\n      result := '' + FormatStr(lst[0]) + ''\n    else\n      ind := 0;\n    for j: integer := ind to lst.Count - 1 do\n    begin\n      result := result + ',' + FormatStr(lst[j]);\n    end;\n  end;\n  result := '[' + result + ']';\nend;"
  },
  {
    "instruction": "Implement structured object to string conversion for nested arrays",
    "output": "function ArrNToString(a: System.Array; indexes: array of integer; i: integer): string;\nconst\n  nmax = 100;\nbegin\n  var sb := new StringBuilder;\n  if i = a.Rank then\n    sb.Append(StructuredObjectToString(a.GetValue(indexes)))\n  else\n  begin\n    sb.Append('[');\n    for var k := 0 to a.GetLength(i) - 1 do\n    begin\n      indexes[i] := k;\n      sb.Append(ArrNToString(a, indexes, i + 1));\n      if (k >= nmax - 1) and (k < a.GetLength(i) - 1) then \n      begin\n        sb.Append(',...');\n        break\n      end\n      else if k < a.GetLength(i) - 1 then\n        sb.Append(',');            \n    end;\n    sb.Append(']');\n  end;\n  Result := sb.ToString;\nend;"
  },
  {
    "instruction": "Implement range generation with arithmetic sequence helper",
    "output": "function Range(a, b, step: integer): sequence of integer;\nbegin\n  if step = 0 then\n    raise new System.ArgumentException('step=0');\n  if (step > 0) and (b < a) or (step < 0) and (b > a) then\n  begin\n    Result := System.Linq.Enumerable.Empty&<integer>;\n    exit;\n  end;\n  var n := abs((b - a) div step) + 1;\n  var ar: ArithmSeq;\n  ar := new ArithmSeq(a, step);\n  Result := System.Linq.Enumerable.Range(0, n).Select(ar.f);\nend;"
  },
  {
    "instruction": "Implement GCHandlersController for pinned object management",
    "output": "constructor GCHandlersController.Create;\nbegin\n  Counters := new Hashtable;\n  Handlers := new Hashtable;\nend;\n\nprocedure GCHandlersController.Add(obj: Object);\nbegin\n  if obj <> nil then begin\n    if Counters.Contains(obj) then\n      Counters[obj] := integer(Counters[obj]) + 1\n    else begin\n      Counters.Add(obj, 1);          \n      Handlers.Add(obj, GCHandle.Alloc(obj, GCHandleType.Pinned));\n    end;\n  end;\nend;"
  },
  {
    "instruction": "Implement GCHandlersController object removal with reference counting",
    "output": "procedure GCHandlersController.Remove(obj: Object);\nbegin\n  if obj <> nil then begin\n    if Counters.Contains(obj) then begin\n      var Count := integer(Counters[obj]);\n      if Count > 1 then \n        Counters[obj] := Count - 1\n      else begin\n        Counters.Remove(obj);\n        GCHandle(Handlers[obj]).Free;\n        Handlers.Remove(obj);\n      end;\n    end else\n      raise new SystemException('PABCSystem.GCHandleForPointersController not contains object ' + obj.ToString);\n  end;  \nend;"
  },
  {
    "instruction": "Implement complex number negation operator",
    "output": "function operator-(Self: Complex): Complex; extensionmethod := Complex.Negate(Self);"
  },
  {
    "instruction": "Implement complex number compound assignment operators",
    "output": "procedure operator+=(var c: Complex; x: Complex); extensionmethod := c := c + x;\n\nprocedure operator*=(var c: Complex; x: Complex); extensionmethod := c := c * x;\n\nprocedure operator-=(var c: Complex; x: Complex); extensionmethod := c := c - x;\n\nprocedure operator/=(var c: Complex; x: Complex); extensionmethod := c := c / x;"
  },
  {
    "instruction": "Implement string repetition with compound assignment",
    "output": "procedure string.operator*=(var left: string; n: integer);\nbegin\n  var sb := new StringBuilder;\n  loop n do\n    sb.Append(left);\n  left := sb.ToString;\nend;"
  },
  {
    "instruction": "Implement StringBuilder implicit conversion from string",
    "output": "function operator implicit(s: string): StringBuilder; extensionmethod := new StringBuilder(s);"
  },
  {
    "instruction": "Implement StringBuilder concatenation assignment operator",
    "output": "procedure operator+=(var left: StringBuilder; right: string); extensionmethod := left.Append(right);"
  },
  {
    "instruction": "Implement array element existence check operator",
    "output": "function operator in<T>(x: T; a: array of T): boolean; extensionmethod := a.Contains(x);"
  },
  {
    "instruction": "Implement List element existence check operator",
    "output": "function List<T>.operator in(x: T; Self: List<T>): boolean;\nbegin\n  Result := Self.Contains(x);\nend;"
  },
  {
    "instruction": "Implement HashSet element existence check operator",
    "output": "function operator in<T>(x: T; Self: HashSet<T>): boolean; extensionmethod := Self.Contains(x);"
  },
  {
    "instruction": "Implement SortedSet element existence check operator",
    "output": "function operator in<T>(x: T; Self: SortedSet<T>): boolean; extensionmethod := Self.Contains(x);"
  },
  {
    "instruction": "Implement Dictionary key existence check operator",
    "output": "function Dictionary<K, V>.operator in(key: K; d: Dictionary<K, V>): boolean;\nbegin\n  Result := d.ContainsKey(key);\nend;"
  },
  {
    "instruction": "Implement SortedDictionary key existence check operator",
    "output": "function SortedDictionary<K, V>.operator in(key: K; d: SortedDictionary<K, V>): boolean;\nbegin\n  Result := d.ContainsKey(key);\nend;"
  },
  {
    "instruction": "Implement SortedList key existence check operator",
    "output": "function SortedList<K, V>.operator in(key: K; d: SortedList<K, V>): boolean;\nbegin\n  Result := d.ContainsKey(key);\nend;"
  },
  {
    "instruction": "Implement power operator for single precision numbers",
    "output": "function operator**(x: single; n: integer): real; extensionmethod := Power(x, n);"
  },
  {
    "instruction": "Implement power operator for integer numbers",
    "output": "function operator**(x, y: integer): real; extensionmethod := Power(real(x), y);"
  },
  {
    "instruction": "Implement power operator for real numbers",
    "output": "function operator**(x, y: real): real; extensionmethod := Power(x, y);"
  },
  {
    "instruction": "Implement power operator for complex numbers",
    "output": "function operator**(x, y: Complex): Complex; extensionmethod := Power(x, y);"
  },
  {
    "instruction": "Implement power operator for BigInteger with integer exponent",
    "output": "function operator**(x: BigInteger; y: integer): BigInteger; extensionmethod := Power(x, y);"
  },
  {
    "instruction": "Implement a generic function to create an array from parameters",
    "output": "function Arr<T>(params a: array of T): array of T;\nbegin\n  Result := new T[a.Length];\n  if a.Length > 0 then\n    System.Array.Copy(a, Result, a.Length);\nend;"
  },
  {
    "instruction": "Implement a function to create an array from a sequence",
    "output": "function Arr<T>(a: sequence of T): array of T;\nbegin\n  Result := a.ToArray;\nend;"
  },
  {
    "instruction": "Implement a function to create an array from an integer range",
    "output": "function Arr(a: IntRange): array of integer := a.ToArray;"
  },
  {
    "instruction": "Implement a function to create an array from a character range",
    "output": "function Arr(a: CharRange): array of char;\nbegin\n  var n := integer(a.High) - integer(a.Low) + 1;\n  Result := new char[n];\n  var x := a.Low;\n  for var i := 0 to n-1 do\n  begin\n    Result[i] := x;\n    Inc(x)\n  end;  \nend;"
  },
  {
    "instruction": "Implement a function to create a sequence from parameters",
    "output": "function Seq<T>(params a: array of T): sequence of T;\nbegin\n  var res := new T[a.Length];\n  System.Array.Copy(a, res, a.Length);\n  Result := res;\nend;"
  },
  {
    "instruction": "Implement an infinite recurrent sequence with initial element and next function",
    "output": "function Iterate<T>(first: T; next: T->T): sequence of T;\nbegin\n  yield first;\n  while True do\n  begin\n    first := next(first);\n    yield first;\n  end;\nend;"
  },
  {
    "instruction": "Implement an infinite recurrent sequence with two initial elements and next function",
    "output": "function Iterate<T>(first, second: T; next: (T,T)->T): sequence of T;\nbegin\n  yield first;\n  yield second;\n  while True do\n  begin\n    var nxt := next(first, second);\n    yield nxt;\n    first := second;\n    second := nxt;\n  end;\nend;"
  },
  {
    "instruction": "Implement a sequence generator with count, first element and next function",
    "output": "function SeqGen<T>(count: integer; first: T; next: T->T): sequence of T;\nbegin\n  if count < 1 then\n    raise new System.ArgumentOutOfRangeException('count', count, GetTranslation(PARAMETER_MUST_BE_GREATER_0));\n  Result := Iterate(first, next).Take(count);\nend;"
  },
  {
    "instruction": "Implement a sequence generator with count, two initial elements and next function",
    "output": "function SeqGen<T>(count: integer; first, second: T; next: (T,T) ->T): sequence of T;\nbegin\n  if count < 1 then\n    raise new System.ArgumentOutOfRangeException('count', count, GetTranslation(PARAMETER_MUST_BE_GREATER_0));\n  Result := Iterate(first, second, next).Take(count);\nend;"
  },
  {
    "instruction": "Implement an array generator with count, first element and next function",
    "output": "function ArrGen<T>(count: integer; first: T; next: T->T): array of T;\nbegin\n  if count < 1 then\n    raise new System.ArgumentOutOfRangeException('count', count, GetTranslation(PARAMETER_MUST_BE_GREATER_0));\n  var a := new T[count];\n  a[0] := first;\n  for var i := 1 to a.Length - 1 do\n    a[i] := next(a[i - 1]);\n  Result := a;\nend;"
  },
  {
    "instruction": "Implement an array generator with count, two initial elements and next function",
    "output": "function ArrGen<T>(count: integer; first, second: T; next: (T,T) ->T): array of T;\nbegin\n  if count < 2 then\n    raise new System.ArgumentOutOfRangeException('count', count, GetTranslation(PARAMETER_MUST_BE_GREATER_1));\n  var a := new T[count];\n  a[0] := first;\n  a[1] := second;\n  for var i := 2 to a.Length - 1 do\n    a[i] := next(a[i - 2], a[i - 1]);\n  Result := a;\nend;"
  },
  {
    "instruction": "Implement a function to create an array filled with specified value",
    "output": "function ArrFill<T>(count: integer; x: T): array of T;\nbegin\n  Result := new T[count];\n  for var i := 0 to Result.Length - 1 do\n    Result[i] := x;\nend;"
  },
  {
    "instruction": "Implement a function to check if two arrays are equal",
    "output": "function ArrEqual<T>(a, b: array of T): boolean;\nbegin\n  Result := True;\n  if a.Length<>b.Length then\n    Result := False\n  else\n    for var i:=0 to a.Length-1 do\n      if a[i]<>b[i] then\n      begin\n        Result := False;\n        exit;\n      end;\nend;"
  },
  {
    "instruction": "Implement a function to create a tuple with two elements",
    "output": "function Rec<T1, T2>(x1: T1; x2: T2) := Tuple.Create(x1, x2);"
  },
  {
    "instruction": "Implement a function to create a tuple with three elements",
    "output": "function Rec<T1, T2, T3>(x1: T1; x2: T2; x3: T3) := Tuple.Create(x1, x2, x3);"
  },
  {
    "instruction": "Implement a function to create a List from parameters",
    "output": "function Lst<T>(params a: array of T): List<T> := new List<T>(a);"
  },
  {
    "instruction": "Implement a function to create a HashSet from parameters",
    "output": "function HSet<T>(params a: array of T): HashSet<T> := new HashSet<T>(a);"
  },
  {
    "instruction": "Implement a function to create a SortedSet from parameters",
    "output": "function SSet<T>(params a: array of T): SortedSet<T> := new SortedSet<T>(a);"
  },
  {
    "instruction": "Implement a function to create a Dictionary from key-value pairs",
    "output": "function Dict<TKey, TVal>(params pairs: array of KeyValuePair<TKey, TVal>): Dictionary<TKey, TVal>;\nbegin\n  Result := new Dictionary<TKey, TVal>();\n  for var i := 0 to pairs.Length - 1 do\n    Result.Add(pairs[i].Key, pairs[i].Value);\nend;"
  },
  {
    "instruction": "Implement a function to create a KeyValuePair",
    "output": "function KV<TKey, TVal>(key: TKey; value: TVal): KeyValuePair<TKey, TVal>;\nbegin\n  Result := new KeyValuePair<TKey, TVal>(key, value);\nend;"
  },
  {
    "instruction": "Implement integer read procedure from standard input",
    "output": "procedure Read(var x: integer);\nbegin\n  CurrentIOSystem.read(x)\nend;"
  },
  {
    "instruction": "Implement real number read procedure from standard input",
    "output": "procedure Read(var x: real);\nbegin\n  CurrentIOSystem.read(x)\nend;"
  },
  {
    "instruction": "Implement character read procedure from standard input",
    "output": "procedure Read(var x: char);\nbegin\n  CurrentIOSystem.read(x)\nend;"
  },
  {
    "instruction": "Implement string read procedure from standard input",
    "output": "procedure Read(var x: string);\nbegin\n  CurrentIOSystem.read(x)\nend;"
  },
  {
    "instruction": "Implement function to read integer from standard input",
    "output": "function ReadInteger: integer;\nbegin\n  Read(Result);\nend;"
  },
  {
    "instruction": "Implement function to read real number from standard input",
    "output": "function ReadReal: real;\nbegin\n  Read(Result);\nend;"
  },
  {
    "instruction": "Implement function to read string from standard input",
    "output": "function ReadString: string;\nbegin\n  Result := CurrentIOSystem.ReadLine;\nend;"
  },
  {
    "instruction": "Implement write procedure for object to standard output",
    "output": "procedure Write(obj: object);\nbegin\n  if output.sw <> nil then\n    write_in_output(obj)\n  else CurrentIOSystem.Write(obj);\nend;"
  },
  {
    "instruction": "Implement writeln procedure for object to standard output",
    "output": "procedure Writeln(obj: object);\nbegin\n  if output.sw <> nil then\n  begin\n    write_in_output(obj);\n    writeln_in_output;\n  end\n  else\n  begin\n    CurrentIOSystem.Write(obj);\n    CurrentIOSystem.Writeln;\n  end\nend;"
  },
  {
    "instruction": "Implement writeln procedure without parameters",
    "output": "procedure Writeln;\nbegin\n  if output.sw <> nil then\n    writeln_in_output\n  else CurrentIOSystem.Writeln;\nend;"
  },
  {
    "instruction": "Implement function to get absolute value of integer",
    "output": "function Abs(x: integer): integer := Math.Abs(x);"
  },
  {
    "instruction": "Implement function to get absolute value of real number",
    "output": "function Abs(x: real): real := Math.Abs(x);"
  },
  {
    "instruction": "Implement sine function",
    "output": "function Sin(x: real) := Math.Sin(x);"
  },
  {
    "instruction": "Implement cosine function",
    "output": "function Cos(x: real) := Math.Cos(x);"
  },
  {
    "instruction": "Implement exponential function",
    "output": "function Exp(x: real) := Math.Exp(x);"
  },
  {
    "instruction": "Implement natural logarithm function",
    "output": "function Ln(x: real) := Math.Log(x);"
  },
  {
    "instruction": "Implement square root function",
    "output": "function Sqrt(x: real) := Math.Sqrt(x);"
  },
  {
    "instruction": "Implement power function for real numbers",
    "output": "function Power(x, y: real): real := Math.Pow(x, y);"
  },
  {
    "instruction": "Implement power function for integer exponent",
    "output": "function Power(x: real; n: integer): real;\nbegin\n  case n of\n  0: Result := 1;\n  1: Result := x;\n  2: Result := x*x;\n  3: Result := x*x*x;\n  4: Result := x*x*x*x;\n  5: Result := x*x*x*x*x;\n  6: Result := x*x*x*x*x*x;\n  else\n  if n<0 then\n    Result := 1/Power(x,-n)\n  else  \n    begin\n      var z := x;\n      var r := 1.0;\n      while n > 0 do\n      begin\n        if n and 1 = 1 then\n          r := r * z;\n        z := z * z;\n        n := n shr 1;\n      end;\n      Result := r;\n    end;\n  end;\nend;"
  },
  {
    "instruction": "Implement rounding function for real numbers",
    "output": "function Round(x: real) := Convert.ToInt32(x);"
  },
  {
    "instruction": "Implement truncation function for real numbers",
    "output": "function Trunc(x: real) := Convert.ToInt32(Math.Truncate(x));"
  },
  {
    "instruction": "Implement random number generator initialization",
    "output": "procedure Randomize;\nbegin\n  rnd := new System.Random;\nend;"
  },
  {
    "instruction": "Implement random integer generator within range",
    "output": "function Random(a, b: integer): integer;\nbegin\n  if a > b then Swap(a, b);\n  Result := rnd.Next(a, b + 1);\nend;"
  },
  {
    "instruction": "Implement random real number generator within range",
    "output": "function Random(a, b: real): real;\nbegin\n  if a > b then Swap(a, b);\n  Result := a + Random()*(b-a);\nend;"
  },
  {
    "instruction": "Implement maximum function for two integers",
    "output": "function Max(a, b: integer) := Math.Max(a, b);"
  },
  {
    "instruction": "Implement minimum function for two integers",
    "output": "function Min(a, b: integer) := Math.Min(a, b);"
  },
  {
    "instruction": "Implement function to check if number is odd",
    "output": "function Odd(i: integer) := (i mod 2) <> 0;"
  },
  {
    "instruction": "Implement function to get substring",
    "output": "function Copy(s: string; index, count: integer): string;\nbegin\n  if index < 1 then\n    index := 1;\n  if (index > s.Length) or (count <= 0) then\n  begin\n    Result := '';\n    exit;\n  end;\n  if index + count - 1 > s.Length then\n    count := s.Length - index + 1;\n  Result := s.SubString(index - 1, count);\nend;"
  },
  {
    "instruction": "Implement function to find substring position",
    "output": "function Pos(subs, s: string; from: integer): integer;\nbegin\n  if (subs = nil) or (subs.Length = 0) or (from > s.Length) then\n    Result := 0\n  else Result := s.IndexOf(subs, from - 1, System.StringComparison.Ordinal) + 1;\nend;"
  },
  {
    "instruction": "Implement function to convert integer to string",
    "output": "function IntToStr(a: integer): string;\nbegin\n  Result := a.ToString;\nend;"
  },
  {
    "instruction": "Implement function to convert string to integer",
    "output": "function StrToInt(s: string): integer;\nbegin\n  var j := 1;\n  while (j <= s.Length) and char.IsWhiteSpace(s[j]) do\n    j += 1;\n  if (j > s.Length) then \n    raise new System.FormatException(ErrorStringFromResource('Format_InvalidString'));\n  var sign := 0;  \n  if s[j] = '-' then\n  begin\n    sign := -1;\n    j += 1;\n  end  \n  else if s[j] = '+' then\n  begin\n    sign := 1;\n    j += 1;\n  end;\n  if (j > s.Length) then \n    raise new System.FormatException(ErrorStringFromResource('Format_InvalidString'));\n  var c := integer(s[j]);\n  if (c < 48) or (c > 57) then\n    raise new System.FormatException(ErrorStringFromResource('Format_InvalidString'));\n  Result := c - 48;\n  j += 1;  \n  while j <= s.Length do\n  begin\n    c := integer(s[j]);\n    if c > 57 then\n      break;\n    if c < 48 then\n      break;\n    if Result > 214748364 then\n      raise new System.OverflowException(ErrorStringFromResource('Overflow_Int32'));\n    Result := Result * 10 + (c - 48);\n    j += 1;\n  end;\n  if Result < 0 then \n    if (Result = -2147483648) and (sign = -1) then\n      exit\n    else raise new System.OverflowException(ErrorStringFromResource('Overflow_Int32'));\n  if sign = -1 then\n    Result := -Result;\n  while (j <= s.Length) and char.IsWhiteSpace(s[j]) do\n    j += 1;\n  if j <= s.Length then  \n    raise new System.FormatException(ErrorStringFromResource('Format_InvalidString'));\nend;"
  },
  {
    "instruction": "Implement increment procedure for integer",
    "output": "procedure Inc(var i: integer);\nbegin\n  i += 1;\nend;"
  },
  {
    "instruction": "Implement decrement procedure for integer",
    "output": "procedure Dec(var i: integer);\nbegin\n  i -= 1;\nend;"
  },
  {
    "instruction": "Implement successor function for integer",
    "output": "function Succ(x: integer): integer;\nbegin\n  Result := x + 1;\nend;"
  },
  {
    "instruction": "Implement function to convert real number to string",
    "output": "function FloatToStr(a: real): string;\nbegin\n  Result := a.ToString(nfi);\nend;"
  },
  {
    "instruction": "Implement string formatting function",
    "output": "function Format(formatstring: string; params pars: array of object): string;\nbegin\n  try\n    Result := string.Format(nfi, formatstring, pars);\n  except\n    on e: Exception do\n      raise e;\n  end;\nend;"
  },
  {
    "instruction": "Implement string concatenation function for two strings",
    "output": "function Concat(s1, s2: string): string;\nbegin\n  Result := s1 + s2;\nend;"
  },
  {
    "instruction": "Implement string concatenation function for multiple strings",
    "output": "function Concat(params strs: array of string): string;\nbegin\n  var sb := new System.Text.StringBuilder;\n  for var i := 0 to strs.length - 1 do\n    sb.Append(strs[i]);\n  concat := sb.ToString;\nend;"
  },
  {
    "instruction": "Implement string to lowercase conversion",
    "output": "function LowerCase(s: string): string;\nbegin\n  Result := s.ToLower;\nend;"
  },
  {
    "instruction": "Implement string to uppercase conversion",
    "output": "function UpperCase(s: string): string;\nbegin\n  Result := s.ToUpper;\nend;"
  },
  {
    "instruction": "Implement string trimming function",
    "output": "function Trim(s: string): string;\nbegin\n  Result := s.Trim(' ');\nend;"
  },
  {
    "instruction": "Implement left string extraction function",
    "output": "function LeftStr(s: string; count: integer): string;\nbegin\n  if count > s.Length then\n    count := s.Length;\n  Result := s.Substring(0, count)\nend;"
  },
  {
    "instruction": "Implement right string extraction function",
    "output": "function RightStr(s: string; count: integer): string;\nbegin\n  if count > s.Length then\n    count := s.Length;\n  Result := s.Substring(s.Length - count, count);\nend;"
  },
  {
    "instruction": "Implement string reversal function",
    "output": "function ReverseString(s: string): string;\nbegin\n  var ca := s.ToCharArray;\n  &Array.Reverse(ca);\n  Result := new string(ca);\nend;"
  },
  {
    "instruction": "Implement function to create string of repeated characters",
    "output": "function StringOfChar(ch: char; count: integer): string;\nbegin\n  Result := new string(ch, count);\nend;"
  },
  {
    "instruction": "Implement array sorting function for generic types",
    "output": "procedure Sort<T>(a: array of T);\nbegin\n  System.Array.Sort(a);\nend;"
  },
  {
    "instruction": "Implement array sorting with custom comparison function",
    "output": "procedure Sort<T>(a: array of T; cmp: (T,T)->integer);\nbegin\n  System.Array.Sort(a, cmp);\nend;"
  },
  {
    "instruction": "Implement array reversal function",
    "output": "procedure Reverse<T>(a: array of T);\nbegin\n  System.Array.Reverse(a);\nend;"
  },
  {
    "instruction": "Implement array shuffling function",
    "output": "procedure Shuffle<T>(a: array of T);\nbegin\n  var n := a.Length;\n  for var i := 0 to n - 1 do\n    Swap(a[i], a[Random(n)]);\nend;"
  },
  {
    "instruction": "Implement function to get array length",
    "output": "function Length(a: &Array): integer;\nbegin\n  if a = nil then\n    Result := 0\n  else Result := a.Length;\nend;"
  },
  {
    "instruction": "Implement function to get array low bound",
    "output": "function Low(i: System.Array): integer;\nbegin\n  if i <> nil then \n    Result := i.GetLowerBound(0)\n  else Result := 0;\nend;"
  },
  {
    "instruction": "Implement function to get array high bound",
    "output": "function High(i: System.Array): integer;\nbegin\n  if i <> nil then \n    Result := i.GetUpperBound(0)\n  else Result := -1;\nend;"
  },
  {
    "instruction": "Implement complex number creation function",
    "output": "function Cplx(re, im: real) := new Complex(re, im);"
  },
  {
    "instruction": "Implement complex number absolute value function",
    "output": "function Abs(c: Complex) := Complex.Abs(c);"
  },
  {
    "instruction": "Implement complex number square root function",
    "output": "function Sqrt(c: Complex) := Complex.Sqrt(c);"
  },
  {
    "instruction": "Implement file existence check function",
    "output": "function FileExists(name: string): boolean;\nbegin\n  Result := System.IO.File.Exists(name);\nend;"
  },
  {
    "instruction": "Implement file deletion function",
    "output": "function DeleteFile(fname: string): boolean;\nbegin\n  if not &File.Exists(fname) then\n  begin\n    Result := False;\n    exit\n  end;\n  try\n    Result := True;\n    &File.Delete(fname);\n  except\n    Result := False;\n  end;\nend;"
  },
  {
    "instruction": "Implement directory creation function",
    "output": "function CreateDir(s: string): boolean;\nbegin\n  try\n    Result := True;\n    Directory.CreateDirectory(s);\n  except\n    Result := False;\n  end;\nend;"
  },
  {
    "instruction": "Implement file rename function",
    "output": "function RenameFile(name, newname: string): boolean;\nbegin\n  try\n    Result := True;\n    &File.Move(name, newname);\n  except\n    Result := False;\n  end;\nend;"
  },
  {
    "instruction": "Implement current directory getter function",
    "output": "function GetCurrentDir: string;\nbegin\n  Result := Environment.CurrentDirectory;\nend;"
  },
  {
    "instruction": "Implement current directory setter function",
    "output": "function SetCurrentDir(s: string): boolean;\nbegin\n  try\n    Result := True;\n    Environment.CurrentDirectory := s;\n  except\n    Result := False;\n  end;\nend;"
  },
  {
    "instruction": "Implement file name extraction function",
    "output": "function ExtractFileName(fname: string): string;\nbegin\n  var fi := new System.IO.FileInfo(fname);\n  Result := fi.Name;\nend;"
  },
  {
    "instruction": "Implement file extension extraction function",
    "output": "function ExtractFileExt(fname: string): string;\nbegin\n  var fi := new System.IO.FileInfo(fname);\n  Result := fi.Extension;\nend;"
  },
  {
    "instruction": "Implement file path extraction function",
    "output": "function ExtractFilePath(fname: string): string;\nbegin\n  var fi := new System.IO.FileInfo(fname);\n  Result := fi.DirectoryName;\n  if (Result.Length > 0) and (Result[Result.Length] <> '\\') and (Result[Result.Length] <> '/') then\n    Result += '\\';\nend;"
  },
  {
    "instruction": "Implement file reading as lines function",
    "output": "function ReadAllLines(path: string): array of string;\nbegin\n  Result := ReadAllLines(path, DefaultEncoding);\nend;"
  },
  {
    "instruction": "Implement file reading as text function",
    "output": "function ReadAllText(path: string): string;\nbegin\n  Result := ReadAllText(path, DefaultEncoding);\nend;"
  },
  {
    "instruction": "Implement file writing lines function",
    "output": "procedure WriteAllLines(path: string; ss: array of string);\nbegin\n  WriteAllLines(path, ss, DefaultEncoding);\nend;"
  },
  {
    "instruction": "Implement file writing text function",
    "output": "procedure WriteAllText(path: string; s: string);\nbegin\n  System.IO.File.WriteAllText(path, s, DefaultEncoding);\nend;"
  },
  {
    "instruction": "Implement command line arguments count function",
    "output": "function ParamCount: integer;\nbegin\n  if (Environment.GetCommandLineArgs.Length > 1) and ((Environment.GetCommandLineArgs[1] = '[REDIRECTIOMODE]') or (Environment.GetCommandLineArgs[1] = '[RUNMODE]')) then\n    Result := Environment.GetCommandLineArgs.Length - 2\n  else\n    Result := Environment.GetCommandLineArgs.Length - 1;\nend;"
  },
  {
    "instruction": "Implement command line argument retrieval function",
    "output": "function ParamStr(i: integer): string;\nbegin\n  if (Environment.GetCommandLineArgs.Length > 1) and ((Environment.GetCommandLineArgs[1] = '[REDIRECTIOMODE]') or (Environment.GetCommandLineArgs[1] = '[RUNMODE]')) then\n    Result := Environment.GetCommandLineArgs[i + 1]\n  else\n    Result := Environment.GetCommandLineArgs[i];\nend;"
  },
  {
    "instruction": "Implement program halt procedure",
    "output": "procedure Halt;\nbegin\n  Halt(ExitCode);\nend;"
  },
  {
    "instruction": "Implement program halt with exit code procedure",
    "output": "procedure Halt(exitCode: integer);\nbegin\n  System.Environment.Exit(exitCode);\nend;"
  },
  {
    "instruction": "Implement sleep procedure",
    "output": "procedure Sleep(ms: integer);\nbegin\n  System.Threading.Thread.Sleep(ms);\nend;"
  },
  {
    "instruction": "Implement milliseconds counter function",
    "output": "function Milliseconds: integer;\nbegin\n  curr_time := DateTime.Now;\n  Milliseconds := Convert.ToInt32((curr_time - StartTime).TotalMilliseconds);\nend;"
  },
  {
    "instruction": "Implement assertion procedure with message",
    "output": "procedure Assert(cond: boolean; message: string; sourceFile: string; line: integer);\nbegin\n  if (Environment.OSVersion.Platform = PlatformID.Unix) or (Environment.OSVersion.Platform = PlatformID.MacOSX) or IsWDE then\n  begin\n    if not IsWDE then\n      System.Diagnostics.Debug.Assert(cond, 'File ' + sourceFile + ', line ' + line.ToString() + ': ' + message)\n    else if not cond then\n    begin\n      var err := 'Assertion failure: ' + message + Environment.NewLine + 'File ' + sourceFile + ', line ' + line.ToString();\n      Writeln(err);\n      System.Threading.Thread.Sleep(500);\n      raise new Exception();\n    end;\n  end\n  else\n    System.Diagnostics.Contracts.Contract.Assert(cond,'File '+sourceFile+', line '+line.ToString() + ': ' + message)\nend;"
  },
  {
    "instruction": "Implement radians to degrees conversion function",
    "output": "function RadToDeg(x: real) := x * 180 / Pi;"
  },
  {
    "instruction": "Implement degrees to radians conversion function",
    "output": "function DegToRad(x: real) := x * Pi / 180;"
  },
  {
    "instruction": "Implement integer part extraction function",
    "output": "function Int(x: real) := x >= 0 ? Math.Floor(x) : Math.Ceiling(x);"
  },
  {
    "instruction": "Implement fractional part extraction function",
    "output": "function Frac(x: real) := x - Int(x);"
  },
  {
    "instruction": "Implement floor function for real numbers",
    "output": "function Floor(x: real) := Convert.ToInt32(Math.Floor(x));"
  },
  {
    "instruction": "Implement ceiling function for real numbers",
    "output": "function Ceil(x: real) := Convert.ToInt32(Math.Ceiling(x));"
  },
  {
    "instruction": "Implement hyperbolic sine function",
    "output": "function Sinh(x: real) := Math.Sinh(x);"
  },
  {
    "instruction": "Implement hyperbolic cosine function",
    "output": "function Cosh(x: real) := Math.Cosh(x);"
  },
  {
    "instruction": "Implement arc sine function",
    "output": "function ArcSin(x: real) := Math.Asin(x);"
  },
  {
    "instruction": "Implement arc cosine function",
    "output": "function ArcCos(x: real) := Math.Acos(x);"
  },
  {
    "instruction": "Implement arc tangent function",
    "output": "function ArcTan(x: real) := Math.Atan(x);"
  },
  {
    "instruction": "Implement base 10 logarithm function",
    "output": "function Log10(x: real) := Math.Log10(x);"
  },
  {
    "instruction": "Implement base 2 logarithm function",
    "output": "function Log2(x: real) := LogN(2, x);"
  },
  {
    "instruction": "Implement logarithm with custom base function",
    "output": "function LogN(base, x: real) := Math.Log(x) / Math.Log(base);"
  },
  {
    "instruction": "Implement square function for integers",
    "output": "function Sqr(x: integer): int64 := int64(x) * int64(x);"
  },
  {
    "instruction": "Implement square function for real numbers",
    "output": "function Sqr(x: real): real := x * x;"
  },
  {
    "instruction": "Implement sign function for integers",
    "output": "function Sign(x: integer): integer := Math.Sign(x);"
  },
  {
    "instruction": "Implement sign function for real numbers",
    "output": "function Sign(x: real): integer := Math.Sign(x);"
  },
  {
    "instruction": "Implement character to uppercase conversion",
    "output": "function UpperCase(ch: char): char;\nbegin\n  Result := char.ToUpper(ch);\nend;"
  },
  {
    "instruction": "Implement character to lowercase conversion",
    "output": "function LowerCase(ch: char): char;\nbegin\n  Result := char.ToLower(ch);\nend;"
  },
  {
    "instruction": "Implement character ordinal value function",
    "output": "function Ord(a: char): word;\nbegin\n  Result := word(a);\nend;"
  },
  {
    "instruction": "Implement character from code point function",
    "output": "function Chr(a: word): char;\nbegin\n  Result := Convert.ToChar(a);\nend;"
  },
  {
    "instruction": "Implement string insertion procedure",
    "output": "procedure Insert(subs: string; var s: string; index: integer);\nbegin\n  if index < 1 then \n    index := 1;\n  if index > s.Length + 1 then\n    index := s.Length + 1;\n  s := s.Insert(index - 1, subs);\nend;"
  },
  {
    "instruction": "Implement string deletion procedure",
    "output": "procedure Delete(var s: string; index, count: integer);\nbegin\n  if (index < 1) or (index > s.Length) or (count <= 0) then\n    Exit;\n  if index + count - 1 > s.Length then\n    count := s.Length - index + 1;\n  s := s.Remove(index - 1, count);\nend;"
  },
  {
    "instruction": "Implement string length function",
    "output": "function Length(s: string): integer;\nbegin\n  if s <> nil then \n    Result := s.Length\n  else Result := 0;\nend;"
  },
  {
    "instruction": "Implement string length setting procedure",
    "output": "procedure SetLength(var s: string; n: integer);\nbegin\n  if n < 0 then\n    raise new System.ArgumentOutOfRangeException('n');\n  if n = 0 then\n    s := String.Empty  \n  else if s.Length > n then\n    s := s.Substring(0, n)\n  else if s.Length < n then\n    s += new string(' ', n - s.Length);\nend;"
  },
  {
    "instruction": "Implement function to read sequence of integers from standard input",
    "output": "function ReadSeqInteger(n: integer): sequence of integer;\nbegin\n  Result := Range(1, n).Select(i -> ReadInteger());\nend;"
  },
  {
    "instruction": "Implement function to read sequence of real numbers from standard input",
    "output": "function ReadSeqReal(n: integer): sequence of real;\nbegin\n  Result := Range(1, n).Select(i -> ReadReal());\nend;"
  },
  {
    "instruction": "Implement function to read sequence of strings from standard input",
    "output": "function ReadSeqString(n: integer): sequence of string;\nbegin\n  Result := Range(1, n).Select(i -> ReadString());\nend;"
  },
  {
    "instruction": "Implement function to read sequence of integers with condition",
    "output": "function ReadSeqIntegerWhile(cond: integer->boolean): sequence of integer;\nbegin\n  while True do\n  begin\n    var x := ReadInteger();\n    if not cond(x) then\n      break;\n    yield x;  \n  end;\nend;"
  },
  {
    "instruction": "Implement function to read array of integers from standard input",
    "output": "function ReadArrInteger(n: integer): array of integer;\nbegin\n  Result := new integer[n];\n  for var i := 0 to Result.Length - 1 do\n    Result[i] := ReadInteger;\nend;"
  },
  {
    "instruction": "Implement function to read array of real numbers from standard input",
    "output": "function ReadArrReal(n: integer): array of real;\nbegin\n  Result := new real[n];\n  for var i := 0 to Result.Length - 1 do\n    Result[i] := ReadReal;\nend;"
  },
  {
    "instruction": "Implement function to read array of strings from standard input",
    "output": "function ReadArrString(n: integer): array of string;\nbegin\n  Result := new string[n];\n  for var i := 0 to Result.Length - 1 do\n    Result[i] := ReadString;\nend;"
  },
  {
    "instruction": "Implement sequence generator with index function",
    "output": "function SeqGen<T>(count: integer; f: integer->T): sequence of T;\nbegin\n  Result := Range(0, count - 1).Select(f)\nend;"
  },
  {
    "instruction": "Implement array generator with index function",
    "output": "function ArrGen<T>(count: integer; gen: integer->T): array of T;\nbegin\n  Result := new T[count];\n  for var i := 0 to Result.Length - 1 do\n    Result[i] := gen(i);\nend;"
  },
  {
    "instruction": "Implement sequence filled with repeated value",
    "output": "function SeqFill<T>(count: integer; x: T): sequence of T;\nbegin\n  Result := System.Linq.Enumerable.Repeat(x, count);\nend;"
  },
  {
    "instruction": "Implement try-read function for integer with message",
    "output": "function TryRead(var x: integer; message: string): boolean;\nbegin\n  Result := True;\n  try\n    if message<>'' then\n      Print(message);\n    Read(x)\n  except\n    Result := False;\n  end\nend;"
  },
  {
    "instruction": "Implement try-read function for real number with message",
    "output": "function TryRead(var x: real; message: string): boolean;\nbegin\n  Result := True;\n  try\n    if message<>'' then\n      Print(message);\n    Read(x)\n  except\n    Result := False;\n  end\nend;"
  },
  {
    "instruction": "Implement readln function for integer",
    "output": "function ReadlnInteger: integer;\nbegin\n  Result := ReadInteger;\n  Readln();\nend;"
  },
  {
    "instruction": "Implement readln function for real number",
    "output": "function ReadlnReal: real;\nbegin\n  Result := ReadReal;\n  Readln();\nend;"
  },
  {
    "instruction": "Implement readln function for string",
    "output": "function ReadlnString: string;\nbegin\n  Result := CurrentIOSystem.ReadLine;\nend;"
  },
  {
    "instruction": "Implement read function for text file integer",
    "output": "function ReadInteger(f: Text): integer;\nbegin\n  Read(f, Result);\nend;"
  },
  {
    "instruction": "Implement read function for text file real number",
    "output": "function ReadReal(f: Text): real;\nbegin\n  Read(f, Result);\nend;"
  },
  {
    "instruction": "Implement read function for text file string",
    "output": "function ReadString(f: Text): string;\nbegin\n  Read(f, Result);\n  Readln(f);\nend;"
  },
  {
    "instruction": "Implement text file assignment procedure",
    "output": "procedure Assign(f: Text; name: string);\nbegin\n  try\n    f.fi := System.IO.FileInfo.Create(name);\n  except\n    on e: Exception do\n      raise e;\n  end;\n  if f = output then\n    f.sw := new StreamWriter(f.fi.FullName);\n  if f = input then\n  begin  \n    f.sr := new StreamReader(f.fi.FullName, DefaultEncoding);\n    (CurrentIOSystem as IOStandardSystem).tr := f.sr;\n    (CurrentIOSystem as IOStandardSystem).realbuflen := -1;\n    _IsPipedRedirected := True;\n    _IsPipedRedirectedQuery := True;\n  end;  \nend;"
  },
  {
    "instruction": "Implement text file close procedure",
    "output": "procedure Close(f: Text);\nbegin\n  if f.fi = nil then\n    raise new IOException(GetTranslation(FILE_NOT_ASSIGNED));\n  if f.sr <> nil then \n  begin\n    f.sr.Close; \n    f.sr := nil; \n    f.sw := nil;\n  end\n  else if f.sw <> nil then \n  begin\n    f.sw.Close;\n    f.sr := nil;\n    f.sw := nil;\n  end\n  else raise new IOException(GetTranslation(FILE_NOT_OPENED));\nend;"
  },
  {
    "instruction": "Implement text file reset procedure",
    "output": "procedure Reset(f: Text);\nbegin\n  Reset(f, DefaultEncoding);\nend;"
  },
  {
    "instruction": "Implement text file rewrite procedure",
    "output": "procedure Rewrite(f: Text);\nbegin\n  Rewrite(f, DefaultEncoding)\nend;"
  },
  {
    "instruction": "Implement text file append procedure",
    "output": "procedure Append(f: Text);\nbegin\n  Append(f, DefaultEncoding);\nend;"
  },
  {
    "instruction": "Implement text file end-of-file check",
    "output": "function Eof(f: Text): boolean;\nbegin\n  if f = input then\n    Result := Eof\n  else if f.sr <> nil then\n    Result := f.sr.EndOfStream\n  else if f.sw <> nil then\n    raise new IOException(GetTranslation(EOF_FOR_TEXT_WRITEOPENED))\n  else raise new IOException(GetTranslation(FILE_NOT_OPENED));\nend;"
  },
  {
    "instruction": "Implement text file end-of-line check",
    "output": "function Eoln(f: Text): boolean;\nbegin\n  if f = input then\n    Result := Eoln\n  else if f.sr <> nil then\n    Result := f.sr.EndOfStream or (f.sr.Peek = 13) or (f.sr.Peek = 10) \n  else if f.sw <> nil then\n    raise new IOException(GetTranslation(EOLN_FOR_TEXT_WRITEOPENED))\n  else raise new IOException(GetTranslation(FILE_NOT_OPENED));\nend;"
  },
  {
    "instruction": "Implement binary file write procedure",
    "output": "procedure Write(f: AbstractBinaryFile; params vals: array of object);\nbegin\n  if f.fi = nil then raise new System.IO.IOException(GetTranslation(FILE_NOT_ASSIGNED));\n  if f.fs = nil then raise new System.IO.IOException(GetTranslation(FILE_NOT_OPENED));\n  for var i := 0 to vals.Length - 1 do\n  begin\n    var NullBasedArray := GetNullBasedArray(vals[i]);\n    var ind := 0;\n    Write(f, vals[i], NullBasedArray <> nil, ind, false);\n  end;\nend;"
  },
  {
    "instruction": "Implement binary file position function",
    "output": "function FilePos(f: BinaryFile): int64;\nbegin\n  if f.fi = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_ASSIGNED));\n  if f.fs = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_OPENED));\n  Result := f.fs.Position;\nend;"
  },
  {
    "instruction": "Implement binary file size function",
    "output": "function FileSize(f: BinaryFile): int64;\nbegin\n  if f.fi = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_ASSIGNED));\n  if f.fs = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_OPENED));\n  Result := f.fs.Length;\nend;"
  },
  {
    "instruction": "Implement binary file seek procedure",
    "output": "procedure Seek(f: BinaryFile; n: int64);\nbegin\n  if f.fi = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_ASSIGNED));\n  if f.fs = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_OPENED));\n  f.fs.Position := n;\nend;"
  },
  {
    "instruction": "Implement typed file position function",
    "output": "function FilePos(f: TypedFile): int64;\nbegin\n  if f.fi = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_ASSIGNED));\n  if f.fs = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_OPENED));\n  Result := f.fs.Position div f.ElementSize;\nend;"
  },
  {
    "instruction": "Implement typed file size function",
    "output": "function FileSize(f: TypedFile): int64;\nbegin\n  if f.fi = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_ASSIGNED));\n  if f.fs = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_OPENED));\n  if f.fs.Length mod f.ElementSize <> 0 then\n    raise new System.IO.IOException('Bad typed file size');\n  Result := f.fs.Length div f.ElementSize;\nend;"
  },
  {
    "instruction": "Implement typed file seek procedure",
    "output": "procedure Seek(f: TypedFile; n: int64);\nbegin\n  if f.fi = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_ASSIGNED));\n  if f.fs = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_OPENED));\n  f.fs.Position := n * f.ElementSize\nend;"
  },
  {
    "instruction": "Implement disk free space function",
    "output": "function DiskFree(diskname: string): int64;\nbegin\n  try\n    var d := new System.IO.DriveInfo(diskname);\n    Result := d.TotalFreeSpace;\n  except\n    Result := -1;\n  end;\nend;"
  },
  {
    "instruction": "Implement disk size function",
    "output": "function DiskSize(diskname: string): int64;\nbegin\n  try\n    var d := new System.IO.DriveInfo(diskname);\n    Result := d.TotalSize;\n  except\n    Result := -1;\n  end;\nend;"
  },
  {
    "instruction": "Implement process execution procedure",
    "output": "procedure Exec(filename: string);\nbegin\n  System.Diagnostics.Process.Start(filename)\nend;"
  },
  {
    "instruction": "Implement process execution with arguments procedure",
    "output": "procedure Exec(filename: string; args: string);\nbegin\n  System.Diagnostics.Process.Start(filename, args)\nend;"
  },
  {
    "instruction": "Implement file enumeration function",
    "output": "function EnumerateFiles(path: string; searchPattern: string): sequence of string;\nbegin\n  Result := System.IO.Directory.EnumerateFiles(path, searchPattern, System.IO.SearchOption.TopDirectoryOnly)\nend;"
  },
  {
    "instruction": "Implement recursive file enumeration function",
    "output": "function EnumerateAllFiles(path: string; searchPattern: string): sequence of string;\nbegin\n  Result := System.IO.Directory.EnumerateFiles(path, searchPattern, System.IO.SearchOption.AllDirectories)\nend;"
  },
  {
    "instruction": "Implement directory enumeration function",
    "output": "function EnumerateDirectories(path: string): sequence of string;\nbegin\n  Result := System.IO.Directory.EnumerateDirectories(path, '*.*', System.IO.SearchOption.TopDirectoryOnly)\nend;"
  },
  {
    "instruction": "Implement recursive directory enumeration function",
    "output": "function EnumerateAllDirectories(path: string): sequence of string;\nbegin\n  Result := System.IO.Directory.EnumerateDirectories(path, '*.*', System.IO.SearchOption.AllDirectories)\nend;"
  },
  {
    "instruction": "Implement string validation procedure",
    "output": "procedure Val(s: string; var value: integer; var err: integer);\nbegin\n  if TryStrToInt(s, value) then\n    err := 0\n  else err := 1;  \nend;"
  },
  {
    "instruction": "Implement real number validation procedure",
    "output": "procedure Val(s: string; var value: real; var err: integer);\nbegin\n  if TryStrToFloat(s, value) then\n    err := 0\n  else err := 1;  \nend;"
  },
  {
    "instruction": "Implement try string to integer conversion function",
    "output": "function TryStrToInt(s: string; var value: integer): boolean;\nbegin\n  Result := True;\n  var Res := 0;\n  var j := 1;\n  while (j <= s.Length) and char.IsWhiteSpace(s[j]) do\n    j += 1;\n  if (j > s.Length) then \n  begin\n    Result := False;\n    exit\n  end;  \n  var sign := 0;  \n  if s[j] = '-' then\n  begin\n    sign := -1;\n    j += 1;\n  end  \n  else if s[j] = '+' then\n  begin\n    sign := 1;\n    j += 1;\n  end;\n  if (j > s.Length) then \n  begin\n    Result := False;\n    exit\n  end;  \n  var c := integer(s[j]);\n  if (c < 48) or (c > 57) then\n  begin\n    Result := False;\n    exit\n  end;  \n  Res := c - 48;\n  j += 1;  \n  while j <= s.Length do\n  begin\n    c := integer(s[j]);\n    if c > 57 then\n      break;\n    if c < 48 then\n      break;\n  if Res > 214748364 then\n    begin\n      Result := False;\n      exit\n    end;  \n    Res := Res * 10 + (c - 48);\n    j += 1;\n  end;\n  if Res < 0 then \n    if (Res = -2147483648) and (sign = -1) then\n      exit\n    else \n    begin\n      Result := False;\n      exit\n    end;  \n  if sign = -1 then\n    Res := -Res;\n  while (j <= s.Length) and char.IsWhiteSpace(s[j]) do\n    j += 1;\n  if j <= s.Length then  \n  begin\n    Result := False;\n    exit\n  end;  \n  value := Res;\nend;"
  },
  {
    "instruction": "Implement try string to real conversion function",
    "output": "function TryStrToReal(s: string; var value: real) := real.TryParse(s,System.Globalization.NumberStyles.Float,new System.Globalization.NumberFormatInfo,value);"
  },
  {
    "instruction": "Implement complex number exponential function",
    "output": "function Exp(c: Complex) := Complex.Exp(c);"
  },
  {
    "instruction": "Implement complex number logarithm function",
    "output": "function Log(c: Complex) := Complex.Log(c);"
  },
  {
    "instruction": "Implement complex number power function",
    "output": "function Power(c, power: Complex) := Complex.Pow(c, power);"
  },
  {
    "instruction": "Implement complex number sine function",
    "output": "function Sin(c: Complex) := Complex.Sin(c);"
  },
  {
    "instruction": "Implement complex number cosine function",
    "output": "function Cos(c: Complex) := Complex.Cos(c);"
  },
  {
    "instruction": "Implement complex number conjugate function",
    "output": "function Conjugate(c: Complex) := Complex.Conjugate(c);"
  },
  {
    "instruction": "Implement complex number from polar coordinates function",
    "output": "function CplxFromPolar(magnitude, phase: real) := Complex.FromPolarCoordinates(magnitude, phase);"
  },
  {
    "instruction": "Implement list sorting procedure",
    "output": "procedure Sort<T>(l: List<T>);\nbegin\n  l.Sort();\nend;"
  },
  {
    "instruction": "Implement list sorting with comparison function",
    "output": "procedure Sort<T>(l: List<T>; cmp: (T,T)->integer);\nbegin\n  l.Sort(cmp);\nend;"
  },
  {
    "instruction": "Implement list reversal procedure",
    "output": "procedure Reverse<T>(a: List<T>);\nbegin\n  a.Reverse\nend;"
  },
  {
    "instruction": "Implement list shuffling procedure",
    "output": "procedure Shuffle<T>(l: List<T>);\nbegin\n  var n := l.Count;\n  for var i := 0 to n - 1 do\n  begin\n    var v := l[i];\n    l[i] := l[Random(n)];\n    l[Random(n)] := v;\n  end;\nend;"
  },
  {
    "instruction": "Implement array copy function",
    "output": "function Copy(a: &Array): &Array;\nbegin\n  Result := &Array(a.Clone());\nend;"
  },
  {
    "instruction": "Implement print procedure for multiple objects",
    "output": "procedure Print(params args: array of object);\nbegin\n  if args.Length = 0 then\n    exit;\n  if PrintDelimDefault<>'' then\n    for var i := 0 to args.length - 1 do\n      Write(args[i], PrintDelimDefault)\n  else     \n    for var i := 0 to args.length - 1 do\n      Write(args[i])\nend;"
  },
  {
    "instruction": "Implement println procedure for multiple objects",
    "output": "procedure Println(params args: array of object);\nbegin\n  Print(args);\n  Writeln;\nend;"
  },
  {
    "instruction": "Implement formatted write procedure",
    "output": "procedure WriteFormat(formatstr: string; params args: array of object);\nbegin\n  var s := Format(formatstr, args);\n  write(s);\nend;"
  },
  {
    "instruction": "Implement formatted writeln procedure",
    "output": "procedure WritelnFormat(formatstr: string; params args: array of object);\nbegin\n  var s := Format(formatstr, args);\n  writeln(s);\nend;"
  },
  {
    "instruction": "Implement object serialization procedure",
    "output": "procedure Serialize(filename: string; obj: object);\nbegin\n  var fs := new System.IO.FileStream(filename,System.IO.FileMode.Create);\n  var formatter := new BinaryFormatter;\n  formatter.Serialize(fs,obj);\n  fs.Close;\nend;"
  },
  {
    "instruction": "Implement object deserialization function",
    "output": "function Deserialize(filename: string): object;\nbegin\n  var fs := new System.IO.FileStream(filename,System.IO.FileMode.Open);\n  var formatter := new BinaryFormatter;\n  Result := formatter.Deserialize(fs);\n  fs.Close;\nend;"
  },
  {
    "instruction": "Implement binary file read bytes function",
    "output": "function BinaryFile.ReadBytes(count: integer): array of byte;\nbegin\n  InternalCheck;\n  Result := Self.br.ReadBytes(count)\nend;"
  },
  {
    "instruction": "Implement binary file write bytes procedure",
    "output": "procedure BinaryFile.WriteBytes(a: array of byte);\nbegin\n  InternalCheck;\n  Self.bw.Write(a);\nend;"
  },
  {
    "instruction": "Implement binary file read integer function",
    "output": "function BinaryFile.ReadInteger: integer;\nbegin\n  InternalCheck;\n  Result := Self.br.ReadInt32;  \nend;"
  },
  {
    "instruction": "Implement binary file read real number function",
    "output": "function BinaryFile.ReadReal: real;\nbegin\n  InternalCheck;\n  Result := Self.br.ReadDouble;  \nend;"
  },
  {
    "instruction": "Implement binary file read string function",
    "output": "function BinaryFile.ReadString: string;\nbegin\n  InternalCheck;\n  Result := Self.br.ReadString;  \nend;"
  },
  {
    "instruction": "Implement binary file serialize procedure",
    "output": "procedure BinaryFile.Serialize(obj: object);\nbegin\n  var formatter := new BinaryFormatter;\n  formatter.Serialize(fs,obj);\nend;"
  },
  {
    "instruction": "Implement binary file deserialize function",
    "output": "function BinaryFile.Deserialize: object;\nbegin\n  var formatter := new BinaryFormatter;\n  Result := formatter.Deserialize(fs);\nend;"
  },
  {
    "instruction": "Implement function to read short string from input",
    "output": "procedure ReadShortString(var s: string; n: integer);\nbegin\n  var sb := new System.Text.StringBuilder;\n  var c := char(CurrentIOSystem.peek());\n  var i := 0;\n  while (c <> #13) and (c <> #10) and (i < n) do \n  begin\n    c := CurrentIOSystem.read_symbol;\n    i += 1;\n    sb.Append(c);\n    c := char(CurrentIOSystem.peek());\n  end;\n  s := sb.ToString;\nend;"
  },
  {
    "instruction": "Implement function to check if input is at end of line",
    "output": "function Eoln: boolean;\nbegin\n  if not console_alloc then\n    AllocConsole;\n  var next := CurrentIOSystem.peek;\n  Result := (next = -1) or (next = 13) or (next = 10);\nend;"
  },
  {
    "instruction": "Implement function to check if input is at end of file",
    "output": "function Eof: boolean;\nbegin\n  if not console_alloc then\n    AllocConsole;\n  Result := CurrentIOSystem.peek = -1\nend;"
  },
  {
    "instruction": "Implement function to seek to end of file in input",
    "output": "function SeekEof: boolean;\nbegin\n  repeat\n    if Eof then\n      break;\n    var i := CurrentIOSystem.peek;\n    if not char.IsWhiteSpace(char(i)) then\n      break;\n    CurrentIOSystem.read_symbol\n  until False;  \n  Result := Eof;\nend;"
  },
  {
    "instruction": "Implement function to seek to end of line in input",
    "output": "function SeekEoln: boolean;\nbegin\n  repeat\n    if Eoln then\n      break;\n    var i := CurrentIOSystem.peek;\n    if (i <> 32) and (i <> 9) then\n      break;\n    CurrentIOSystem.read_symbol;\n  until False;\n  var next := CurrentIOSystem.peek;\n  Result := (next = -1) or (next = 13) or (next = 10);\nend;"
  },
  {
    "instruction": "Implement function to get command line arguments",
    "output": "function CommandLineArgs: array of string;\nbegin\n  Result := _CommandLineArgs;\n  if Result = nil then\n  begin\n    var arg := Environment.GetCommandLineArgs();\n    if arg.Length > 1 then begin\n      _CommandLineArgs := new string[arg.Length - 1];\n      for var i := 1 to arg.Length - 1 do\n        _CommandLineArgs[i - 1] := arg[i];\n    end else\n      _CommandLineArgs := new string[0];\n    Result := _CommandLineArgs;\n  end;\nend;"
  },
  {
    "instruction": "Implement function to get PascalABC version",
    "output": "function PascalABCVersion: string;\nbegin\n  Result := '3.2.0.1364';\nend;"
  },
  {
    "instruction": "Implement function to get executable file name",
    "output": "function GetEXEFileName: string;\nbegin\n  Result := System.Reflection.Assembly.GetEntryAssembly().ManifestModule.FullyQualifiedName;\nend;"
  },
  {
    "instruction": "Implement function to convert pointer to string",
    "output": "function PointerToString(p: pointer): string;\nbegin\n  if p = nil then\n    result := 'nil'\n  else if Environment.Is64BitProcess then \n    result := '$' + int64(p).ToString('X')\n  else\n    result := '$' + integer(p).ToString('X')\nend;"
  },
  {
    "instruction": "Implement procedure to swap two values",
    "output": "procedure Swap<T>(var a, b: T);\nbegin\n  var v := a;\n  a := b;\n  b := v;\nend;"
  },
  {
    "instruction": "Implement function to read integer from string with position tracking",
    "output": "function ReadIntegerFromString(s: string; var from: integer): integer;\nbegin\n  while (from <= s.Length) and char.IsWhiteSpace(s[from]) do\n    from += 1;\n  if (from > s.Length) then \n    raise new System.FormatException(ErrorStringFromResource('Format_InvalidString'));\n  var sign := 0;  \n  if s[from] = '-' then\n  begin\n    sign := -1;\n    from += 1;\n  end  \n  else if s[from] = '+' then\n  begin\n    sign := 1;\n    from += 1;\n  end;\n  if (from > s.Length) then \n    raise new System.FormatException(ErrorStringFromResource('Format_InvalidString'));\n  var c := integer(s[from]);\n  if (c < 48) or (c > 57) then\n    raise new System.FormatException(ErrorStringFromResource('Format_InvalidString'));\n  Result := c - 48;\n  from += 1;  \n  while from <= s.Length do\n  begin\n    c := integer(s[from]);\n    if c > 57 then\n      break;\n    if c < 48 then\n      break;\n    if Result > 214748364 then\n      raise new System.OverflowException(ErrorStringFromResource('Overflow_Int32'));\n    Result := Result * 10 + (c - 48);\n    from += 1;\n  end;\n  if Result < 0 then \n    if (Result = -2147483648) and (sign = -1) then\n      exit\n    else raise new System.OverflowException(ErrorStringFromResource('Overflow_Int32'));\n  if sign = -1 then\n    Result := -Result;\nend;"
  },
  {
    "instruction": "Implement function to read word from string with position tracking",
    "output": "function ReadWordFromString(s: string; var from: integer): string;\nbegin\n  while (from <= s.Length) and char.IsWhiteSpace(s[from]) do\n    from += 1;\n  var res := new System.Text.StringBuilder();\n  while (from <= s.Length) and not char.IsWhiteSpace(s[from]) do\n  begin\n    res.Append(s[from]);\n    from += 1;\n  end;  \n  Result := res.ToString;\nend;"
  },
  {
    "instruction": "Implement function to check if string is empty from given position",
    "output": "function StringIsEmpty(s: string; var from: integer): boolean;\nbegin\n  while (from <= s.Length) and char.IsWhiteSpace(s[from]) do\n    from += 1;\n  Result := from > s.Length;\nend;"
  },
  {
    "instruction": "Implement function to read real number from string with position tracking",
    "output": "function ReadRealFromString(s: string; var from: integer): real;\nbegin\n  Result := real.Parse(ReadWordFromString(s, from));  \nend;"
  },
  {
    "instruction": "Implement function to try read real number from string with position tracking",
    "output": "function TryReadRealFromString(s: string; var from: integer; var res: real): boolean;\nbegin\n  Result := real.TryParse(ReadWordFromString(s, from), res);\nend;"
  },
  {
    "instruction": "Implement function to try read integer from string with position tracking",
    "output": "function TryReadIntegerFromString(s: string; var from: integer; var res: integer): boolean;\nbegin\n  Result := TryStrToInt(ReadWordFromString(s, from), res);\nend;"
  },
  {
    "instruction": "Implement procedure for increment with step for integer",
    "output": "procedure Inc(var i: integer; n: integer);\nbegin\n  i += n;\nend;"
  },
  {
    "instruction": "Implement procedure for decrement with step for integer",
    "output": "procedure Dec(var i: integer; n: integer);\nbegin\n  i -= n;\nend;"
  },
  {
    "instruction": "Implement procedure for increment with step for character",
    "output": "procedure Inc(var c: char; n: integer);\nbegin\n  c := ChrUnicode(word(c) + n);\nend;"
  },
  {
    "instruction": "Implement procedure for decrement with step for character",
    "output": "procedure Dec(var c: char; n: integer);\nbegin\n  c := ChrUnicode(word(c) - n);\nend;"
  },
  {
    "instruction": "Implement procedure for increment with step for byte",
    "output": "procedure Inc(var b: byte; n: integer);\nbegin\n  b += n;\nend;"
  },
  {
    "instruction": "Implement procedure for decrement with step for byte",
    "output": "procedure Dec(var b: byte; n: integer);\nbegin\n  b -= n;\nend;"
  },
  {
    "instruction": "Implement function for successor with step for character",
    "output": "function Succ(x: char; n: integer): char;\nbegin\n  Result := char(integer(x)+n);\nend;"
  },
  {
    "instruction": "Implement function to generate random pair of integers",
    "output": "function Random2(a, b: integer) := (Random(a, b), Random(a, b));"
  },
  {
    "instruction": "Implement function to generate random pair of real numbers",
    "output": "function Random2(a, b: real) := (Random(a, b), Random(a, b));"
  },
  {
    "instruction": "Implement function to generate random triple of integers",
    "output": "function Random3(a, b: integer) := (Random(a, b), Random(a, b), Random(a, b));"
  },
  {
    "instruction": "Implement function to generate random triple of real numbers",
    "output": "function Random3(a, b: real) := (Random(a, b), Random(a, b), Random(a, b));"
  },
  {
    "instruction": "Implement function for maximum of three integers",
    "output": "function Max(a, b, c: integer): integer;\nbegin\n  Result := a;\n  if b > Result then Result := b;\n  if c > Result then Result := c;\nend;"
  },
  {
    "instruction": "Implement function for maximum of four integers",
    "output": "function Max(a, b, c, d: integer): integer;\nbegin\n  Result := a;\n  if b > Result then Result := b;\n  if c > Result then Result := c;\n  if d > Result then Result := d;\nend;"
  },
  {
    "instruction": "Implement function for minimum of three integers",
    "output": "function Min(a, b, c: integer): integer;\nbegin\n  Result := a;\n  if b < Result then Result := b;\n  if c < Result then Result := c;\nend;"
  },
  {
    "instruction": "Implement function for minimum of four integers",
    "output": "function Min(a, b, c, d: integer): integer;\nbegin\n  Result := a;\n  if b < Result then Result := b;\n  if c < Result then Result := c;\n  if d < Result then Result := d;\nend;"
  },
  {
    "instruction": "Implement function for maximum of array of integers",
    "output": "function Max(params a: array of integer): integer := a.Max;"
  },
  {
    "instruction": "Implement function for minimum of array of integers",
    "output": "function Min(params a: array of integer): integer := a.Min;"
  },
  {
    "instruction": "Implement function for maximum of generic array",
    "output": "function Max<T>(params a: array of T): T := a.Max;"
  },
  {
    "instruction": "Implement function for minimum of generic array",
    "output": "function Min<T>(params a: array of T): T := a.Min;"
  },
  {
    "instruction": "Implement function to convert ANSI character to byte",
    "output": "function OrdAnsi(a: char): byte;\nbegin\n  if a < #128 then\n    Result := byte(a)\n  else\n  begin\n    Result := Encoding.GetEncoding(1251).GetBytes(new char[1](a))[0];\n  end;\nend;"
  },
  {
    "instruction": "Implement function to convert byte to ANSI character",
    "output": "function ChrAnsi(a: Byte): char;\nbegin\n  if a < 128 then\n    Result := char(a)\n  else\n  begin\n    Result := Encoding.GetEncoding(1251).GetChars(new byte[1](a))[0];\n  end;\nend;"
  },
  {
    "instruction": "Implement function to convert character to Unicode code point",
    "output": "function OrdUnicode(a: char): word;\nbegin\n  Result := word(a);\nend;"
  },
  {
    "instruction": "Implement function to create character from Unicode code point",
    "output": "function ChrUnicode(a: word): char;\nbegin\n  Result := Convert.ToChar(a);\nend;"
  },
  {
    "instruction": "Implement procedure to toggle boolean value",
    "output": "procedure Inc(var f: boolean);\nbegin\n  f := not f;\nend;"
  },
  {
    "instruction": "Implement procedure to toggle boolean value using Dec",
    "output": "procedure Dec(var f: boolean);\nbegin\n  f := not f;\nend;"
  },
  {
    "instruction": "Implement function for successor of boolean",
    "output": "function Succ(x: boolean): boolean;\nbegin\n  Result := not x;\nend;"
  },
  {
    "instruction": "Implement function to read integer with prompt",
    "output": "function ReadInteger(prompt: string): integer;\nbegin\n  Print(prompt);\n  Result := ReadInteger;\nend;"
  },
  {
    "instruction": "Implement function to read real number with prompt",
    "output": "function ReadReal(prompt: string): real;\nbegin\n  Print(prompt);\n  Result := ReadReal;\nend;"
  },
  {
    "instruction": "Implement function to read string with prompt",
    "output": "function ReadString(prompt: string): string;\nbegin\n  Print(prompt);\n  Result := ReadString;\nend;"
  },
  {
    "instruction": "Implement function to read array of integers with prompt",
    "output": "function ReadArrInteger(prompt: string; n: integer): array of integer;\nbegin\n  Print(prompt);\n  Result := ReadArrInteger(n);\nend;"
  },
  {
    "instruction": "Implement function to read array of real numbers with prompt",
    "output": "function ReadArrReal(prompt: string; n: integer): array of real;\nbegin\n  Print(prompt);\n  Result := ReadArrReal(n);\nend;"
  },
  {
    "instruction": "Implement function to read array of strings with prompt",
    "output": "function ReadArrString(prompt: string; n: integer): array of string;\nbegin\n  Print(prompt);\n  Result := ReadArrString(n);\nend;"
  },
  {
    "instruction": "Implement function to read sequence of integers with prompt",
    "output": "function ReadSeqInteger(prompt: string; n: integer): sequence of integer;\nbegin\n  Print(prompt);\n  Result := ReadSeqInteger(n);\nend;"
  },
  {
    "instruction": "Implement function to read sequence of real numbers with prompt",
    "output": "function ReadSeqReal(prompt: string; n: integer): sequence of real;\nbegin\n  Print(prompt);\n  Result := ReadSeqReal(n);\nend;"
  },
  {
    "instruction": "Implement function to read sequence of strings with prompt",
    "output": "function ReadSeqString(prompt: string; n: integer): sequence of string;\nbegin\n  Print(prompt);\n  Result := ReadSeqString(n);\nend;"
  },
  {
    "instruction": "Implement text file write procedure for object",
    "output": "procedure Write(f: Text; val: object);\nbegin\n  if f.fi = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_ASSIGNED));\n  if f.sw = nil then \n    raise new System.IO.IOException(GetTranslation(FILE_NOT_OPENED_FOR_WRITING));\n  f.sw.Write(StructuredObjectToString(val));\nend;"
  },
  {
    "instruction": "Implement text file writeln procedure for object",
    "output": "procedure Writeln(f: Text; val: object);\nbegin\n  write(f, val);\n  writeln(f);\nend;"
  },
  {
    "instruction": "Implement text file print procedure for multiple objects",
    "output": "procedure Text.Print(params o: array of Object);\nbegin\n  if PrintDelimDefault<>'' then\n    foreach var s in o do\n      PABCSystem.Write(Self, s, PrintDelimDefault)\n  else    \n    foreach var s in o do\n      PABCSystem.Write(Self, s)\nend;"
  },
  {
    "instruction": "Implement text file println procedure for multiple objects",
    "output": "procedure Text.Println(params o: array of Object);\nbegin\n  if o.Length <> 0 then\n  begin\n    if PrintDelimDefault<>'' then\n      for var i:=0 to o.Length-2 do\n        PABCSystem.Write(Self, o[i], PrintDelimDefault)\n    else    \n      for var i:=0 to o.Length-2 do\n        PABCSystem.Write(Self, o[i]);\n    PABCSystem.Write(Self, o.Last);\n  end;\n  PABCSystem.Writeln(Self);\nend;"
  },
  {
    "instruction": "Implement text file lines property as sequence",
    "output": "function Text.Lines: sequence of string;\nbegin\n  Self.sr.BaseStream.Position := 0;\n  while not Eof do\n    yield ReadlnString;\nend;"
  },
  {
    "instruction": "Implement binary file reset procedure with encoding",
    "output": "procedure Reset(f: AbstractBinaryFile; en: Encoding);\nbegin\n  if f.fi = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_ASSIGNED));\n  if (f is TypedFile) and not en.IsSingleByte then\n    raise new System.IO.IOException(GetTranslation(TYPED_FILE_CANBE_OPENED_IN_SINGLEBYTE_ENCODING_ONLY));\n  if f.fs = nil then \n  begin\n    f.fs := new FileStream(f.fi.FullName, FileMode.Open);\n    f.br := new BinaryReader(f.fs, en);\n    f.bw := new BinaryWriter(f.fs, en);\n  end \n  else\n    f.fs.Position := 0;\nend;"
  },
  {
    "instruction": "Implement binary file rewrite procedure with encoding",
    "output": "procedure Rewrite(f: AbstractBinaryFile; en: Encoding);\nbegin\n  if f.fi = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_ASSIGNED));\n  if (f is TypedFile) and not en.IsSingleByte then\n    raise new System.IO.IOException(GetTranslation(TYPED_FILE_CANBE_OPENED_IN_SINGLEBYTE_ENCODING_ONLY));\n  if f.fs = nil then\n  begin\n    f.fs := new FileStream(f.fi.FullName, FileMode.Create);\n    f.bw := new BinaryWriter(f.fs, en);\n    f.br := new BinaryReader(f.fs, en);\n  end\n  else \n  begin\n    f.fs.Position := 0;\n    Truncate(f);\n  end;  \nend;"
  },
  {
    "instruction": "Implement binary file truncate procedure",
    "output": "procedure Truncate(f: AbstractBinaryFile);\nbegin\n  if f.fi = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_ASSIGNED));\n  if f.fs = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_OPENED));\n  f.fs.SetLength(f.fs.Position);\nend;"
  },
  {
    "instruction": "Implement function to read boolean from text file",
    "output": "function ReadBoolean(f: Text): boolean;\nbegin\n  Read(f, Result);\nend;"
  },
  {
    "instruction": "Implement function to read integer from text file with newline",
    "output": "function ReadlnInteger(f: Text): integer;\nbegin\n  Result := ReadInteger(f);\n  Readln(f);\nend;"
  },
  {
    "instruction": "Implement function to read real number from text file with newline",
    "output": "function ReadlnReal(f: Text): real;\nbegin\n  Result := ReadReal(f);\n  Readln(f);\nend;"
  },
  {
    "instruction": "Implement function to read character from text file with newline",
    "output": "function ReadlnChar(f: Text): char;\nbegin\n  Result := ReadChar(f);\n  Readln(f);\nend;"
  },
  {
    "instruction": "Implement function to read string from text file with newline",
    "output": "function ReadlnString(f: Text): string;\nbegin\n  Result := ReadString(f);\nend;"
  },
  {
    "instruction": "Implement function to read boolean from text file with newline",
    "output": "function ReadlnBoolean(f: Text): boolean;\nbegin\n  Result := ReadBoolean(f);\n  Readln(f);\nend;"
  },
  {
    "instruction": "Implement function to read lexem from text file",
    "output": "function ReadLexem(f: Text): string;\nbegin\n  if f = input then\n  begin  \n    Result := ReadLexem;\n    exit\n  end;\n  if f.fi = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_ASSIGNED));\n  if f.sr = nil then \n    raise new System.IO.IOException(GetTranslation(FILE_NOT_OPENED_FOR_READING));\n  var i: integer;\n  repeat\n    i := f.sr.Read();\n  until not char.IsWhiteSpace(char(i)); // pass spaces\n  if i=-1 then \n    raise new System.IO.IOException(GetTranslation(READ_LEXEM_AFTER_END_OF_TEXT_FILE));\n  var c := char(i);\n  var sb := System.Text.StringBuilder.Create;\n  repeat\n    sb.Append(c);\n    i := f.sr.Peek();\n    if i = -1 then\n      break;\n    c := char(i);\n    if char.IsWhiteSpace(c) then\n      break;\n    f.sr.Read();\n  until False; // accumulate nonspaces\n  Result := sb.ToString;\nend;"
  },
  {
    "instruction": "Implement procedure to read from text file without parameters",
    "output": "procedure read(f: Text);\nbegin\nend;"
  },
  {
    "instruction": "Implement procedure to read integer from text file",
    "output": "procedure read(f: Text; var x: integer);\nbegin\n  try\n    x := Convert.ToInt32(ReadLexem(f));\n  except\n    on e: Exception do\n      raise e;\n  end;\nend;"
  },
  {
    "instruction": "Implement procedure to read real number from text file",
    "output": "procedure read(f: Text; var x: real);\nbegin\n  try\n    x := Convert.ToDouble(ReadLexem(f), nfi);\n  except\n    on e: Exception do\n      raise e;\n  end;\nend;"
  },
  {
    "instruction": "Implement procedure to read character from text file",
    "output": "procedure read(f: Text; var x: char);\nbegin\n  if f.fi = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_ASSIGNED));\n  if f.sr = nil then \n    raise new System.IO.IOException(GetTranslation(FILE_NOT_OPENED_FOR_READING));\n  try\n    x := Convert.ToChar(f.sr.Read());\n  except\n    on e: Exception do\n      raise e;\n  end;\nend;"
  },
  {
    "instruction": "Implement procedure to read string from text file",
    "output": "procedure read(f: Text; var x: string);\nbegin\n  if f.fi = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_ASSIGNED));\n  if f.sr = nil then \n    raise new System.IO.IOException(GetTranslation(FILE_NOT_OPENED_FOR_READING));\n  \n  var s := new System.Text.StringBuilder;\n  repeat\n    if f.sr.EndOfStream then\n      break;\n    if f.sr.Peek = 13 then\n      break;\n    if f.sr.Peek = 10 then\n      break;\n    s.Append(Convert.ToChar(f.sr.Read));\n  until False;\n  x := s.ToString; {}\n  if x = nil then \n    x := string.Empty; \nend;"
  },
  {
    "instruction": "Implement procedure to read byte from text file",
    "output": "procedure read(f: Text; var x: byte);\nbegin\n  try\n    x := Convert.ToByte(ReadLexem(f));\n  except\n    on e: Exception do\n      raise e;\n  end;\nend;"
  },
  {
    "instruction": "Implement procedure to read shortint from text file",
    "output": "procedure read(f: Text; var x: shortint);\nbegin\n  try\n    x := Convert.ToSByte(ReadLexem(f));\n  except\n    on e: Exception do\n      raise e;\n  end;\nend;"
  },
  {
    "instruction": "Implement procedure to read smallint from text file",
    "output": "procedure read(f: Text; var x: smallint);\nbegin\n  try\n    x := Convert.ToInt16(ReadLexem(f));\n  except\n    on e: Exception do\n      raise e;\n  end;\nend;"
  },
  {
    "instruction": "Implement procedure to read word from text file",
    "output": "procedure read(f: Text; var x: word);\nbegin\n  try\n    x := Convert.ToUInt16(ReadLexem(f));\n  except\n    on e: Exception do\n      raise e;\n  end;\nend;"
  },
  {
    "instruction": "Implement procedure to read longword from text file",
    "output": "procedure read(f: Text; var x: longword);\nbegin\n  try\n    x := Convert.ToUInt32(ReadLexem(f));\n  except\n    on e: Exception do\n      raise e;\n  end;\nend;"
  },
  {
    "instruction": "Implement procedure to read int64 from text file",
    "output": "procedure read(f: Text; var x: int64);\nbegin\n  try\n    x := Convert.ToInt64(ReadLexem(f));\n  except\n    on e: Exception do\n      raise e;\n  end;\nend;"
  },
  {
    "instruction": "Implement procedure to read uint64 from text file",
    "output": "procedure read(f: Text; var x: uint64);\nbegin\n  try\n    x := Convert.ToUInt64(ReadLexem(f));\n  except\n    on e: Exception do\n      raise e;\n  end;\nend;"
  },
  {
    "instruction": "Implement procedure to read single from text file",
    "output": "procedure read(f: Text; var x: single);\nbegin\n  try\n    x := Convert.ToSingle(ReadLexem(f));\n  except\n    on e: Exception do\n      raise e;\n  end;\nend;"
  },
  {
    "instruction": "Implement procedure to read boolean from text file",
    "output": "procedure read(f: Text; var x: boolean);\nbegin\n  var s := ReadLexem(f).ToLower;\n  if s = 'true' then\n    x := True\n  else if s = 'false' then\n    x := False  \n  else raise new System.FormatException('Input string had incorrect format');\nend;"
  },
  {
    "instruction": "Implement procedure to read string with newline from text file",
    "output": "procedure readln(f: Text; var x: string);\nbegin\n  if f.fi = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_ASSIGNED));\n  if f.sr = nil then \n    raise new System.IO.IOException(GetTranslation(FILE_NOT_OPENED_FOR_READING));\n  \n  x := f.sr.ReadLine;\n  if x = nil then\n    x := '';\nend;"
  },
  {
    "instruction": "Implement procedure to read newline from text file",
    "output": "procedure readln(f: Text);\nbegin\n  if f.fi = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_ASSIGNED));\n  if f.sr = nil then \n    raise new System.IO.IOException(GetTranslation(FILE_NOT_OPENED_FOR_READING));\n  f.sr.ReadLine;\nend;"
  },
  {
    "instruction": "Implement procedure to write to text file without parameters",
    "output": "procedure Write(f: Text);\nbegin\nend;"
  },
  {
    "instruction": "Implement procedure to write object to text file",
    "output": "procedure Write(f: Text; val: object);\nbegin\n  if f.fi = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_ASSIGNED));\n  if f.sw = nil then \n    raise new System.IO.IOException(GetTranslation(FILE_NOT_OPENED_FOR_WRITING));\n  \n  f.sw.Write(StructuredObjectToString(val));\nend;"
  },
  {
    "instruction": "Implement procedure to write multiple objects to text file",
    "output": "procedure Write(f: Text; params args: array of object);\nbegin\n  for var i := 0 to args.length - 1 do\n    write(f, args[i]);\nend;"
  },
  {
    "instruction": "Implement procedure to write newline to text file",
    "output": "procedure Writeln(f: Text);\nbegin\n  if f.fi = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_ASSIGNED));\n  if f.sw = nil then \n    raise new System.IO.IOException(GetTranslation(FILE_NOT_OPENED_FOR_WRITING));\n  \n  f.sw.WriteLine;\nend;"
  },
  {
    "instruction": "Implement procedure to write object with newline to text file",
    "output": "procedure Writeln(f: Text; val: object);\nbegin\n  write(f, val);\n  writeln(f);\nend;"
  },
  {
    "instruction": "Implement procedure to write multiple objects with newline to text file",
    "output": "procedure Writeln(f: Text; params args: array of object);\nbegin\n  for var i := 0 to args.length - 1 do\n    write(f, args[i]);\n  writeln(f);  \nend;"
  },
  {
    "instruction": "Implement function to read short string from file",
    "output": "procedure ReadShortStringFromFile(f: Text; var s: string; n: integer);\nbegin\n  var i := 1;\n  var sb := new System.Text.StringBuilder;\n  repeat\n    if f.sr.EndOfStream then\n      break;\n    if f.sr.Peek = 13 then\n      break;\n    if f.sr.Peek = 10 then\n      break;\n    if i > n then break;\n    sb.Append(Convert.ToChar(f.sr.Read));\n    i := i + 1;\n  until False;\n  s := sb.ToString; {}\n  if s = nil then \n    s := string.Empty;\n  if s.Length > n then s := s.Substring(0, n);\nend;"
  },
  {
    "instruction": "Implement text file seek to end of file function",
    "output": "function SeekEof(f: Text): boolean;\nbegin\n  if f = input then\n  begin  \n    Result := SeekEof;\n    exit;\n  end;  \n  if f.sw <> nil then\n    raise new IOException(GetTranslation(SEEKEOF_FOR_TEXT_WRITEOPENED));\n  if f.sr = nil then  \n    raise new IOException(GetTranslation(FILE_NOT_OPENED));\n  repeat\n    if f.sr.EndOfStream then\n      break;\n    var i := f.sr.Peek;\n    if not char.IsWhiteSpace(char(i)) then\n      break;\n    f.sr.Read;\n  until False;  \n  Result := f.sr.EndOfStream;\nend;"
  },
  {
    "instruction": "Implement text file seek to end of line function",
    "output": "function SeekEoln(f: Text): boolean;\nbegin\n  if f = input then\n  begin  \n    Result := SeekEoln;\n    exit;\n  end;  \n  if f.sw <> nil then\n    raise new IOException(GetTranslation(SEEKEOLN_FOR_TEXT_WRITEOPENED));\n  if f.sr = nil then  \n    raise new IOException(GetTranslation(FILE_NOT_OPENED));\n  repeat\n    if f.sr.EndOfStream then\n      break;\n    var i := f.sr.Peek;\n    if (i <> 32) and (i <> 9) then\n      break;\n    f.sr.Read;\n  until False;\n  Result := f.sr.EndOfStream or (f.sr.Peek = 13) or (f.sr.Peek = 10);\nend;"
  },
  {
    "instruction": "Implement text file flush procedure",
    "output": "procedure Flush(f: Text);\nbegin\n  if f.sw <> nil then\n    f.sw.Flush\nend;"
  },
  {
    "instruction": "Implement text file erase procedure",
    "output": "procedure Erase(f: Text);\nbegin\n  if f.fi = nil then\n    raise new IOException(GetTranslation(FILE_NOT_ASSIGNED));\n  f.fi.Delete;\nend;"
  },
  {
    "instruction": "Implement text file rename procedure",
    "output": "procedure Rename(f: Text; newname: string);\nbegin\n  if f.fi = nil then\n    raise new IOException(GetTranslation(FILE_NOT_ASSIGNED));\n  System.IO.File.Move(f.fi.FullName, newname);\nend;"
  },
  {
    "instruction": "Implement text file initialization procedure",
    "output": "procedure TextFileInit(var f: Text);\nbegin\n  f := new Text;  \nend;"
  },
  {
    "instruction": "Implement open file for reading function",
    "output": "function OpenRead(fname: string): Text := OpenRead(fname, DefaultEncoding);"
  },
  {
    "instruction": "Implement open file for writing function",
    "output": "function OpenWrite(fname: string): Text := OpenWrite(fname, DefaultEncoding);"
  },
  {
    "instruction": "Implement open file for appending function",
    "output": "function OpenAppend(fname: string): Text := OpenAppend(fname, DefaultEncoding);"
  },
  {
    "instruction": "Implement function to read array of int64 from standard input",
    "output": "function ReadArrInt64(n: integer): array of int64;\nbegin\n  Result := new int64[n];\n  for var i := 0 to Result.Length - 1 do\n    Result[i] := ReadInt64;\nend;"
  },
  {
    "instruction": "Implement function to read sequence of integers with prompt",
    "output": "function ReadSeqInteger(prompt: string; n: integer): sequence of integer;\nbegin\n  Print(prompt);\n  Result := ReadSeqInteger(n);\nend;"
  },
  {
    "instruction": "Implement function to read sequence of real numbers with prompt",
    "output": "function ReadSeqReal(prompt: string; n: integer): sequence of real;\nbegin\n  Print(prompt);\n  Result := ReadSeqReal(n);\nend;"
  },
  {
    "instruction": "Implement function to read sequence of strings with prompt",
    "output": "function ReadSeqString(prompt: string; n: integer): sequence of string;\nbegin\n  Print(prompt);\n  Result := ReadSeqString(n);\nend;"
  },
  {
    "instruction": "Implement function to read sequence of integers with condition and prompt",
    "output": "function ReadSeqIntegerWhile(prompt: string; cond: integer->boolean): sequence of integer;\nbegin\n  Print(prompt);\n  Result := ReadSeqIntegerWhile(cond);\nend;"
  },
  {
    "instruction": "Implement function to read sequence of real numbers with condition and prompt",
    "output": "function ReadSeqRealWhile(prompt: string; cond: real->boolean): sequence of real;\nbegin\n  Print(prompt);\n  Result := ReadSeqRealWhile(cond);\nend;"
  },
  {
    "instruction": "Implement function to read sequence of strings with condition and prompt",
    "output": "function ReadSeqStringWhile(prompt: string; cond: string->boolean): sequence of string;\nbegin\n  Print(prompt);\n  Result := ReadSeqStringWhile(cond);\nend;"
  },
  {
    "instruction": "Implement function to read two integers from standard input",
    "output": "function ReadInteger2 := (ReadInteger, ReadInteger);"
  },
  {
    "instruction": "Implement function to read two real numbers from standard input",
    "output": "function ReadReal2 := (ReadReal, ReadReal);"
  },
  {
    "instruction": "Implement function to read two characters from standard input",
    "output": "function ReadChar2 := (ReadChar, ReadChar);"
  },
  {
    "instruction": "Implement function to read two strings from standard input",
    "output": "function ReadString2 := (ReadString, ReadString);"
  },
  {
    "instruction": "Implement function to read two integers with newline",
    "output": "function ReadlnInteger2 := (ReadInteger, ReadlnInteger);"
  },
  {
    "instruction": "Implement function to read two real numbers with newline",
    "output": "function ReadlnReal2 := (ReadReal, ReadlnReal);"
  },
  {
    "instruction": "Implement function to read two characters with newline",
    "output": "function ReadlnChar2 := (ReadChar, ReadlnChar);"
  },
  {
    "instruction": "Implement function to read two strings with newline",
    "output": "function ReadlnString2 := (ReadString, ReadlnString);"
  },
  {
    "instruction": "Implement function to read three integers from standard input",
    "output": "function ReadInteger3 := (ReadInteger, ReadInteger, ReadInteger);"
  },
  {
    "instruction": "Implement function to read three real numbers from standard input",
    "output": "function ReadReal3 := (ReadReal, ReadReal, ReadReal);"
  },
  {
    "instruction": "Implement function to read three characters from standard input",
    "output": "function ReadChar3 := (ReadChar, ReadChar, ReadChar);"
  },
  {
    "instruction": "Implement function to read three strings from standard input",
    "output": "function ReadString3 := (ReadString, ReadString, ReadString);"
  },
  {
    "instruction": "Implement function to read three integers with newline",
    "output": "function ReadlnInteger3 := (ReadInteger, ReadInteger, ReadlnInteger);"
  },
  {
    "instruction": "Implement function to read three real numbers with newline",
    "output": "function ReadlnReal3 := (ReadReal, ReadReal, ReadlnReal);"
  },
  {
    "instruction": "Implement function to read three characters with newline",
    "output": "function ReadlnChar3 := (ReadChar, ReadChar, ReadlnChar);"
  },
  {
    "instruction": "Implement function to read three strings with newline",
    "output": "function ReadlnString3 := (ReadString, ReadString, ReadlnString);"
  },
  {
    "instruction": "Implement function to read four integers from standard input",
    "output": "function ReadInteger4 := (ReadInteger, ReadInteger, ReadInteger, ReadInteger);"
  },
  {
    "instruction": "Implement function to read four real numbers from standard input",
    "output": "function ReadReal4 := (ReadReal, ReadReal, ReadReal, ReadReal);"
  },
  {
    "instruction": "Implement function to read four characters from standard input",
    "output": "function ReadChar4 := (ReadChar, ReadChar, ReadChar, ReadChar);"
  },
  {
    "instruction": "Implement function to read four strings from standard input",
    "output": "function ReadString4 := (ReadString, ReadString, ReadString, ReadString);"
  },
  {
    "instruction": "Implement function to read four integers with newline",
    "output": "function ReadlnInteger4 := (ReadInteger, ReadInteger, ReadInteger, ReadlnInteger);"
  },
  {
    "instruction": "Implement function to read four real numbers with newline",
    "output": "function ReadlnReal4 := (ReadReal, ReadReal, ReadReal, ReadlnReal);"
  },
  {
    "instruction": "Implement function to read four characters with newline",
    "output": "function ReadlnChar4 := (ReadChar, ReadChar, ReadChar, ReadlnChar);"
  },
  {
    "instruction": "Implement function to read four strings with newline",
    "output": "function ReadlnString4 := (ReadString, ReadString, ReadString, ReadlnString);"
  },
  {
    "instruction": "Implement function to read two integers with prompt",
    "output": "function ReadInteger2(prompt: string) := (ReadInteger(prompt), ReadInteger);"
  },
  {
    "instruction": "Implement function to read two real numbers with prompt",
    "output": "function ReadReal2(prompt: string) := (ReadReal(prompt), ReadReal);"
  },
  {
    "instruction": "Implement function to read two characters with prompt",
    "output": "function ReadChar2(prompt: string) := (ReadChar(prompt), ReadChar);"
  },
  {
    "instruction": "Implement function to read two strings with prompt",
    "output": "function ReadString2(prompt: string) := (ReadString(prompt), ReadString);"
  },
  {
    "instruction": "Implement function to read two integers with prompt and newline",
    "output": "function ReadlnInteger2(prompt: string) := (ReadInteger(prompt), ReadlnInteger);"
  },
  {
    "instruction": "Implement function to read two real numbers with prompt and newline",
    "output": "function ReadlnReal2(prompt: string) := (ReadReal(prompt), ReadlnReal);"
  },
  {
    "instruction": "Implement function to read two characters with prompt and newline",
    "output": "function ReadlnChar2(prompt: string) := (ReadChar(prompt), ReadlnChar);"
  },
  {
    "instruction": "Implement function to read two strings with prompt and newline",
    "output": "function ReadlnString2(prompt: string) := (ReadString(prompt), ReadlnString);"
  },
  {
    "instruction": "Implement function to read three integers with prompt",
    "output": "function ReadInteger3(prompt: string) := (ReadInteger(prompt), ReadInteger, ReadInteger);"
  },
  {
    "instruction": "Implement function to read three real numbers with prompt",
    "output": "function ReadReal3(prompt: string) := (ReadReal(prompt), ReadReal, ReadReal);"
  },
  {
    "instruction": "Implement function to read three characters with prompt",
    "output": "function ReadChar3(prompt: string) := (ReadChar(prompt), ReadChar, ReadChar);"
  },
  {
    "instruction": "Implement function to read three strings with prompt",
    "output": "function ReadString3(prompt: string) := (ReadString(prompt), ReadString, ReadString);"
  },
  {
    "instruction": "Implement function to read three integers with prompt and newline",
    "output": "function ReadlnInteger3(prompt: string) := (ReadInteger(prompt), ReadInteger, ReadlnInteger);"
  },
  {
    "instruction": "Implement function to read three real numbers with prompt and newline",
    "output": "function ReadlnReal3(prompt: string) := (ReadReal(prompt), ReadReal, ReadlnReal);"
  },
  {
    "instruction": "Implement function to read three characters with prompt and newline",
    "output": "function ReadlnChar3(prompt: string) := (ReadChar(prompt), ReadChar, ReadlnChar);"
  },
  {
    "instruction": "Implement function to read three strings with prompt and newline",
    "output": "function ReadlnString3(prompt: string) := (ReadString(prompt), ReadString, ReadlnString);"
  },
  {
    "instruction": "Implement function to read four integers with prompt",
    "output": "function ReadInteger4(prompt: string) := (ReadInteger(prompt), ReadInteger, ReadInteger, ReadInteger);"
  },
  {
    "instruction": "Implement function to read four real numbers with prompt",
    "output": "function ReadReal4(prompt: string) := (ReadReal(prompt), ReadReal, ReadReal, ReadReal);"
  },
  {
    "instruction": "Implement function to read four characters with prompt",
    "output": "function ReadChar4(prompt: string) := (ReadChar(prompt), ReadChar, ReadChar, ReadChar);"
  },
  {
    "instruction": "Implement function to read four strings with prompt",
    "output": "function ReadString4(prompt: string) := (ReadString(prompt), ReadString, ReadString, ReadString);"
  },
  {
    "instruction": "Implement function to read four integers with prompt and newline",
    "output": "function ReadlnInteger4(prompt: string) := (ReadInteger(prompt), ReadInteger, ReadInteger, ReadlnInteger);"
  },
  {
    "instruction": "Implement function to read four real numbers with prompt and newline",
    "output": "function ReadlnReal4(prompt: string) := (ReadReal(prompt), ReadReal, ReadReal, ReadlnReal);"
  },
  {
    "instruction": "Implement function to read four characters with prompt and newline",
    "output": "function ReadlnChar4(prompt: string) := (ReadChar(prompt), ReadChar, ReadChar, ReadlnChar);"
  },
  {
    "instruction": "Implement function to read four strings with prompt and newline",
    "output": "function ReadlnString4(prompt: string) := (ReadString(prompt), ReadString, ReadString, ReadlnString);"
  },
  {
    "instruction": "Implement function to read integer with prompt and newline",
    "output": "function ReadlnInteger(prompt: string): integer;\nbegin\n  Print(prompt);\n  Result := ReadlnInteger;\nend;"
  },
  {
    "instruction": "Implement function to read int64 with prompt and newline",
    "output": "function ReadlnInt64(prompt: string): int64;\nbegin\n  Print(prompt);\n  Result := ReadlnInt64;\nend;"
  },
  {
    "instruction": "Implement function to read real number with prompt and newline",
    "output": "function ReadlnReal(prompt: string): real;\nbegin\n  Print(prompt);\n  Result := ReadlnReal;\nend;"
  },
  {
    "instruction": "Implement function to read character with prompt and newline",
    "output": "function ReadlnChar(prompt: string): char;\nbegin\n  Print(prompt);\n  Result := ReadlnChar;\nend;"
  },
  {
    "instruction": "Implement function to read string with prompt and newline",
    "output": "function ReadlnString(prompt: string): string;\nbegin\n  Print(prompt);\n  Result := ReadlnString;\nend;"
  },
  {
    "instruction": "Implement function to read boolean with prompt and newline",
    "output": "function ReadlnBoolean(prompt: string): boolean;\nbegin\n  Print(prompt);\n  Result := ReadlnBoolean;\nend;"
  },
  {
    "instruction": "Implement function to read BigInteger with prompt",
    "output": "function ReadBigInteger(prompt: string): BigInteger;\nbegin\n  Print(prompt);\n  Result := ReadBigInteger;\nend;"
  },
  {
    "instruction": "Implement function to read BigInteger with prompt and newline",
    "output": "function ReadlnBigInteger(prompt: string): BigInteger;\nbegin\n  Print(prompt);\n  Result := ReadlnBigInteger;\nend;"
  },
  {
    "instruction": "Implement function to create sequence from integer range",
    "output": "function Seq(a: IntRange): sequence of integer := a;"
  },
  {
    "instruction": "Implement function to create sequence from character range",
    "output": "function Seq(a: CharRange): sequence of char := a;"
  },
  {
    "instruction": "Implement function to create LinkedList from parameters",
    "output": "function LLst<T>(params a: array of T): LinkedList<T> := new LinkedList<T>(a);"
  },
  {
    "instruction": "Implement function to create LinkedList from sequence",
    "output": "function LLst<T>(a: sequence of T): LinkedList<T> := new LinkedList<T>(a);"
  },
  {
    "instruction": "Implement function to create LinkedList from integer range",
    "output": "function LLst(a: IntRange): LinkedList<integer> := a.ToLinkedList;"
  },
  {
    "instruction": "Implement function to create LinkedList from character range",
    "output": "function LLst(a: CharRange): LinkedList<char> := a.ToLinkedList;"
  },
  {
    "instruction": "Implement function to create HashSet from sequence",
    "output": "function HSet<T>(a: sequence of T): HashSet<T> := new HashSet<T>(a);"
  },
  {
    "instruction": "Implement function to create SortedSet from sequence",
    "output": "function SSet<T>(a: sequence of T): SortedSet<T> := new SortedSet<T>(a);"
  },
  {
    "instruction": "Implement function to create HashSet from integer range",
    "output": "function HSet(a: IntRange): HashSet<integer> := a.ToHashSet;"
  },
  {
    "instruction": "Implement function to create HashSet from character range",
    "output": "function HSet(a: CharRange): HashSet<char> := a.ToHashSet;"
  },
  {
    "instruction": "Implement function to create SortedSet from integer range",
    "output": "function SSet(a: IntRange): SortedSet<integer> := a.ToSortedSet;"
  },
  {
    "instruction": "Implement function to create SortedSet from character range",
    "output": "function SSet(a: CharRange): SortedSet<char> := a.ToSortedSet;"
  },
  {
    "instruction": "Implement function to create Dictionary from tuple pairs",
    "output": "function Dict<TKey, TVal>(params pairs: array of (TKey, TVal)): Dictionary<TKey, TVal>;\nbegin\n  Result := new Dictionary<TKey, TVal>();\n  for var i := 0 to pairs.Length - 1 do\n    Result.Add(pairs[i][0], pairs[i][1]);\nend;"
  },
  {
    "instruction": "Implement function to create string Dictionary from tuple pairs",
    "output": "function DictStr(params pairs: array of (string, string)): Dictionary<string, string>\n  := Dict&<string, string>(pairs);"
  },
  {
    "instruction": "Implement function to create string-integer Dictionary from tuple pairs",
    "output": "function DictStrInt(params pairs: array of (string, integer)): Dictionary<string, integer>\n  := Dict&<string, integer>(pairs);"
  },
  {
    "instruction": "Implement function for type checking and assignment",
    "output": "function __TypeCheckAndAssignForIsMatch<T>(obj: object; var res: T): boolean;\nbegin\n  if obj is T then\n  begin\n    res := T(obj);\n    Result := true;\n  end\n  else\n  begin\n    res := default(T);\n    Result := false;\n  end;\nend;"
  },
  {
    "instruction": "Implement function for wildcard tuple equality comparison with two elements",
    "output": "function __WildCardsTupleEqual<T1, T2, T3, T4>(\n    first: Tuple<T1, T2>; \n    second: Tuple<T3, T4>;\n    elemsToCompare: sequence of integer): boolean;\nbegin\nResult := True;\nforeach var ind in elemsToCompare do\nbegin\n  case ind of\n  0: Result := Result and first.Item1.Equals(second.Item1);\n  1: Result := Result and first.Item2.Equals(second.Item2);\n  end;\nend;\nend;"
  },
  {
    "instruction": "Implement function for wildcard tuple equality comparison with three elements",
    "output": "function __WildCardsTupleEqual<T1, T2, T3, T4, T5, T6>(\n    first: Tuple<T1, T2, T3>; \n    second: Tuple<T4, T5, T6>;\n    elemsToCompare: sequence of integer): boolean;\nbegin\nResult := True;\nforeach var ind in elemsToCompare do\nbegin\n  case ind of\n  0: Result := Result and first.Item1.Equals(second.Item1);\n  1: Result := Result and first.Item2.Equals(second.Item2);\n  2: Result := Result and first.Item3.Equals(second.Item3);\n  end;\nend;\nend;"
  },
  {
    "instruction": "Implement function for wildcard tuple equality comparison with four elements",
    "output": "function __WildCardsTupleEqual<T1, T2, T3, T4, T5, T6, T7, T8>(\n    first: Tuple<T1, T2, T3, T4>; \n    second: Tuple<T5, T6, T7, T8>;\n    elemsToCompare: sequence of integer): boolean;\nbegin\nResult := True;\nforeach var ind in elemsToCompare do\nbegin\n  case ind of\n  0: Result := Result and first.Item1.Equals(second.Item1);\n  1: Result := Result and first.Item2.Equals(second.Item2);\n  2: Result := Result and first.Item3.Equals(second.Item3);\n  3: Result := Result and first.Item4.Equals(second.Item4);\n  end;\nend;\nend;"
  },
  {
    "instruction": "Implement function for wildcard tuple equality comparison with five elements",
    "output": "function __WildCardsTupleEqual<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(\n    first: Tuple<T1, T2, T3, T4, T5>; \n    second: Tuple<T6, T7, T8, T9, T10>;\n    elemsToCompare: sequence of integer): boolean;\nbegin\nResult := True;\nforeach var ind in elemsToCompare do\nbegin\n  case ind of\n  0: Result := Result and first.Item1.Equals(second.Item1);\n  1: Result := Result and first.Item2.Equals(second.Item2);\n  2: Result := Result and first.Item3.Equals(second.Item3);\n  3: Result := Result and first.Item4.Equals(second.Item4);\n  4: Result := Result and first.Item5.Equals(second.Item5);\n  end;\nend;\nend;"
  },
  {
    "instruction": "Implement function for wildcard tuple equality comparison with six elements",
    "output": "function __WildCardsTupleEqual<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(\n    first: Tuple<T1, T2, T3, T4, T5, T6>; \n    second: Tuple<T7, T8, T9, T10, T11, T12>;\n    elemsToCompare: sequence of integer): boolean;\nbegin\nResult := True;\nforeach var ind in elemsToCompare do\nbegin\n  case ind of\n  0: Result := Result and first.Item1.Equals(second.Item1);\n  1: Result := Result and first.Item2.Equals(second.Item2);\n  2: Result := Result and first.Item3.Equals(second.Item3);\n  3: Result := Result and first.Item4.Equals(second.Item4);\n  4: Result := Result and first.Item5.Equals(second.Item5);\n  5: Result := Result and first.Item6.Equals(second.Item6);\n  end;\nend;\nend;"
  },
  {
    "instruction": "Implement function for wildcard tuple equality comparison with seven elements",
    "output": "function __WildCardsTupleEqual<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(\n    first: Tuple<T1, T2, T3, T4, T5, T6, T7>; \n    second: Tuple<T8, T9, T10, T11, T12, T13, T14>;\n    elemsToCompare: sequence of integer): boolean;\nbegin\nResult := True;\nforeach var ind in elemsToCompare do\nbegin\n  case ind of\n  0: Result := Result and first.Item1.Equals(second.Item1);\n  1: Result := Result and first.Item2.Equals(second.Item2);\n  2: Result := Result and first.Item3.Equals(second.Item3);\n  3: Result := Result and first.Item4.Equals(second.Item4);\n  4: Result := Result and first.Item5.Equals(second.Item5);\n  5: Result := Result and first.Item6.Equals(second.Item6);\n  6: Result := Result and first.Item7.Equals(second.Item7);\n  end;\nend;\nend;"
  },
  {
    "instruction": "Implement extension method for deconstructing single value",
    "output": "procedure Deconstruct<T>(self: T; var res: T); extensionmethod;\nbegin\n  res := self;\nend;"
  },
  {
    "instruction": "Implement function to convert object to string representation",
    "output": "function _ObjectToString(o: object): string;\nbegin\n  Result := StructuredObjectToString(o);\nend;"
  },
  {
    "instruction": "Implement function to create array generator with starting index",
    "output": "function ArrGen<T>(count: integer; gen: integer->T; from: integer): array of T;\nbegin\n  Result := new T[count];\n  for var i := 0 to Result.Length - 1 do\n    Result[i] := gen(i + from);\nend;"
  },
  {
    "instruction": "Implement function to create sequence generator with starting index",
    "output": "function SeqGen<T>(count: integer; f: integer->T; from: integer): sequence of T;\nbegin\n  Result := Range(from, count + from - 1).Select(f)\nend;"
  },
  {
    "instruction": "Implement function to create sequence while condition is true with single element",
    "output": "function SeqWhile<T>(first: T; next: T->T; pred: T->boolean): sequence of T;\nbegin\n  Result := Iterate(first, next).TakeWhile(pred);\nend;"
  },
  {
    "instruction": "Implement function to create sequence while condition is true with two elements",
    "output": "function SeqWhile<T>(first, second: T; next: (T,T) ->T; pred: T->boolean): sequence of T;\nbegin\n  Result := Iterate(first, second, next).TakeWhile(pred);\nend;"
  },
  {
    "instruction": "Implement procedure for try read byte with message",
    "output": "function TryRead(var x: byte; message: string): boolean;\nbegin\n  Result := True;\n  try\n    if message<>'' then\n      Print(message);\n    Read(x)\n  except\n    Result := False;\n  end\nend;"
  },
  {
    "instruction": "Implement procedure for try read shortint with message",
    "output": "function TryRead(var x: shortint; message: string): boolean;\nbegin\n  Result := True;\n  try\n    if message<>'' then\n      Print(message);\n    Read(x)\n  except\n    Result := False;\n  end\nend;"
  },
  {
    "instruction": "Implement procedure for try read smallint with message",
    "output": "function TryRead(var x: smallint; message: string): boolean;\nbegin\n  Result := True;\n  try\n    if message<>'' then\n      Print(message);\n    Read(x)\n  except\n    Result := False;\n  end\nend;"
  },
  {
    "instruction": "Implement procedure for try read word with message",
    "output": "function TryRead(var x: word; message: string): boolean;\nbegin\n  Result := True;\n  try\n    if message<>'' then\n      Print(message);\n    Read(x)\n  except\n    Result := False;\n  end\nend;"
  },
  {
    "instruction": "Implement procedure for try read longword with message",
    "output": "function TryRead(var x: longword; message: string): boolean;\nbegin\n  Result := True;\n  try\n    if message<>'' then\n      Print(message);\n    Read(x)\n  except\n    Result := False;\n  end\nend;"
  },
  {
    "instruction": "Implement procedure for try read uint64 with message",
    "output": "function TryRead(var x: uint64; message: string): boolean;\nbegin\n  Result := True;\n  try\n    if message<>'' then\n      Print(message);\n    Read(x)\n  except\n    Result := False;\n  end\nend;"
  },
  {
    "instruction": "Implement procedure for try read single with message",
    "output": "function TryRead(var x: single; message: string): boolean;\nbegin\n  Result := True;\n  try\n    if message<>'' then\n      Print(message);\n    Read(x)\n  except\n    Result := False;\n  end\nend;"
  },
  {
    "instruction": "Implement procedure for try read boolean with message",
    "output": "function TryRead(var x: boolean; message: string): boolean;\nbegin\n  Result := True;\n  try\n    if message<>'' then\n      Print(message);\n    Read(x)\n  except\n    Result := False;\n  end\nend;"
  },
  {
    "instruction": "Implement procedure for try read BigInteger with message",
    "output": "function TryRead(var x: BigInteger; message: string): boolean;\nbegin\n  Result := True;\n  try\n    if message<>'' then\n      Print(message);\n    Read(x)\n  except\n    Result := False;\n  end\nend;"
  },
  {
    "instruction": "Implement function to generate random pair with maximum value",
    "output": "function Random2(maxValue: integer) := (Random(maxValue), Random(maxValue));"
  },
  {
    "instruction": "Implement function to generate random pair with maximum real value",
    "output": "function Random2(maxValue: real) := (Random(maxValue), Random(maxValue));"
  },
  {
    "instruction": "Implement function to generate random triple with maximum value",
    "output": "function Random3(maxValue: integer) := (Random(maxValue), Random(maxValue), Random(maxValue));"
  },
  {
    "instruction": "Implement function to generate random triple with maximum real value",
    "output": "function Random3(maxValue: Real) := (Random(maxValue), Random(maxValue), Random(maxValue));"
  },
  {
    "instruction": "Implement function to generate random pair without parameters",
    "output": "function Random2 := (Random, Random);"
  },
  {
    "instruction": "Implement function to generate random triple without parameters",
    "output": "function Random3 := (Random, Random, Random);"
  },
  {
    "instruction": "Implement procedure to read BigInteger from standard input",
    "output": "procedure Read(var x: BigInteger);\nbegin\n  CurrentIOSystem.read(x)\nend;"
  },
  {
    "instruction": "Implement function to read BigInteger from standard input",
    "output": "function ReadBigInteger: BigInteger;\nbegin\n  Read(Result);\nend;"
  },
  {
    "instruction": "Implement function to read BigInteger with newline from standard input",
    "output": "function ReadlnBigInteger: BigInteger;\nbegin\n  Result := ReadBigInteger;\n  Readln();\nend;"
  },
  {
    "instruction": "Implement procedure to read BigInteger from text file",
    "output": "procedure read(f: Text; var x: BigInteger);\nbegin\n  x := BigInteger.Parse(ReadLexem(f))\nend;"
  },
  {
    "instruction": "Implement function to read BigInteger from text file",
    "output": "function ReadBigInteger(f: Text): BigInteger;\nbegin\n  Read(f, Result);\nend;"
  },
  {
    "instruction": "Implement function to read BigInteger with newline from text file",
    "output": "function ReadlnBigInteger(f: Text): BigInteger;\nbegin\n  Result := ReadBigInteger(f);\n  Readln(f);\nend;"
  },
  {
    "instruction": "Implement procedure for validation of BigInteger from string",
    "output": "procedure Val(s: string; var value: BigInteger; var err: integer);\nbegin\n  if BigInteger.TryParse(s, value) then\n    err := 0\n  else err := 1;\nend;"
  },
  {
    "instruction": "Implement function to round real number to BigInteger",
    "output": "function RoundBigInteger(x: real) := BigInteger.Create(Math.Round(x));"
  },
  {
    "instruction": "Implement function to truncate real number to BigInteger",
    "output": "function TruncBigInteger(x: real) := BigInteger.Create(Math.Truncate(x));"
  },
  {
    "instruction": "Implement function to get sign of BigInteger",
    "output": "function Sign(x: BigInteger) := x.Sign;"
  },
  {
    "instruction": "Implement function to get absolute value of BigInteger",
    "output": "function Abs(x: BigInteger): BigInteger := BigInteger.Abs(x);"
  },
  {
    "instruction": "Implement function to calculate power with BigInteger base and integer exponent",
    "output": "function Power(x: BigInteger; y: integer) := BigInteger.Pow(x, y);"
  },
  {
    "instruction": "Implement function to check if BigInteger is odd",
    "output": "function Odd(i: BigInteger) := not i.IsEven;"
  },
  {
    "instruction": "Implement function to get minimum of two BigIntegers",
    "output": "function Min(a, b: BigInteger) := BigInteger.Min(a, b);"
  },
  {
    "instruction": "Implement function to get maximum of two BigIntegers",
    "output": "function Max(a, b: BigInteger) := BigInteger.Max(a, b);"
  },
  {
    "instruction": "Implement function to get square of BigInteger",
    "output": "function Sqr(x: BigInteger): BigInteger := x * x;"
  },
  {
    "instruction": "Implement function to get successor of BigInteger",
    "output": "function Succ(x: BigInteger): BigInteger;\nbegin\n  Result := x + 1;\nend;"
  },
  {
    "instruction": "Implement procedure for reading without parameters",
    "output": "procedure Read;\nbegin\nend;"
  },
  {
    "instruction": "Implement procedure for reading newline without parameters",
    "output": "procedure Readln;\nbegin\n  CurrentIOSystem.readln\nend;"
  },
  {
    "instruction": "Implement procedure for writing without parameters",
    "output": "procedure Write;\nbegin\nend;"
  },
  {
    "instruction": "Implement procedure for writing newline without parameters",
    "output": "procedure Writeln;\nbegin\n  if output.sw <> nil then\n    writeln_in_output\n  else CurrentIOSystem.Writeln;\nend;"
  },
  {
    "instruction": "Implement procedure for writing two objects",
    "output": "procedure Write(obj1, obj2: object);\nbegin\n  if output.sw <> nil then\n  begin\n    write_in_output(obj1);\n    write_in_output(obj2);\n  end\n  else\n  begin\n    CurrentIOSystem.Write(obj1);\n    CurrentIOSystem.Write(obj2);\n  end;\nend;"
  },
  {
    "instruction": "Implement procedure for writing two objects with newline",
    "output": "procedure Writeln(obj1, obj2: object);\nbegin\n  if output.sw <> nil then\n  begin\n    write_in_output(obj1);\n    write_in_output(obj2);\n    writeln_in_output;\n  end\n  else\n  begin\n    CurrentIOSystem.Write(obj1);\n    CurrentIOSystem.Write(obj2);\n    CurrentIOSystem.Writeln;\n  end\nend;"
  },
  {
    "instruction": "Implement procedure for formatted writing to standard output",
    "output": "procedure WriteFormat(formatstr: string; params args: array of object);\nbegin\n  var s := Format(formatstr, args);\n  write(s);\nend;"
  },
  {
    "instruction": "Implement procedure for formatted writing with newline to standard output",
    "output": "procedure WritelnFormat(formatstr: string; params args: array of object);\nbegin\n  var s := Format(formatstr, args);\n  writeln(s);\nend;"
  },
  {
    "instruction": "Implement procedure for formatted writing to text file",
    "output": "procedure WriteFormat(f: Text; formatstr: string; params args: array of object);\nbegin\n  var s := Format(formatstr, args);\n  write(f, s);\nend;"
  },
  {
    "instruction": "Implement procedure for formatted writing with newline to text file",
    "output": "procedure WritelnFormat(f: Text; formatstr: string; params args: array of object);\nbegin\n  var s := Format(formatstr, args);\n  Writeln(f, s);\nend;"
  },
  {
    "instruction": "Implement procedure for printing string to standard output",
    "output": "procedure Print(s: string);\nbegin\n  if PrintDelimDefault<>'' then\n    Write(s, PrintDelimDefault)\n  else Write(s)  \nend;"
  },
  {
    "instruction": "Implement procedure for printing object to standard output",
    "output": "procedure Print(o: object);\nbegin\n  if PrintDelimDefault<>'' then\n    Write(o, PrintDelimDefault)\n  else     \n    Write(o)\nend;"
  },
  {
    "instruction": "Implement procedure for printing to text file",
    "output": "procedure Print(f: Text; params args: array of object);\nbegin\n  if args.Length = 0 then\n    exit;\n  if PrintDelimDefault<>'' then\n    for var i := 0 to args.length - 1 do\n      Write(f, args[i], PrintDelimDefault)\n  else     \n    for var i := 0 to args.length - 1 do\n      Write(f, args[i])\nend;"
  },
  {
    "instruction": "Implement procedure for printing with newline to text file",
    "output": "procedure Println(f: Text; params args: array of object);\nbegin\n  Print(f, args);\n  Writeln(f);\nend;"
  },
  {
    "instruction": "Implement function to read word from text file",
    "output": "function Text.ReadWord := ReadLexem(Self);"
  },
  {
    "instruction": "Implement procedure to reset text file with encoding",
    "output": "procedure Text.Reset(en: Encoding) := PABCSystem.Reset(Self,en);"
  },
  {
    "instruction": "Implement procedure to rewrite text file with encoding",
    "output": "procedure Text.Rewrite(en: Encoding) := PABCSystem.Rewrite(Self,en);"
  },
  {
    "instruction": "Implement procedure to append text file with encoding",
    "output": "procedure Text.Append(en: Encoding) := PABCSystem.Append(Self,en);"
  },
  {
    "instruction": "Implement function to get text file name",
    "output": "function Text.Name := fi.Name;"
  },
  {
    "instruction": "Implement function to get text file full name",
    "output": "function Text.FullName := fi.FullName;"
  },
  {
    "instruction": "Implement function to read entire text file content",
    "output": "function Text.ReadToEnd := sr.ReadToEnd;"
  },
  {
    "instruction": "Implement procedure to reset text file to beginning",
    "output": "procedure Text.Reset := PABCSystem.Reset(Self);"
  },
  {
    "instruction": "Implement procedure to rewrite text file",
    "output": "procedure Text.Rewrite := PABCSystem.Rewrite(Self);"
  },
  {
    "instruction": "Implement procedure to append to text file",
    "output": "procedure Text.Append := PABCSystem.Append(Self);"
  },
  {
    "instruction": "Implement procedure to close abstract binary file",
    "output": "procedure AbstractBinaryFile.Close := PABCSystem.Close(Self);"
  },
  {
    "instruction": "Implement procedure to truncate abstract binary file",
    "output": "procedure AbstractBinaryFile.Truncate := PABCSystem.Truncate(Self);"
  },
  {
    "instruction": "Implement function to check end of abstract binary file",
    "output": "function AbstractBinaryFile.Eof := PABCSystem.Eof(Self);"
  },
  {
    "instruction": "Implement procedure to erase abstract binary file",
    "output": "procedure AbstractBinaryFile.Erase := PABCSystem.Erase(Self);"
  },
  {
    "instruction": "Implement procedure to rename abstract binary file",
    "output": "procedure AbstractBinaryFile.Rename(newname: string) := PABCSystem.Rename(Self, newname);"
  },
  {
    "instruction": "Implement procedure to write to abstract binary file",
    "output": "procedure AbstractBinaryFile.Write(params vals: array of object) := PABCSystem.Write(Self, vals);"
  },
  {
    "instruction": "Implement procedure to reset abstract binary file",
    "output": "procedure AbstractBinaryFile.Reset := PABCSystem.Reset(Self);"
  },
  {
    "instruction": "Implement procedure to rewrite abstract binary file",
    "output": "procedure AbstractBinaryFile.Rewrite := PABCSystem.Rewrite(Self);"
  },
  {
    "instruction": "Implement function to get abstract binary file name",
    "output": "function AbstractBinaryFile.Name := fi.Name;"
  },
  {
    "instruction": "Implement function to get abstract binary file full name",
    "output": "function AbstractBinaryFile.FullName := fi.FullName;"
  },
  {
    "instruction": "Implement procedure to reset binary file with encoding",
    "output": "procedure BinaryFile.Reset(en: Encoding) := PABCSystem.Reset(Self,en);"
  },
  {
    "instruction": "Implement procedure to rewrite binary file with encoding",
    "output": "procedure BinaryFile.Rewrite(en: Encoding) := PABCSystem.Rewrite(Self,en);"
  },
  {
    "instruction": "Implement function to get binary file position",
    "output": "function BinaryFile.GetFilePos: int64 := PABCSystem.FilePos(Self);"
  },
  {
    "instruction": "Implement function to get binary file size",
    "output": "function BinaryFile.Size: int64 := PABCSystem.FileSize(Self);"
  },
  {
    "instruction": "Implement procedure to seek in binary file",
    "output": "procedure BinaryFile.Seek(n: int64) := PABCSystem.Seek(Self, n);"
  },
  {
    "instruction": "Implement function to read boolean from binary file",
    "output": "function BinaryFile.ReadBoolean: boolean;\nbegin\n  InternalCheck;\n  Result := Self.br.ReadBoolean;  \nend;"
  },
  {
    "instruction": "Implement function to read byte from binary file",
    "output": "function BinaryFile.ReadByte: byte;\nbegin\n  InternalCheck;\n  Result := Self.br.ReadByte;  \nend;"
  },
  {
    "instruction": "Implement function to read character from binary file",
    "output": "function BinaryFile.ReadChar: char;\nbegin\n  InternalCheck;\n  Result := Self.br.ReadChar;  \nend;"
  },
  {
    "instruction": "Implement procedure to assign file with alternative name",
    "output": "procedure AssignFile(f: Text; name: string) := Assign(f, name);"
  },
  {
    "instruction": "Implement procedure to close file with alternative name",
    "output": "procedure CloseFile(f: Text) := Close(f);"
  },
  {
    "instruction": "Implement procedure to reset file with name and encoding",
    "output": "procedure Reset(f: Text; name: string; en: Encoding);\nbegin\n  Assign(f, name);\n  Reset(f, en);\nend;"
  },
  {
    "instruction": "Implement procedure to rewrite file with name and encoding",
    "output": "procedure Rewrite(f: Text; name: string; en: Encoding);\nbegin\n  Assign(f, name);\n  Rewrite(f, en);\nend;"
  },
  {
    "instruction": "Implement procedure to append file with name and encoding",
    "output": "procedure Append(f: Text; name: string; en: Encoding);\nbegin\n  Assign(f, name);\n  Append(f, en);\nend;"
  },
  {
    "instruction": "Implement procedure to assign binary file with alternative name",
    "output": "procedure AssignFile(f: AbstractBinaryFile; name: string) := Assign(f, name);"
  },
  {
    "instruction": "Implement procedure to close binary file with alternative name",
    "output": "procedure CloseFile(f: AbstractBinaryFile) := Close(f);"
  },
  {
    "instruction": "Implement procedure to reset binary file with name",
    "output": "procedure Reset(f: AbstractBinaryFile; name: string);\nbegin\n  Assign(f, name);\n  Reset(f);\nend;"
  },
  {
    "instruction": "Implement procedure to reset binary file with name and encoding",
    "output": "procedure Reset(f: AbstractBinaryFile; name: string; en: Encoding);\nbegin\n  Assign(f, name);\n  Reset(f,en);\nend;"
  },
  {
    "instruction": "Implement procedure to rewrite binary file with name",
    "output": "procedure Rewrite(f: AbstractBinaryFile; name: string);\nbegin\n  Assign(f, name);\n  Rewrite(f);\nend;"
  },
  {
    "instruction": "Implement procedure to rewrite binary file with name and encoding",
    "output": "procedure Rewrite(f: AbstractBinaryFile; name: string; en: Encoding);\nbegin\n  Assign(f, name);\n  Rewrite(f,en);\nend;"
  },
  {
    "instruction": "Implement function to open read with encoding",
    "output": "function OpenRead(fname: string; en: Encoding): Text;\nbegin\n  var f: Text := new Text;\n  Reset(f, fname, en);\n  Result := f;\nend;"
  },
  {
    "instruction": "Implement function to open write with encoding",
    "output": "function OpenWrite(fname: string; en: Encoding): Text;\nbegin\n  var f: Text := new Text;\n  Rewrite(f, fname, en);\n  Result := f;\nend;"
  },
  {
    "instruction": "Implement function to open append with encoding",
    "output": "function OpenAppend(fname: string; en: Encoding): Text;\nbegin\n  var f: Text := new Text;\n  Append(f, fname, en);\n  Result := f;\nend;"
  },
  {
    "instruction": "Implement function to read lines from file with encoding",
    "output": "function ReadLines(path: string; en: Encoding): sequence of string;\nbegin\n  Result := System.IO.File.ReadLines(path, en);\nend;"
  },
  {
    "instruction": "Implement function to read all lines from file with encoding",
    "output": "function ReadAllLines(path: string; en: Encoding): array of string;\nbegin\n  Result := System.IO.File.ReadAllLines(path, en);\nend;"
  },
  {
    "instruction": "Implement function to read all text from file with encoding",
    "output": "function ReadAllText(path: string; en: Encoding): string;\nbegin\n  Result := System.IO.File.ReadAllText(path, en);\nend;"
  },
  {
    "instruction": "Implement procedure to write lines to file with encoding",
    "output": "procedure WriteLines(path: string; ss: sequence of string; en: Encoding);\nbegin\n  System.IO.File.WriteAllLines(path, ss, en);\nend;"
  },
  {
    "instruction": "Implement procedure to write all lines to file with encoding",
    "output": "procedure WriteAllLines(path: string; ss: array of string; en: Encoding);\nbegin\n  System.IO.File.WriteAllLines(path, ss, en);\nend;"
  },
  {
    "instruction": "Implement procedure to write all text to file with encoding",
    "output": "procedure WriteAllText(path: string; s: string; en: Encoding);\nbegin\n  System.IO.File.WriteAllText(path, s, en);\nend;"
  },
  {
    "instruction": "Implement procedure for typed file initialization with element type",
    "output": "procedure TypedFileInit(var f: TypedFile; ElementType: System.Type);\nbegin\n  f := new TypedFile(ElementType, 0, new integer[0]);\nend;"
  },
  {
    "instruction": "Implement procedure for typed file initialization with offsets",
    "output": "procedure TypedFileInit(var f: TypedFile; ElementType: System.Type; off: integer; params offs: array of integer);\nbegin\n  f := new TypedFile(ElementType, off, offs);\nend;"
  },
  {
    "instruction": "Implement procedure for typed file initialization with short string support",
    "output": "procedure TypedFileInitWithShortString(var f: TypedFile; ElementType: System.Type; off: integer; params offs: array of integer);\nbegin\n  f := new TypedFile(ElementType, off, offs);\nend;"
  },
  {
    "instruction": "Implement function to read from typed file",
    "output": "function TypedFileRead(f: TypedFile): object;\nbegin\n  var ind := 0;\n  if f.fi = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_ASSIGNED));\n  if f.fs = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_OPENED));\n  Result := AbstractBinaryFileReadT(f, f.ElementType, ind, false);\nend;"
  },
  {
    "instruction": "Implement procedure for binary file initialization",
    "output": "procedure BinaryFileInit(var f: BinaryFile);\nbegin\n  f := new BinaryFile();\nend;"
  },
  {
    "instruction": "Implement function to read from binary file with element type",
    "output": "function BinaryFileRead(var f: BinaryFile; ElementType: System.Type): object;\nbegin\n  if f.fi = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_ASSIGNED));\n  if f.fs = nil then\n    raise new System.IO.IOException(GetTranslation(FILE_NOT_OPENED));\n  var ind := 0;\n  Result := AbstractBinaryFileReadT(f, ElementType, ind, false);\nend;"
  },
  {
    "instruction": "Implement function to convert disk number to disk name",
    "output": "function ConvertDiskToDiskName(disk: integer): string;\nbegin\n  if disk = 0 then\n  begin\n    var s := Paramstr(0);\n    var p := Pos(':', s);\n    if p > 0 then \n      Result := Copy(s, 1, p)\n    else Result := 'C:';\n  end\n  else\n  begin\n    if disk < 0 then disk := 0;\n    if disk > 26 then disk := 26;\n    var ch := 'A';\n    Inc(ch, disk - 1);\n    Result := ch + ':';\n  end;\nend;"
  },
  {
    "instruction": "Implement function to get disk free space by disk number",
    "output": "function DiskFree(disk: integer): int64;\nbegin\n  Result := DiskFree(ConvertDiskToDiskName(disk));\nend;"
  },
  {
    "instruction": "Implement function to get disk size by disk number",
    "output": "function DiskSize(disk: integer): int64;\nbegin\n  Result := DiskSize(ConvertDiskToDiskName(disk));\nend;"
  },
  {
    "instruction": "Implement function to get milliseconds delta",
    "output": "function MillisecondsDelta: integer;\nbegin\n  var t := DateTime.Now;\n  Result := Convert.ToInt32((t - curr_time).TotalMilliseconds);\n  curr_time := DateTime.Now;\nend;"
  },
  {
    "instruction": "Implement procedure to execute process with filename",
    "output": "procedure Execute(filename: string);\nbegin\n  System.Diagnostics.Process.Start(filename)\nend;"
  },
  {
    "instruction": "Implement procedure to execute process with filename and arguments",
    "output": "procedure Execute(filename: string; args: string) := System.Diagnostics.Process.Start(filename, args);"
  },
  {
    "instruction": "Implement function to change file name extension",
    "output": "function ChangeFileNameExtension(name, newext: string): string;\nbegin\n  Result := System.IO.Path.ChangeExtension(name, newext);\nend;"
  },
  {
    "instruction": "Implement function to extract file directory",
    "output": "function ExtractFileDir(fname: string): string;\nbegin\n  var fi := new System.IO.FileInfo(fname);\n  Result := fi.DirectoryName;\nend;"
  },
  {
    "instruction": "Implement function to extract file drive",
    "output": "function ExtractFileDrive(fname: string): string;\nbegin\n  try\n    var fi := new System.IO.FileInfo(fname);\n    Result := fi.DirectoryName;\n    var p := Pos(':', Result);\n    if p > 0 then\n      Result := Copy(Result, 1, p)\n    else Result := '';\n  except\n    on e: Exception do\n      raise e;\n  end;\nend;"
  },
  {
    "instruction": "Implement function to expand file name to full path",
    "output": "function ExpandFileName(fname: string): string;\nbegin\n  var fi := new System.IO.FileInfo(fname);\n  Result := fi.FullName;\nend;"
  },
  {
    "instruction": "Implement procedure to set string length for short strings",
    "output": "procedure SetLengthForShortString(var s: string; n, sz: integer);\nbegin\n  if n < 0 then\n    raise new System.ArgumentOutOfRangeException('n');\n  if n = 0 then\n    s := String.Empty\n  else if s.Length > n then\n    s := s.Substring(0, n)\n  else if s.Length < n then\n    if n <= sz then\n      s += new string(' ', n - s.Length)\n    else \n      s += new String(' ', sz - s.Length)\nend;"
  },
  {
    "instruction": "Implement procedure to insert into short string with length limit",
    "output": "procedure InsertInShortString(subs: string; var s: string; index, n: integer);\nbegin\n  if index < 1 then \n    index := 1;\n  if index > n then\n    exit;\n  try\n    s := s.Insert(index - 1, subs);\n    if s.Length > n then s := s.Substring(0, n);\n  except\n    s := s.Insert(s.Length, subs);\n    if s.Length > n then s := s.Substring(0, n);\n  end;\nend;"
  },
  {
    "instruction": "Implement procedure for string conversion from integer",
    "output": "procedure Str(i: integer; var s: string);\nbegin\n  s := i.ToString;\nend;"
  },
  {
    "instruction": "Implement procedure for string conversion from longword",
    "output": "procedure Str(i: longword; var s: string);\nbegin\n  s := i.ToString;\nend;"
  },
  {
    "instruction": "Implement procedure for string conversion from int64",
    "output": "procedure Str(i: int64; var s: string);\nbegin\n  s := i.ToString;\nend;"
  },
  {
    "instruction": "Implement procedure for string conversion from uint64",
    "output": "procedure Str(i: uint64; var s: string);\nbegin\n  s := i.ToString;\nend;"
  },
  {
    "instruction": "Implement procedure for string conversion from string",
    "output": "procedure Str(s1: string; var s: string);\nbegin\n  s := s1;\nend;"
  },
  {
    "instruction": "Implement procedure for string conversion from single",
    "output": "procedure Str(r: single; var s: string);\nbegin\n  s := Convert.ToString(r, nfi);\nend;"
  },
  {
    "instruction": "Implement procedure for string conversion from real",
    "output": "procedure Str(r: real; var s: string);\nbegin\n  s := Convert.ToString(r, nfi);\nend;"
  },
  {
    "instruction": "Implement function for string comparison",
    "output": "function CompareStr(s1, s2: string): Integer;\nbegin\n  Result := string.CompareOrdinal(s1, s2);\nend;"
  },
  {
    "instruction": "Implement function for string left trim",
    "output": "function TrimLeft(s: string): string;\nbegin\n  Result := s.TrimStart(' ');\nend;"
  },
  {
    "instruction": "Implement function for string right trim",
    "output": "function TrimRight(s: string): string;\nbegin\n  Result := s.TrimEnd(' ');\nend;"
  },
  {
    "instruction": "Implement function to get last position of substring in string",
    "output": "function LastPos(subs, s: string): integer;\nbegin\n  if (subs = nil) or (subs.Length = 0) then\n    Result := 0\n  else Result := s.LastIndexOf(subs, s.Length - 1, System.StringComparison.Ordinal) + 1;\nend;"
  },
  {
    "instruction": "Implement function to get last position of substring in string from specified index",
    "output": "function LastPos(subs, s: string; from: integer): integer;\nbegin\n  if (subs = nil) or (subs.Length = 0) or (from > s.Length) then\n    Result := 0\n  else Result := s.LastIndexOf(subs, from - 1, System.StringComparison.Ordinal) + 1;\nend;"
  },
  {
    "instruction": "Implement function to reverse string with specified index and length",
    "output": "function ReverseString(s: string; index,length: integer): string;\nbegin\n  var ca := s.ToCharArray;\n  &Array.Reverse(ca,index-1,length);\n  Result := new string(ca);\nend;"
  },
  {
    "instruction": "Implement procedure to reverse string in place with specified index and length",
    "output": "procedure Reverse(var s: string; index, count: integer);\nbegin\n  var cc := s.ToCharArray;\n  Reverse(cc,index-1,count);\n  s := new string(cc);\nend;"
  },
  {
    "instruction": "Implement procedure to sort array in descending order",
    "output": "procedure SortDescending<T>(a: array of T);\nbegin\n  Sort(a);\n  Reverse(a);\nend;"
  },
  {
    "instruction": "Implement procedure to sort list in descending order",
    "output": "procedure SortDescending<T>(l: List<T>);\nbegin\n  Sort(l);\n  Reverse(l);\nend;"
  },
  {
    "instruction": "Implement procedure to reverse array with specified index and count",
    "output": "procedure Reverse<T>(a: array of T; index, count: integer);\nbegin\n  System.Array.Reverse(a, index, count);\nend;"
  },
  {
    "instruction": "Implement procedure to reverse list with specified index and count",
    "output": "procedure Reverse<T>(a: List<T>; index, count: integer);\nbegin\n  a.Reverse(index, count)\nend;"
  },
  {
    "instruction": "Implement procedure to sort list with comparison function",
    "output": "procedure Sort<T>(l: List<T>; less: (T,T)->boolean);\nbegin\n  l.Sort((x, y)-> less(x, y) ? -1 : (less(y, x) ? 1 : 0));\nend;"
  },
  {
    "instruction": "Implement function for successor of byte",
    "output": "function Succ(x: byte): byte;\nbegin\n  Result := x + 1;\nend;"
  },
  {
    "instruction": "Implement function for successor of shortint",
    "output": "function Succ(x: shortint): shortint;\nbegin\n  Result := x + 1;\nend;"
  },
  {
    "instruction": "Implement function for successor of smallint",
    "output": "function succ(x: smallint): smallint;\nbegin\n  Result := x + 1;\nend;"
  },
  {
    "instruction": "Implement function for successor of word",
    "output": "function Succ(x: word): word;\nbegin\n  Result := x + 1;\nend;"
  },
  {
    "instruction": "Implement function for successor of longword",
    "output": "function Succ(x: longword): longword;\nbegin\n  Result := x + 1;\nend;"
  },
  {
    "instruction": "Implement function for successor of int64",
    "output": "function Succ(x: int64): int64;\nbegin\n  Result := x + 1;\nend;"
  },
  {
    "instruction": "Implement function for successor of uint64",
    "output": "function Succ(x: uint64): uint64;\nbegin\n  Result := x + 1;\nend;"
  },
  {
    "instruction": "Implement function for successor of character",
    "output": "function Succ(x: char): char;\nbegin\n  Result := char(integer(x)+1);\nend;"
  },
  {
    "instruction": "Implement function for sign of shortint",
    "output": "function Sign(x: shortint): integer := Math.Sign(x);"
  },
  {
    "instruction": "Implement function for sign of smallint",
    "output": "function Sign(x: smallint): integer := Math.Sign(x);"
  },
  {
    "instruction": "Implement function for sign of byte",
    "output": "function Sign(x: byte): integer := 1;"
  },
  {
    "instruction": "Implement function for sign of word",
    "output": "function Sign(x: word): integer := 1;"
  },
  {
    "instruction": "Implement function for sign of longword",
    "output": "function Sign(x: longword): integer := 1;"
  },
  {
    "instruction": "Implement function for sign of uint64",
    "output": "function Sign(x: uint64): integer := 1;"
  },
  {
    "instruction": "Implement function for absolute value of shortint",
    "output": "function Abs(x: shortint): shortint := Math.Abs(x);"
  },
  {
    "instruction": "Implement function for absolute value of smallint",
    "output": "function Abs(x: smallint): smallint := Math.Abs(x);"
  },
  {
    "instruction": "Implement function for absolute value of byte",
    "output": "function Abs(x: byte): byte := x;"
  },
  {
    "instruction": "Implement function for absolute value of word",
    "output": "function Abs(x: word): word := x;"
  },
  {
    "instruction": "Implement function for absolute value of longword",
    "output": "function Abs(x: longword): longword := x;"
  },
  {
    "instruction": "Implement function for absolute value of uint64",
    "output": "function Abs(x: uint64): uint64 := x;"
  },
  {
    "instruction": "Implement function for absolute value of single",
    "output": "function Abs(x: single): single := Math.Abs(x);"
  },
  {
    "instruction": "Implement function for square of shortint",
    "output": "function Sqr(x: shortint): integer := x * x;"
  },
  {
    "instruction": "Implement function for square of smallint",
    "output": "function Sqr(x: smallint): integer := x * x;"
  },
  {
    "instruction": "Implement function for square of byte",
    "output": "function Sqr(x: byte): integer := x * x;"
  },
  {
    "instruction": "Implement function for square of word",
    "output": "function Sqr(x: word): uint64 := uint64(x) * uint64(x);"
  },
  {
    "instruction": "Implement function for square of longword",
    "output": "function Sqr(x: longword): uint64 := uint64(x) * uint64(x);"
  },
  {
    "instruction": "Implement function for square of int64",
    "output": "function Sqr(x: int64): int64 := int64(x) * int64(x);"
  },
  {
    "instruction": "Implement function for square of uint64",
    "output": "function Sqr(x: uint64): uint64 := x * x;"
  },
  {
    "instruction": "Implement function for odd check of byte",
    "output": "function Odd(i: byte) := (i mod 2) <> 0;"
  },
  {
    "instruction": "Implement function for odd check of shortint",
    "output": "function Odd(i: shortint) := (i mod 2) <> 0;"
  },
  {
    "instruction": "Implement function for odd check of word",
    "output": "function Odd(i: word) := (i mod 2) <> 0;"
  },
  {
    "instruction": "Implement function for odd check of smallint",
    "output": "function Odd(i: smallint) := (i mod 2) <> 0;"
  },
  {
    "instruction": "Implement function for odd check of longword",
    "output": "function Odd(i: longword) := (i mod 2) <> 0;"
  },
  {
    "instruction": "Implement function for odd check of int64",
    "output": "function Odd(i: int64) := (i mod 2) <> 0;"
  },
  {
    "instruction": "Implement function for odd check of uint64",
    "output": "function Odd(i: uint64) := (i mod 2) <> 0;"
  },
  {
    "instruction": "Implement function for maximum of byte values",
    "output": "function Max(a, b: byte) := Math.Max(a, b);"
  },
  {
    "instruction": "Implement function for maximum of shortint values",
    "output": "function Max(a, b: shortint) := Math.Max(a, b);"
  },
  {
    "instruction": "Implement function for maximum of word values",
    "output": "function Max(a, b: word) := Math.Max(a, b);"
  },
  {
    "instruction": "Implement function for maximum of smallint values",
    "output": "function Max(a, b: smallint) := Math.Max(a, b);"
  },
  {
    "instruction": "Implement function for maximum of longword values",
    "output": "function Max(a, b: longword) := Math.Max(a, b);"
  },
  {
    "instruction": "Implement function for maximum of int64 values",
    "output": "function Max(a, b: int64) := Math.Max(a, b);"
  },
  {
    "instruction": "Implement function for maximum of uint64 values",
    "output": "function Max(a, b: uint64) := Math.Max(a, b);"
  },
  {
    "instruction": "Implement function for minimum of byte values",
    "output": "function Min(a, b: byte) := Math.Min(a, b);"
  },
  {
    "instruction": "Implement function for minimum of shortint values",
    "output": "function Min(a, b: shortint) := Math.Min(a, b);"
  },
  {
    "instruction": "Implement function for minimum of word values",
    "output": "function Min(a, b: word) := Math.Min(a, b);"
  },
  {
    "instruction": "Implement function for minimum of smallint values",
    "output": "function Min(a, b: smallint) := Math.Min(a, b);"
  },
  {
    "instruction": "Implement function for minimum of longword values",
    "output": "function Min(a, b: longword) := Math.Min(a, b);"
  },
  {
    "instruction": "Implement function for minimum of int64 values",
    "output": "function Min(a, b: int64) := Math.Min(a, b);"
  },
  {
    "instruction": "Implement function for minimum of uint64 values",
    "output": "function Min(a, b: uint64) := Math.Min(a, b);"
  },
  {
    "instruction": "Implement function for ordinal value of integer",
    "output": "function Ord(a: integer): integer;\nbegin\n  Result := a;\nend;"
  },
  {
    "instruction": "Implement function for ordinal value of longword",
    "output": "function Ord(a: longword): longword;\nbegin\n  Result := a;\nend;"
  },
  {
    "instruction": "Implement function for ordinal value of int64",
    "output": "function Ord(a: int64): int64;\nbegin\n  Result := a;\nend;"
  },
  {
    "instruction": "Implement function for ordinal value of uint64",
    "output": "function Ord(a: uint64): uint64;\nbegin\n  Result := a;\nend;"
  },
  {
    "instruction": "Implement function for ordinal value of boolean",
    "output": "function Ord(a: boolean): integer;\nbegin\n  Result := integer(a);\nend;"
  },
  {
    "instruction": "Implement function for character uppercase (alternative name)",
    "output": "function UpCase(ch: char): char;\nbegin\n  Result := char.ToUpper(ch);\nend;"
  },
  {
    "instruction": "Implement function for character lowercase (alternative name)",
    "output": "function LowCase(ch: char): char;\nbegin\n  Result := char.ToLower(ch);\nend;"
  },
  {
    "instruction": "Implement a Pred function for boolean type that returns the logical negation",
    "output": "function Pred(x: boolean): boolean;\nbegin\n  Result := not x;\nend;"
  },
  {
    "instruction": "Implement a Pred function for byte type that returns the previous value",
    "output": "function Pred(x: byte): byte;\nbegin\n  Result := x - 1;\nend;"
  },
  {
    "instruction": "Implement a Pred function for char type that returns the previous character",
    "output": "function Pred(x: char): char;\nbegin\n  Result := char(integer(x)-1);\nend;"
  },
  {
    "instruction": "Implement a generic Swap procedure that exchanges values of two variables",
    "output": "procedure Swap<T>(var a, b: T);\nbegin\n  var v := a;\n  a := b;\n  b := v;\nend;"
  },
  {
    "instruction": "Implement an extension method that generates an infinite recurrent sequence starting from initial element using next function",
    "output": "function Iterate<T>(Self: T; next: T->T): sequence of T; extensionmethod;\nbegin\n  Result := Iterate&<T>(Self, next);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns infinite sequence of integers starting from current value with step 1",
    "output": "function Step(Self: integer): sequence of integer; extensionmethod;\nbegin\n  while True do\n  begin\n    yield Self;\n    Self += 1;\n  end;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns infinite sequence of integers starting from current value with specified step",
    "output": "function Step(Self: integer; step: integer): sequence of integer; extensionmethod;\nbegin\n  while True do\n  begin\n    yield Self;\n    Self += step;\n  end;\nend;"
  },
  {
    "instruction": "Implement an extension method that repeats sequence infinite number of times",
    "output": "function Cycle<T>(Self: sequence of T): sequence of T; extensionmethod;\nbegin\n  while True do\n  begin\n    foreach var x in Self do\n      yield x;\n  end;\nend;"
  },
  {
    "instruction": "Implement an extension method Print for integer type that outputs value followed by space",
    "output": "function Print(Self: integer): integer; extensionmethod;\nbegin\n  PABCSystem.Print(Self);\n  Result := Self;\nend;"
  },
  {
    "instruction": "Implement an extension method Println for integer type that outputs value and moves to new line",
    "output": "function Println(Self: integer): integer; extensionmethod;\nbegin\n  PABCSystem.Println(Self);\n  Result := Self;\nend;"
  },
  {
    "instruction": "Implement an extension method that prints sequence using specified delimiter",
    "output": "function Print<T>(Self: sequence of T; delim: string): sequence of T; extensionmethod;\nbegin\n  var g := Self.GetEnumerator();\n  if g.MoveNext() then\n  begin  \n    Write(g.Current);\n    while g.MoveNext() do\n      if delim <> '' then\n        Write(delim, g.Current)\n      else Write(g.Current);\n  end;  \n  Result := Self; \nend;"
  },
  {
    "instruction": "Implement an extension method that joins sequence elements into string using specified delimiter",
    "output": "function JoinToString<T>(Self: sequence of T; delim: string): string; extensionmethod;\nbegin\n  var g := Self.GetEnumerator();\n  var sb := new System.Text.StringBuilder('');\n  if g.MoveNext() then\n  begin\n    sb.Append(g.Current.ToString());\n    while g.MoveNext() do \n      sb.Append(delim + g.Current.ToString());\n  end;  \n  Result := sb.ToString;  \nend;"
  },
  {
    "instruction": "Implement an extension method that applies action to each element of sequence",
    "output": "procedure &ForEach<T>(Self: sequence of T; action: T -> ()); extensionmethod;\nbegin\n  foreach x: T in Self do\n    action(x);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns product of sequence elements",
    "output": "function Product(Self: sequence of real): real; extensionmethod;\nbegin\n  Result := 1.0;\n  foreach var x in Self do\n    Result *= x;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns sorted sequence in ascending order",
    "output": "function Sorted<T>(Self: sequence of T): sequence of T; extensionmethod;\nbegin\n  Result := Self.OrderBy(x -> x);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns first element of sequence with minimal key value",
    "output": "function MinBy<T, TKey>(Self: sequence of T; selector: T->TKey): T; extensionmethod;\nbegin\n  if selector = nil then\n    raise new ArgumentNullException('selector');\n  \n  var comp := Comparer&<TKey>.Default;\n  Result := Self.Aggregate((min, x)-> comp.Compare(selector(x), selector(min)) < 0 ? x : min);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns last count elements of sequence",
    "output": "function TakeLast<T>(Self: sequence of T; count: integer): sequence of T; extensionmethod;\nbegin\n  Result := Self.Reverse.Take(count).Reverse;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns Cartesian product of two sequences as sequence of pairs",
    "output": "function Cartesian<T, T1>(Self: sequence of T; b: sequence of T1): sequence of (T, T1); extensionmethod;\nbegin\n  if b = nil then\n    raise new System.ArgumentNullException('b');\n  \n  foreach var x in Self do\n    foreach var y in b do\n      yield (x, y)\nend;"
  },
  {
    "instruction": "Implement an extension method that splits sequence into two at specified position",
    "output": "function SplitAt<T>(Self: sequence of T; ind: integer): (sequence of T, sequence of T); extensionmethod;\nbegin\n  Result := (Self.Take(ind), Self.Skip(ind));\nend;"
  },
  {
    "instruction": "Implement an extension method that partitions sequence into two based on condition",
    "output": "function Partition<T>(Self: sequence of T; cond: T->boolean): (sequence of T, sequence of T); extensionmethod;\nbegin\n  Result := (Self.Where(cond), Self.Where(x -> not cond(x)));\nend;"
  },
  {
    "instruction": "Implement an extension method that interleaves elements of two sequences",
    "output": "function Interleave<T>(Self: sequence of T; a: sequence of T): sequence of T; extensionmethod;\nbegin\n  if a = nil then\n    raise new System.ArgumentNullException('a');\n  Result := Self.ZipTuple(a).SelectMany(x -> Seq(x[0], x[1]))\nend;"
  },
  {
    "instruction": "Implement an extension method that numerates sequence starting from 1",
    "output": "function Numerate<T>(Self: sequence of T): sequence of (integer, T); extensionmethod;\nbegin\n  var i := 1;\n  foreach var x in Self do\n  begin\n    yield (i,x);\n    i += 1;\n  end;  \nend;"
  },
  {
    "instruction": "Implement an extension method that transforms sequence into sequence of pairs of adjacent elements",
    "output": "function Pairwise<T>(Self: sequence of T): sequence of (T, T); extensionmethod;\nbegin\n  var previous: T;\n  var it := Self.GetEnumerator();\n  if (it.MoveNext()) then\n    previous := it.Current;\n  \n  while (it.MoveNext()) do\n  begin\n    yield (previous, it.Current);\n    previous := it.Current;\n  end\nend;"
  },
  {
    "instruction": "Implement an extension method that returns sequence of differences between adjacent elements",
    "output": "function Incremental(Self: sequence of integer): sequence of integer; extensionmethod;\nbegin\n  Result := IncrementalSeq(Self);\nend;"
  },
  {
    "instruction": "Implement an extension method that groups consecutive identical elements",
    "output": "function AdjacentGroup<T>(Self: sequence of T): sequence of array of T; extensionmethod;\nbegin\n  var c := new AdjGroupClass<T>(Self);\n  while c.fin do\n    yield c.TakeGroup().ToArray;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns count of elements equal to specified value",
    "output": "function CountOf<T>(Self: sequence of T; x: T): integer; extensionmethod;\nbegin\n  Result := 0;\n  foreach var y in Self do\n    if y = x then\n      Result += 1;\nend;"
  },
  {
    "instruction": "Implement an extension method that shuffles list elements randomly",
    "output": "function Shuffle<T>(Self: List<T>): List<T>; extensionmethod;\nbegin\n  var n := Self.Count;\n  for var i := 0 to n - 1 do\n  begin\n    var r := Random(n);\n    var v := Self[i];\n    Self[i] := Self[r];\n    Self[r] := v;\n  end;\n  Result := Self;  \nend;"
  },
  {
    "instruction": "Implement an extension method that finds first pair of consecutive identical elements and returns index of first element",
    "output": "function AdjacentFind<T>(Self: IList<T>; start: integer := 0): integer; extensionmethod;\nbegin\n  Result := -1;\n  for var i := start to Self.Count - 2 do\n    if Self[i] = Self[i + 1] then \n    begin\n      Result := i;\n      exit;\n    end;\nend;"
  },
  {
    "instruction": "Implement an extension method that replaces all occurrences of old value with new value in list",
    "output": "procedure Replace<T>(Self: List<T>; oldValue, newValue: T); extensionmethod;\nbegin\n  for var i := 0 to Self.Count - 1 do\n    if Self[i] = oldValue then\n      Self[i] := newValue;\nend;"
  },
  {
    "instruction": "Implement an extension method that transforms list elements using specified function",
    "output": "procedure Transform<T>(Self: List<T>; f: T->T); extensionmethod;\nbegin\n  for var i := 0 to Self.Count - 1 do\n    Self[i] := f(Self[i]);\nend;"
  },
  {
    "instruction": "Implement an extension method that fills list elements with specified value",
    "output": "procedure Fill<T>(Self: List<T>; x: T); extensionmethod;\nbegin\n  for var i := 0 to Self.Count - 1 do\n    Self[i] := x;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns number of rows in 2D array",
    "output": "function RowCount<T>(Self: array [,] of T): integer; extensionmethod;\nbegin\n  Result := Self.GetLength(0);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns number of columns in 2D array",
    "output": "function ColCount<T>(Self: array [,] of T): integer; extensionmethod;\nbegin\n  Result := Self.GetLength(1);\nend;"
  },
  {
    "instruction": "Implement an extension method that prints 2D array with specified field width",
    "output": "function Print<T>(Self: array [,] of T; w: integer := 4): array [,] of T; extensionmethod;\nbegin\n  for var i := 0 to Self.RowCount - 1 do\n  begin\n    for var j := 0 to Self.ColCount - 1 do\n    begin\n      if PrintMatrixWithFormat then\n        Write(StructuredObjectToString(Self[i, j]).PadLeft(w))\n      else Print(Self[i, j]);\n    end;\n    Writeln;  \n  end;\n  Result := Self;  \nend;"
  },
  {
    "instruction": "Implement an extension method that returns k-th row of 2D array",
    "output": "function Row<T>(Self: array [,] of T; k: integer): array of T; extensionmethod;\nbegin\n  var n := Self.ColCount;\n  var res := new T[n];\n  for var j := 0 to n - 1 do\n    res[j] := Self[k, j];\n  Result := res;\nend;"
  },
  {
    "instruction": "Implement an extension method that swaps two rows in 2D array",
    "output": "procedure SwapRows<T>(Self: array [,] of T; k1, k2: integer); extensionmethod;\nbegin\n  for var j := 0 to Self.ColCount - 1 do\n    Swap(Self[k1, j], Self[k2, j])\nend;"
  },
  {
    "instruction": "Implement an extension method that sets k-th row of 2D array to specified array",
    "output": "procedure SetRow<T>(Self: array [,] of T; k: integer; a: array of T); extensionmethod;\nbegin\n  if a.Length <> Self.ColCount then\n    raise new System.ArgumentException(GetTranslation(ARR_LENGTH_MUST_BE_MATCH_TO_MATR_SIZE));\n  for var j := 0 to Self.ColCount - 1 do\n    Self[k, j] := a[j]\nend;"
  },
  {
    "instruction": "Implement an extension method that transforms elements of 2D array using specified function",
    "output": "procedure Transform<T>(Self: array [,] of T; f: T->T); extensionmethod;\nbegin\n  for var i := 0 to Self.RowCount - 1 do\n    for var j := 0 to Self.ColCount - 1 do\n      Self[i, j] := f(Self[i, j]);\nend;"
  },
  {
    "instruction": "Implement an extension method that fills array with random values in specified range",
    "output": "procedure FillRandom(Self: array of integer; a,b: integer); extensionmethod;\nbegin\n  for var i:=0 to Self.Length-1 do\n    Self[i] := Random(a,b);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns random element from array",
    "output": "function RandomElement<T>(Self: array of T): T; extensionmethod;\nbegin\n  Result := Self[Random(Self.Length)];  \nend;"
  },
  {
    "instruction": "Implement an extension method that returns minimal element of array",
    "output": "function Min<T>(Self: array of T): T; extensionmethod; where T: System.IComparable<T>;\nbegin\n  Result := Self[0];\n  for var i := 1 to Self.Length - 1 do\n    if Self[i].CompareTo(Result) < 0 then \n      Result := Self[i];\nend;"
  },
  {
    "instruction": "Implement an extension method that returns index of first minimal element starting from specified position",
    "output": "function IndexMin<T>(Self: array of T; index: integer := 0): integer; extensionmethod; where T: IComparable<T>;\nbegin\n  var min := Self[index];\n  Result := index;\n  for var i := index + 1 to Self.Count - 1 do\n    if Self[i].CompareTo(min) < 0 then \n    begin\n      Result := i;\n      min := Self[i];\n    end;\nend;"
  },
  {
    "instruction": "Implement an extension method that fills array elements with specified value",
    "output": "procedure Fill<T>(Self: array of T; x: T); extensionmethod;\nbegin\n  for var i := 0 to Self.Length - 1 do\n    Self[i] := x;\nend;"
  },
  {
    "instruction": "Implement an extension method that transforms array elements using specified function",
    "output": "procedure Transform<T>(Self: array of T; f: T->T); extensionmethod;\nbegin\n  for var i := 0 to Self.Length - 1 do\n    Self[i] := f(Self[i]);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns all combinations of m elements from array",
    "output": "function Combinations<T>(Self: array of T; m: integer): sequence of array of T; extensionmethod;\nbegin\n  var res := new T[m];\n  var a := Self;\n  var n := a.Length;\n  var ind := Arr(0..n-1);\n  repeat\n    for var i:=0 to m-1 do\n      res[i] := a[ind[i]];\n    yield Arr(res);\n  until not NextCombHelper(ind,m,n);  \nend;"
  },
  {
    "instruction": "Implement an extension method that returns all permutations of array elements",
    "output": "function Permutations<T>(Self: array of T): sequence of array of T; extensionmethod;\nbegin\n  var a := Self;\n  var n := a.Length;\n  var res := new T[n];\n  var ind := Arr(0..n-1);\n  repeat\n    for var i:=0 to n-1 do\n      res[i] := a[ind[i]];\n    yield Arr(res);\n  until not NextPermutation(ind);  \nend;"
  },
  {
    "instruction": "Implement an extension method that checks if integer is divisible by specified value",
    "output": "function Divs(Self,d: integer): boolean; extensionmethod := Self mod d = 0;"
  },
  {
    "instruction": "Implement an extension method that checks if integer is even",
    "output": "function IsEven(Self: integer): boolean; extensionmethod;\nbegin\n  Result := Self mod 2 = 0;\nend;"
  },
  {
    "instruction": "Implement an extension method that generates sequence of integers from 1 to current value",
    "output": "function Range(Self: integer): sequence of integer; extensionmethod;\nbegin\n  Result := Range(1, Self);  \nend;"
  },
  {
    "instruction": "Implement an extension method that generates sequence of integers from current value to n",
    "output": "function &To(Self: integer; n: integer): sequence of integer; extensionmethod;\nbegin\n  Result := Range(Self, n);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns square root of real number",
    "output": "function Sqrt(Self: real): real; extensionmethod;\nbegin\n  Result := Sqrt(Self);\nend;"
  },
  {
    "instruction": "Implement an extension method that rounds real number to nearest integer",
    "output": "function Round(Self: real): integer; extensionmethod;\nbegin\n  Result := Round(Self);\nend;"
  },
  {
    "instruction": "Implement an extension method that checks if character is digit",
    "output": "function IsDigit(Self: char); extensionmethod := char.IsDigit(Self);"
  },
  {
    "instruction": "Implement an extension method that converts character to lowercase",
    "output": "function ToLower(Self: char): char; extensionmethod;\nbegin\n  Result := char.ToLower(Self);\nend;"
  },
  {
    "instruction": "Implement an extension method that converts string to integer",
    "output": "function ToInteger(Self: string): integer; extensionmethod := StrToInt(Self);"
  },
  {
    "instruction": "Implement an extension method that converts string to real number",
    "output": "function ToReal(Self: string): real; extensionmethod := real.Parse(Self, nfi);"
  },
  {
    "instruction": "Implement an extension method that splits string into words using specified delimiters",
    "output": "function ToWords(Self: string; params delim: array of char): array of string; extensionmethod;\nbegin\n  Result := Self.Split(delim, System.StringSplitOptions.RemoveEmptyEntries);\nend;"
  },
  {
    "instruction": "Implement an extension method that converts string to array of integers",
    "output": "function ToIntegers(Self: string): array of integer; extensionmethod;\nbegin\n  var l := new List<integer>(10);\n  var from := 1;\n  while from <= Self.Length do\n  begin\n    l.Add(ReadIntegerFromString(Self,from));\n    PassSpaces(Self,from);\n  end;  \n  Result := l.ToArray;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns string inversion",
    "output": "function Inverse(Self: string): string; extensionmethod;\nbegin\n  var sb := new System.Text.StringBuilder(Self.Length);\n  for var i := Self.Length downto 1 do\n    sb.Append(Self[i]);\n  Result := sb.ToString;\nend;"
  },
  {
    "instruction": "Implement an extension method that replaces all occurrences of regular expression in string",
    "output": "function RegexReplace(Self: string; reg, repl: string; options: RegexOptions := RegexOptions.None): string; extensionmethod;\nbegin\n  Result := Regex.Replace(Self, reg, repl, options)\nend;"
  },
  {
    "instruction": "Implement an extension method that finds all matches of regular expression in string",
    "output": "function Matches(Self: string; reg: string; options: RegexOptions := RegexOptions.None): sequence of &Match; extensionmethod;\nbegin\n  Result := (new Regex(reg, options)).Matches(Self).Cast&<&Match>();\nend;"
  },
  {
    "instruction": "Implement an extension method that composes two functions",
    "output": "function Compose<T1, T2, TResult>(Self: T2->TResult; composer: T1->T2): T1->TResult; extensionmethod;\nbegin\n  if composer = nil then\n    raise new System.ArgumentNullException('composer');\n  var Slf := Self;\n  Result := x -> Slf(composer(x));\nend;"
  },
  {
    "instruction": "Implement an extension method that gets value from dictionary by key with default value if key not found",
    "output": "function Get<Key, Value>(Self: IDictionary<Key, Value>; K: Key): Value; extensionmethod;\nbegin\n  var b := Self.TryGetValue(K, Result);\n  if not b then \n    Result := default(Value);\nend;"
  },
  {
    "instruction": "Implement a function that creates 2D array from array of arrays by rows",
    "output": "function MatrByRow<T>(a: array of array of T): array [,] of T;\nbegin\n  var m := a.Length;\n  var n := if m = 0 then 0 else a.Max(aa -> aa.Length);\n  var res := new T[m,n];\n  for var i := 0 to m - 1 do\n  for var j := 0 to a[i].Length-1 do\n    res[i,j] := a[i][j];\n  Result := res;\nend;"
  },
  {
    "instruction": "Implement a function that creates 2D array from sequence of sequences by rows",
    "output": "function MatrByRow<T>(a: sequence of sequence of T): array [,] of T;\nbegin\n  var m := a.Count;\n  var n := if m = 0 then 0 else a.First.Count;\n  var res := new T[m,n];\n  var i := 0;\n  foreach var aa in a do\n  begin\n    var j := 0;  \n    foreach var x in aa do\n    begin  \n      res[i,j] := x;\n      j += 1;\n    end;  \n    i += 1;    \n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Implement a function that creates 2D array with random integer values",
    "output": "function MatrRandom(m: integer; n: integer; a, b: integer): array [,] of integer;\nbegin\n  Result := new integer[m, n];\n  for var i := 0 to Result.RowCount - 1 do\n    for var j := 0 to Result.ColCount - 1 do\n      Result[i, j] := Random(a, b);\nend;"
  },
  {
    "instruction": "Implement a function that creates 2D array filled with specified value",
    "output": "function MatrFill<T>(m, n: integer; x: T): array [,] of T;\nbegin\n  Result := new T[m, n];\n  for var i := 0 to Result.RowCount - 1 do\n    for var j := 0 to Result.ColCount - 1 do\n      Result[i, j] := x;\nend;"
  },
  {
    "instruction": "Implement a function that transposes 2D array",
    "output": "function Transpose<T>(a: array [,] of T): array [,] of T;\nbegin\n  var m := a.RowCount;\n  var n := a.ColCount;\n  Result := new T[n, m];\n  for var i := 0 to Result.RowCount - 1 do\n    for var j := 0 to Result.ColCount - 1 do\n      Result[i, j] := a[j, i]\nend;"
  },
  {
    "instruction": "Implement a Pred function for shortint type that returns the previous value",
    "output": "function Pred(x: shortint): shortint;\nbegin\n  Result := x - 1;\nend;"
  },
  {
    "instruction": "Implement a Pred function for smallint type that returns the previous value",
    "output": "function Pred(x: smallint): smallint;\nbegin\n  Result := x - 1;\nend;"
  },
  {
    "instruction": "Implement a Pred function for word type that returns the previous value",
    "output": "function Pred(x: word): word;\nbegin\n  Result := x - 1;\nend;"
  },
  {
    "instruction": "Implement a Pred function for longword type that returns the previous value",
    "output": "function Pred(x: longword): longword;\nbegin\n  Result := x - 1;\nend;"
  },
  {
    "instruction": "Implement a Pred function for int64 type that returns the previous value",
    "output": "function Pred(x: int64): int64;\nbegin\n  Result := x - 1;\nend;"
  },
  {
    "instruction": "Implement a Pred function for uint64 type that returns the previous value",
    "output": "function Pred(x: uint64): uint64;\nbegin\n  Result := x - 1;\nend;"
  },
  {
    "instruction": "Implement a Pred function for char type with step parameter that returns character shifted by n positions",
    "output": "function Pred(x: char; n: integer): char;\nbegin\n  Result := char(integer(x)-n);\nend;"
  },
  {
    "instruction": "Implement an extension method that generates infinite recurrent sequence from initial and second elements using next function",
    "output": "function Iterate<T>(Self, second: T; next: (T,T) ->T): sequence of T; extensionmethod;\nbegin\n  Result := Iterate&<T>(Self, second, next);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns infinite sequence of real numbers starting from current value with specified step",
    "output": "function Step(Self: real; step: real): sequence of real; extensionmethod;\nbegin\n  while True do\n  begin\n    yield Self;\n    Self += step;\n  end;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns infinite sequence of elements equal to current element",
    "output": "function &Repeat<T>(Self: T): sequence of T; extensionmethod;\nbegin\n  while True do\n    yield Self;\nend;"
  },
  {
    "instruction": "Implement an extension method Print for int64 type that outputs value followed by space",
    "output": "function Print(Self: int64): int64; extensionmethod;\nbegin\n  PABCSystem.Print(Self);\n  Result := Self;\nend;"
  },
  {
    "instruction": "Implement an extension method Print for real type that outputs value followed by space",
    "output": "function Print(Self: real): real; extensionmethod;\nbegin\n  PABCSystem.Print(Self);\n  Result := Self;\nend;"
  },
  {
    "instruction": "Implement an extension method Print for char type that outputs value followed by space",
    "output": "function Print(Self: char): char; extensionmethod;\nbegin\n  PABCSystem.Print(Self);\n  Result := Self;\nend;"
  },
  {
    "instruction": "Implement an extension method Print for boolean type that outputs value followed by space",
    "output": "function Print(Self: boolean): boolean; extensionmethod;\nbegin\n  PABCSystem.Print(Self);\n  Result := Self;\nend;"
  },
  {
    "instruction": "Implement an extension method Print for BigInteger type that outputs value followed by space",
    "output": "function Print(Self: BigInteger): BigInteger; extensionmethod;\nbegin\n  PABCSystem.Print(Self);\n  Result := Self;\nend;"
  },
  {
    "instruction": "Implement an extension method Print for string type that outputs value followed by space",
    "output": "function Print(Self: string): string; extensionmethod;\nbegin\n  PABCSystem.Print(Self);\n  Result := Self;\nend;"
  },
  {
    "instruction": "Implement an extension method Println for int64 type that outputs value and moves to new line",
    "output": "function Println(Self: int64): int64; extensionmethod;\nbegin\n  PABCSystem.Println(Self);\n  Result := Self;\nend;"
  },
  {
    "instruction": "Implement an extension method Println for real type that outputs value and moves to new line",
    "output": "function Println(Self: real): real; extensionmethod;\nbegin\n  PABCSystem.Println(Self);\n  Result := Self;\nend;"
  },
  {
    "instruction": "Implement an extension method Println for char type that outputs value and moves to new line",
    "output": "function Println(Self: char): char; extensionmethod;\nbegin\n  PABCSystem.Println(Self);\n  Result := Self;\nend;"
  },
  {
    "instruction": "Implement an extension method Println for boolean type that outputs value and moves to new line",
    "output": "function Println(Self: boolean): boolean; extensionmethod;\nbegin\n  PABCSystem.Println(Self);\n  Result := Self;\nend;"
  },
  {
    "instruction": "Implement an extension method Println for BigInteger type that outputs value and moves to new line",
    "output": "function Println(Self: BigInteger): BigInteger; extensionmethod;\nbegin\n  PABCSystem.Println(Self);\n  Result := Self;\nend;"
  },
  {
    "instruction": "Implement an extension method Println for string type that outputs value and moves to new line",
    "output": "function Println(Self: string): string; extensionmethod;\nbegin\n  PABCSystem.Println(Self);\n  Result := Self;\nend;"
  },
  {
    "instruction": "Implement an extension method that prints sequence using space as delimiter",
    "output": "function Print<T>(Self: sequence of T): sequence of T; extensionmethod;\nbegin\n  if typeof(T) = typeof(char) then \n    Result := Self.Print('')\n  else  \n    Result := Self.Print(PrintDelimDefault);  \nend;"
  },
  {
    "instruction": "Implement an extension method that prints sequence using specified delimiter and moves to new line",
    "output": "function Println<T>(Self: sequence of T; delim: string): sequence of T; extensionmethod;\nbegin\n  Self.Print(delim);\n  Writeln;\n  Result := Self;  \nend;"
  },
  {
    "instruction": "Implement an extension method that writes sequence of strings to file",
    "output": "function WriteLines(Self: sequence of string; fname: string): sequence of string; extensionmethod;\nbegin\n  WriteLines(fname, Self);\n  Result := Self\nend;"
  },
  {
    "instruction": "Implement an extension method that prints sequence with each element on new line",
    "output": "function PrintLines<T>(Self: sequence of T): sequence of T; extensionmethod;\nbegin\n  Self.Println(NewLine);\n  Result := Self\nend;"
  },
  {
    "instruction": "Implement an extension method that prints sequence with elements transformed by map function, each on new line",
    "output": "function PrintLines<T,T1>(Self: sequence of T; map: T->T1): sequence of T; extensionmethod;\nbegin\n  Self.Select(map).Println(NewLine);\n  Result := Self\nend;"
  },
  {
    "instruction": "Implement an extension method that applies action to each element of sequence with index",
    "output": "procedure &ForEach<T>(Self: sequence of T; action: (T,integer) -> ()); extensionmethod;\nbegin\n  var i := 0;\n  foreach x: T in Self do\n  begin\n    action(x, i);\n    i += 1;\n  end;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns product of integer sequence elements",
    "output": "function Product(Self: sequence of integer): int64; extensionmethod;\nbegin\n  Result := 1;\n  foreach var x in Self do\n    Result *= x;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns product of sequence elements projected to numeric value",
    "output": "function Product<T>(Self: sequence of T; f: T->real): real; extensionmethod;\nbegin\n  Result := 1.0;\n  foreach var x in Self do\n    Result *= f(x);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns product of sequence elements projected to integer value",
    "output": "function Product<T>(Self: sequence of T; f: T->integer): int64; extensionmethod;\nbegin\n  Result := 1;\n  foreach var x in Self do\n    Result *= f(x);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns product of sequence elements projected to BigInteger value",
    "output": "function Product<T>(Self: sequence of T; f: T->BigInteger): BigInteger; extensionmethod;\nbegin\n  Result := 1;\n  foreach var x in Self do\n    Result *= f(x);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns sum of BigInteger sequence elements",
    "output": "function Sum(Self: sequence of BigInteger): BigInteger; extensionmethod;\nbegin\n  Result := 0bi;\n  foreach var a in Self do\n    Result += a\nend;"
  },
  {
    "instruction": "Implement an extension method that returns average of BigInteger sequence elements",
    "output": "function Average(Self: sequence of BigInteger): real; extensionmethod;\nbegin\n  var cnt := 0;\n  var sum := 0bi;\n  foreach var a in Self do\n  begin\n    sum += a;\n    cnt += 1;\n  end;  \n  if cnt <> 0 then \n    Result := sum/cnt\n  else Result := 0\nend;"
  },
  {
    "instruction": "Implement an extension method that returns product of BigInteger sequence elements",
    "output": "function Product(Self: sequence of BigInteger): BigInteger; extensionmethod;\nbegin\n  Result := 1bi;\n  foreach var a in Self do\n    Result *= a\nend;"
  },
  {
    "instruction": "Implement an extension method that returns sequence sorted in descending order",
    "output": "function SortedDescending<T>(Self: sequence of T): sequence of T; extensionmethod;\nbegin\n  Result := Self.OrderByDescending(x -> x);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns sequence sorted in ascending order (alias for Sorted)",
    "output": "function Order<T>(Self: sequence of T): sequence of T; extensionmethod;\nbegin\n  Result := Self.OrderBy(x -> x);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns sequence sorted in descending order (alias for SortedDescending)",
    "output": "function OrderDescending<T>(Self: sequence of T): sequence of T; extensionmethod;\nbegin\n  Result := Self.OrderByDescending(x -> x);\nend;"
  },
  {
    "instruction": "Implement an extension method that converts sequence to HashSet",
    "output": "function ToHashSet<T>(Self: sequence of T): HashSet<T>; extensionmethod;\nbegin\n  Result := new HashSet<T>(Self);\nend;"
  },
  {
    "instruction": "Implement an extension method that converts sequence to SortedSet",
    "output": "function ToSortedSet<T>(Self: sequence of T): SortedSet<T>; extensionmethod;\nbegin\n  Result := new SortedSet<T>(Self);\nend;"
  },
  {
    "instruction": "Implement an extension method that converts sequence to LinkedList",
    "output": "function ToLinkedList<T>(Self: sequence of T): LinkedList<T>; extensionmethod;\nbegin\n  Result := new LinkedList<T>(Self);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns last element of sequence with minimal key value",
    "output": "function LastMinBy<T, TKey>(Self: sequence of T; selector: T->TKey): T; extensionmethod;\nbegin\n  if selector = nil then\n    raise new ArgumentNullException('selector');\n  \n  var comp := Comparer&<TKey>.Default;\n  Result := Self.Aggregate((min, x)-> comp.Compare(selector(x), selector(min)) <= 0 ? x : min);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns last element of sequence with maximal key value",
    "output": "function LastMaxBy<T, TKey>(Self: sequence of T; selector: T->TKey): T; extensionmethod;\nbegin\n  if selector = nil then\n    raise new ArgumentNullException('selector');\n  \n  var comp := Comparer&<TKey>.Default;\n  Result := Self.Aggregate((max, x)-> comp.Compare(selector(x), selector(max)) >= 0 ? x : max);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns sequence without last count elements",
    "output": "function SkipLast<T>(self: sequence of T; count: integer := 1): sequence of T; extensionmethod;\nbegin\n  Result := Self.Reverse.Skip(count).Reverse;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns Cartesian product of sequences projecting each pair to value",
    "output": "function Cartesian<T, T1, T2>(Self: sequence of T; b: sequence of T1; func: (T,T1)->T2): sequence of T2; extensionmethod;\nbegin\n  if b = nil then\n    raise new System.ArgumentNullException('b');\n  \n  foreach var x in Self do\n    foreach var y in b do\n      yield func(x, y)\nend;"
  },
  {
    "instruction": "Implement an extension method that partitions sequence into two based on condition with index",
    "output": "function Partition<T>(Self: sequence of T; cond: (T,integer)->boolean): (sequence of T, sequence of T); extensionmethod;\nbegin\n  Result := (Self.Where(cond), Self.Where((x, i) -> not cond(x, i)));\nend;"
  },
  {
    "instruction": "Implement an extension method that combines two sequences into sequence of two-element tuples",
    "output": "function ZipTuple<T, T1>(Self: sequence of T; a: sequence of T1): sequence of (T, T1); extensionmethod;\nbegin\n  if a = nil then\n    raise new System.ArgumentNullException('a');\n  Result := Self.Zip(a, (x, y) -> (x, y));\nend;"
  },
  {
    "instruction": "Implement an extension method that combines three sequences into sequence of three-element tuples",
    "output": "function ZipTuple<T, T1, T2>(Self: sequence of T; a: sequence of T1; b: sequence of T2): sequence of (T, T1, T2); extensionmethod;\nbegin\n  if a = nil then\n    raise new System.ArgumentNullException('a');\n  if b = nil then\n    raise new System.ArgumentNullException('b');\n  Result := Self.Zip(a, (x, y) -> (x, y)).Zip(b, (p, z) -> (p[0], p[1], z));\nend;"
  },
  {
    "instruction": "Implement an extension method that combines four sequences into sequence of four-element tuples",
    "output": "function ZipTuple<T, T1, T2, T3>(Self: sequence of T; a: sequence of T1; b: sequence of T2; c: sequence of T3): sequence of (T, T1, T2, T3); extensionmethod;\nbegin\n  if a = nil then\n    raise new System.ArgumentNullException('a');\n  if b = nil then\n    raise new System.ArgumentNullException('b');\n  if c = nil then\n    raise new System.ArgumentNullException('c');\n  Result := Self.Zip(a, (x, y)-> (x, y)).Zip(b, (p, z)-> (p[0], p[1], z)).Zip(c, (p, z)-> (p[0], p[1], p[2], z));\nend;"
  },
  {
    "instruction": "Implement an extension method that splits sequence of two-element tuples into two sequences",
    "output": "function UnZipTuple<T, T1>(Self: sequence of (T, T1)): (sequence of T, sequence of T1); extensionmethod;\nbegin\n  Result := (Self.Select(x -> x[0]), Self.Select(x -> x[1]))\nend;"
  },
  {
    "instruction": "Implement an extension method that splits sequence of three-element tuples into three sequences",
    "output": "function UnZipTuple<T, T1, T2>(Self: sequence of (T, T1, T2)): (sequence of T, sequence of T1, sequence of T2); extensionmethod;\nbegin\n  Result := (Self.Select(x -> x[0]), Self.Select(x -> x[1]), Self.Select(x -> x[2]))\nend;"
  },
  {
    "instruction": "Implement an extension method that splits sequence of four-element tuples into four sequences",
    "output": "function UnZipTuple<T, T1, T2, T3>(Self: sequence of (T, T1, T2, T3)): (sequence of T, sequence of T1, sequence of T2, sequence of T3); extensionmethod;\nbegin\n  Result := (Self.Select(x -> x[0]), Self.Select(x -> x[1]), Self.Select(x -> x[2]), Self.Select(x -> x[3]))\nend;"
  },
  {
    "instruction": "Implement an extension method that interleaves elements of three sequences",
    "output": "function Interleave<T>(Self: sequence of T; a, b: sequence of T): sequence of T; extensionmethod;\nbegin\n  if a = nil then\n    raise new System.ArgumentNullException('a');\n  if b = nil then\n    raise new System.ArgumentNullException('b');\n  Result := Self.ZipTuple(a, b).SelectMany(x -> Seq(x[0], x[1], x[2]))\nend;"
  },
  {
    "instruction": "Implement an extension method that interleaves elements of four sequences",
    "output": "function Interleave<T>(Self: sequence of T; a, b, c: sequence of T): sequence of T; extensionmethod;\nbegin\n  if a = nil then\n    raise new System.ArgumentNullException('a');\n  if b = nil then\n    raise new System.ArgumentNullException('b');\n  if c = nil then\n    raise new System.ArgumentNullException('c');\n  Result := Self.ZipTuple(a, b, c).SelectMany(x -> Seq(x[0], x[1], x[2], x[3]))\nend;"
  },
  {
    "instruction": "Implement an extension method that numerates sequence starting from specified number",
    "output": "function Numerate<T>(Self: sequence of T; from: integer): sequence of (integer, T); extensionmethod;\nbegin\n  var i := from;\n  foreach var x in Self do\n  begin\n    yield (i,x);\n    i += 1;\n  end;  \nend;"
  },
  {
    "instruction": "Implement an extension method that tabulates function over sequence",
    "output": "function Tabulate<T, T1>(Self: sequence of T; F: T->T1): sequence of (T, T1); extensionmethod;\nbegin\n  Result := Self.Select(x -> (x, f(x)));\nend;"
  },
  {
    "instruction": "Implement an extension method that transforms sequence into sequence of adjacent element pairs using function",
    "output": "function Pairwise<T, Res>(Self: sequence of T; func: (T,T)->Res): sequence of Res; extensionmethod;\nbegin\n  var previous: T;\n  var it := Self.GetEnumerator();\n  if (it.MoveNext()) then\n    previous := it.Current;\n  \n  while (it.MoveNext()) do\n  begin\n    yield func(previous, it.Current);\n    previous := it.Current;\n  end\nend;"
  },
  {
    "instruction": "Implement an extension method that splits sequence into batches of specified size",
    "output": "function Batch<T>(Self: sequence of T; size: integer): sequence of sequence of T; extensionmethod;\nbegin\n  Result := SeqWhile(Self, v -> v.Skip(size), v -> v.Count > 0).Select(v -> v.Take(size))\nend;"
  },
  {
    "instruction": "Implement an extension method that splits sequence into batches of specified size and applies projection to each batch",
    "output": "function Batch<T, Res>(Self: sequence of T; size: integer; proj: Func<IEnumerable<T>, Res>): sequence of Res; extensionmethod;\nbegin\n  Result := SeqWhile(Self, v -> v.Skip(size), v -> v.Count > 0).Select(v -> v.Take(size)).Select(ss -> proj(ss));\nend;"
  },
  {
    "instruction": "Implement an extension method that returns slice of sequence from specified index with step",
    "output": "function Slice<T>(Self: sequence of T; from, step: integer): sequence of T; extensionmethod;\nbegin\n  if step <= 0 then\n    raise new ArgumentException(GetTranslation(PARAMETER_STEP_MUST_BE_GREATER_0));\n  \n  if from < 0 then\n    raise new ArgumentException(GetTranslation(PARAMETER_FROM_OUT_OF_RANGE));\n  \n  Result := Self.Skip(from).Where((x, i)-> i mod step = 0)\nend;"
  },
  {
    "instruction": "Implement an extension method that returns slice of sequence from specified index with step and maximum count",
    "output": "function Slice<T>(Self: sequence of T; from, step, count: integer): sequence of T; extensionmethod;\nbegin\n  if step <= 0 then\n    raise new ArgumentException(GetTranslation(PARAMETER_STEP_MUST_BE_GREATER_0));\n  \n  if from < 0 then\n    raise new ArgumentException(GetTranslation(PARAMETER_FROM_OUT_OF_RANGE));\n  \n  Result := Self.Skip(from).Where((x, i)-> i mod step = 0).Take(count)\nend;"
  },
  {
    "instruction": "Implement an extension method that returns sequence of differences between adjacent elements using custom function",
    "output": "function Incremental<T, T1>(Self: sequence of T; func: (T,T)->T1): sequence of T1; extensionmethod;\nbegin\n  var iter := Self.GetEnumerator();\n  if iter.MoveNext() then\n  begin\n    var prevItem := iter.Current;\n    while iter.MoveNext() do\n    begin\n      var nextItem := iter.Current;\n      yield func(prevItem, nextItem);\n      prevItem := nextItem;\n    end\n  end\nend;"
  },
  {
    "instruction": "Implement an extension method that returns sequence of differences between adjacent elements using function with index",
    "output": "function Incremental<T, T1>(Self: sequence of T; func: (T,T,integer)->T1): sequence of T1; extensionmethod;\nbegin\n  var iter := Self.GetEnumerator();\n  if iter.MoveNext() then\n  begin\n    var ind := 0;\n    var prevItem := iter.Current;\n    while iter.MoveNext() do\n    begin\n      var nextItem := iter.Current;\n      ind += 1;\n      yield func(prevItem, nextItem, ind);\n      prevItem := nextItem;\n    end\n  end\nend;"
  },
  {
    "instruction": "Implement an extension method that returns sequence of list indices",
    "output": "function Indices<T>(Self: List<T>): sequence of integer; extensionmethod := Range(0, Self.Count - 1);"
  },
  {
    "instruction": "Implement an extension method that returns sequence of list indices satisfying condition",
    "output": "function Indices<T>(Self: List<T>; cond: T->boolean): sequence of integer; extensionmethod;\nbegin\n  for var i := 0 to Self.Count - 1 do\n    if cond(Self[i]) then\n      yield i;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns sequence of list indices satisfying condition with index",
    "output": "function Indices<T>(Self: List<T>; cond: (T,integer) ->boolean): sequence of integer; extensionmethod;\nbegin\n  for var i := 0 to Self.Count - 1 do\n    if cond(Self[i], i) then\n      yield i;\nend;"
  },
  {
    "instruction": "Implement an extension method that finds first pair of consecutive identical elements using comparison function",
    "output": "function AdjacentFind<T>(Self: IList<T>; eq: (T,T)->boolean; start: integer := 0): integer; extensionmethod;\nbegin\n  Result := -1;\n  for var i := start to Self.Count - 2 do\n    if eq(Self[i], Self[i + 1]) then \n    begin\n      Result := i;\n      exit;\n    end;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns index of first minimal element in list starting from specified position",
    "output": "function IndexMin<T>(Self: List<T>; index: integer := 0): integer; extensionmethod; where T: IComparable<T>;\nbegin\n  var min := Self[index];\n  Result := index;\n  for var i := index + 1 to Self.Count - 1 do\n    if Self[i].CompareTo(min) < 0 then \n    begin\n      Result := i;\n      min := Self[i];\n    end;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns index of first maximal element in list starting from specified position",
    "output": "function IndexMax<T>(Self: List<T>; index: integer := 0): integer; extensionmethod; where T: System.IComparable<T>;\nbegin\n  var max := Self[index];\n  Result := index;\n  for var i := index + 1 to Self.Count - 1 do\n    if Self[i].CompareTo(max) > 0 then \n    begin\n      Result := i;\n      max := Self[i];\n    end;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns index of last minimal element in list within range [0,index]",
    "output": "function LastIndexMin<T>(Self: List<T>; index: integer): integer; extensionmethod; where T: System.IComparable<T>;\nbegin\n  var min := Self[index];\n  Result := index;\n  for var i := index - 1 downto 0 do\n    if Self[i].CompareTo(min) < 0 then \n    begin\n      Result := i;\n      min := Self[i];\n    end;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns index of last minimal element in list",
    "output": "function LastIndexMin<T>(Self: List<T>): integer; extensionmethod; where T: System.IComparable<T>;\nbegin\n  Result := Self.LastIndexMin(Self.Count - 1);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns index of last maximal element in list within range [0,index]",
    "output": "function LastIndexMax<T>(Self: List<T>; index: integer): integer; extensionmethod; where T: System.IComparable<T>;\nbegin\n  var max := Self[index];\n  Result := index;\n  for var i := index - 1 downto 0 do\n    if Self[i].CompareTo(max) > 0 then \n    begin\n      Result := i;\n      max := Self[i];\n    end;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns index of last maximal element in list",
    "output": "function LastIndexMax<T>(Self: List<T>): integer; extensionmethod; where T: System.IComparable<T>;\nbegin\n  Result := Self.LastIndexMax(Self.Count - 1);\nend;"
  },
  {
    "instruction": "Implement an extension method that transforms list elements using function with index",
    "output": "procedure Transform<T>(Self: List<T>; f: (T,integer)->T); extensionmethod;\nbegin\n  for var i := 0 to Self.Count - 1 do\n    Self[i] := f(Self[i],i);\nend;"
  },
  {
    "instruction": "Implement an extension method that fills list elements with values computed by function",
    "output": "procedure Fill<T>(Self: List<T>; f: integer->T); extensionmethod;\nbegin\n  for var i := 0 to Self.Count - 1 do\n    Self[i] := f(i);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns slice of list from index with step",
    "output": "function Slice<T>(Self: List<T>; from, step: integer): List<T>; extensionmethod;\nbegin\n  Result := SliceListImpl(Self, from, step, integer.MaxValue);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns slice of list from index with step and maximum count",
    "output": "function Slice<T>(Self: List<T>; from, step, count: integer): List<T>; extensionmethod;\nbegin\n  Result := SliceListImpl(Self, from, step, count);\nend;"
  },
  {
    "instruction": "Implement an extension method that removes last element from list",
    "output": "function RemoveLast<T>(Self: List<T>): List<T>; extensionmethod;\nbegin\n  Self.RemoveAt(Self.Count - 1);\n  Result := Self;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns size of 2D array as tuple (rows, columns)",
    "output": "function Size<T>(Self: array [,] of T): (integer,integer); extensionmethod;\nbegin\n  Result := (Self.GetLength(0),Self.GetLength(1));\nend;"
  },
  {
    "instruction": "Implement an extension method that checks if element exists in 2D array",
    "output": "function operator in<T>(x: T; a: array[,] of T): boolean; extensionmethod;\nbegin\n  var (m,n) := a.Size;\n  Result := False;\n  for var i:=0 to m-1 do\n  for var j:=0 to n-1 do\n    if a[i,j]=x then\n    begin\n      Result := True;\n      exit;\n    end;\nend;"
  },
  {
    "instruction": "Implement an extension method that prints 2D real array with specified format (width and decimal places)",
    "output": "function Print(Self: array [,] of real; w: integer := 7; f: integer := 2): array [,] of real; extensionmethod;\nbegin\n  for var i := 0 to Self.RowCount - 1 do\n  begin\n    for var j := 0 to Self.ColCount - 1 do\n    begin\n      if PrintMatrixWithFormat then\n        Write(FormatValue(Self[i, j], w, f))\n      else Print(Self[i, j]);\n    end;  \n    Writeln;  \n  end;\n  Result := Self;  \nend;"
  },
  {
    "instruction": "Implement an extension method that prints 2D array with specified width and moves to new line",
    "output": "function Println<T>(Self: array [,] of T; w: integer := 4): array [,] of T; extensionmethod;\nbegin\n  Self.Print(w);\n  Result := Self;  \nend;"
  },
  {
    "instruction": "Implement an extension method that prints 2D real array with specified format and moves to new line",
    "output": "function Println(Self: array [,] of real; w: integer := 7; f: integer := 2): array [,] of real; extensionmethod;\nbegin\n  Self.Print(w, f);\n  Result := Self;  \nend;"
  },
  {
    "instruction": "Implement an extension method that returns k-th column of 2D array",
    "output": "function Col<T>(Self: array [,] of T; k: integer): array of T; extensionmethod;\nbegin\n  var m := Self.RowCount;\n  var res := new T[m];\n  for var i := 0 to m - 1 do\n    res[i] := Self[i, k];\n  Result := res;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns k-th row of 2D array as sequence",
    "output": "function RowSeq<T>(Self: array [,] of T; k: integer): sequence of T; extensionmethod;\nbegin\n  for var j := 0 to Self.ColCount - 1 do\n    yield Self[k, j];\nend;"
  },
  {
    "instruction": "Implement an extension method that returns k-th column of 2D array as sequence",
    "output": "function ColSeq<T>(Self: array [,] of T; k: integer): sequence of T; extensionmethod;\nbegin\n  for var i := 0 to Self.RowCount - 1 do\n    yield Self[i, k];\nend;"
  },
  {
    "instruction": "Implement an extension method that returns array of rows of 2D array",
    "output": "function Rows<T>(Self: array [,] of T): array of array of T; extensionmethod;\ntype ArrT = array of T;\nbegin\n  var m := Self.RowCount;\n  var n := Self.ColCount;\n  var a := new ArrT[m];\n  for var i := 0 to m - 1 do\n    a[i] := new T[n];\n  for var i := 0 to m - 1 do\n  for var j := 0 to n - 1 do\n    a[i][j] := Self[i,j];\n  Result := a;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns array of columns of 2D array",
    "output": "function Cols<T>(Self: array [,] of T): array of array of T; extensionmethod;\ntype ArrT = array of T;\nbegin\n  var m := Self.RowCount;\n  var n := Self.ColCount;\n  var a := new ArrT[n];\n  for var j := 0 to n - 1 do\n    a[j] := new T[m];\n  for var j := 0 to n - 1 do\n  for var i := 0 to m - 1 do\n    a[j][i] := Self[i,j];\n  Result := a;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns sequence of rows of 2D array",
    "output": "function RowsSeq<T>(Self: array [,] of T): sequence of sequence of T; extensionmethod;\nbegin\n  for var i := 0 to Self.RowCount - 1 do\n    yield Self.RowSeq(i);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns sequence of columns of 2D array",
    "output": "function ColsSeq<T>(Self: array [,] of T): sequence of sequence of T; extensionmethod;\nbegin\n  for var j := 0 to Self.ColCount - 1 do\n    yield Self.ColSeq(j);\nend;"
  },
  {
    "instruction": "Implement an extension method that swaps two columns in 2D array",
    "output": "procedure SwapCols<T>(Self: array [,] of T; k1, k2: integer); extensionmethod;\nbegin\n  for var i := 0 to Self.RowCount - 1 do\n    Swap(Self[i, k1], Self[i, k2])\nend;"
  },
  {
    "instruction": "Implement an extension method that sets k-th column of 2D array to specified array",
    "output": "procedure SetCol<T>(Self: array [,] of T; k: integer; a: array of T); extensionmethod;\nbegin\n  if a.Length <> Self.RowCount then\n    raise new System.ArgumentException(GetTranslation(ARR_LENGTH_MUST_BE_MATCH_TO_MATR_SIZE));\n  for var i := 0 to Self.RowCount - 1 do\n    Self[i, k] := a[i]\nend;"
  },
  {
    "instruction": "Implement an extension method that sets k-th column of 2D array to specified sequence",
    "output": "procedure SetCol<T>(Self: array [,] of T; k: integer; a: sequence of T); extensionmethod := Self.SetCol(k,a.ToArray);"
  },
  {
    "instruction": "Implement an extension method that returns sequence of elements with indices from 2D array",
    "output": "function ElementsWithIndices<T>(Self: array [,] of T): sequence of (T, integer, integer); extensionmethod;\nbegin\n  for var i := 0 to Self.RowCount - 1 do\n    for var j := 0 to Self.ColCount - 1 do\n      yield (Self[i, j], i, j)\nend;"
  },
  {
    "instruction": "Implement an extension method that returns sequence of indices of elements satisfying condition in 2D array",
    "output": "function Indices<T>(Self: array [,] of T; cond: T -> boolean): sequence of (integer, integer); extensionmethod;\nbegin\n  for var i := 0 to Self.RowCount - 1 do\n    for var j := 0 to Self.ColCount - 1 do\n      if cond(Self[i,j]) then \n        yield (i, j)\nend;"
  },
  {
    "instruction": "Implement an extension method that returns sequence of indices of elements satisfying condition with indices in 2D array",
    "output": "function Indices<T>(Self: array [,] of T; cond: (T,integer,integer) -> boolean): sequence of (integer, integer); extensionmethod;\nbegin\n  for var i := 0 to Self.RowCount - 1 do\n    for var j := 0 to Self.ColCount - 1 do\n      if cond(Self[i,j],i,j) then \n        yield (i, j)\nend;"
  },
  {
    "instruction": "Implement an extension method that returns sequence of 2D array elements by rows",
    "output": "function ElementsByRow<T>(Self: array [,] of T): sequence of T; extensionmethod;\nbegin\n  for var i := 0 to Self.RowCount - 1 do\n    for var j := 0 to Self.ColCount - 1 do\n      yield Self[i, j]\nend;"
  },
  {
    "instruction": "Implement an extension method that returns sequence of 2D array elements by columns",
    "output": "function ElementsByCol<T>(Self: array [,] of T): sequence of T; extensionmethod;\nbegin\n  for var j := 0 to Self.ColCount - 1 do\n    for var i := 0 to Self.RowCount - 1 do\n      yield Self[i, j]\nend;"
  },
  {
    "instruction": "Implement an extension method that converts all elements of 2D array using converter function",
    "output": "function ConvertAll<T, T1>(Self: array [,] of T; converter: T->T1): array [,] of T1; extensionmethod;\nbegin\n  Result := new T1[Self.RowCount, Self.ColCount];\n  for var i := 0 to Self.RowCount - 1 do\n    for var j := 0 to Self.ColCount - 1 do\n      Result[i, j] := converter(Self[i, j]);  \nend;"
  },
  {
    "instruction": "Implement an extension method that converts all elements of 2D array using converter function with indices",
    "output": "function ConvertAll<T, T1>(Self: array [,] of T; converter: (T,integer,integer)->T1): array [,] of T1; extensionmethod;\nbegin\n  Result := new T1[Self.RowCount, Self.ColCount];\n  for var i := 0 to Self.RowCount - 1 do\n    for var j := 0 to Self.ColCount - 1 do\n      Result[i, j] := converter(Self[i, j],i,j);  \nend;"
  },
  {
    "instruction": "Implement an extension method that transforms elements of 2D array using function with indices",
    "output": "procedure Transform<T>(Self: array [,] of T; f: (T,integer,integer)->T); extensionmethod;\nbegin\n  for var i := 0 to Self.RowCount - 1 do\n    for var j := 0 to Self.ColCount - 1 do\n      Self[i, j] := f(Self[i, j],i,j);\nend;"
  },
  {
    "instruction": "Implement an extension method that fills 2D array elements with values computed by function",
    "output": "procedure Fill<T>(Self: array [,] of T; f: (integer,integer) ->T); extensionmethod;\nbegin\n  for var i := 0 to Self.RowCount - 1 do\n    for var j := 0 to Self.ColCount - 1 do\n      Self[i, j] := f(i, j);\nend;"
  },
  {
    "instruction": "Implement an extension method that fills 2D integer array with random values in specified range",
    "output": "procedure FillRandom(Self: array [,] of integer; a,b: integer); extensionmethod;\nbegin\n  for var i := 0 to Self.RowCount - 1 do\n    for var j := 0 to Self.ColCount - 1 do\n      Self[i, j] := Random(a,b);\nend;"
  },
  {
    "instruction": "Implement an extension method that fills 2D real array with random values in specified range",
    "output": "procedure FillRandom(Self: array [,] of real; a,b: real); extensionmethod;\nbegin\n  for var i := 0 to Self.RowCount - 1 do\n    for var j := 0 to Self.ColCount - 1 do\n      Self[i, j] := a + Random*(b-a);\nend;"
  },
  {
    "instruction": "Implement an extension method that applies action to each element of 2D array",
    "output": "procedure &ForEach<T>(Self: array [,] of T; act: T -> ()); extensionmethod;\nbegin\n  for var i := 0 to Self.RowCount - 1 do\n    for var j := 0 to Self.ColCount - 1 do\n      act(Self[i, j]);\nend;"
  },
  {
    "instruction": "Implement an extension method that applies action to each element of 2D array with indices",
    "output": "procedure &ForEach<T>(Self: array [,] of T; act: (T,integer,integer) -> ()); extensionmethod;\nbegin\n  for var i := 0 to Self.RowCount - 1 do\n    for var j := 0 to Self.ColCount - 1 do\n      act(Self[i, j],i,j);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns slice of 2D array using specified row and column indices",
    "output": "function MatrSlice<T>(Self: array[,] of T; RowIndex: array of integer; ColIndex: array of integer): array[,] of T; extensionmethod;\nbegin\n  if RowIndex = nil then\n    raise new System.ArgumentNullException('RowIndex');\n  if ColIndex = nil then\n    raise new System.ArgumentNullException('ColIndex');\n  if RowIndex.Any(i->not InR(i,0,Self.RowCount-1)) then  \n    raise new System.ArgumentOutOfRangeException(GetTranslation(BAD_ROW_INDEX),new Exception);\n  if ColIndex.Any(i->not InR(i,0,Self.ColCount-1)) then  \n    raise new System.ArgumentOutOfRangeException(GetTranslation(BAD_COL_INDEX),new Exception);\n  Result := new T[RowIndex.Length, ColIndex.Length];\n  var r := 0;\n  foreach var ir in RowIndex do\n  begin\n    var c := 0;\n    foreach var jc in ColIndex do\n    begin\n      Result[r, c] := Self[ir, jc];\n      c += 1;\n    end;\n    r += 1;\n  end\nend;"
  },
  {
    "instruction": "Implement an extension method that returns slice of 2D array between specified row and column ranges",
    "output": "function MatrSlice<T>(Self: array[,] of T; FromRow, ToRow, FromCol, ToCol: integer): array[,] of T; extensionmethod;\nbegin\n  if not InR(FromRow,0,Self.RowCount-1) then  \n    raise new System.ArgumentOutOfRangeException(GetTranslation(BAD_ROW_INDEX_FROM),new Exception);\n  if not InR(ToRow,0,Self.RowCount-1) then      raise new System.ArgumentOutOfRangeException(GetTranslation(BAD_ROW_INDEX_TO),new Exception);\n  if not InR(FromCol,0,Self.ColCount-1) then  \n    raise new System.ArgumentOutOfRangeException(GetTranslation(BAD_COL_INDEX_FROM),new Exception);\n  if not InR(ToCol,0,Self.ColCount-1) then  \n    raise new System.ArgumentOutOfRangeException(GetTranslation(BAD_COL_INDEX_TO),new Exception);\n  Result := new T[ToRow-FromRow+1, ToCol-FromCol+1];\n  var r := 0;\n  for var ir:=FromRow to ToRow do\n  begin\n    var c := 0;\n    for var jc:=FromCol to ToCol do\n    begin\n      Result[r, c] := Self[ir, jc];\n      c += 1;\n    end;\n    r += 1;\n  end\nend;"
  },
  {
    "instruction": "Implement an extension method that checks if arrays are equal",
    "output": "function ArrEqual<T>(Self,b: array of T): boolean; extensionmethod := ArrEqual(Self,b);"
  },
  {
    "instruction": "Implement an extension method that fills array of real numbers with random values in specified range",
    "output": "procedure FillRandom(Self: array of real; a,b: real); extensionmethod;\nbegin\n  for var i:=0 to Self.Length-1 do\n    Self[i] := a + Random*(b-a);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns maximal element of integer array",
    "output": "function Max(Self: array of integer): integer; extensionmethod;\nbegin\n  Result := Self[0];\n  for var i := 1 to Self.Length - 1 do\n    if Self[i] > Result then \n      Result := Self[i];\nend;"
  },
  {
    "instruction": "Implement an extension method that returns maximal element of real array",
    "output": "function Max(Self: array of real): real; extensionmethod;\nbegin\n  Result := Self[0];\n  for var i := 1 to Self.Length - 1 do\n    if Self[i] > Result then \n      Result := Self[i];\nend;"
  },
  {
    "instruction": "Implement an extension method that returns index of first maximal element in array starting from specified position",
    "output": "function IndexMax<T>(Self: array of T; index: integer := 0): integer; extensionmethod; where T: System.IComparable<T>;\nbegin\n  var max := Self[index];\n  Result := index;\n  for var i := index + 1 to Self.Count - 1 do\n    if Self[i].CompareTo(max) > 0 then \n    begin\n      Result := i;\n      max := Self[i];\n    end;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns index of last minimal element in array within range [0,index]",
    "output": "function LastIndexMin<T>(Self: array of T; index: integer): integer; extensionmethod; where T: System.IComparable<T>;\nbegin\n  var min := Self[index];\n  Result := index;\n  for var i := index - 1 downto 0 do\n    if Self[i].CompareTo(min) < 0 then \n    begin\n      Result := i;\n      min := Self[i];\n    end;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns index of last minimal element in array",
    "output": "function LastIndexMin<T>(Self: array of T): integer; extensionmethod; where T: System.IComparable<T>;\nbegin\n  Result := Self.LastIndexMin(Self.Length - 1);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns index of last maximal element in array within range [0,index]",
    "output": "function LastIndexMax<T>(Self: array of T; index: integer): integer; extensionmethod; where T: System.IComparable<T>;\nbegin\n  var max := Self[index];\n  Result := index;\n  for var i := index - 1 downto 0 do\n    if Self[i].CompareTo(max) > 0 then \n    begin\n      Result := i;\n      max := Self[i];\n    end;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns index of last maximal element in array",
    "output": "function LastIndexMax<T>(Self: array of T): integer; extensionmethod; where T: System.IComparable<T>;\nbegin\n  Result := Self.LastIndexMax(Self.Length - 1);\nend;"
  },
  {
    "instruction": "Implement an extension method that transforms array elements using function with index",
    "output": "procedure Transform<T>(Self: array of T; f: (T,integer)->T); extensionmethod;\nbegin\n  for var i := 0 to Self.Length - 1 do\n    Self[i] := f(Self[i],i);\nend;"
  },
  {
    "instruction": "Implement an extension method that performs binary search in sorted array",
    "output": "function BinarySearch<T>(Self: array of T; x: T): integer; extensionmethod;\nbegin\n  Result := System.Array.BinarySearch(self, x);  \nend;"
  },
  {
    "instruction": "Implement an extension method that converts all array elements using converter function",
    "output": "function ConvertAll<T, T1>(Self: array of T; converter: T->T1): array of T1; extensionmethod;\nbegin\n  Result := System.Array.ConvertAll(self, t -> converter(t));  \nend;"
  },
  {
    "instruction": "Implement an extension method that converts all array elements using converter function with index",
    "output": "function ConvertAll<T, T1>(Self: array of T; converter: (T,integer)->T1): array of T1; extensionmethod;\nbegin\n  Result := new T1[Self.Length];\n  for var i := 0 to Self.Length - 1 do\n    Result[i] := converter(Self[i],i);\nend;"
  },
  {
    "instruction": "Implement an extension method that finds first element in array satisfying predicate",
    "output": "function Find<T>(Self: array of T; p: T->boolean): T; extensionmethod;\nbegin\n  Result := System.Array.Find(self, p);  \nend;"
  },
  {
    "instruction": "Implement an extension method that finds index of first element in array satisfying predicate",
    "output": "function FindIndex<T>(Self: array of T; p: T->boolean): integer; extensionmethod;\nbegin\n  Result := System.Array.FindIndex(self, p);  \nend;"
  },
  {
    "instruction": "Implement an extension method that finds index of first element in array satisfying predicate starting from index",
    "output": "function FindIndex<T>(Self: array of T; start: integer; p: T->boolean): integer; extensionmethod;\nbegin\n  Result := System.Array.FindIndex(self, start, p);  \nend;"
  },
  {
    "instruction": "Implement an extension method that returns all elements in array satisfying predicate",
    "output": "function FindAll<T>(Self: array of T; p: T->boolean): array of T; extensionmethod;\nbegin\n  Result := System.Array.FindAll(self, p);  \nend;"
  },
  {
    "instruction": "Implement an extension method that finds last element in array satisfying predicate",
    "output": "function FindLast<T>(Self: array of T; p: T->boolean): T; extensionmethod;\nbegin\n  Result := System.Array.FindLast(self, p);  \nend;"
  },
  {
    "instruction": "Implement an extension method that finds index of last element in array satisfying predicate",
    "output": "function FindLastIndex<T>(Self: array of T; p: T->boolean): integer; extensionmethod;\nbegin\n  Result := System.Array.FindLastIndex(self, p);  \nend;"
  },
  {
    "instruction": "Implement an extension method that finds index of last element in array satisfying predicate in range [0,start]",
    "output": "function FindLastIndex<T>(self: array of T; start: integer; p: T->boolean): integer; extensionmethod;\nbegin\n  Result := System.Array.FindLastIndex(Self, start, p);  \nend;"
  },
  {
    "instruction": "Implement an extension method that returns index of first occurrence of element in array",
    "output": "function IndexOf<T>(Self: array of T; x: T): integer; extensionmethod;\nbegin\n  Result := System.Array.IndexOf(Self, x);  \nend;"
  },
  {
    "instruction": "Implement an extension method that returns index of first occurrence of element in array starting from index",
    "output": "function IndexOf<T>(Self: array of T; x: T; start: integer): integer; extensionmethod;\nbegin\n  Result := System.Array.IndexOf(Self, x, start);  \nend;"
  },
  {
    "instruction": "Implement an extension method that returns index of last occurrence of element in array",
    "output": "function LastIndexOf<T>(Self: array of T; x: T): integer; extensionmethod;\nbegin\n  Result := System.Array.LastIndexOf(Self, x);  \nend;"
  },
  {
    "instruction": "Implement an extension method that returns index of last occurrence of element in array starting from index",
    "output": "function LastIndexOf<T>(Self: array of T; x: T; start: integer): integer; extensionmethod;\nbegin\n  Result := System.Array.LastIndexOf(Self, x, start);  \nend;"
  },
  {
    "instruction": "Implement an extension method that sorts array in ascending order",
    "output": "procedure Sort<T>(Self: array of T); extensionmethod;\nbegin\n  System.Array.Sort(Self);  \nend;"
  },
  {
    "instruction": "Implement an extension method that sorts array using comparison function",
    "output": "procedure Sort<T>(Self: array of T; cmp: (T,T) ->integer); extensionmethod;\nbegin\n  System.Array.Sort(Self, cmp);  \nend;"
  },
  {
    "instruction": "Implement an extension method that returns high index of array",
    "output": "function High(Self: System.Array); extensionmethod := High(Self);"
  },
  {
    "instruction": "Implement an extension method that returns low index of array",
    "output": "function Low(Self: System.Array); extensionmethod := Low(Self);"
  },
  {
    "instruction": "Implement an extension method that returns sequence of array indices",
    "output": "function Indices<T>(Self: array of T): sequence of integer; extensionmethod := Range(0, Self.Length - 1);"
  },
  {
    "instruction": "Implement an extension method that returns sequence of array indices satisfying condition",
    "output": "function Indices<T>(Self: array of T; cond: T->boolean): sequence of integer; extensionmethod;\nbegin\n  for var i := 0 to Self.High do\n    if cond(Self[i]) then\n      yield i;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns sequence of array indices satisfying condition with index",
    "output": "function Indices<T>(Self: array of T; cond: (T,integer) ->boolean): sequence of integer; extensionmethod;\nbegin\n  for var i := 0 to Self.High do\n    if cond(Self[i], i) then\n      yield i;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns all permutations of m elements from array",
    "output": "function Permutations<T>(Self: array of T; m: integer): sequence of array of T; extensionmethod;\nbegin\n  Result := Self.Combinations(m).SelectMany(c->c.Permutations);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns n-th Cartesian power of array elements",
    "output": "function Cartesian<T>(Self: array of T; n: integer): sequence of array of T; extensionmethod;\nbegin\n  var r := new integer[n];\n  var ar1 := new T[n];\n  for var i:=0 to n-1 do\n    ar1[i] := Self[r[i]];\n  yield ar1;\n  \n  var m := Self.Length;\n  while True do\n  begin\n    var i := n-1;  \n    r[i] += 1;\n    while r[i]>=m do\n    begin\n      r[i] := 0;\n      i -= 1;\n      if i<0 then\n        exit;\n      r[i] += 1;\n    end;\n    \n    var ar := new T[n];\n    for var j:=0 to n-1 do\n      ar[j] := Self[r[j]];\n    yield ar;\n  end;  \nend;"
  },
  {
    "instruction": "Implement an extension method that returns slice of array from index with step",
    "output": "function Slice<T>(Self: array of T; from, step: integer): array of T; extensionmethod;\nbegin\n  Result := SliceArrayImpl(Self, from, step, integer.MaxValue);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns slice of array from index with step and maximum count",
    "output": "function Slice<T>(Self: array of T; from, step, count: integer): array of T; extensionmethod;\nbegin\n  Result := SliceArrayImpl(Self, from, step, count);\nend;"
  },
  {
    "instruction": "Implement an extension method that checks if integer is not divisible by specified value",
    "output": "function NotDivs(Self,d: integer): boolean; extensionmethod := Self mod d <> 0;"
  },
  {
    "instruction": "Implement an extension method that checks if integer is divisible by any of specified values",
    "output": "function DivsAny(Self: integer; params a: array of integer): boolean; extensionmethod;\nbegin\n  Result := False;\n  for var i:=0 to a.High do\n    if Self mod a[i] = 0 then\n    begin\n      Result := True;\n      exit\n    end;\nend;"
  },
  {
    "instruction": "Implement an extension method that checks if integer is divisible by all specified values",
    "output": "function DivsAll(Self: integer; params a: array of integer): boolean; extensionmethod;\nbegin\n  Result := True;\n  for var i:=0 to a.High do\n    if Self mod a[i] <> 0 then\n    begin\n      Result := False;\n      exit\n    end;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns square root of integer",
    "output": "function Sqrt(Self: integer): real; extensionmethod;\nbegin\n  Result := Sqrt(Self);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns square of integer",
    "output": "function Sqr(Self: integer): integer; extensionmethod;\nbegin\n  Result := Sqr(Self);\nend;"
  },
  {
    "instruction": "Implement an extension method that checks if integer value is between two other values",
    "output": "function Between(Self: integer; a, b: integer): boolean; extensionmethod;\nbegin\n  Result := (a <= Self) and (Self <= b) or (b <= Self) and (Self <= a);\nend;"
  },
  {
    "instruction": "Implement an extension method that checks if integer value is in range (alias for Between)",
    "output": "function InRange(Self: integer; a,b: integer): boolean; extensionmethod;\nbegin\n  Result := (a <= Self) and (Self <= b) or (b <= Self) and (Self <= a);\nend;"
  },
  {
    "instruction": "Implement an extension method that checks if integer is odd",
    "output": "function IsOdd(Self: integer): boolean; extensionmethod;\nbegin\n  Result := Self mod 2 <> 0;\nend;"
  },
  {
    "instruction": "Implement an extension method that generates sequence of integers from current value to n in descending order",
    "output": "function &Downto(Self: integer; n: integer): sequence of integer; extensionmethod;\nbegin\n  Result := Range(Self, n, -1); \nend;"
  },
  {
    "instruction": "Implement an extension method that returns sequence of integers 0,1,...n-1",
    "output": "function Times(Self: integer): sequence of integer; extensionmethod;\nbegin\n  Result := Range(0, Self - 1);\nend;"
  },
  {
    "instruction": "Implement an extension method that clamps integer value between bottom and top inclusive",
    "output": "function Clamp(Self: integer; bottom,top: integer): integer; extensionmethod;\nbegin\n  if Self < bottom then \n    Result := bottom\n  else if Self > top then \n    Result := top\n  else Result := Self;  \nend;"
  },
  {
    "instruction": "Implement an extension method that clamps integer value to top value",
    "output": "function ClampTop(Self: integer; top: integer): integer; extensionmethod;\nbegin\n  if Self > top then \n    Result := top\n  else Result := Self;  \nend;"
  },
  {
    "instruction": "Implement an extension method that clamps integer value to bottom value",
    "output": "function ClampBottom(Self: integer; bottom: integer): integer; extensionmethod;\nbegin\n  if Self < bottom then \n    Result := bottom\n  else Result := Self;  \nend;"
  },
  {
    "instruction": "Implement an extension method that returns square root of BigInteger",
    "output": "function Sqrt(Self: BigInteger): real; extensionmethod;\nbegin\n  Result := Sqrt(real(Self));\nend;"
  },
  {
    "instruction": "Implement an extension method that checks if real value is between two other values",
    "output": "function Between(Self: real; a, b: real): boolean; extensionmethod;\nbegin\n  Result := (a <= Self) and (Self <= b) or (b <= Self) and (Self <= a);\nend;"
  },
  {
    "instruction": "Implement an extension method that checks if real value is in range (alias for Between)",
    "output": "function InRange(Self: real; a,b: real): boolean; extensionmethod;\nbegin\n  Result := (a <= Self) and (Self <= b) or (b <= Self) and (Self <= a);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns square of real number",
    "output": "function Sqr(Self: real): real; extensionmethod;\nbegin\n  Result := Sqr(Self);\nend;"
  },
  {
    "instruction": "Implement an extension method that rounds real number to specified number of decimal places",
    "output": "function Round(Self: real; digits: integer): real; extensionmethod;\nbegin\n  Result := Round(Self,digits);\nend;"
  },
  {
    "instruction": "Implement an extension method that rounds real number to nearest BigInteger",
    "output": "function RoundBigInteger(Self: real): BigInteger; extensionmethod;\nbegin\n  Result := RoundBigInteger(Self);\nend;"
  },
  {
    "instruction": "Implement an extension method that truncates real number to integer",
    "output": "function Trunc(Self: real): integer; extensionmethod;\nbegin\n  Result := Trunc(Self);\nend;"
  },
  {
    "instruction": "Implement an extension method that truncates real number to BigInteger",
    "output": "function TruncBigInteger(Self: real): BigInteger; extensionmethod;\nbegin\n  Result := TruncBigInteger(Self);\nend;"
  },
  {
    "instruction": "Implement an extension method that formats real number to string with specified decimal places",
    "output": "function ToString(Self: real; frac: integer): string; extensionmethod;\nbegin\n  if frac < 0 then\n    raise new System.ArgumentOutOfRangeException('frac', 'frac<0');\n  if frac >= 100 then\n    raise new System.ArgumentOutOfRangeException('frac', 'frac>=100');\n  Result := Format('{0:f' + frac + '}', Self)\nend;"
  },
  {
    "instruction": "Implement an extension method that clamps real value between bottom and top inclusive",
    "output": "function Clamp(Self: real; bottom,top: real): real; extensionmethod;\nbegin\n  if Self < bottom then \n    Result := bottom\n  else if Self > top then \n    Result := top\n  else Result := Self;  \nend;"
  },
  {
    "instruction": "Implement an extension method that clamps real value to top value",
    "output": "function ClampTop(Self: real; top: real): real; extensionmethod;\nbegin\n  if Self > top then \n    Result := top\n  else Result := Self;  \nend;"
  },
  {
    "instruction": "Implement an extension method that clamps real value to bottom value",
    "output": "function ClampBottom(Self: real; bottom: real): real; extensionmethod;\nbegin\n  if Self < bottom then \n    Result := bottom\n  else Result := Self;  \nend;"
  },
  {
    "instruction": "Implement an extension method that checks if character value is between two other characters",
    "output": "function Between(Self: char; a, b: char): boolean; extensionmethod;\nbegin\n  Result := (a <= Self) and (Self <= b) or (b <= Self) and (Self <= a);\nend;"
  },
  {
    "instruction": "Implement an extension method that checks if character value is in range (alias for Between)",
    "output": "function InRange(Self: char; a,b: char): boolean; extensionmethod;\nbegin\n  Result := (a <= Self) and (Self <= b) or (b <= Self) and (Self <= a);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns previous character",
    "output": "function Pred(Self: char); extensionmethod := PABCSystem.Pred(Self);"
  },
  {
    "instruction": "Implement an extension method that returns next character",
    "output": "function Succ(Self: char); extensionmethod := PABCSystem.Succ(Self);"
  },
  {
    "instruction": "Implement an extension method that returns Unicode code of character",
    "output": "function Code(Self: char): integer; extensionmethod := word(Self);"
  },
  {
    "instruction": "Implement an extension method that checks if character is letter",
    "output": "function IsLetter(Self: char): boolean; extensionmethod;\nbegin\n  Result := char.IsLetter(Self);\nend;"
  },
  {
    "instruction": "Implement an extension method that checks if character is lowercase",
    "output": "function IsLower(Self: char): boolean; extensionmethod;\nbegin\n  Result := char.IsLower(Self);\nend;"
  },
  {
    "instruction": "Implement an extension method that checks if character is uppercase",
    "output": "function IsUpper(Self: char): boolean; extensionmethod;\nbegin\n  Result := char.IsUpper(Self);\nend;"
  },
  {
    "instruction": "Implement an extension method that converts character to digit",
    "output": "function ToDigit(Self: char): integer; extensionmethod;\nbegin\n  Result := OrdUnicode(Self) - OrdUnicode('0');\n  if (Result < 0) or (Result >= 10) then\n    raise new System.FormatException('not a Digit');\nend;"
  },
  {
    "instruction": "Implement an extension method that converts character to uppercase",
    "output": "function ToUpper(Self: char): char; extensionmethod;\nbegin\n  Result := char.ToUpper(Self);\nend;"
  },
  {
    "instruction": "Implement an extension method that replaces specified number of occurrences of substring in string",
    "output": "function Replace(Self: string; oldStr,newStr: string; count: integer): string; extensionmethod;\nbegin\n  var reg := new Regex(oldStr);\n  Result := reg.Replace(Self,newStr,count);\nend;"
  },
  {
    "instruction": "Implement an extension method that checks if string value is between two other strings",
    "output": "function Between(Self: string; a, b: string): boolean; extensionmethod;\nbegin\n  Result := (a <= Self) and (Self <= b) or (b <= Self) and (Self <= a);\nend;"
  },
  {
    "instruction": "Implement an extension method that checks if string value is in range (alias for Between)",
    "output": "function InRange(Self: string; a, b: string): boolean; extensionmethod;\nbegin\n  Result := (a <= Self) and (Self <= b) or (b <= Self) and (Self <= a);\nend;"
  },
  {
    "instruction": "Implement an extension method that reads integer from string starting from specified position",
    "output": "function ReadInteger(Self: string; var from: integer): integer; extensionmethod;\nbegin\n  var from1 := from + 1;\n  Result := ReadIntegerFromString(Self, from1);\n  from := from1 - 1;\nend;"
  },
  {
    "instruction": "Implement an extension method that reads real number from string starting from specified position",
    "output": "function ReadReal(Self: string; var from: integer): real; extensionmethod;\nbegin\n  var from1 := from + 1;\n  Result := ReadRealFromString(Self, from1);\n  from := from1 - 1;\nend;"
  },
  {
    "instruction": "Implement an extension method that reads word from string starting from specified position",
    "output": "function ReadWord(Self: string; var from: integer): string; extensionmethod;\nbegin\n  var from1 := from + 1;\n  Result := ReadwordFromString(Self, from1);\n  from := from1 - 1;\nend;"
  },
  {
    "instruction": "Implement an extension method that converts string to BigInteger",
    "output": "function ToBigInteger(Self: string): BigInteger; extensionmethod := BigInteger.Parse(Self);"
  },
  {
    "instruction": "Implement an extension method that tries to convert string to integer and returns success status",
    "output": "function TryToInteger(Self: string; var value: integer): boolean; extensionmethod := TryStrToInt(Self,value);"
  },
  {
    "instruction": "Implement an extension method that tries to convert string to real number and returns success status",
    "output": "function TryToReal(Self: string; var value: real): boolean; extensionmethod := TryStrToReal(Self,value);"
  },
  {
    "instruction": "Implement an extension method that checks if string can be converted to real number",
    "output": "function IsReal(Self: string): boolean; extensionmethod;\nbegin\n  var r: real;\n  Result := TryStrToReal(Self, r);\nend;"
  },
  {
    "instruction": "Implement an extension method that checks if string can be converted to integer",
    "output": "function IsInteger(Self: string): boolean; extensionmethod;\nbegin\n  var i: integer;\n  Result := TryStrToInt(Self, i);\nend;"
  },
  {
    "instruction": "Implement an extension method that converts string to integer with default value",
    "output": "function ToInteger(Self: string; defaultvalue: integer): integer; extensionmethod;\nbegin\n  var b := TryStrToInt(Self,Result);\n  if not b then\n    Result := defaultvalue\nend;"
  },
  {
    "instruction": "Implement an extension method that converts string to real number with default value",
    "output": "function ToReal(Self: string; defaultvalue: real): real; extensionmethod;\nbegin\n  var b := TryStrToReal(Self,Result);\n  if not b then\n    Result := defaultvalue\nend;"
  },
  {
    "instruction": "Implement an extension method that splits string into words using delimiter string",
    "output": "function ToWords(Self: string; delims: string := ' '): array of string; extensionmethod;\nbegin\n  Result := Self.Split(delims.ToCharArray, System.StringSplitOptions.RemoveEmptyEntries);\nend;"
  },
  {
    "instruction": "Implement an extension method that converts string to array of integers with specified count",
    "output": "function ToIntegers(Self: string; N: integer): array of integer; extensionmethod;\nbegin\n  Result := new integer[N];\n  var from := 1;\n  for var i:=0 to N-1 do\n    Result[i] := Self.ReadInteger(from);\nend;"
  },
  {
    "instruction": "Implement an extension method that converts string to array of real numbers",
    "output": "function ToReals(Self: string): array of real; extensionmethod;\nbegin\n  Result := Self.ToWords().ConvertAll(s -> StrToFloat(s));\nend;"
  },
  {
    "instruction": "Implement an extension method that replaces all occurrences of regular expression using replacement function",
    "output": "function RegexReplace(Self: string; reg: string; repl: &Match->string; options: RegexOptions := RegexOptions.None): string; extensionmethod;\nbegin\n  Result := Regex.Replace(Self, reg, repl, options)\nend;"
  },
  {
    "instruction": "Implement an extension method that finds first match of regular expression in string and returns its value",
    "output": "function MatchValue(Self: string; reg: string; options: RegexOptions := RegexOptions.None): string; extensionmethod;\nbegin\n  Result := (new Regex(reg, options)).&Match(Self).Value;\nend;"
  },
  {
    "instruction": "Implement an extension method that finds all match values of regular expression in string",
    "output": "function MatchValues(Self: string; reg: string; options: RegexOptions := RegexOptions.None): sequence of string; extensionmethod;\nbegin\n  Result := Self.Matches(reg, options).Select(m -> m.Value);\nend;"
  },
  {
    "instruction": "Implement an extension method that checks if string matches regular expression",
    "output": "function IsMatch(Self: string; reg: string; options: RegexOptions := RegexOptions.None): boolean; extensionmethod := Regex.IsMatch(Self, reg, options);"
  },
  {
    "instruction": "Implement an extension method that removes all occurrences of specified strings from string",
    "output": "function Remove(Self: string; params targets: array of string): string; extensionmethod;\nbegin\n  var builder := new StringBuilder(Self);\n  \n  for var i := 0 to targets.Length - 1 do\n    builder.Replace(targets[i], String.Empty);\n  \n  Result := builder.ToString();\nend;"
  },
  {
    "instruction": "Implement an extension method that returns rightmost characters of string",
    "output": "function Right(Self: string; length: integer): string; extensionmethod;\nbegin\n  length := Max(length, 0);\n  \n  if Self.Length > length then\n    Result := Self.Substring(Self.Length - length, length)\n  else Result := Self;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns leftmost characters of string",
    "output": "function Left(Self: string; length: integer): string; extensionmethod;\nbegin\n  length := Max(length, 0);\n  \n  if Self.Length > length then\n    Result := Self.Substring(0, length)\n  else Result := Self;\nend;"
  },
  {
    "instruction": "Implement an extension method that returns sequence of substring occurrence indices in string",
    "output": "function IndicesOf(Self, SubS: string; overlay: boolean := False): sequence of integer; extensionmethod;\nbegin\n  var L := new List<integer>;\n  var (n, m) := (Self.Length, SubS.Length);\n  var border := PrefixFunction(SubS);\n  var temp := 0;\n  for var i := 1 to n do\n  begin\n    while (temp > 0) and (SubS[temp + 1] <> Self[i]) do\n      temp := border[temp];\n    if SubS[temp + 1] = Self[i] then\n      temp += 1;\n    if temp = m then\n    begin\n      var pos := i - m + 1;\n      if overlay or (L.Count = 0) or (pos >= L[L.Count - 1] + m) then \n        L.Add(pos);\n      temp := border[m]\n    end;\n  end;\n  Result := L.Select(i -> i - 1)\nend;"
  },
  {
    "instruction": "Implement an extension method that returns slice of string from index with step",
    "output": "function Slice(Self: string; from, step: integer): string; extensionmethod;\nbegin\n  Result := SliceStringImpl(Self, from, step, integer.MaxValue);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns slice of string from index with step and maximum count",
    "output": "function Slice(Self: string; from, step, count: integer): string; extensionmethod;\nbegin\n  Result := SliceStringImpl(Self, from, step, count);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns complex conjugate of complex number",
    "output": "function Conjugate(Self: Complex): Complex; extensionmethod;\nbegin\n  Result := Complex.Conjugate(Self);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns dictionary mapping group key to count of elements in group",
    "output": "function EachCount<Key,Source>(Self: sequence of System.Linq.IGrouping<Key,Source>): Dictionary<Key,integer>; extensionmethod;\nbegin\n  Result := Self.ToDictionary(g -> g.Key, g -> g.Count);\nend;"
  },
  {
    "instruction": "Implement an extension method that returns dictionary mapping group key to result of group operation",
    "output": "function Each<Key,Source,Res>(Self: sequence of System.Linq.IGrouping<Key,Source>; grOperation: System.Linq.IGrouping<Key,Source> -> Res): Dictionary<Key,Res>; extensionmethod;\nbegin\n  Result := Self.ToDictionary(g -> g.Key, g -> grOperation(g));\nend;"
  },
  {
    "instruction": "Implement an extension operator that removes key-value pair from dictionary",
    "output": "procedure operator-=<Key,Value>(Self: IDictionary<Key,Value>; k: Key); extensionmethod;\nbegin\n  Self.Remove(k);\nend;"
  },
  {
    "instruction": "Implement a function that creates 2D array with specified dimensions and data",
    "output": "function Matr<T>(m,n: integer; params data: array of T): array [,] of T;\nbegin\n  if data.Length<>m*n then\n    raise new System.ArgumentException(GetTranslation(INITELEM_COUNT_MUST_BE_EQUAL_TO_MATRIX_ELEMS_COUNT));\n  \n  Result := new T[m, n];\n  var k := 0;\n  for var i:=0 to Result.RowCount-1 do\n  for var j:=0 to Result.ColCount-1 do\n  begin\n    Result[i,j] := data[k];\n    k += 1;\n  end;\nend;"
  },
  {
    "instruction": "Implement a function that creates 2D array from array of arrays",
    "output": "function Matr<T>(params aa: array of array of T): array [,] of T;\nbegin\n  var cols := aa.Max(a -> a.Length);\n  var r := new T[aa.Length,cols];\n  \n  for var i:=0 to aa.Length-1 do\n  for var j:=0 to aa[i].Length-1 do\n    r[i,j] := aa[i][j];\n  \n  Result := r;\nend;"
  },
  {
    "instruction": "Implement a function that creates 2D array from sequence of arrays by rows",
    "output": "function MatrByRow<T>(a: sequence of array of T): array [,] of T;\nbegin\n  var m := a.Count;\n  var n := if m = 0 then 0 else a.Max(aa -> aa.Length);\n  var res := new T[m,n];\n  var i := 0;\n  foreach var aa in a do\n  begin  \n    for var j := 0 to aa.Length-1 do\n      res[i,j] := aa[j];\n    i += 1;    \n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Implement a function that creates 2D array from sequence by rows with specified dimensions",
    "output": "function MatrByRow<T>(m,n: integer; a: sequence of T): array [,] of T;\nbegin\n  var res := new T[m,n];\n  var (i,j,num) := (0,0,0);\n  foreach var x in a do\n  begin\n    if num >= m*n then\n      break;\n    res[i,j] := x;\n    num += 1;\n    j += 1;\n    if j >= n then\n    begin\n      j := 0;\n      i += 1;\n    end;\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Implement a function that creates 2D array from array of arrays by columns",
    "output": "function MatrByCol<T>(a: array of array of T): array [,] of T;\nbegin\n  var n := a.Length;\n  var m := if n = 0 then 0 else a.Select(aa -> aa.Length).Max;\n  var res := new T[m,n];\n  for var j := 0 to n - 1 do\n  for var i := 0 to a[j].Length-1 do\n    res[i,j] := a[j][i];\n  Result := res;\nend;"
  },
  {
    "instruction": "Implement a function that creates 2D array from sequence of arrays by columns",
    "output": "function MatrByCol<T>(a: sequence of array of T): array [,] of T;\nbegin\n  var n := a.Count;\n  var m := if n = 0 then 0 else a.Select(aa -> aa.Length).Max;\n  var res := new T[m,n];\n  var j := 0;\n  foreach var aa in a do\n  begin  \n    for var i := 0 to aa.Length-1 do\n      res[i,j] := aa[i];\n    j += 1;\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Implement a function that creates 2D array from sequence of sequences by columns",
    "output": "function MatrByCol<T>(a: sequence of sequence of T): array [,] of T;\nbegin\n  var n := a.Count;\n  var m := if n = 0 then 0 else a.First.Count;\n  var res := new T[m,n];\n  var j := 0;\n  foreach var aa in a do\n  begin\n    var i := 0;\n    foreach var x in aa do\n    begin  \n      res[i,j] := x;\n      i += 1;\n    end;  \n    j += 1;\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Implement a function that creates 2D array from sequence by columns with specified dimensions",
    "output": "function MatrByCol<T>(m,n: integer; a: sequence of T): array [,] of T;\nbegin\n  var res := new T[m,n];\n  var (i,j,num) := (0,0,0);\n  foreach var x in a do\n  begin\n    if num >= m*n then\n      break;\n    res[i,j] := x;\n    num += 1;\n    i += 1;\n    if i >= m then\n    begin\n      i := 0;\n      j += 1;\n    end;\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Implement a function that creates 2D array with random real values",
    "output": "function MatrRandomReal(m: integer; n: integer; a, b: real): array [,] of real;\nbegin\n  Result := new real[m, n];\n  for var i := 0 to Result.RowCount - 1 do\n    for var j := 0 to Result.ColCount - 1 do\n      Result[i, j] := Random() * (b - a) + a;\nend;"
  },
  {
    "instruction": "Implement a function that creates 2D array with elements generated by function",
    "output": "function MatrGen<T>(m, n: integer; gen: (integer,integer)->T): array [,] of T;\nbegin\n  Result := new T[m, n];\n  for var i := 0 to Result.RowCount - 1 do\n    for var j := 0 to Result.ColCount - 1 do\n      Result[i, j] := gen(i, j);\nend;"
  },
  {
    "instruction": "Implement a function that reads 2D integer array from input",
    "output": "function ReadMatrInteger(m, n: integer): array [,] of integer;\nbegin\n  Result := new integer[m, n];\n  for var i := 0 to m - 1 do\n    for var j := 0 to n - 1 do\n      Result[i, j] := ReadInteger;\nend;"
  },
  {
    "instruction": "Implement a function that reads 2D real array from input",
    "output": "function ReadMatrReal(m, n: integer): array [,] of real;\nbegin\n  Result := new real[m, n];\n  for var i := 0 to m - 1 do\n    for var j := 0 to n - 1 do\n      Result[i, j] := ReadReal;\nend;"
  },
  {
    "instruction": "Implement a function that checks if two 2D arrays are equal",
    "output": "function MatrEqual<T>(a, b: array [,] of T): boolean;\nbegin\n  var (m1,n1) := a.Size;\n  var (m2,n2) := b.Size;\n  Result := True;\n  if (m1<>m2) or (n1<>n2) then\n    Result := False\n  else\n    for var i:=0 to m1-1 do\n    for var j:=0 to n1-1 do\n      if a[i,j]<>b[i,j] then\n      begin\n        Result := False;\n        exit;\n      end;\nend;"
  },
  {
    "instruction": "Implement a helper class for adjacent grouping of sequence elements",
    "output": "type\n  AdjGroupClass<T> = class\n  private \n    cur: T;\n    enm: IEnumerator<T>;\n    fin: boolean;\n  public \n    constructor Create(a: sequence of T);\n    begin\n      enm := a.GetEnumerator();\n      fin := enm.MoveNext;\n      if fin then\n        cur := enm.Current;\n    end;\n    \n    function TakeGroup: sequence of T;\n    begin\n      yield cur;\n      fin := enm.movenext;\n      while fin do\n      begin\n        if enm.current = cur then\n          yield enm.current\n        else\n        begin\n          cur := enm.Current;\n          break;\n        end;\n        fin := enm.movenext;\n      end;  \n    end;\n  end;"
  },
  {
    "instruction": "Implement a helper function for incremental sequence calculation for integers",
    "output": "function IncrementalSeq(Self: sequence of integer): sequence of integer; \nbegin\n  var iter := Self.GetEnumerator();\n  if iter.MoveNext() then\n  begin\n    var prevItem := iter.Current;\n    while iter.MoveNext() do\n    begin\n      var nextItem := iter.Current;\n      yield nextItem - prevItem;\n      prevItem := nextItem;\n    end\n  end\nend;"
  },
  {
    "instruction": "Implement a helper function for incremental sequence calculation for real numbers",
    "output": "function IncrementalSeq(Self: sequence of real): sequence of real;\nbegin\n  var iter := Self.GetEnumerator();\n  if iter.MoveNext() then\n  begin\n    var prevItem := iter.Current;\n    while iter.MoveNext() do\n    begin\n      var nextItem := iter.Current;\n      yield nextItem - prevItem;\n      prevItem := nextItem;\n    end\n  end\nend;"
  },
  {
    "instruction": "Implement a helper function for creating slice from list with internal implementation",
    "output": "function CreateSliceFromListInternal<T>(Self: List<T>; from, step, count: integer): List<T>;\nbegin\n  Result := new List<T>(count);\n  \n  var f := from;\n  loop count do\n  begin\n    Result.Add(Self[f]);\n    f += step;\n  end;\nend;"
  },
  {
    "instruction": "Implement a helper function to correct count for slice operations",
    "output": "procedure CorrectCountForSlice(Len, from, step: integer; var count: integer);\nbegin\n  if step = 0 then\n    raise new ArgumentException(GetTranslation(PARAMETER_STEP_MUST_BE_NOT_EQUAL_0));\n  \n  if count < 0 then\n    raise new System.ArgumentOutOfRangeException('count', count, GetTranslation(PARAMETER_MUST_BE_GREATER_EQUAL_0));\n  \n  if (from < 0) or (from > Len - 1) then\n    raise new ArgumentException(GetTranslation(PARAMETER_FROM_OUT_OF_RANGE));\n  \n  var cnt := step > 0 ? Len - from : from + 1; \n  var cntstep := (cnt - 1) div abs(step) + 1;\n  if count > cntstep then \n    count := cntstep;\nend;"
  },
  {
    "instruction": "Implement a helper function for slice list implementation",
    "output": "function SliceListImpl<T>(Self: List<T>; from, step, count: integer): List<T>;\nbegin\n  CorrectCountForSlice(Self.Count, from, step, count);\n  Result := CreateSliceFromListInternal(Self, from, step, count);\nend;"
  },
  {
    "instruction": "Implement a helper procedure to correct from and to parameters for slice operations",
    "output": "procedure CorrectFromTo(situation: integer; Len: integer; var from, &to: integer; step: integer);\nbegin\n  if situation=0 then exit;\n  if step > 0 then\n  begin\n    case situation of\n      1: from := 0;\n      2: &to := Len;\n      3: (from, &to) := (0, Len)\n    end;  \n  end\n  else\n  begin\n    case situation of\n      1: from := Len - 1;\n      2: &to := -1;\n      3: (from, &to) := (Len - 1, -1);\n    end;\n  end;\nend;"
  },
  {
    "instruction": "Implement a helper function to correct from/to and calculate count for system slice with question syntax",
    "output": "function CorrectFromToAndCalcCountForSystemSliceQuestion(situation: integer; Len: integer; var from, &to: integer; step: integer): integer;\nbegin\n  if step = 0 then\n    raise new ArgumentException(GetTranslation(PARAMETER_STEP_MUST_BE_NOT_EQUAL_0));\n  \n  CorrectFromTo(situation, Len, from, &to, step);\n  \n  if step > 0 then\n  begin\n    if from < 0 then\n      from += (step - from - 1) div step * step;\n    var m := Min(Len,&to);\n    if from >= m then \n      Result := 0\n    else Result := (m - from - 1) div step + 1\n  end\n  else\n  begin\n    if from > Len - 1 then\n      from -= (from - Len - step) div step * step;\n    var m := Max(&to,-1);\n    if from <= m then\n      Result := 0\n    else Result := (from - m - 1) div (-step) + 1\n  end;\nend;"
  },
  {
    "instruction": "Implement a helper function to check and correct from/to parameters and calculate count for system slice",
    "output": "function CheckAndCorrectFromToAndCalcCountForSystemSlice(situation: integer; Len: integer; var from, &to: integer; step: integer): integer;\nbegin\n  if step = 0 then\n    raise new ArgumentException(GetTranslation(PARAMETER_STEP_MUST_BE_NOT_EQUAL_0));\n  \n  if (situation = 0) or (situation = 2) then\n    if (from < 0) or (from > Len - 1) then\n      raise new ArgumentException(GetTranslation(PARAMETER_FROM_OUT_OF_RANGE));\n  \n  if (situation = 0) or (situation = 1) then\n    if (&to < -1) or (&to > Len) then\n      raise new ArgumentException(GetTranslation(PARAMETER_TO_OUT_OF_RANGE));\n  \n  if situation > 0 then\n    CorrectFromTo(situation, Len, from, &to, step);\n  \n  if step = 1 then\n  begin\n    Result := &to - from;\n    if Result<0 then \n      Result := 0;\n    exit;  \n  end;\n  \n  var count: integer;\n  \n  if step > 0 then\n  begin\n    var cnt := &to - from;\n    if cnt <= 0 then \n      count := 0\n    else count := (cnt - 1) div step + 1;\n  end\n  else\n  begin\n    var cnt := from - &to;\n    if cnt <= 0 then \n      count := 0\n    else count := (cnt - 1) div (-step) + 1;\n  end;\n  \n  Result := count;\nend;"
  },
  {
    "instruction": "Implement a helper function for system slice list implementation",
    "output": "function SystemSliceListImpl<T>(Self: List<T>; situation: integer; from, &to: integer; step: integer := 1): List<T>;\nbegin\n  var count := CheckAndCorrectFromToAndCalcCountForSystemSlice(situation, Self.Count, from, &to, step);\n  if step=1 then \n    Result := Self.GetRange(from,count)\n  else Result := CreateSliceFromListInternal(Self, from, step, count);\nend;"
  },
  {
    "instruction": "Implement a helper procedure for system slice assignment in lists",
    "output": "procedure SystemSliceAssignmentListImpl<T>(Self: List<T>; rightValue: List<T>; situation: integer; from, &to: integer; step: integer := 1);\nbegin\n  var count := CheckAndCorrectFromToAndCalcCountForSystemSlice(situation, Self.Count, from, &to, step);\n  if count <> rightValue.Count then\n    raise new System.ArgumentException(GetTranslation(SLICE_SIZE_AND_RIGHT_VALUE_SIZE_MUST_BE_EQUAL));\n  var f := from;\n  for var i:=0 to count-1 do\n  begin\n    Self[f] := rightValue[i];\n    f += step;\n  end;\nend;"
  },
  {
    "instruction": "Implement a helper function for system slice list implementation with question syntax",
    "output": "function SystemSliceListImplQuestion<T>(Self: List<T>; situation: integer; from, &to: integer; step: integer := 1): List<T>;\nbegin\n  var count := CorrectFromToAndCalcCountForSystemSliceQuestion(situation, Self.Count, from, &to, step);\n  \n  Result := CreateSliceFromListInternal(Self, from, step, count);\nend;"
  },
  {
    "instruction": "Implement a helper function for creating slice from array with internal implementation",
    "output": "function CreateSliceFromArrayInternal<T>(Self: array of T; from, step, count: integer): array of T;\nbegin\n  Result := new T[count];\n  \n  var f := from;\n  for var i := 0 to count - 1 do\n  begin\n    Result[i] := Self[f];\n    f += step;\n  end;\nend;"
  },
  {
    "instruction": "Implement a helper function for slice array implementation",
    "output": "function SliceArrayImpl<T>(Self: array of T; from, step, count: integer): array of T;\nbegin\n  CorrectCountForSlice(Self.Length, from, step, count);  \n  Result := CreateSliceFromArrayInternal(Self, from, step, count)\nend;"
  },
  {
    "instruction": "Implement a helper function for system slice array implementation",
    "output": "function SystemSliceArrayImpl<T>(Self: array of T; situation: integer; from, &to: integer; step: integer := 1): array of T;\nbegin\n  var count := CheckAndCorrectFromToAndCalcCountForSystemSlice(situation, Self.Length, from, &to, step);\n  Result := CreateSliceFromArrayInternal(Self, from, step, count)\nend;"
  },
  {
    "instruction": "Implement a helper procedure for system slice assignment in arrays",
    "output": "procedure SystemSliceAssignmentArrayImpl<T>(Self: array of T; rightValue: array of T; situation: integer; from, &to: integer; step: integer := 1);\nbegin\n  var count := CheckAndCorrectFromToAndCalcCountForSystemSlice(situation, Self.Length, from, &to, step);\n  if count <> rightValue.Length then\n    raise new System.ArgumentException(GetTranslation(SLICE_SIZE_AND_RIGHT_VALUE_SIZE_MUST_BE_EQUAL));\n  var f := from;\n  var i := 0;\n  loop count do\n  begin\n    Self[f] := rightValue[i];\n    f += step;\n    i += 1;\n  end;\nend;"
  },
  {
    "instruction": "Implement a helper function for system slice array implementation with question syntax",
    "output": "function SystemSliceArrayImplQuestion<T>(Self: array of T; situation: integer; from, &to: integer; step: integer := 1): array of T;\nbegin\n  var count := CorrectFromToAndCalcCountForSystemSliceQuestion(situation, Self.Length, from, &to, step);\n  \n  Result := CreateSliceFromArrayInternal(Self, from, step, count);\nend;"
  },
  {
    "instruction": "Implement a helper function for creating slice from string with internal implementation",
    "output": "function CreateSliceFromStringInternal(Self: string; from, step, count: integer): string;\nbegin\n  var res := new StringBuilder(count);\n  \n  loop count do\n  begin\n    res.Append(Self[from]);\n    from += step;\n  end;\n  Result := res.ToString;\nend;"
  },
  {
    "instruction": "Implement a helper function for slice string implementation",
    "output": "function SliceStringImpl(Self: string; from, step, count: integer): string;\nbegin\n  CorrectCountForSlice(Self.Length, from, step, count);\n  \n  Result := CreateSliceFromStringInternal(Self, from + 1, step, count);\nend;"
  },
  {
    "instruction": "Implement a helper function for system slice string implementation",
    "output": "function SystemSliceStringImpl(Self: string; situation: integer; from, &to: integer; step: integer := 1): string;\nbegin\n  var fromv := from - 1;\n  var tov := &to - 1;\n  var count := CheckAndCorrectFromToAndCalcCountForSystemSlice(situation, Self.Length, fromv, tov, step);\n  \n  if step = 1 then\n    Result := Self.Substring(fromv,count) \n  else Result := CreateSliceFromStringInternal(Self, fromv + 1, step, count)\nend;"
  },
  {
    "instruction": "Implement a helper function for system slice string implementation with question syntax",
    "output": "function SystemSliceStringImplQuestion(Self: string; situation: integer; from, &to: integer; step: integer := 1): string;\nbegin\n  var fromv := from - 1;\n  var tov := &to - 1;\n  \n  var count := CorrectFromToAndCalcCountForSystemSliceQuestion(situation, Self.Length, fromv, tov, step);\n  \n  Result := CreateSliceFromStringInternal(Self, fromv + 1, step, count);\nend;"
  },
  {
    "instruction": "Implement a helper function for next combination generation",
    "output": "function NextCombHelper(ind: array of integer; m,n: integer): boolean;\nbegin\n  for var i:=m-1 downto 0 do\n    if ind[i] < n - m + i then\n    begin\n      ind[i] += 1;\n      for var j:=i to m-1 do \n        ind[j+1] := ind[j] + 1;\n      Result := True;\n      exit\n    end;\n  Result := False;  \nend;"
  },
  {
    "instruction": "Implement a helper function for next permutation generation",
    "output": "function NextPermutation(a: array of integer): boolean;\nbegin\n  var n := a.Length;\n  var j := n - 2;\n  while (j <> -1) and (a[j] >= a[j + 1]) do\n    j -= 1;\n  if j = -1 then\n  begin  \n    Result := False;  \n    exit;\n  end;  \n  var k := n - 1;\n  while a[j] >= a[k] do \n    k -= 1;\n  Swap(a[j], a[k]);\n  Reverse(a,j+1,n-1-j);\n  Result := True;\nend;"
  },
  {
    "instruction": "Implement a helper function to check if value is in range for internal use",
    "output": "function InR(Self: integer; a,b: integer): boolean;\nbegin\n  Result := (a <= Self) and (Self <= b);\nend;"
  },
  {
    "instruction": "Implement a helper procedure to pass spaces in string parsing",
    "output": "procedure PassSpaces(var s: string; var from: integer); \nbegin\n  while (from <= s.Length) and (s[from]=' ') do\n    from += 1;\nend;"
  },
  {
    "instruction": "Implement a helper function for prefix function calculation in string algorithms",
    "output": "function PrefixFunction(s: string): array of integer;\nbegin\n  var n := s.Length;\n  Result := ArrFill(n + 1, 0);\n  for var i := 1 to n - 1 do\n  begin\n    var temp := Result[i];\n    while (temp > 0) and (s[i + 1] <> s[temp + 1]) do\n      temp := Result[temp];\n    Result[i + 1] := s[i + 1] = s[temp + 1] ? temp + 1 : 0\n  end\nend;"
  },
  {
    "instruction": "Implement a helper function for internal range equality comparison for tuples",
    "output": "function InternalEqual<T1, T2> (x: (T1,T2); y: (T1,T2)): boolean; \nbegin\n  var xn := Object.ReferenceEquals(x,nil);\n  var yn := Object.ReferenceEquals(y,nil);\n  if xn then\n    Result := yn\n  else if yn then \n    Result := xn\n  else Result := x.Equals(y);\nend;"
  },
  {
    "instruction": "Implement a helper function for tuple comparison for 2-element tuples",
    "output": "function CompareToTup2<T1, T2>(v1: (T1, T2); v2: (T1, T2)) := (v1 as System.IComparable).CompareTo(v2);"
  },
  {
    "instruction": "Implement a helper function for internal range equality comparison for 3-element tuples",
    "output": "function InternalEqual<T1, T2, T3> (x: (T1,T2,T3); y: (T1,T2,T3)): boolean; \nbegin\n  var xn := Object.ReferenceEquals(x,nil);\n  var yn := Object.ReferenceEquals(y,nil);\n  if xn then\n    Result := yn\n  else if yn then \n    Result := xn\n  else Result := x.Equals(y);\nend;"
  },
  {
    "instruction": "Implement a helper function for tuple comparison for 3-element tuples",
    "output": "function CompareToTup3<T1, T2, T3>(v1: (T1, T2, T3); v2: (T1, T2, T3)) := (v1 as System.IComparable).CompareTo(v2);"
  },
  {
    "instruction": "Implement a helper function for internal range equality comparison for 4-element tuples",
    "output": "function InternalEqual<T1, T2, T3, T4> (x: (T1,T2,T3,T4); y: (T1,T2,T3,T4)): boolean; \nbegin\n  var xn := Object.ReferenceEquals(x,nil);\n  var yn := Object.ReferenceEquals(y,nil);\n  if xn then\n    Result := yn\n  else if yn then \n    Result := xn\n  else Result := x.Equals(y);\nend;"
  },
  {
    "instruction": "Implement a helper function for tuple comparison for 4-element tuples",
    "output": "function CompareToTup4<T1, T2, T3, T4>(v1: (T1, T2, T3, T4); v2: (T1, T2, T3, T4)) := (v1 as System.IComparable).CompareTo(v2);"
  },
  {
    "instruction": "Implement a helper function for internal range equality comparison for 5-element tuples",
    "output": "function InternalEqual<T1, T2, T3, T4, T5> (x: (T1,T2,T3,T4,T5); y: (T1,T2,T3,T4,T5)): boolean; \nbegin\n  var xn := Object.ReferenceEquals(x,nil);\n  var yn := Object.ReferenceEquals(y,nil);\n  if xn then\n    Result := yn\n  else if yn then \n    Result := xn\n  else Result := x.Equals(y);\nend;"
  },
  {
    "instruction": "Implement a helper function for tuple comparison for 5-element tuples",
    "output": "function CompareToTup5<T1, T2, T3, T4,T5>(v1: (T1, T2, T3, T4,T5); v2: (T1, T2, T3, T4,T5)) := (v1 as System.IComparable).CompareTo(v2);"
  },
  {
    "instruction": "Implement a helper function for internal range equality comparison for 6-element tuples",
    "output": "function InternalEqual<T1, T2, T3, T4, T5, T6> (x: (T1,T2,T3,T4,T5,T6); y: (T1,T2,T3,T4,T5,T6)): boolean; \nbegin\n  var xn := Object.ReferenceEquals(x,nil);\n  var yn := Object.ReferenceEquals(y,nil);\n  if xn then\n    Result := yn\n  else if yn then \n    Result := xn\n  else Result := x.Equals(y);\nend;"
  },
  {
    "instruction": "Implement a helper function for internal range equality comparison for 7-element tuples",
    "output": "function InternalEqual<T1, T2, T3, T4, T5, T6, T7> (x: (T1,T2,T3,T4,T5,T6,T7); y: (T1,T2,T3,T4,T5,T6,T7)): boolean; \nbegin\n  var xn := Object.ReferenceEquals(x,nil);\n  var yn := Object.ReferenceEquals(y,nil);\n  if xn then\n    Result := yn\n  else if yn then \n    Result := xn\n  else Result := x.Equals(y);\nend;"
  },
  {
    "instruction": "Implement a helper function for slice sequence implementation",
    "output": "function SliceSeqImpl<T>(Self: sequence of T; from, step, count: integer): sequence of T;\nbegin\n  if step <= 0 then\n    raise new ArgumentException(GetTranslation(PARAMETER_STEP_MUST_BE_GREATER_0));\n  \n  if from < 0 then\n    raise new ArgumentException(GetTranslation(PARAMETER_FROM_OUT_OF_RANGE));\n  \n  Result := Self.Skip(from).Where((x, i)-> i mod step = 0)\nend;"
  },
  {
    "instruction": "Implement a helper function for internal range check",
    "output": "function InRangeInternal(x: integer; a,b: integer): boolean; \nbegin\n  Result := (a <= x) and (x <= b)\nend;"
  },
  {
    "instruction": "Implement a helper function for internal range check for real numbers",
    "output": "function InRangeInternal(x: real; a,b: real): boolean; \nbegin\n  Result := (a <= x) and (x <= b)\nend;"
  },
  {
    "instruction": "Implement a helper function for internal range check for characters",
    "output": "function InRangeInternal(x: char; a,b: char): boolean; \nbegin\n  Result := (a <= x) and (x <= b)\nend;"
  },
  {
    "instruction": "Implement a helper function to get sizes of multidimensional array",
    "output": "function get_sizes(a: &Array): array of integer;\nbegin\n  var rank := a.Rank;\n  Result := Result;\n  SetLength(Result, rank);\n  for var i := 0 to rank - 1 do\n    Result[i] := a.GetLength(i);  \nend;"
  },
  {
    "instruction": "Implement a helper procedure for internal array copying with size consideration",
    "output": "procedure internal_copy(source, dest: &Array; source_sizes, dest_sizes: array of integer; i: integer; var src_ind, dest_ind: integer; flag: byte);\nbegin\n  if i <> source_sizes.Length - 1 then\n  begin\n    for var j := 0 to min(source_sizes[i], dest_sizes[i]) - 1 do\n      internal_copy(source, dest, source_sizes, dest_sizes, i + 1, src_ind, dest_ind, flag);\n    if dest_sizes[i] > source_sizes[i] then\n      for var j := source_sizes[i] to dest_sizes[i] - 1 do\n      begin\n        internal_copy(source, dest, source_sizes, dest_sizes, i + 1, src_ind, dest_ind, 1);\n      end\n    else\n    if dest_sizes[i] < source_sizes[i] then\n      for var j := dest_sizes[i] to source_sizes[i] - 1 do\n      begin\n        internal_copy(source, dest, source_sizes, dest_sizes, i + 1, src_ind, dest_ind, 2);\n      end\n  end\n  else\n  begin\n    if flag = 0 then\n    begin\n      System.Array.Copy(source, src_ind, dest, dest_ind, min(source_sizes[source_sizes.Length - 1], dest_sizes[source_sizes.Length - 1]));\n      src_ind += source_sizes[source_sizes.Length - 1];\n      dest_ind += dest_sizes[source_sizes.Length - 1];\n    end\n    else if flag = 1 then\n      dest_ind += dest_sizes[source_sizes.Length - 1]\n    else\n      src_ind += source_sizes[source_sizes.Length - 1];\n  end;\nend;"
  },
  {
    "instruction": "Implement a helper function to copy array with size consideration",
    "output": "function CopyWithSize(source, dest: &Array): &Array;\nbegin\n  if source <> nil then\n  begin\n    var source_sizes := get_sizes(source);\n    var dest_sizes := get_sizes(dest);\n    var src_ind := 0;\n    var dest_ind := 0;\n    internal_copy(source, dest, source_sizes, dest_sizes, 0, src_ind, dest_ind, 0);\n  end;\n  Result := dest;\nend;"
  },
  {
    "instruction": "Implement a helper function to check integer range with bounds",
    "output": "function check_in_range(val: int64; low, up: int64): int64;\nbegin\n  if (val < low) or (val > up) then\n    raise new RangeException(GetTranslation(RANGE_ERROR_MESSAGE));\n  Result := val;\nend;"
  },
  {
    "instruction": "Implement a helper function to check character range with bounds",
    "output": "function check_in_range_char(val: char; low, up: char): char;\nbegin\n  if (val < low) or (val > up) then\n    raise new RangeException(GetTranslation(RANGE_ERROR_MESSAGE));\n  Result := val;\nend;"
  },
  {
    "instruction": "Implement a helper function to get runtime size of type",
    "output": "function RunTimeSizeOf(t: System.Type): integer;\nvar\n  t1: System.Type;\n  elem: object;\n  fa: array of System.Reflection.FieldInfo;\n  NullBasedArray: System.Array;\n  fi: System.Reflection.FieldInfo;\nbegin\n  if t.IsPrimitive or t.IsEnum then \n    case System.Type.GetTypeCode(t) of\n      TypeCode.Boolean: Result := sizeof(Boolean);\n      TypeCode.Byte: Result := sizeof(Byte);\n      TypeCode.Char: Result := 1;\n      TypeCode.Decimal: Result := sizeof(Decimal);\n      TypeCode.Double: Result := sizeof(Double);\n      TypeCode.Int16: Result := sizeof(Int16);\n      TypeCode.Int32: Result := sizeof(Int32);\n      TypeCode.Int64: Result := sizeof(Int64);\n      TypeCode.UInt16: Result := sizeof(UInt16);\n      TypeCode.UInt32: Result := sizeof(UInt32);\n      TypeCode.UInt64: Result := sizeof(UInt64);\n      TypeCode.SByte: Result := sizeof(SByte);\n      TypeCode.Single: Result := sizeof(Single);\n    else if t.IsEnum then Result := sizeof(integer);\n    end\n  else\n  if t.IsValueType then\n  begin\n    fa := t.GetFields(System.Reflection.BindingFlags.GetField or System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Public or System.Reflection.BindingFlags.NonPublic);\n    Result := 0;\n    for var i := 0 to fa.Length - 1 do\n      if not fa[i].IsLiteral then \n        Result := Result + RunTimeSizeOf(fa[i].FieldType)\n  end\n  else if t = typeof(string) then\n    Result := 0\n  else\n  if t = typeof(TypedSet) then\n  begin\n    Result := 256 div 8;\n  end\n  else\n  begin\n    fi := t.GetField(InternalNullBasedArrayName);\n    if fi = nil then \n      raise new SystemException(GetTranslation(BAD_TYPE_IN_RUNTIMESIZEOF));\n    elem := Activator.CreateInstance(t);\n    NullBasedArray := GetNullBasedArray(elem);\n    \n    t1 := NullBasedArray.GetType.GetElementType;\n    Result := RunTimeSizeOf(t1) * NullBasedArray.Length;\n  end;\nend;"
  },
  {
    "instruction": "Implement a helper function to get character in short string with bounds checking",
    "output": "function GetCharInShortString(s: string; ind, n: integer): char;\nbegin\n  if ind < 0 then \n    raise new IndexOutOfRangeException;\n  if ind = 0 then \n    Result := char(s.Length)\n  else \n    try\n      Result := s[ind];\n    except \n      on e: Exception do\n        if ind > n then raise;\n    end;\nend;"
  },
  {
    "instruction": "Implement a helper function to set character in short string with bounds checking",
    "output": "function SetCharInShortString(s: string; ind, n: integer; c: char): string;\nbegin\n  if ind < 0 then \n    raise new IndexOutOfRangeException;\n  if ind <> 0 then\n  begin\n    var sb := new System.Text.StringBuilder();\n    sb.Append(s);\n    if ind - 1 < sb.Length then\n      sb[ind - 1] := c;\n    if ind > n then raise new IndexOutOfRangeException;\n    Result := sb.ToString;\n  end\n  else\n  begin\n    raise new IndexOutOfRangeException;\n  end;\nend;"
  },
  {
    "instruction": "Implement a helper function to clip short string to specified length",
    "output": "function ClipShortString(s: string; len: integer): string;\nbegin\n  if s.Length <= len then \n    Result := s\n  else Result := s.Substring(0, len);\nend;"
  },
  {
    "instruction": "Implement a helper function to get resource stream",
    "output": "function GetResourceStream(ResourceFileName: string): Stream;\nbegin\n  Result := System.Reflection.Assembly.GetEntryAssembly().GetManifestResourceStream(ResourceFileName);\nend;"
  },
  {
    "instruction": "Implement a helper function to format value as string with specified width",
    "output": "function FormatValue(value: object; NumOfChars: integer): string;\nbegin\n  if value <> nil then\n    Result := StructuredObjectToString(value)\n  else\n    Result := 'nil';\n  Result := Result.PadLeft(NumOfChars);\nend;"
  },
  {
    "instruction": "Implement a helper function to format integer value with specified width",
    "output": "function FormatValue(value: integer; NumOfChars: integer): string;\nbegin\n  Result := value.ToString;\n  Result := Result.PadLeft(NumOfChars);\nend;"
  },
  {
    "instruction": "Implement a helper function to format int64 value with specified width",
    "output": "function FormatValue(value: int64; NumOfChars: integer): string;\nbegin\n  Result := value.ToString;\n  Result := Result.PadLeft(NumOfChars);\nend;"
  },
  {
    "instruction": "Implement a helper function to format real value with specified width",
    "output": "function FormatValue(value: real; NumOfChars: integer): string;\nbegin\n  Result := value.ToString(nfi);\n  Result := Result.PadLeft(NumOfChars);\nend;"
  },
  {
    "instruction": "Implement a helper function to format real value with specified width and decimal places",
    "output": "function FormatValue(value: real; NumOfChars, NumOfSignesAfterDot: integer): string;\nbegin\n  var FmtStr := '{0,' + NumOfChars.ToString + ':f' + abs(NumOfSignesAfterDot).ToString + '}';\n  Result := Format(FmtStr, value);\nend;"
  },
  {
    "instruction": "Implement a helper procedure to set string default property",
    "output": "procedure StringDefaultPropertySet(var s: string; index: integer; c: char);\nbegin\n  var chars := s.ToCharArray;\n  chars[index] := c;\n  s := new String(chars);\nend;"
  },
  {
    "instruction": "Implement a helper procedure to change character value",
    "output": "procedure ChangeChar(var c: char; val: char);\nbegin\n  c := val;\nend;"
  },
  {
    "instruction": "Implement a helper procedure to check if type can be used for pointers",
    "output": "procedure CheckCanUsePointerOnType(T: System.Type);\nbegin\n  if T.IsPointer then\n  begin\n    CheckCanUsePointerOnType(T.GetElementType());\n    exit;\n  end;\n  if T.IsValueType then\n  begin\n    var fields := T.GetFields();\n    foreach var fi in fields do\n      if not fi.IsStatic then\n        CheckCanUsePointerOnType(fi.FieldType);\n    exit;\n  end;\n  raise new CanNotUseTypeForPointersException(T);\nend;"
  },
  {
    "instruction": "Implement a helper procedure to check if type can be used for files",
    "output": "procedure CheckCanUseTypeForFiles(T: System.Type; FileIsBinary: boolean);\nvar\n  fields: array of System.Reflection.FieldInfo;\nbegin\n  if T.IsPrimitive or T.IsEnum then\n    exit;\n  if T = typeof(TypedSet) then\n  begin\n    raise new CanNotUseTypeForFilesException(T);\n  end;\n  if T = typeof(string) then\n    if FileIsBinary then\n      exit\n    else\n      raise new CanNotUseTypeForTypedFilesException(T);\n  if T.IsValueType then\n  begin\n    fields := T.GetFields();\n    foreach var fi in fields do\n      if not fi.IsStatic then\n        CheckCanUseTypeForFiles(fi.FieldType, FileIsBinary);\n    exit;\n  end;\n  raise new CanNotUseTypeForFilesException(T);\nend;"
  },
  {
    "instruction": "Implement a helper procedure to check if type can be used for binary files",
    "output": "procedure CheckCanUseTypeForBinaryFiles(T: System.Type);\nbegin\n  CheckCanUseTypeForFiles(T, true);\nend;"
  },
  {
    "instruction": "Implement a helper procedure to check if type can be used for typed files",
    "output": "procedure CheckCanUseTypeForTypedFiles(T: System.Type);\nbegin\n  CheckCanUseTypeForFiles(T, false);\nend;"
  },
  {
    "instruction": "Implement a helper function to determine type at runtime",
    "output": "function RuntimeDetermineType(T: System.Type): byte;\nbegin\n  result := 0;\n  if T.IsValueType and (T.GetMethod('$Init$') <> nil) then\n  begin\n    result := 1;\n    exit;\n  end;\n  if T = typeof(string) then\n  begin\n    result := 2;\n    exit;\n  end;\n  if T = typeof(TypedSet) then\n  begin\n    result := 3;\n    exit;\n  end;\n  if T = typeof(Text) then\n  begin\n    result := 4;\n    exit;\n  end;\n  if T = typeof(BinaryFile) then\n  begin\n    result := 5;\n    exit;\n  end;\nend;"
  },
  {
    "instruction": "Implement a helper function to initialize runtime objects",
    "output": "function RuntimeInitialize(kind: byte; variable: object): object;\nbegin\n  case kind of\n    1: \n      begin\n        variable.GetType.InvokeMember('$Init$',\n        System.Reflection.BindingFlags.InvokeMethod or\n        System.Reflection.BindingFlags.Instance or\n        System.Reflection.BindingFlags.Public, nil, variable, nil);\n        result := variable;\n      end;\n    2: result := '';\n    3: result := new TypedSet;\n    4: result := new Text;\n    5: result := new BinaryFile;\n  end;\nend;"
  },
  {
    "instruction": "Implement a helper function to get runtime size of generic type",
    "output": "function GetRuntimeSize<T>: integer;\nvar\n  val: T;\nbegin\n  result := System.Runtime.InteropServices.Marshal.SizeOf(val);\nend;"
  },
  {
    "instruction": "Implement a helper function to fix pointer for interop",
    "output": "function __FixPointer(obj: object): GCHandle;\nbegin\n  if obj <> nil then\n  begin\n    try\n      if (NotPinnableWrapper.notPinnableTypes <> nil) and NotPinnableWrapper.notPinnableTypes.Contains(obj.GetType()) then\n        Result := GCHandle.Alloc(obj)\n      else\n        Result := GCHandle.Alloc(obj, GCHandleType.Pinned);\n    except\n      if NotPinnableWrapper.notPinnableTypes = nil then \n          NotPinnableWrapper.notPinnableTypes := new HashSet<&Type>;\n      NotPinnableWrapper.notPinnableTypes.Add(obj.GetType());\n      Result := GCHandle.Alloc(obj);\n    end;\n  end;\nend;"
  },
  {
    "instruction": "Implement a helper function to convert to nullable value type",
    "output": "function DQNToNullable<T>(v: T): System.Nullable<T>; where T: record;\nbegin\n  Result := new System.Nullable<T>(v);\nend;"
  },
  {
    "instruction": "Implement a SliceType class for multidimensional array slicing operations",
    "output": "type\n  SliceType = class\n    situation,from, &to, step, count: integer;\n    fromInverted, toInverted: boolean;\n    function oneelem: boolean := step = integer.MaxValue;\n    constructor (sit,f,t: integer; st: integer := 1);\n    begin\n      situation := sit;\n      from := f;\n      &to := t;\n      fromInverted := False;\n      toInverted := False;\n      step := st;\n      count := -1;\n    end;\n    procedure CorrectSliceAndCalcCount(len: integer);\n    begin\n      if fromInverted then\n        from := len - from;\n      if toInverted then\n        &to := len - &to;\n\n      if oneelem then\n        count := 1 \n      else count := CheckAndCorrectFromToAndCalcCountForSystemSlice(situation, len, from, &to, step);\n    end;\n    static function operator implicit(i: integer): SliceType;\n    static function operator implicit(ir: IntRange): SliceType;\n    static function operator implicit(sl: (integer,integer,integer)): SliceType;\n    static function operator implicit(sl: (SystemIndex,SystemIndex,integer)): SliceType;\n    static function operator implicit(sl: (integer,SystemIndex,integer)): SliceType;\n    static function operator implicit(sl: (SystemIndex,integer,integer)): SliceType;\n  end;"
  },
  {
    "instruction": "Implement helper functions for creating slice type instances",
    "output": "function Diap(f, t: integer) := new SliceType(0, f, t, 1);\nfunction Elem(ind: integer) := new SliceType(0, ind, ind+1, integer.MaxValue);\nfunction Slice(f, t: integer; st: integer := 1): SliceType;\nbegin\n  var sit := 0;\n  if f = integer.MaxValue then\n    sit += 1;\n  if t = integer.MaxValue then\n    sit += 2;\n  Result := new SliceType(sit, f, t, st);\nend;"
  },
  {
    "instruction": "Implement implicit conversion operators for SliceType class",
    "output": "static function SliceType.operator implicit(i: integer): SliceType;\nbegin\n  Result := Elem(i);\nend;\n\nstatic function SliceType.operator implicit(ir: IntRange): SliceType;\nbegin\n  Result := Diap(ir.Low,ir.High);\nend;\n\nstatic function SliceType.operator implicit(sl: (integer,integer,integer)): SliceType;\nbegin\n  Result := Slice(sl[0],sl[1],sl[2]);\nend;\n\nstatic function SliceType.operator implicit(sl: (SystemIndex,SystemIndex,integer)): SliceType;\nbegin\n  Result := Slice(sl[0].IndexValue,sl[1].IndexValue,sl[2]);\n  Result.fromInverted := sl[0].IsInverted;\n  Result.toInverted := sl[1].IsInverted;\nend;\n\nstatic function SliceType.operator implicit(sl: (integer,SystemIndex,integer)): SliceType;\nbegin\n  Result := Slice(sl[0],sl[1].IndexValue,sl[2]);\n  Result.toInverted := sl[1].IsInverted;\nend;\n\nstatic function SliceType.operator implicit(sl: (SystemIndex,integer,integer)): SliceType;\nbegin\n  Result := Slice(sl[0].IndexValue,sl[1],sl[2]);\n  Result.fromInverted := sl[0].IsInverted;\nend;"
  },
  {
    "instruction": "Implement helper functions for converting multidimensional arrays to one-dimensional arrays",
    "output": "function ToOneDim<T>(a: array [,] of T; l: array of SliceType): array of T;\nbegin\n  for var i:=0 to l.Length-1 do\n    l[i].CorrectSliceAndCalcCount(a.GetLength(i));\n  var onedimsz := l[0].count * l[1].count;\n  var res := new T[onedimsz];\n  if onedimsz>0 then\n  begin\n    var cur := 0;\n    var i0 := l[0].from;\n    loop l[0].count do\n    begin\n      var i1:=l[1].from;\n      loop l[1].count do\n      begin\n        res[cur] := a[i0,i1];\n        cur += 1;\n        i1 += l[1].step;\n      end;\n      i0 += l[0].step;\n    end;\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Implement helper function for converting 3D arrays to one-dimensional arrays",
    "output": "function ToOneDim<T>(a: array [,,] of T; l: array of SliceType): array of T;\nbegin\n  for var i:=0 to l.Length-1 do\n    l[i].CorrectSliceAndCalcCount(a.GetLength(i));\n  var onedimsz := l[0].count * l[1].count * l[2].count;\n  var res := new T[onedimsz];\n  if onedimsz>0 then\n  begin\n    var cur := 0;\n    var i0 := l[0].from;\n    loop l[0].count do\n    begin\n      var i1:=l[1].from;\n      loop l[1].count do\n      begin\n        var i2 := l[2].from;\n        loop l[2].count do\n        begin\n          res[cur] := a[i0,i1,i2];\n          cur += 1;\n          i2 += l[2].step;\n        end;\n        i1 += l[1].step;\n      end;\n      i0 += l[0].step;\n    end;\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Implement helper function for converting 4D arrays to one-dimensional arrays",
    "output": "function ToOneDim<T>(a: array [,,,] of T; l: array of SliceType): array of T;\nbegin\n  for var i:=0 to l.Length-1 do\n    l[i].CorrectSliceAndCalcCount(a.GetLength(i));\n  var onedimsz := l[0].count * l[1].count * l[2].count * l[3].count;\n  var res := new T[onedimsz];\n  if onedimsz>0 then\n  begin\n    var cur := 0;\n    var i0 := l[0].from;\n    loop l[0].count do\n    begin\n      var i1:=l[1].from;\n      loop l[1].count do\n      begin\n        var i2 := l[2].from;\n        loop l[2].count do\n        begin\n          var i3 := l[3].from;\n          loop l[3].count do\n          begin\n            res[cur] := a[i0,i1,i2,i3];\n            cur += 1;\n            i3 += l[3].step;\n          end;  \n          i2 += l[2].step;\n        end;\n        i1 += l[1].step;\n      end;\n      i0 += l[0].step;\n    end;\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Implement helper functions for converting one-dimensional arrays back to multidimensional arrays",
    "output": "function FromOneDim2<T>(r: array of T; l: array of SliceType): array [,] of T;\nbegin\n  var dims := l.FindAll(x -> x.oneelem = False).ConvertAll(x -> x.count);\n  var cur := 0;\n  var res := new T[dims[0],dims[1]];\n  for var i0:=0 to dims[0]-1 do\n  for var i1:=0 to dims[1]-1 do\n  begin\n    res[i0,i1] := r[cur];\n    cur += 1;\n  end;\n  Result := res;\nend;\n\nfunction FromOneDim3<T>(r: array of T; l: array of SliceType): array [,,] of T;\nbegin\n  var dims := l.FindAll(x -> x.oneelem = False).ConvertAll(x -> x.count);\n  var cur := 0;\n  var res := new T[dims[0],dims[1],dims[2]];\n  for var i0:=0 to dims[0]-1 do\n  for var i1:=0 to dims[1]-1 do\n  for var i2:=0 to dims[2]-1 do\n  begin\n    res[i0,i1,i2] := r[cur];\n    cur += 1;\n  end;\n  Result := res;\nend;\n\nfunction FromOneDim4<T>(r: array of T; l: array of SliceType): array [,,,] of T;\nbegin\n  var dims := l.FindAll(x -> x.oneelem = False).ConvertAll(x -> x.count);\n  var cur := 0;\n  var res := new T[dims[0],dims[1],dims[2],dims[3]];\n  for var i0:=0 to dims[0]-1 do\n  for var i1:=0 to dims[1]-1 do\n  for var i2:=0 to dims[2]-1 do\n  for var i3:=0 to dims[3]-1 do\n  begin\n    res[i0,i1,i2,i3] := r[cur];\n    cur += 1;\n  end;\n  Result := res;\nend;"
  },
  {
    "instruction": "Implement helper function for converting one-dimensional arrays to N-dimensional arrays",
    "output": "function FromOneDimN<T>(r: array of T; l: array of SliceType): System.Array;\nbegin\n  var rank := l.Count(x -> x.oneelem = False);\n  case rank of\n    1: Result := r;\n    2: Result := FromOneDim2(r,l);\n    3: Result := FromOneDim3(r,l);\n    4: Result := FromOneDim4(r,l);\n  end;  \nend;"
  },
  {
    "instruction": "Implement helper functions for slicing N-dimensional arrays",
    "output": "function SliceN<T>(a: array[,] of T; l: array of SliceType): System.Array;\nbegin\n  var r := ToOneDim(a,l);\n  Result := FromOneDimN(r,l);\nend;\n\nfunction SliceN<T>(a: array[,,] of T; l: array of SliceType): System.Array;\nbegin\n  var r := ToOneDim(a,l);\n  Result := FromOneDimN(r,l);\nend;\n\nfunction SliceN<T>(a: array[,,,] of T; l: array of SliceType): System.Array;\nbegin\n  var r := ToOneDim(a,l);\n  Result := FromOneDimN(r,l);\nend;"
  },
  {
    "instruction": "Implement extension methods for system slicing of multidimensional arrays returning arrays",
    "output": "function SystemSliceN1<T>(Self: array[,] of T; params l: array of SliceType): array of T; extensionmethod \n  := SliceN(Self,l) as array of T;\n\nfunction SystemSliceN1<T>(Self: array[,,] of T; params l: array of SliceType): array of T; extensionmethod \n  := SliceN(Self,l) as array of T;\n\nfunction SystemSliceN1<T>(Self: array[,,,] of T; params l: array of SliceType): array of T; extensionmethod \n  := SliceN(Self,l) as array of T;"
  },
  {
    "instruction": "Implement extension methods for system slicing of multidimensional arrays returning 2D arrays",
    "output": "function SystemSliceN2<T>(Self: array[,] of T; params l: array of SliceType): array[,] of T; extensionmethod \n  := SliceN(Self,l) as array [,] of T;\n\nfunction SystemSliceN2<T>(Self: array[,,] of T; params l: array of SliceType): array[,] of T; extensionmethod \n  := SliceN(Self,l) as array [,] of T;\n\nfunction SystemSliceN2<T>(Self: array[,,,] of T; params l: array of SliceType): array[,] of T; extensionmethod \n  := SliceN(Self,l) as array [,] of T;"
  },
  {
    "instruction": "Implement extension methods for system slicing of multidimensional arrays returning 3D arrays",
    "output": "function SystemSliceN3<T>(Self: array[,,] of T; params l: array of SliceType): array[,,] of T; extensionmethod \n  := SliceN(Self,l) as array [,,] of T;\n\nfunction SystemSliceN3<T>(Self: array[,,,] of T; params l: array of SliceType): array[,,] of T; extensionmethod \n  := SliceN(Self,l) as array [,,] of T;"
  },
  {
    "instruction": "Implement extension method for system slicing of 4D arrays returning 4D arrays",
    "output": "function SystemSliceN4<T>(Self: array[,,,] of T; params l: array of SliceType): array[,,,] of T; extensionmethod \n  := SliceN(Self,l) as array [,,,] of T;"
  },
  {
    "instruction": "Implement extension methods for system slicing of lists with SystemIndex parameters",
    "output": "function SystemSlice<T>(Self: List<T>; situation: integer; from, &to: SystemIndex; step: integer := 1): List<T>; extensionmethod;\nbegin\n  if from.IsInverted then\n    from.IndexValue := Self.Count - from.IndexValue;\n  if &to.IsInverted then\n    &to.IndexValue := Self.Count - &to.IndexValue;\n  Result := SystemSliceListImpl(Self, situation, from.IndexValue, &to.IndexValue, step);\nend;"
  },
  {
    "instruction": "Implement extension methods for system slice assignment in lists with SystemIndex parameters",
    "output": "procedure SystemSliceAssignment<T>(Self: List<T>; rightValue: List<T>; situation: integer; from, &to: SystemIndex; step: integer := 1); extensionmethod;\nbegin\n  if from.IsInverted then\n    from.IndexValue := Self.Count - from.IndexValue;\n  if &to.IsInverted then\n    &to.IndexValue := Self.Count - &to.IndexValue;\n  SystemSliceAssignmentListImpl(Self, rightValue, situation, from.IndexValue, &to.IndexValue, step);\nend;"
  },
  {
    "instruction": "Implement extension methods for system slicing of lists with question syntax and SystemIndex parameters",
    "output": "function SystemSliceQuestion<T>(Self: List<T>; situation: integer; from, &to: SystemIndex; step: integer := 1): List<T>; extensionmethod;\nbegin\n  if from.IsInverted then\n    from.IndexValue := Self.Count - from.IndexValue;\n  if &to.IsInverted then\n    &to.IndexValue := Self.Count - &to.IndexValue;\n  Result := SystemSliceListImplQuestion(Self, situation, from.IndexValue, &to.IndexValue, step);\nend;"
  },
  {
    "instruction": "Implement extension methods for system slicing of arrays with SystemIndex parameters",
    "output": "function SystemSlice<T>(Self: array of T; situation: integer; from, &to: SystemIndex; step: integer := 1): array of T; extensionmethod;\nbegin\n  if from.IsInverted then\n    from.IndexValue := Self.Count - from.IndexValue;\n  if &to.IsInverted then\n    &to.IndexValue := Self.Count - &to.IndexValue;\n  Result := SystemSliceArrayImpl(Self, situation, from.IndexValue, &to.IndexValue, step);\nend;"
  },
  {
    "instruction": "Implement extension methods for system slice assignment in arrays with SystemIndex parameters",
    "output": "procedure SystemSliceAssignment<T>(Self: array of T; rightValue: array of T; situation: integer; from, &to: SystemIndex; step: integer := 1); extensionmethod;\nbegin\n  if from.IsInverted then\n    from.IndexValue := Self.Count - from.IndexValue;\n  if &to.IsInverted then\n    &to.IndexValue := Self.Count - &to.IndexValue;\n  SystemSliceAssignmentArrayImpl(Self, rightValue, situation, from.IndexValue, &to.IndexValue, step);\nend;"
  },
  {
    "instruction": "Implement extension methods for system slicing of arrays with question syntax and SystemIndex parameters",
    "output": "function SystemSliceQuestion<T>(Self: array of T; situation: integer; from, &to: SystemIndex; step: integer := 1): array of T; extensionmethod;\nbegin\n  if from.IsInverted then\n    from.IndexValue := Self.Count - from.IndexValue;\n  if &to.IsInverted then\n    &to.IndexValue := Self.Count - &to.IndexValue;\n  Result := SystemSliceArrayImplQuestion(Self, situation, from.IndexValue, &to.IndexValue, step);\nend;"
  },
  {
    "instruction": "Implement extension methods for system slicing of strings with SystemIndex parameters",
    "output": "function SystemSlice(Self: string; situation: integer; from, &to: SystemIndex; step: integer := 1): string; extensionmethod;\nbegin\n  if from.IsInverted then\n    from.IndexValue := Self.Count - from.IndexValue + 1;\n  if &to.IsInverted then\n    &to.IndexValue := Self.Count - &to.IndexValue + 1;\n  Result := SystemSliceStringImpl(Self, situation, from.IndexValue, &to.IndexValue, step);\nend;"
  },
  {
    "instruction": "Implement extension methods for system slicing of strings with question syntax and SystemIndex parameters",
    "output": "function SystemSliceQuestion(Self: string; situation: integer; from, &to: SystemIndex; step: integer := 1): string; extensionmethod;\nbegin\n  if from.IsInverted then\n    from.IndexValue := Self.Count - from.IndexValue + 1;\n  if &to.IsInverted then\n    &to.IndexValue := Self.Count - &to.IndexValue + 1;\n  Result := SystemSliceStringImplQuestion(Self, situation, from.IndexValue, &to.IndexValue, step);\nend;"
  },
  {
    "instruction": "Implement extension methods for adding elements to tuples",
    "output": "function Add<T1, T2, T3>(Self: (T1, T2); v: T3): (T1, T2, T3); extensionmethod;\nbegin\n  Result := (Self[0], Self[1], v);\nend;\n\nfunction Add<T1, T2, T3, T4>(Self: (T1, T2, T3); v: T4): (T1, T2, T3, T4); extensionmethod;\nbegin\n  Result := (Self[0], Self[1], Self[2], v);\nend;\n\nfunction Add<T1, T2, T3, T4, T5>(Self: (T1, T2, T3, T4); v: T5): (T1, T2, T3, T4, T5); extensionmethod;\nbegin\n  Result := (Self[0], Self[1], Self[2], Self[3], v);\nend;\n\nfunction Add<T1, T2, T3, T4, T5, T6>(Self: (T1, T2, T3, T4, T5); v: T6): (T1, T2, T3, T4, T5, T6); extensionmethod;\nbegin\n  Result := (Self[0], Self[1], Self[2], Self[3], Self[4], v);\nend;\n\nfunction Add<T1, T2, T3, T4, T5, T6, T7>(Self: (T1, T2, T3, T4, T5, T6); v: T7): (T1, T2, T3, T4, T5, T6, T7); extensionmethod;\nbegin\n  Result := (Self[0], Self[1], Self[2], Self[3], Self[4], Self[5], v);\nend;"
  },
  {
    "instruction": "Implement extension methods for printing tuples of various sizes",
    "output": "procedure Print<T1, T2>(Self: (T1, T2)); extensionmethod := Print(Self);\nprocedure Print<T1, T2, T3>(Self: (T1, T2, T3)); extensionmethod := Print(Self);\nprocedure Print<T1, T2, T3, T4>(Self: (T1, T2, T3, T4)); extensionmethod := Print(Self);\nprocedure Print<T1, T2, T3, T4, T5>(Self: (T1, T2, T3, T4, T5)); extensionmethod := Print(Self);\nprocedure Print<T1, T2, T3, T4, T5, T6>(Self: (T1, T2, T3, T4, T5, T6)); extensionmethod := Print(Self);\nprocedure Print<T1, T2, T3, T4, T5, T6, T7>(Self: (T1, T2, T3, T4, T5, T6, T7)); extensionmethod := Print(Self);"
  },
  {
    "instruction": "Implement extension methods for printing tuples with new line of various sizes",
    "output": "procedure Println<T1, T2>(Self: (T1, T2)); extensionmethod := Println(Self);\nprocedure Println<T1, T2, T3>(Self: (T1, T2, T3)); extensionmethod := Println(Self);\nprocedure Println<T1, T2, T3, T4>(Self: (T1, T2, T3, T4)); extensionmethod := Println(Self);\nprocedure Println<T1, T2, T3, T4, T5>(Self: (T1, T2, T3, T4, T5)); extensionmethod := Println(Self);\nprocedure Println<T1, T2, T3, T4, T5, T6>(Self: (T1, T2, T3, T4, T5, T6)); extensionmethod := Println(Self);\nprocedure Println<T1, T2, T3, T4, T5, T6, T7>(Self: (T1, T2, T3, T4, T5, T6, T7)); extensionmethod := Println(Self);"
  },
  {
    "instruction": "Implement extension methods for combinations and permutations of sequences",
    "output": "function Combinations<T>(Self: sequence of T; m: integer): sequence of array of T; extensionmethod;\nbegin\n  Result := Self.ToArray.Combinations(m);\nend;\n\nfunction Permutations<T>(Self: sequence of T): sequence of array of T; extensionmethod;\nbegin\n  Result := Self.ToArray.Permutations\nend;\n\nfunction Permutations<T>(Self: sequence of T; m: integer): sequence of array of T; extensionmethod;\nbegin\n  Result := Self.ToArray.Permutations(m);\nend;\n\nfunction Cartesian<T>(Self: sequence of T; n: integer): sequence of array of T; extensionmethod;\nbegin\n  Result := Self.ToArray.Cartesian(n);\nend;"
  },
  {
    "instruction": "Implement extension methods for incremental operations on various collection types",
    "output": "function Incremental(Self: array of integer): sequence of integer; extensionmethod;\nbegin\n  Result := IncrementalSeq(Self);\nend;\n\nfunction Incremental(Self: List<integer>): sequence of integer; extensionmethod;\nbegin\n  Result := IncrementalSeq(Self);\nend;\n\nfunction Incremental(Self: LinkedList<integer>): sequence of integer; extensionmethod;\nbegin\n  Result := IncrementalSeq(Self);\nend;\n\nfunction Incremental(Self: array of real): sequence of real; extensionmethod;\nbegin\n  Result := IncrementalSeq(Self);\nend;\n\nfunction Incremental(Self: List<real>): sequence of real; extensionmethod;\nbegin\n  Result := IncrementalSeq(Self);\nend;\n\nfunction Incremental(Self: LinkedList<real>): sequence of real; extensionmethod;\nbegin\n  Result := IncrementalSeq(Self);\nend;"
  },
  {
    "instruction": "Implement extension method for setting row of 2D array using sequence",
    "output": "procedure SetRow<T>(Self: array [,] of T; k: integer; a: sequence of T); extensionmethod := Self.SetRow(k,a.ToArray);"
  },
  {
    "instruction": "Implement extension method that checks if 2D arrays are equal",
    "output": "function MatrEqual<T>(Self,b: array[,] of T): boolean; extensionmethod := MatrEqual(Self,b);"
  },
  {
    "instruction": "Implement extension method that joins sequence into string with default delimiter",
    "output": "function JoinToString<T>(Self: sequence of T): string; extensionmethod;\nbegin\n  if typeof(T) = typeof(char) then\n    Result := Self.JoinIntoString('') \n  else Result := Self.JoinIntoString(' ');  \nend;"
  },
  {
    "instruction": "Implement extension method that prints sequence with default delimiter and moves to new line",
    "output": "function Println<T>(Self: sequence of T): sequence of T; extensionmethod;\nbegin\n  if typeof(T) = typeof(char) then \n    Result := Self.Println('')\n  else  \n    Result := Self.Println(PrintDelimDefault);  \nend;"
  },
  {
    "instruction": "Implement extension method for joining sequence into string with alias",
    "output": "function JoinIntoString<T>(Self: sequence of T; delim: string): string; extensionmethod\n  := Self.JoinToString(delim);"
  },
  {
    "instruction": "Implement extension method for joining sequence into string with default delimiter with alias",
    "output": "function JoinIntoString<T>(Self: sequence of T): string; extensionmethod\n  := Self.JoinToString();"
  },
  {
    "instruction": "Implement extension operator for function composition",
    "output": "function operator*<T1, T2, TResult>(Self: T2->TResult; composer: T1->T2): T1->TResult; extensionmethod;\nbegin\n  if composer = nil then\n    raise new System.ArgumentNullException('composer');\n  Result := Self.Compose(composer);\nend;"
  },
  {
    "instruction": "Implement extension operators for tuple concatenation",
    "output": "function operator+<T1, T2, T3>(Self: (T1, T2); v: T3): (T1, T2, T3); extensionmethod;\nbegin\n  Result := (Self[0], Self[1], v);\nend;\n\nfunction operator+<T1, T2, T3, T4>(Self: (T1, T2, T3); v: T4): (T1, T2, T3, T4); extensionmethod;\nbegin\n  Result := (Self[0], Self[1], Self[2], v);\nend;\n\nfunction operator+<T1, T2, T3, T4, T5>(Self: (T1, T2, T3, T4); v: T5): (T1, T2, T3, T4, T5); extensionmethod;\nbegin\n  Result := (Self[0], Self[1], Self[2], Self[3], v);\nend;\n\nfunction operator+<T1, T2, T3, T4, T5, T6>(Self: (T1, T2, T3, T4, T5); v: T6): (T1, T2, T3, T4, T5, T6); extensionmethod;\nbegin\n  Result := (Self[0], Self[1], Self[2], Self[3], Self[4], v);\nend;\n\nfunction operator+<T1, T2, T3, T4, T5, T6, T7>(Self: (T1, T2, T3, T4, T5, T6); v: T7): (T1, T2, T3, T4, T5, T6, T7); extensionmethod;\nbegin\n  Result := (Self[0], Self[1], Self[2], Self[3], Self[4], Self[5], v);\nend;"
  },
  {
    "instruction": "Implement extension operators for tuple comparison",
    "output": "function operator=<T1, T2> (x: (T1,T2); y: (T1,T2)): boolean; extensionmethod := InternalEqual(x,y);\nfunction operator<><T1, T2> (x: (T1,T2); y: (T1,T2)): boolean; extensionmethod := not InternalEqual(x,y);\nfunction operator<<T1, T2>(Self: (T1, T2); v: (T1, T2)); extensionmethod := CompareToTup2(Self, v) < 0;\nfunction operator<=<T1, T2>(Self: (T1, T2); v: (T1, T2)); extensionmethod := CompareToTup2(Self, v) <= 0;\nfunction operator><T1, T2>(Self: (T1, T2); v: (T1, T2)); extensionmethod := CompareToTup2(Self, v) > 0;\nfunction operator>=<T1, T2>(Self: (T1, T2); v: (T1, T2)); extensionmethod := CompareToTup2(Self, v) >= 0;"
  },
  {
    "instruction": "Implement extension operators for 3-element tuple comparison",
    "output": "function operator=<T1, T2, T3> (x: (T1,T2,T3); y: (T1,T2,T3)); extensionmethod := InternalEqual(x,y);\nfunction operator<><T1, T2, T3> (x: (T1,T2,T3); y: (T1,T2,T3)); extensionmethod := not InternalEqual(x,y);\nfunction operator<<T1,T2,T3>(Self: (T1, T2, T3); v: (T1, T2, T3)); extensionmethod := CompareToTup3(Self, v) < 0;\nfunction operator<=<T1,T2,T3>(Self: (T1, T2, T3); v: (T1, T2, T3)); extensionmethod := CompareToTup3(Self, v) <= 0;\nfunction operator><T1,T2,T3>(Self: (T1, T2, T3); v: (T1, T2, T3)); extensionmethod := CompareToTup3(Self, v) > 0;\nfunction operator>=<T1,T2,T3>(Self: (T1, T2, T3); v: (T1, T2, T3)); extensionmethod := CompareToTup3(Self, v) >= 0;"
  },
  {
    "instruction": "Implement extension operators for 4-element tuple comparison",
    "output": "function operator=<T1, T2, T3, T4> (x: (T1,T2,T3,T4); y: (T1,T2,T3,T4)); extensionmethod := InternalEqual(x,y);\nfunction operator<><T1, T2, T3, T4> (x: (T1,T2,T3,T4); y: (T1,T2,T3,T4)); extensionmethod := not InternalEqual(x,y);\nfunction operator<<T1,T2,T3,T4>(Self: (T1, T2, T3, T4); v: (T1, T2, T3, T4)); extensionmethod := CompareToTup4(Self, v) < 0;\nfunction operator<=<T1,T2,T3,T4>(Self: (T1, T2, T3, T4); v: (T1, T2, T3, T4)); extensionmethod := CompareToTup4(Self, v) <= 0;\nfunction operator><T1,T2,T3,T4>(Self: (T1, T2, T3, T4); v: (T1, T2, T3, T4)); extensionmethod := CompareToTup4(Self, v) > 0;\nfunction operator>=<T1,T2,T3,T4>(Self: (T1, T2, T3, T4); v: (T1, T2, T3, T4)); extensionmethod := CompareToTup4(Self, v) >= 0;"
  },
  {
    "instruction": "Implement extension operators for 5-element tuple comparison",
    "output": "function operator=<T1, T2, T3, T4,T5> (x: (T1,T2,T3,T4,T5); y: (T1,T2,T3,T4,T5)); extensionmethod := InternalEqual(x,y);\nfunction operator<><T1, T2, T3, T4,T5> (x: (T1,T2,T3,T4,T5); y: (T1,T2,T3,T4,T5)); extensionmethod := not InternalEqual(x,y);\nfunction operator<<T1,T2,T3,T4,T5>(Self: (T1, T2, T3, T4,T5); v: (T1, T2, T3, T4,T5)); extensionmethod := CompareToTup5(Self, v) < 0;\nfunction operator<=<T1,T2,T3,T4,T5>(Self: (T1, T2, T3, T4,T5); v: (T1, T2, T3, T4,T5)); extensionmethod := CompareToTup5(Self, v) <= 0;\nfunction operator><T1,T2,T3,T4,T5>(Self: (T1, T2, T3, T4,T5); v: (T1, T2, T3, T4,T5)); extensionmethod := CompareToTup5(Self, v) > 0;\nfunction operator>=<T1,T2,T3,T4,T5>(Self: (T1, T2, T3, T4,T5); v: (T1, T2, T3, T4,T5)); extensionmethod := CompareToTup5(Self, v) >= 0;"
  },
  {
    "instruction": "Implement extension operators for 6-element tuple comparison",
    "output": "function operator=<T1, T2, T3, T4,T5,T6> (x: (T1,T2,T3,T4,T5,T6); y: (T1,T2,T3,T4,T5,T6)); extensionmethod := InternalEqual(x,y);\nfunction operator<><T1, T2, T3, T4,T5,T6> (x: (T1,T2,T3,T4,T5,T6); y: (T1,T2,T3,T4,T5,T6)); extensionmethod := not InternalEqual(x,y);\nfunction operator<<T1,T2,T3,T4,T5,T6>(Self: (T1, T2, T3, T4,T5,T6); v: (T1, T2, T3, T4,T5,T6)); extensionmethod := CompareToTup5(Self, v) < 0;\nfunction operator<=<T1,T2,T3,T4,T5,T6>(Self: (T1, T2, T3, T4,T5,T6); v: (T1, T2, T3, T4,T5,T6)); extensionmethod := CompareToTup5(Self, v) <= 0;\nfunction operator><T1,T2,T3,T4,T5,T6>(Self: (T1, T2, T3, T4,T5,T6); v: (T1, T2, T3, T4,T5,T6)); extensionmethod := CompareToTup5(Self, v) > 0;\nfunction operator>=<T1,T2,T3,T4,T5,T6>(Self: (T1, T2, T3, T4,T5,T6); v: (T1, T2, T3, T4,T5,T6)); extensionmethod := CompareToTup5(Self, v) >= 0;"
  },
  {
    "instruction": "Implement extension operators for 7-element tuple comparison",
    "output": "function operator=<T1, T2, T3, T4,T5,T6,T7> (x: (T1,T2,T3,T4,T5,T6,T7); y: (T1,T2,T3,T4,T5,T6,T7)); extensionmethod := InternalEqual(x,y);\nfunction operator<><T1, T2, T3, T4,T5,T6,T7> (x: (T1,T2,T3,T4,T5,T6,T7); y: (T1,T2,T3,T4,T5,T6,T7)); extensionmethod := not InternalEqual(x,y);\nfunction operator<<T1,T2,T3,T4,T5,T6,T7>(Self: (T1, T2, T3, T4,T5,T6,T7); v: (T1, T2, T3, T4,T5,T6,T7)); extensionmethod := CompareToTup5(Self, v) < 0;\nfunction operator<=<T1,T2,T3,T4,T5,T6,T7>(Self: (T1, T2, T3, T4,T5,T6,T7); v: (T1, T2, T3, T4,T5,T6,T7)); extensionmethod := CompareToTup5(Self, v) <= 0;\nfunction operator><T1,T2,T3,T4,T5,T6,T7>(Self: (T1, T2, T3, T4,T5,T6,T7); v: (T1, T2, T3, T4,T5,T6,T7)); extensionmethod := CompareToTup5(Self, v) > 0;\nfunction operator>=<T1,T2,T3,T4,T5,T6,T7>(Self: (T1, T2, T3, T4,T5,T6,T7); v: (T1, T2, T3, T4,T5,T6,T7)); extensionmethod := CompareToTup5(Self, v) >= 0;"
  },
  {
    "instruction": "Convert a decimal number to binary system",
    "output": "function Bin(number: int64): string;\nbegin\n  if number < 0 then number := -number;\n  Result := '';\n  while number >= 2 do\n  begin\n    Result += number mod 2;\n    number := number div 2\n  end;  \n  Result += number;\n  Result := Result.Inverse\nend;"
  },
  {
    "instruction": "Convert a decimal number to octal system",
    "output": "function Oct(number: int64): string;\nbegin\n  if number < 0 then number := -number;\n  Result := '';\n  while number >= 8 do\n  begin\n    Result += number mod 8;\n    number := number div 8\n  end;  \n  Result += number;\n  Result := Result.Inverse;\nend;"
  },
  {
    "instruction": "Convert a decimal number to hexadecimal system",
    "output": "function Hex(number: int64): string;\nbegin\n  if number < 0 then number := -number;\n  var hex_nums := '0123456789ABCDEF';\n  Result := '';\n  while number >= 16 do\n  begin\n    Result += hex_nums[number mod 16 + 1];\n    number := number div 16\n  end;  \n  Result += hex_nums[number + 1];\n  Result := Result.Inverse;\nend;"
  },
  {
    "instruction": "Convert from base system (2..36) to decimal",
    "output": "function Dec(str: string; base: integer): int64;\nbegin\n  if not (base in 2..36) then\n    raise new School_InvalidBase\n    ($'Dec: Invalid base {base}');\n  str := str.ToUpper;\n  var invalid_chars := \n    str.Except(valid_chars[:base + 1]).JoinToString;\n  if invalid_chars.Length > 0 then\n    raise new School_BadCharInString\n    ($'Dec: Invalid characters \"{invalid_chars}\"');\n  var rank_weight := 1bi;\n  var res := 0bi;\n  foreach var char in str.Reverse do\n  begin\n    var rank_value := Pos(char, valid_chars) - 1;\n    res += rank_weight * rank_value;\n    rank_weight *= base\n  end;\n  Result := int64(res)\nend;"
  },
  {
    "instruction": "Convert decimal number to any base system (2..36)",
    "output": "function ToBase(number: int64; base: integer): string;\nbegin\n  if not (base in 2..36) then\n    raise new School_InvalidBase\n    ($'ToBase: Invalid base {base}');\n  var sb := new System.Text.StringBuilder('');\n  while number > 0 do \n  begin\n    sb.Insert(0, valid_chars[number mod base + 1]);\n    number := number div base\n  end;\n  Result := if sb.Length = 0 then '0'\n    else sb.ToString\nend;"
  },
  {
    "instruction": "Find minimum and maximum of a sequence",
    "output": "function MinMax(seq: sequence of int64): (int64, int64);\nbegin\n  var min := int64.MaxValue;\n  var max := int64.MinValue;\n  foreach var elem in seq do\n  begin\n    if elem < min then\n      min := elem;\n    if elem > max then\n      max := elem\n  end;\n  Result := (min, max)\nend;"
  },
  {
    "instruction": "Calculate GCD of two numbers",
    "output": "function НОД(a, b: int64): int64;\nbegin\n  while b <> 0 do\n    (a, b) := (b, a mod b);\n  Result := Abs(a)\nend;"
  },
  {
    "instruction": "Calculate LCM of two numbers",
    "output": "function НОК(a, b: int64): int64;\nbegin\n  var (a1, b1) := (a, b);\n  while b <> 0 do\n    (a, b) := (b, a mod b);\n  Result := Abs(a1 div a * b1)\nend;"
  },
  {
    "instruction": "Check if a number is prime",
    "output": "function IsPrime(n: integer): boolean;\nbegin\n  if n < 2 then\n    Result := False\n  else\n  begin\n    Result := True;\n    foreach var prime in LPrimes do\n      if Sqr(prime) > n then\n        break\n      else if n mod prime = 0 then\n      begin\n        Result := False;\n        break\n      end\n  end\nend;"
  },
  {
    "instruction": "Get prime numbers in range [2;n]",
    "output": "function Primes(n: integer): List<integer>;\nbegin\n  Result := [];\n  if n < 2 then\n    exit;\n  var Sieve := new boolean[n];\n  var p := 2;\n  while Sqr(p) <= n do\n  begin\n    if not Sieve[p - 1] then\n    begin\n      var notPrime := p * p;\n      while notPrime <= n do\n      begin\n        Sieve[notPrime - 1] := True;\n        notPrime += p\n      end\n    end;\n    p += 1\n  end;\n  for var i := 2 to n do\n    if not Sieve[i - 1] then\n      Result.Add(i)\nend;"
  },
  {
    "instruction": "Get prime factors of a number",
    "output": "function PrimeFactors(n: integer): List<integer>;\nbegin\n  Result := [];\n  if n < 2 then exit;\n  var (i, prime, m) := (0, LPrimes[0], n);\n  while Sqr(prime) <= n do\n  begin\n    while n mod prime = 0 do\n    begin\n      Result.Add(prime);\n      n := n div prime\n    end;\n    Inc(i);\n    prime := LPrimes[i];\n  end;\n  if Result.Count = 0 then Result.Add(m)\n  else if n > 1 then Result.Add(n)\nend;"
  },
  {
    "instruction": "Get digits of a number in given base",
    "output": "function Digits(n: int64; base: integer): List<integer>;\nbegin\n  Result := [];\n  if (n < 0) or (base < 2) or (base > integer.MaxValue) then exit;\n  if n = 0 then Result := Lst(0)\n  else\n    while n > 0 do\n    begin\n      var rem: integer := n mod base;\n      Result.Add(rem);\n      n := n div base\n    end;\n    Result.Reverse\nend;"
  },
  {
    "instruction": "Get all divisors of a natural number",
    "output": "function Divisors(n: integer): List<integer>;\nbegin\n  Result := [];\n  Result.Add(1);\n  foreach var prime in LPrimes do\n  begin\n    if Sqr(prime) > n then break;\n    var ndivs := Result.Count;\n    while n mod prime = 0 do\n    begin\n      for var i := Result.Count - ndivs to Result.Count - 1 do\n        Result.Add(Result[i] * prime);\n      n := n div prime\n    end\n  end;\n  if n > 1 then\n    for var i := 0 to Result.Count - 1 do\n      Result.Add(Result[i] * n);\n  Result.Sort;\nend;"
  },
  {
    "instruction": "Calculate sine of angle in degrees",
    "output": "function SinDegrees(x: real): real := Sin(DegToRad(x));"
  },
  {
    "instruction": "Generate array of random real numbers",
    "output": "function ArrRandomReal(n: integer; a, b: real; t: integer): array of real;\nbegin\n  Result := new real[n];\n  for var i := 0 to Result.Length - 1 do\n    Result[i] := Round(Random * (b - a) + a, t);\nend;"
  },
  {
    "instruction": "Generate truth table for boolean function with 2 variables",
    "output": "function TrueTable(f: function(a, b: boolean): boolean):\n    array[,] of boolean;\nbegin\n  Result := new boolean[4, 3];\n  var i := 0;\n  for var a := False to True do\n    for var b := False to True do\n    begin\n      Result[i, 0] := a;\n      Result[i, 1] := b;\n      Result[i, 2] := f(a, b);\n      i += 1\n    end;\nend;"
  },
  {
    "instruction": "Replace last occurrence of substring in string",
    "output": "procedure ReplaceLast(var s: string; source, target: string);\nbegin\n  var position := LastPos(source, s);\n  if position > 0 then\n  begin\n    Delete(s, position, source.Length);\n    Insert(target, s, position)\n  end\nend;"
  },
  {
    "instruction": "Multiple character replacement in string",
    "output": "function ReplaceMany(s, source, target: string): string;\nbegin\n  var SB := new StringBuilder(s);\n  var m := target.Length;\n  for var i := 1 to source.Length do\n    if i <= m then SB.Replace(source[i], target[i])\n    else SB.Replace(source[i],'');\n  Result := SB.ToString\nend;"
  },
  {
    "instruction": "Bitwise AND operation for Addr32 objects",
    "output": "static function Addr32.operator and (a, b: Addr32): Addr32;\nbegin\n  Result := new Addr32;\n  Result.addr10 := a.addr10 and b.addr10;\n  SetAddress(Result) \nend;"
  },
  {
    "instruction": "Convert decimal BigInteger to binary system",
    "output": "function Bin(number: BigInteger): string;\nbegin\n  if number < 0 then number := -number;\n  Result := '';\n  while number >= 2 do\n  begin\n    Result += byte(number mod 2);\n    number := number div 2\n  end;  \n  Result += byte(number);\n  Result := Result.Inverse\nend;"
  },
  {
    "instruction": "Convert decimal number to binary with formatting",
    "output": "function BinFormat(number: BigInteger; bytes: integer; split: string): string;\nbegin\n  if number < 0 then number := -number;\n  var a := number = 0 ? [byte(0)] : number.ToByteArray;\n  var len := a.Length;\n  if (number > 0) and (a[^1] = 0) then Dec(len);\n  SetLength(a, Max(bytes, len));\n  Result := a.Reverse.Select(t -> (Convert.ToString(t, 2)).PadLeft(8, '0')).JoinToString(split)\nend;"
  },
  {
    "instruction": "Convert decimal BigInteger to octal system",
    "output": "function Oct(number: BigInteger): string;\nbegin\n  if number < 0 then number := -number;\n  Result := '';\n  while number >= 8 do\n  begin\n    Result += byte(number mod 8);\n    number := number div 8\n  end;  \n  Result += byte(number);\n  Result := Result.Inverse;\nend;"
  },
  {
    "instruction": "Convert decimal BigInteger to hexadecimal system",
    "output": "function Hex(number: BigInteger): string;\nbegin\n  if number < 0 then number := -number;\n  var hex_nums := '0123456789ABCDEF';\n  Result := '';\n  while number >= 16 do\n  begin\n    Result += hex_nums[byte(number mod 16 + 1)];\n    number := number div 16\n  end;  \n  Result += hex_nums[byte(number + 1)];\n  Result := Result.Inverse;\nend;"
  },
  {
    "instruction": "Convert from base system to BigInteger decimal",
    "output": "function DecBig(str: string; base: integer): BigInteger;\nbegin\n  if not (base in 2..36) then\n    raise new School_InvalidBase\n    ($'DecBig: Invalid base {base}');\n  str := str.ToUpper;\n  var invalid_chars := \n    str.Except(valid_chars[:base + 1]).JoinToString;\n  if invalid_chars.Length > 0 then\n    raise new School_BadCharInString\n    ($'DecBig: Invalid characters \"{invalid_chars}\"');\n  var rank_weight := 1bi;\n  Result := 0bi;\n  foreach var char in str.Reverse do\n  begin\n    var rank_value := Pos(char, valid_chars) - 1;\n    Result += rank_weight * rank_value;\n    rank_weight *= base\n  end\nend;"
  },
  {
    "instruction": "Convert decimal BigInteger to any base system",
    "output": "function ToBase(number: BigInteger; base: integer): string;\nbegin\n  if not (base in 2..36) then\n    raise new School_InvalidBase\n    ($'ToBase: Invalid base {base}');\n  var sb := new System.Text.StringBuilder('');\n  while number > 0 do \n  begin\n    sb.Insert(0, valid_chars[integer(number mod base) + 1]);\n    number := number div base\n  end;\n  Result := if sb.Length = 0 then '0'\n    else sb.ToString\nend;"
  },
  {
    "instruction": "Calculate GCD and LCM of two numbers",
    "output": "function НОДНОК(a, b: int64): (int64, int64);\nbegin\n  var (a1, b1) := (a, b);\n  while b <> 0 do\n    (a, b) := (b, a mod b);\n  Result := (a, Abs(a1 div a * b1))\nend;"
  },
  {
    "instruction": "Get prime numbers in range [m;n]",
    "output": "function Primes(m, n: integer): List<integer>;\nbegin\n  var ls := ubPrimeDivs;\n  if m > n then Swap(m, n);\n  Result := [];\n  if m <= LPrimes[^1] then\n  begin\n    foreach var prime in LPrimes do\n    begin\n      if prime > n then break;\n      if prime >= m then Result.Add(prime)\n    end;\n    if Result.Count = 0 then exit;\n    m := Result[^1] + 1;\n    if m >= n then exit\n  end;  \n  var ls64: int64 := ls;\n  var ln := Ceil(m / ls);\n  var rn := Ceil(n / ls);\n  for var sn := ln to rn do\n  begin\n    var a := Max((sn - 1) * ls64 + 1, 2);\n    var b := sn * ls64;\n    var Sieve := new boolean[ls];\n    for var i := 0 to LPrimes.Count - 1 do\n    begin\n      var prime := LPrimes[i];\n      if Sqr(prime) > b then break;\n      var k := a;\n      var d := k mod prime;\n      if d <> 0 then k += prime - d;\n      while k <= b do\n      begin\n        Sieve[integer(k - a)] := True;\n        k += prime\n      end\n    end;\n    for var i := 0 to Sieve.High do\n      if not Sieve[i] then\n        if (a + i >= m) and (a + i <= n) then\n          Result.Add(a + i)\n  end\nend;"
  },
  {
    "instruction": "Get first k prime numbers",
    "output": "function FirstPrimes(k: integer): List<integer>;\nbegin\n  if k <= nPrimeDivs then Result := LPrimes[:k]\n  else\n  begin\n    Result := LPrimes;\n    var kprimes := nPrimeDivs;\n    var n := maxPrimeDiv + 2;\n    repeat\n      if n.IsPrime then\n      begin\n        Result.Add(n);\n        Inc(kprimes)\n      end;  \n      n += 2\n    until kprimes = k\n  end\nend;"
  },
  {
    "instruction": "Get unique prime divisors of a number",
    "output": "function PrimeDivisors(n: integer): List<integer>;\nbegin\n  Result := [];\n  if n < 2 then exit;\n  var (i, prime, m) := (0, LPrimes[0], n);\n  while Sqr(prime) <= n do\n  begin\n    if n mod prime = 0 then\n    begin\n      Result.Add(prime);\n      repeat\n        n := n div prime\n      until n mod prime <> 0\n    end;\n    Inc(i);\n    prime := LPrimes[i];\n  end;\n  if Result.Count = 0 then Result.Add(m)\n  else if n > 1 then Result.Add(n)\nend;"
  },
  {
    "instruction": "Count unique prime divisors of a number",
    "output": "function PrimeDivisorsCount(n: integer): integer;\nbegin\n  Result := 0;\n  if n < 2 then Exit;\n  var (i, prime, DivIsPrime) := (0, LPrimes[0], True);\n  while Sqr(prime) <= n do\n  begin\n    if n mod prime = 0 then\n    begin\n      Inc(Result);\n      DivIsPrime := False;\n      repeat\n        n := n div prime\n      until n mod prime <> 0\n    end;\n    Inc(i);\n    prime := LPrimes[i];\n  end;\n  if DivIsPrime then Result := 1\n  else if n > 1 then Result += 1\nend;"
  },
  {
    "instruction": "Count prime factors of a number",
    "output": "function PrimeFactorsCount(n: integer): integer;\nbegin\n  Result := 0;\n  if n < 2 then exit;\n  var (i, prime, DivIsPrime) := (0, LPrimes[0], True);\n  while Sqr(prime) <= n do\n  begin\n    while n mod prime = 0 do\n    begin\n      Inc(Result);\n      DivIsPrime := False;\n      n := n div prime\n    end;\n    Inc(i);\n    prime := LPrimes[i];\n  end;\n  if DivIsPrime then Result := 1\n  else if n > 1 then Result += 1\nend;"
  },
  {
    "instruction": "Convert digits list to BigInteger",
    "output": "function DigitsToBigInteger(ext: List<integer>; base: integer): BigInteger;\nbegin\n  Result := BigInteger.Zero;\n  var p := BigInteger.One;\n  for var i := ext.Count -1 downto 0 do\n  begin  \n    Result += ext[i] * p;\n    p *= base\n  end\nend;"
  },
  {
    "instruction": "Count divisors of a number",
    "output": "function DivisorsCount(n: integer): integer;\nbegin\n  Result := 1;\n  foreach var prime in LPrimes do\n  begin\n    if Sqr(prime) > n then break;\n    var ndivs := Result;\n    while n mod prime = 0 do\n    begin\n      for var i := Result - ndivs to Result - 1 do\n        Result += 1;\n      n := n div prime;\n    end\n  end;  \n  if n > 1 then\n    for var i := 0 to Result - 1 do\n      Result += 1;\nend;"
  },
  {
    "instruction": "Calculate cosine of angle in degrees",
    "output": "function CosDegrees(x: real): real := Cos(DegToRad(x));"
  },
  {
    "instruction": "Calculate tangent of angle in degrees",
    "output": "function TanDegrees(x: real): real := Tan(DegToRad(x));"
  },
  {
    "instruction": "Generate sequence of random real numbers",
    "output": "function SeqRandomReal(n: integer; a, b: real; t: integer): sequence of real;\nbegin\n  loop n do\n    yield Round(Random * (b - a) + a, t)\nend;"
  },
  {
    "instruction": "Generate matrix of random real numbers",
    "output": "function MatrRandomReal(m: integer; n: integer; a, b: real; t: integer): array [,] of real;\nbegin\n  Result := new real[m, n];\n  for var i := 0 to Result.RowCount - 1 do\n    for var j := 0 to Result.ColCount - 1 do\n      Result[i, j] := Round(Random * (b - a) + a, t);\nend;"
  },
  {
    "instruction": "Generate truth table for boolean function with 3 variables",
    "output": "function TrueTable(f: function(a, b, c: boolean): boolean):\n    array[,] of boolean;\nbegin\n  Result := new boolean[8, 4];\n  var i := 0;\n  for var a := False to True do\n    for var b := False to True do\n      for var c := False to True do\n      begin\n        Result[i, 0] := a;\n        Result[i, 1] := b;\n        Result[i, 2] := c;\n        Result[i, 3] := f(a, b, c);\n        i += 1\n      end;\nend;"
  },
  {
    "instruction": "Generate truth table for boolean function with n variables",
    "output": "function TrueTable(n: integer; f: (array of boolean) -> boolean):\n    array[,] of boolean;\nbegin\n  Result := new boolean[1 shl n, n + 1];\n  foreach var values in [False, True].CartesianPower(n) index i do\n  begin\n    foreach var val in values index j do \n    begin\n      Result[i, j] := val\n    end;\n    Result[i, ^1] := f(values)\n  end\nend;"
  },
  {
    "instruction": "Multiple substring replacement in string",
    "output": "function ReplaceMany(s: string; source, target: IList<string>): string;\nbegin\n  var SB := new StringBuilder(s);\n  var tl := target.Count - 1;\n  for var i := 0 to source.Count - 1 do\n    if i <= tl then SB.Replace(source[i], target[i])\n    else SB.Replace(source[i], '');\n  Result := SB.ToString\nend;"
  },
  {
    "instruction": "Swap substrings in string",
    "output": "procedure SwapSubstr(var s: string; ss1, ss2: string);\nbegin\n  if not ((ss1 in s) and (ss2 in s)) then exit;\n  var D := Dict((ss1, ss2), (ss2, ss1));\n  s := Regex.Replace(s, $'({ss1}|{ss2})', m -> D[m.Value])\nend;"
  },
  {
    "instruction": "Translate characters in string",
    "output": "function Translate(s, source, target: string): string;\nbegin\n  var sb := new StringBuilder(s.Length);\n  foreach var x in s do \n  begin\n    var ind := source.IndexOf(x); \n    if ind >= 0 then\n    begin\n      if ind <= target.Length - 1 then\n        sb.Append(target[ind + 1])\n    end\n    else sb.Append(x)\n  end;\n  Result := sb.ToString\nend;"
  },
  {
    "instruction": "Bitwise OR operation for Addr32 objects",
    "output": "static function Addr32.operator or (a, b: Addr32): Addr32;\nbegin\n  Result := new Addr32;\n  Result.addr10 := a.addr10 or b.addr10;\n  SetAddress(Result)\nend;"
  },
  {
    "instruction": "Bitwise NOT operation for Addr32 object",
    "output": "static function Addr32.operator not (a: Addr32): Addr32;\nbegin\n  Result := new Addr32;\n  Result.addr10 := not a.addr10;\n  SetAddress(Result)\nend;"
  },
  {
    "instruction": "Addition operation for Addr32 object",
    "output": "static function Addr32.operator + (a: Addr32; b: longword): Addr32;\nbegin\n  Result := new Addr32;\n  Result.addr10 := a.addr10 + b;\n  SetAddress(Result)\nend;"
  },
  {
    "instruction": "Validate IP address format with octets",
    "output": "function Addr32.AddressValid(address: string): boolean := \n    (address = address.MatchValue('(\\d{1,3}\\.){3}\\d{1,3}')) and\n    address.Split('.').All(t -> t.ToInteger <= 255);"
  },
  {
    "instruction": "Validate 32-bit binary address format",
    "output": "function Addr32.AddressBinValid(address: string): boolean :=\n    address.MatchValue('[0|1]*').Length = 32;"
  },
  {
    "instruction": "Convert IP address/mask from decimal with octets to 32-bit binary",
    "output": "function Addr32.AddressToBin(address: string): string :=\n    address.Split('.')\n    .Select(t -> Convert.ToString(Convert.ToByte(t), 2).PadLeft(8, '0'))\n    .JoinToString('');"
  },
  {
    "instruction": "Convert 32-bit binary string to decimal value",
    "output": "function Addr32.BinToDec(bits: string): longword := Convert.ToUInt32(bits, 2);"
  },
  {
    "instruction": "Convert binary address representation to decimal with octets",
    "output": "static function Addr32.BinToAddress(pic: string): string;\nbegin\n  var s := if '.' in pic then pic.Split('.') else pic.Batch(8).Select(t -> t.JoinToString(''));\n  Result := s.Select(t -> Convert.ToByte(t, 2)).JoinToString('.')\nend;"
  },
  {
    "instruction": "Format 32-bit binary address with octets",
    "output": "function Addr32.AddrFormat(addr: string): string;\nbegin\n  Result := addr.Substring(0, 8);\n  for var i := 1 to 3 do\n    Result += '.' + addr.Substring(8 * i, 8);\nend;"
  },
  {
    "instruction": "Set address for Addr32 object",
    "output": "procedure Addr32.SetAddress(value: string);\nbegin\n  if AddressValid(value) then\n  begin\n    addr := value;\n    addr2 := AddressToBin(value);\n    addr10 := BinToDec(addr2)\n  end\n  else\n  begin\n    Println('Incorrect address record:', value);\n    Halt\n  end\nend;"
  },
  {
    "instruction": "Set binary address for Addr32 object",
    "output": "procedure Addr32.SetAddressBin(value: string);\nbegin\n  if AddressBinValid(value) then\n  begin\n    addr := Addr32.BinToAddress(value);\n    addr2 := value;\n    addr10 := BinToDec(addr2)\n  end\n  else\n  begin\n    Println('Incorrect address record:', value);\n    Halt\n  end\nend;"
  },
  {
    "instruction": "Binary representation of decimal number for CalcIP",
    "output": "function CalcIP.Bin(n:int64): string := Convert.ToString(n, 2);"
  },
  {
    "instruction": "32-bit binary representation of decimal number for CalcIP",
    "output": "function CalcIP.Bin32(n:int64): string := Convert.ToString(n, 2).PadLeft(32, '0');"
  },
  {
    "instruction": "Convert binary string to decimal for CalcIP",
    "output": "function CalcIP.BinToDec(bits: string): integer := integer(Convert.ToInt64(bits, 2));"
  },
  {
    "instruction": "Format address with network and host separation",
    "output": "function CalcIP.AddrFine(addr: Addr32): string;\nbegin\n  Result := AddrFormat(addr.value2);\n  var d := bit_mask + bit_mask div 8 + 1;\n  if bit_mask > 0 then Result := Result[:d] + '  ' + Result[d:]\nend;"
  },
  {
    "instruction": "Validate IP address format for CalcIP",
    "output": "function CalcIP.AddressValid(addr: string): boolean :=\n    (addr = addr.MatchValue('(\\d{1,3}\\.){3}\\d{1,3}')) and\n    addr.Split('.').All(t -> t.ToInteger <= 255);"
  },
  {
    "instruction": "Convert IP address to binary for CalcIP",
    "output": "function CalcIP.AddressToBin(addr: string): string :=\n    addr.Split('.')\n    .Select(t -> Convert.ToString(Convert.ToByte(t), 2).PadLeft(8, '0'))\n    .JoinToString('');"
  },
  {
    "instruction": "Convert binary address to decimal with octets for CalcIP",
    "output": "function CalcIP.BinToAddress(pic: string): string;\nbegin\n  var s := if '.' in pic then pic.Split('.') else pic.Batch(8).Select(t -> t.JoinToString(''));\n  Result := s.Select(t -> Convert.ToByte(t, 2)).JoinToString('.')\nend;"
  },
  {
    "instruction": "Validate subnet mask",
    "output": "function CalcIP.MaskValid(mask: Addr32): boolean :=\n    mask.value2.MatchValue('1+0+').Length = 32;"
  },
  {
    "instruction": "Calculate IP network parameters",
    "output": "procedure CalcIP.Calc;\nbegin\n  bit_mask := Pos('0', mask32.value2) - 1;\n  n_hosts := integer(2 ** (32 - bit_mask)) - 2;\n  var addr := mask32.value.Split('.').Select(t -> (255 - Convert.ToByte(t)).ToString).JoinToString('.');\n  wildcard32 := new Addr32(addr);\n  network32 := ip32 and mask32;\n  broadcast32 := network32 or wildcard32;\n  hostmin32 := network32 + 1;\n  hostmax32 := network32 + n_hosts\nend;"
  },
  {
    "instruction": "Format address with bitmask separation",
    "output": "function CalcIP.AddressFormat(pic: string): string := pic[:bit_mask + 1] + '  ' + pic[bit_mask + 1:];"
  },
  {
    "instruction": "Get string representation of Addr32 object",
    "output": "function Addr32.ToString: string := $'{addr + '','', -15}{AddrFormat(addr2)}';"
  },
  {
    "instruction": "Get string representation of CalcIP object",
    "output": "function CalcIP.ToString: string;\nbegin\n  var s := \n       $'IP address (Address)                  | {ip32.value, -15} | {AddrFine(ip32)}{NewLine}';\n  s += $'Subnet mask prefix (Bitmask)          | /{bit_mask}{NewLine}';\n  s += $'Subnet mask (Netmask)                 | {mask32.value, -15} | {AddrFine(mask32)}{NewLine}';\n  s += $'Host mask (Wildcard)                  | {Wildcard32.value, -15} | {AddrFine(wildcard32)}{NewLine}';\n  s += $'Network IP address (Network)          | {network32.value, -15} | {AddrFine(network32)}{NewLine}';\n  s += $'Broadcast address (Broadcast)         | {broadcast32.value, -15} | {AddrFine(broadcast32)}{NewLine}';\n  s += $'Available host addresses (Hosts)      | {n_hosts}{NewLine}';\n  s += $'First host address (Hostmin)          | {hostmin32.value, -15} | {AddrFine(hostmin32)}{NewLine}';\n  s += $'Last host address (Hostmax)           | {hostmax32.value, -15} | {AddrFine(hostmax32)}{NewLine}';\n  Result := s\nend;"
  },
  {
    "instruction": "Initialize prime numbers list using Sieve of Eratosthenes",
    "output": "procedure PrimesInternal;\nbegin\n  LPrimes := new List<integer>;\n  var Sieve := new boolean[ubPrimeDivs + 1];\n  for var i := 2 to ubPrimeDivs do\n    if not Sieve[i] then\n    begin\n      LPrimes.Add(i);\n      var k := i;\n      while k <= ubPrimeDivs - i do\n      begin\n        k += i;\n        Sieve[k] := True\n      end\n    end\nend;"
  },
  {
    "instruction": "Print truth table with filtering options",
    "output": "procedure TrueTablePrint(a: array[,] of boolean; f: integer; s: string);\nbegin\n  var n := a.ColCount;\n  s := s?[:n];\n  s := s.PadRight(n - 1, ' ');\n  Write(' ');\n  for var i := 1 to s.Length do\n    Print(s[i]);\n  Writeln('F');\n  Writeln(' ' + (2 * n - 1) * '-');\n  for var i := 0 to a.RowCount - 1 do\n    if not (((f = 0) and a[i, n - 1]) or ((f = 1) and not a[i, n - 1])) then\n    begin\n      for var j := 0 to n - 1 do\n        Write(if a[i, j] then ' 1' else ' 0');\n      Writeln\n    end\nend;"
  },
  {
    "instruction": "Logical implication extension method",
    "output": "function Imp(Self, b: boolean): boolean; extensionmethod := not Self or b;"
  },
  {
    "instruction": "GCD extension method for integer tuple",
    "output": "function НОД(Self: (integer, integer)): integer; extensionmethod;\nbegin\n  var (a, b) := Self;\n  while b <> 0 do\n    (a, b) := (b, a mod b);\n  Result := Abs(a)\nend;"
  },
  {
    "instruction": "IsPrime extension method for integer",
    "output": "function IsPrime(Self: integer): boolean; extensionmethod := IsPrime(Self);"
  },
  {
    "instruction": "PrimeDivisors extension method for integer",
    "output": "function PrimeDivisors(Self: integer): List<integer>; extensionmethod := PrimeDivisors(Self);"
  },
  {
    "instruction": "PrimeDivisorsCount extension method for integer",
    "output": "function PrimeDivisorsCount(Self: integer): integer; extensionmethod := PrimeDivisorsCount(Self);"
  },
  {
    "instruction": "PrimeFactors extension method for integer",
    "output": "function PrimeFactors(Self: integer): List<integer>; extensionmethod := PrimeFactors(Self);"
  },
  {
    "instruction": "PrimeFactorsCount extension method for integer",
    "output": "function PrimeFactorsCount(Self: integer): integer; extensionmethod := PrimeFactorsCount(Self);"
  },
  {
    "instruction": "Divisors extension method for integer",
    "output": "function Divisors(Self: integer): List<integer>; extensionmethod :=\nDivisors(Self);"
  },
  {
    "instruction": "DivisorsCount extension method for integer",
    "output": "function DivisorsCount(Self: integer): integer; extensionmethod := DivisorsCount(Self);"
  },
  {
    "instruction": "ToBase extension method for int64",
    "output": "function ToBase(Self: int64; base: integer): string; extensionmethod := ToBase(Self, base);"
  },
  {
    "instruction": "ToBase extension method for BigInteger",
    "output": "function ToBase(Self: BigInteger; base: integer): string; extensionmethod := ToBase(Self, base);"
  },
  {
    "instruction": "ToBase extension method for string",
    "output": "function ToBase(Self: string; base: integer): string; extensionmethod := ToBase(Self, base);"
  },
  {
    "instruction": "Digits extension method for integer",
    "output": "function Digits(Self: integer; base: integer := 10): List<integer>;\n    extensionmethod := Digits(Self, base);"
  },
  {
    "instruction": "Digits extension method for int64",
    "output": "function Digits(Self: int64; base: integer := 10): List<integer>;\n    extensionmethod := Digits(Self, base);"
  },
  {
    "instruction": "Digits extension method for BigInteger",
    "output": "function Digits(Self: Biginteger; base: integer := 10): List<integer>;\n    extensionmethod := Digits(Self, base);"
  },
  {
    "instruction": "DigitsToInt64 extension method for List<integer>",
    "output": "function DigitsToInt64(Self: List<integer>; base: integer := 10): int64;\n    extensionmethod := DigitsToInt64(Self, base);"
  },
  {
    "instruction": "DigitsToBigInteger extension method for List<integer>",
    "output": "function DigitsToBigInteger(Self: List<integer>; base: integer := 10): BigInteger;\n    extensionmethod := DigitsToBigInteger(Self, base);"
  },
  {
    "instruction": "ReplaceMany extension method for string with characters",
    "output": "function ReplaceMany(Self, source, target: string): string;\nextensionmethod := ReplaceMany(Self, source, target);"
  },
  {
    "instruction": "ReplaceMany extension method for string with substrings",
    "output": "function ReplaceMany(Self: string; source, target: IList<string>): string;\nextensionmethod := ReplaceMany(Self, source, target);"
  },
  {
    "instruction": "SwapSubstr extension method for string",
    "output": "procedure SwapSubstr(var Self: string; ss1, ss2: string);\n  extensionmethod := SwapSubstr(Self, ss1, ss2);"
  },
  {
    "instruction": "Translate extension method for string",
    "output": "function Translate(Self, source, target: string): string;\n  extensionmethod := Translate(Self, source, target);"
  },
  {
    "instruction": "Set internal address for Addr32 object",
    "output": "static procedure Addr32.SetAddress(a: Addr32);\nbegin\n  a.addr2 := Bin32(a.addr10);\n  a.addr := BinToAddress(a.addr2)\nend;"
  },
  {
    "instruction": "Generate truth table for boolean function with 4 variables",
    "output": "function TrueTable(f: function(a, b, c, d: boolean): boolean):\n    array[,] of boolean;\nbegin\n  Result := new boolean[16, 5];\n  var i := 0;\n  for var a := False to True do\n    for var b := False to True do\n      for var c := False to True do\n        for var d := False to True do\n        begin\n          Result[i, 0] := a;\n          Result[i, 1] := b;\n          Result[i, 2] := c;\n          Result[i, 3] := d;\n          Result[i, 4] := f(a, b, c, d);\n          i += 1\n        end;\nend;"
  },
  {
    "instruction": "Generate truth table for boolean function with 5 variables",
    "output": "function TrueTable(f: function(a, b, c, d, e: boolean): boolean):\n    array[,] of boolean;\nbegin\n  Result := new boolean[32, 6];\n  var i := 0;\n  for var a := False to True do\n    for var b := False to True do\n      for var c := False to True do\n        for var d := False to True do\n          for var e := False to True do\n          begin\n            Result[i, 0] := a;\n            Result[i, 1] := b;\n            Result[i, 2] := c;\n            Result[i, 3] := d;\n            Result[i, 4] := e;\n            Result[i, 5] := f(a, b, c, d, e);\n            i += 1\n          end;\nend;"
  },
  {
    "instruction": "MinMax extension method for sequence of int64",
    "output": "function MinMax(Self: sequence of int64): (int64, int64); extensionmethod :=\nMinMax(Self);"
  },
  {
    "instruction": "MinMax extension method for sequence of integer",
    "output": "function MinMax(Self: sequence of integer): (integer, integer);\n    extensionmethod :=\nMinMax(Self);"
  },
  {
    "instruction": "MinMax extension method for sequence of real",
    "output": "function MinMax(Self: sequence of real): (real, real); extensionmethod :=\nMinMax(Self);"
  },
  {
    "instruction": "MinMax extension method for sequence of BigInteger",
    "output": "function MinMax(Self: sequence of BigInteger): (BigInteger, BigInteger);\nextensionmethod := MinMax(Self);"
  },
  {
    "instruction": "GCD extension method for int64 tuple",
    "output": "function НОД(Self: (int64, int64)): integer; extensionmethod;\nbegin\n  var (a, b) := Self;\n  while b <> 0 do\n    (a, b) := (b, a mod b);\n  Result := Abs(a)\nend;"
  },
  {
    "instruction": "Factorize function as alias for PrimeFactors",
    "output": "function Factorize(n: integer): List<integer> := PrimeFactors(n);"
  },
  {
    "instruction": "Factorize extension method for integer",
    "output": "function Factorize(Self: integer): List<integer>; extensionmethod := PrimeFactors(Self);"
  },
  {
    "instruction": "Divizors function as alias for Divisors",
    "output": "function Divizors(n: integer) := Divisors(n);"
  },
  {
    "instruction": "Divizors extension method for integer",
    "output": "function Divizors(Self: integer): List<integer>; extensionmethod :=\nDivisors(Self);"
  },
  {
    "instruction": "BinFormat for int64 with default parameters",
    "output": "function BinFormat(number: int64; bytes: integer; split: string): string :=\n    BinFormat(BigInteger(number), bytes, split);"
  },
  {
    "instruction": "32-bit binary representation static method for Addr32",
    "output": "static function Addr32.Bin32(n:integer): string := (Convert.ToString(n, 2)).PadLeft(32, '0');"
  },
  {
    "instruction": "Format address with octets for CalcIP",
    "output": "function CalcIP.AddrFormat(addr: string): string;\nbegin\n  Result := addr.Substring(0, 8);\n  for var i := 1 to 3 do\n    Result += '.' + addr.Substring(8 * i, 8);\nend;"
  },
  {
    "instruction": "Find minimum and maximum of real sequence",
    "output": "function MinMax(seq: sequence of real): (real, real);\nbegin\n  var min := real.MaxValue;\n  var max := -real.MaxValue;\n  foreach var elem in seq do\n  begin\n    if elem < min then\n      min := elem;\n    if elem > max then\n      max := elem\n  end; \n  Result := (min, max)\nend;"
  },
  {
    "instruction": "Find minimum and maximum of BigInteger sequence",
    "output": "function MinMax(seq: sequence of BigInteger): (BigInteger, BigInteger);\nbegin\n  var min, max: BigInteger;\n  var is_first := True;\n  foreach var elem in seq do\n    if is_first then\n    begin\n      (min, max) := (elem, elem);\n      is_first := False\n    end  \n    else\n    begin\n      if elem < min then\n        min := elem;\n      if elem > max then\n        max := elem\n    end;\n  Result := (min, max)\nend;"
  },
  {
    "instruction": "Find minimum and maximum of integer sequence",
    "output": "function MinMax(seq: sequence of integer): (integer, integer);\nbegin\n  var min := integer.MaxValue;\n  var max := integer.MinValue;\n  foreach var elem in seq do\n  begin\n    if elem < min then\n      min := elem;\n    if elem > max then\n      max := elem\n  end;\n  Result := (min, max)\nend;"
  }
]